// Generated by tsbindgen - Architecture
// Namespace: System.Formats.Tar
// Assembly: System.Formats.Tar

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { IEnumerable_1, IReadOnlyDictionary_2, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import type { Stream, UnixFileMode } from "../../System.IO/internal/index.js";
import type { Task, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Byte, DateTimeOffset, Enum, IAsyncDisposable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, Int64, ISpanFormattable, Object as ClrObject, String as ClrString, Type, TypeCode, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum TarEntryFormat {
    unknown_ = 0,
    V7 = 1,
    ustar = 2,
    pax = 3,
    gnu = 4
}


export enum TarEntryType {
    regularFile = 48,
    hardLink = 49,
    symbolicLink = 50,
    characterDevice = 51,
    blockDevice = 52,
    directory = 53,
    fifo = 54,
    contiguousFile = 55,
    extendedAttributes = 120,
    globalExtendedAttributes = 103,
    directoryList = 68,
    longLink = 75,
    longPath = 76,
    multiVolume = 77,
    v7RegularFile = 0,
    renamedOrSymlinked = 78,
    sparseFile = 83,
    tapeVolume = 86
}


export interface GnuTarEntry$instance extends PosixTarEntry {
    accessTime: DateTimeOffset;
    changeTime: DateTimeOffset;
}


export const GnuTarEntry: {
    new(entryType: TarEntryType, entryName: string): GnuTarEntry$instance;
    new(other: TarEntry): GnuTarEntry$instance;
};


export type GnuTarEntry = GnuTarEntry$instance;

export interface PaxGlobalExtendedAttributesTarEntry$instance extends PosixTarEntry {
    readonly globalExtendedAttributes: IReadOnlyDictionary_2<CLROf<string>, CLROf<string>>;
}


export const PaxGlobalExtendedAttributesTarEntry: {
    new(globalExtendedAttributes: IEnumerable_1<KeyValuePair_2<CLROf<string>, CLROf<string>>>): PaxGlobalExtendedAttributesTarEntry$instance;
};


export type PaxGlobalExtendedAttributesTarEntry = PaxGlobalExtendedAttributesTarEntry$instance;

export interface PaxTarEntry$instance extends PosixTarEntry {
    readonly extendedAttributes: IReadOnlyDictionary_2<CLROf<string>, CLROf<string>>;
}


export const PaxTarEntry: {
    new(entryType: TarEntryType, entryName: string): PaxTarEntry$instance;
    new(entryType: TarEntryType, entryName: string, extendedAttributes: IEnumerable_1<KeyValuePair_2<CLROf<string>, CLROf<string>>>): PaxTarEntry$instance;
    new(other: TarEntry): PaxTarEntry$instance;
};


export type PaxTarEntry = PaxTarEntry$instance;

export interface PosixTarEntry$instance extends TarEntry {
    deviceMajor: int;
    deviceMinor: int;
    groupName: string;
    userName: string;
}


export const PosixTarEntry: {
};


export type PosixTarEntry = PosixTarEntry$instance;

export interface TarEntry$instance {
    readonly checksum: int;
    readonly dataOffset: long;
    dataStream: Stream;
    readonly entryType: TarEntryType;
    readonly format: TarEntryFormat;
    gid: int;
    readonly length: long;
    linkName: string;
    mode: UnixFileMode;
    modificationTime: DateTimeOffset;
    name: string;
    uid: int;
    extractToFile(destinationFileName: string, overwrite: boolean): void;
    extractToFileAsync(destinationFileName: string, overwrite: boolean, cancellationToken?: CancellationToken): Task;
    toString(): string;
}


export const TarEntry: {
};


export type TarEntry = TarEntry$instance;

export interface TarReader$instance {
    dispose(): void;
    disposeAsync(): ValueTask;
    getNextEntry(copyData?: boolean): TarEntry;
    getNextEntryAsync(copyData?: boolean, cancellationToken?: CancellationToken): ValueTask_1<TarEntry>;
}


export const TarReader: {
    new(archiveStream: Stream, leaveOpen: boolean): TarReader$instance;
};


export interface __TarReader$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface TarReader$instance extends System_Internal.IAsyncDisposable$instance, System_Internal.IDisposable$instance {}

export type TarReader = TarReader$instance & __TarReader$views;


export interface TarWriter$instance {
    readonly format: TarEntryFormat;
    dispose(): void;
    disposeAsync(): ValueTask;
    writeEntry(fileName: string, entryName: string): void;
    writeEntry(entry: TarEntry): void;
    writeEntryAsync(fileName: string, entryName: string, cancellationToken?: CancellationToken): Task;
    writeEntryAsync(entry: TarEntry, cancellationToken?: CancellationToken): Task;
}


export const TarWriter: {
    new(archiveStream: Stream): TarWriter$instance;
    new(archiveStream: Stream, leaveOpen: boolean): TarWriter$instance;
    new(archiveStream: Stream, format: TarEntryFormat, leaveOpen: boolean): TarWriter$instance;
};


export interface __TarWriter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface TarWriter$instance extends System_Internal.IAsyncDisposable$instance, System_Internal.IDisposable$instance {}

export type TarWriter = TarWriter$instance & __TarWriter$views;


export interface UstarTarEntry$instance extends PosixTarEntry {
}


export const UstarTarEntry: {
    new(entryType: TarEntryType, entryName: string): UstarTarEntry$instance;
    new(other: TarEntry): UstarTarEntry$instance;
};


export type UstarTarEntry = UstarTarEntry$instance;

export interface V7TarEntry$instance extends TarEntry {
}


export const V7TarEntry: {
    new(entryType: TarEntryType, entryName: string): V7TarEntry$instance;
    new(other: TarEntry): V7TarEntry$instance;
};


export type V7TarEntry = V7TarEntry$instance;

export abstract class TarFile$instance {
    static createFromDirectory(sourceDirectoryName: string, destination: Stream, includeBaseDirectory: boolean): void;
    static createFromDirectory(sourceDirectoryName: string, destinationFileName: string, includeBaseDirectory: boolean): void;
    static createFromDirectoryAsync(sourceDirectoryName: string, destination: Stream, includeBaseDirectory: boolean, cancellationToken?: CancellationToken): Task;
    static createFromDirectoryAsync(sourceDirectoryName: string, destinationFileName: string, includeBaseDirectory: boolean, cancellationToken?: CancellationToken): Task;
    static extractToDirectory(source: Stream, destinationDirectoryName: string, overwriteFiles: boolean): void;
    static extractToDirectory(sourceFileName: string, destinationDirectoryName: string, overwriteFiles: boolean): void;
    static extractToDirectoryAsync(source: Stream, destinationDirectoryName: string, overwriteFiles: boolean, cancellationToken?: CancellationToken): Task;
    static extractToDirectoryAsync(sourceFileName: string, destinationDirectoryName: string, overwriteFiles: boolean, cancellationToken?: CancellationToken): Task;
}


export type TarFile = TarFile$instance;

