// Generated by tsbindgen - Architecture
// Namespace: System.ComponentModel
// Assembly: System.ComponentModel, System.ComponentModel.EventBasedAsync, System.ComponentModel.Primitives, System.ComponentModel.TypeConverter, System.ObjectModel, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IList_1, IReadOnlyCollection_1, IReadOnlyList_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_ObjectModel_Internal from "../../System.Collections.ObjectModel/internal/index.js";
import type { Collection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { Hashtable, ICollection, IComparer, IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator, IList, ReadOnlyCollectionBase } from "../../System.Collections/internal/index.js";
import type { IDesigner } from "../../System.ComponentModel.Design/internal/index.js";
import type { CultureInfo } from "../../System.Globalization/internal/index.js";
import type { UnmanagedMemoryStream } from "../../System.IO/internal/index.js";
import type { Assembly, MethodBase, MethodInfo, Module } from "../../System.Reflection/internal/index.js";
import * as System_Resources_Internal from "../../System.Resources/internal/index.js";
import type { ResourceManager, ResourceSet } from "../../System.Resources/internal/index.js";
import * as System_Runtime_InteropServices_Internal from "../../System.Runtime.InteropServices/internal/index.js";
import type { ExternalException } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { SendOrPostCallback, SynchronizationContext } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ArgumentException, Array as ClrArray, AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Char, Delegate, Double, Enum, EventArgs, EventHandler, EventHandler_1, Exception, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, IServiceProvider, ISpanFormattable, MarshalByRefObject, MulticastDelegate, Nullable_1, Object as ClrObject, SByte, Single, String as ClrString, SystemException, Type, TypeCode, UInt16, UInt32, UInt64, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum BindableSupport {
    no = 0,
    yes = 1,
    default_ = 2
}


export enum BindingDirection {
    oneWay = 0,
    twoWay = 1
}


export enum CollectionChangeAction {
    add = 1,
    remove = 2,
    refresh = 3
}


export enum DataObjectMethodType {
    fill = 0,
    select = 1,
    update = 2,
    insert = 3,
    delete_ = 4
}


export enum DesignerSerializationVisibility {
    hidden = 0,
    visible = 1,
    content = 2
}


export enum EditorBrowsableState {
    always = 0,
    never_ = 1,
    advanced = 2
}


export enum InheritanceLevel {
    inherited = 1,
    inheritedReadOnly = 2,
    notInherited = 3
}


export enum LicenseUsageMode {
    runtime = 0,
    designtime = 1
}


export enum ListChangedType {
    reset = 0,
    itemAdded = 1,
    itemDeleted = 2,
    itemMoved = 3,
    itemChanged = 4,
    propertyDescriptorAdded = 5,
    propertyDescriptorDeleted = 6,
    propertyDescriptorChanged = 7
}


export enum ListSortDirection {
    ascending = 0,
    descending = 1
}


export enum MaskedTextResultHint {
    unknown_ = 0,
    characterEscaped = 1,
    noEffect = 2,
    sideEffect = 3,
    success = 4,
    asciiCharacterExpected = -1,
    alphanumericCharacterExpected = -2,
    digitExpected = -3,
    letterExpected = -4,
    signedDigitExpected = -5,
    invalidInput = -51,
    promptCharNotAllowed = -52,
    unavailableEditPosition = -53,
    nonEditPosition = -54,
    positionOutOfRange = -55
}


export enum PropertyTabScope {
    static_ = 0,
    global = 1,
    document = 2,
    component = 3
}


export enum RefreshProperties {
    none = 0,
    all = 1,
    repaint = 2
}


export enum ToolboxItemFilterType {
    allow = 0,
    custom = 1,
    prevent = 2,
    require = 3
}


export type AddingNewEventHandler = (sender: unknown, e: AddingNewEventArgs) => void;


export type AsyncCompletedEventHandler = (sender: unknown, e: AsyncCompletedEventArgs) => void;


export type CancelEventHandler = (sender: unknown, e: CancelEventArgs) => void;


export type CollectionChangeEventHandler = (sender: unknown, e: CollectionChangeEventArgs) => void;


export type DoWorkEventHandler = (sender: unknown, e: DoWorkEventArgs) => void;


export type HandledEventHandler = (sender: unknown, e: HandledEventArgs) => void;


export type ListChangedEventHandler = (sender: unknown, e: ListChangedEventArgs) => void;


export type ProgressChangedEventHandler = (sender: unknown, e: ProgressChangedEventArgs) => void;


export type PropertyChangedEventHandler = (sender: unknown, e: PropertyChangedEventArgs) => void;


export type PropertyChangingEventHandler = (sender: unknown, e: PropertyChangingEventArgs) => void;


export type RefreshEventHandler = (e: RefreshEventArgs) => void;


export type RunWorkerCompletedEventHandler = (sender: unknown, e: RunWorkerCompletedEventArgs) => void;


export interface IBindingList$instance extends IList, ICollection, IEnumerable {
    readonly allowNew: boolean;
    readonly allowEdit: boolean;
    readonly allowRemove: boolean;
    readonly supportsChangeNotification: boolean;
    readonly supportsSearching: boolean;
    readonly supportsSorting: boolean;
    readonly isSorted: boolean;
    readonly sortProperty: PropertyDescriptor;
    readonly sortDirection: ListSortDirection;
    item: unknown;
    readonly isReadOnly: boolean;
    readonly isFixedSize: boolean;
    readonly count: int;
    readonly syncRoot: unknown;
    readonly isSynchronized: boolean;
    add(value: unknown): int;
    addIndex(property: PropertyDescriptor): void;
    addNew(): unknown;
    applySort(property: PropertyDescriptor, direction: ListSortDirection): void;
    contains(value: unknown): boolean;
    copyTo(array: ClrArray, index: int): void;
    find(property: PropertyDescriptor, key: unknown): int;
    getEnumerator(): IEnumerator;
    insert(index: int, value: unknown): void;
    remove(value: unknown): void;
    removeAt(index: int): void;
    removeSort(): void;
}


export type IBindingList = IBindingList$instance;

export interface IBindingListView$instance extends IBindingList, IList, ICollection, IEnumerable {
    filter: string;
    readonly sortDescriptions: ListSortDescriptionCollection;
    readonly supportsAdvancedSorting: boolean;
    readonly supportsFiltering: boolean;
    readonly allowNew: boolean;
    readonly allowEdit: boolean;
    readonly allowRemove: boolean;
    readonly supportsChangeNotification: boolean;
    readonly supportsSearching: boolean;
    readonly supportsSorting: boolean;
    readonly isSorted: boolean;
    readonly sortProperty: PropertyDescriptor;
    readonly sortDirection: ListSortDirection;
    item: unknown;
    readonly isReadOnly: boolean;
    readonly isFixedSize: boolean;
    readonly count: int;
    readonly syncRoot: unknown;
    readonly isSynchronized: boolean;
    add(value: unknown): int;
    addIndex(property: PropertyDescriptor): void;
    addNew(): unknown;
    applySort(property: PropertyDescriptor, direction: ListSortDirection): void;
    applySort(sorts: ListSortDescriptionCollection): void;
    contains(value: unknown): boolean;
    copyTo(array: ClrArray, index: int): void;
    find(property: PropertyDescriptor, key: unknown): int;
    getEnumerator(): IEnumerator;
    insert(index: int, value: unknown): void;
    remove(value: unknown): void;
    removeAt(index: int): void;
    removeFilter(): void;
}


export type IBindingListView = IBindingListView$instance;

export interface ICancelAddNew$instance {
    cancelNew(itemIndex: int): void;
}


export type ICancelAddNew = ICancelAddNew$instance;

export interface IChangeTracking$instance {
    readonly isChanged: boolean;
    acceptChanges(): void;
}


export type IChangeTracking = IChangeTracking$instance;

export interface IComNativeDescriptorHandler$instance {
    getAttributes(component: unknown): AttributeCollection;
    getClassName(component: unknown): string;
    getConverter(component: unknown): TypeConverter;
    getDefaultEvent(component: unknown): EventDescriptor;
    getDefaultProperty(component: unknown): PropertyDescriptor;
    getEditor(component: unknown, baseEditorType: Type): unknown;
    getEvents(component: unknown, attributes: Attribute[]): EventDescriptorCollection;
    getEvents(component: unknown): EventDescriptorCollection;
    getProperties(component: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    getPropertyValue(component: unknown, dispid: int, success: { value: ref<boolean> }): unknown;
    getPropertyValue(component: unknown, propertyName: string, success: { value: ref<boolean> }): unknown;
}


export type IComNativeDescriptorHandler = IComNativeDescriptorHandler$instance;

export interface IComponent$instance extends IDisposable {
    site: ISite;
    dispose(): void;
}


export interface IComponent$instance extends System_Internal.IDisposable$instance {}

export type IComponent = IComponent$instance;

export interface IContainer$instance extends IDisposable {
    readonly components: ComponentCollection;
    add(component: IComponent, name: string): void;
    add(component: IComponent): void;
    dispose(): void;
}


export interface IContainer$instance extends System_Internal.IDisposable$instance {}

export type IContainer = IContainer$instance;

export interface ICustomTypeDescriptor$instance {
    readonly requireRegisteredTypes: Nullable_1<CLROf<boolean>>;
    getAttributes(): AttributeCollection;
    getClassName(): string;
    getConverter(): TypeConverter;
    getDefaultEvent(): EventDescriptor;
    getDefaultProperty(): PropertyDescriptor;
    getEditor(editorBaseType: Type): unknown;
    getEvents(): EventDescriptorCollection;
    getEvents(attributes: Attribute[]): EventDescriptorCollection;
    getProperties(): PropertyDescriptorCollection;
    getProperties(attributes: Attribute[]): PropertyDescriptorCollection;
    getPropertyOwner(pd: PropertyDescriptor): unknown;
}


export type ICustomTypeDescriptor = ICustomTypeDescriptor$instance;

export interface IDataErrorInfo$instance {
    readonly item: string;
    readonly error: string;
}


export type IDataErrorInfo = IDataErrorInfo$instance;

export interface IEditableObject$instance {
    beginEdit(): void;
}


export type IEditableObject = IEditableObject$instance;

export interface IExtenderProvider$instance {
    canExtend(extendee: unknown): boolean;
}


export type IExtenderProvider = IExtenderProvider$instance;

export interface IIntellisenseBuilder$instance {
    readonly name: string;
    show(language: string, value: string, newValue: { value: ref<string> }): boolean;
}


export type IIntellisenseBuilder = IIntellisenseBuilder$instance;

export interface IListSource$instance {
    readonly containsListCollection: boolean;
    getList(): IList;
}


export type IListSource = IListSource$instance;

export interface INestedContainer$instance extends IContainer, IDisposable {
    readonly owner: IComponent;
    readonly components: ComponentCollection;
    add(component: IComponent, name: string): void;
    add(component: IComponent): void;
    dispose(): void;
}


export type INestedContainer = INestedContainer$instance;

export interface INestedSite$instance extends ISite, IServiceProvider {
    readonly fullName: string;
    readonly component: IComponent;
    readonly container: IContainer;
    readonly designMode: boolean;
    name: string;
    getService(serviceType: Type): unknown;
}


export type INestedSite = INestedSite$instance;

export interface INotifyDataErrorInfo$instance {
    readonly hasErrors: boolean;
    getErrors(propertyName: string): IEnumerable;
}


export type INotifyDataErrorInfo = INotifyDataErrorInfo$instance;

export interface INotifyPropertyChanged$instance {
}


export type INotifyPropertyChanged = INotifyPropertyChanged$instance;

export interface INotifyPropertyChanging$instance {
}


export type INotifyPropertyChanging = INotifyPropertyChanging$instance;

export interface IRaiseItemChangedEvents$instance {
    readonly raisesItemChangedEvents: boolean;
}


export type IRaiseItemChangedEvents = IRaiseItemChangedEvents$instance;

export interface IRevertibleChangeTracking$instance extends IChangeTracking {
    readonly isChanged: boolean;
    rejectChanges(): void;
}


export interface IRevertibleChangeTracking$instance extends IChangeTracking$instance {}

export type IRevertibleChangeTracking = IRevertibleChangeTracking$instance;

export interface ISite$instance extends IServiceProvider {
    readonly component: IComponent;
    readonly container: IContainer;
    readonly designMode: boolean;
    name: string;
    getService(serviceType: Type): unknown;
}


export interface ISite$instance extends System_Internal.IServiceProvider$instance {}

export type ISite = ISite$instance;

export interface ISupportInitialize$instance {
    beginInit(): void;
}


export type ISupportInitialize = ISupportInitialize$instance;

export interface ISupportInitializeNotification$instance extends ISupportInitialize {
    readonly isInitialized: boolean;
    beginInit(): void;
}


export interface ISupportInitializeNotification$instance extends ISupportInitialize$instance {}

export type ISupportInitializeNotification = ISupportInitializeNotification$instance;

export interface ISynchronizeInvoke$instance {
    readonly invokeRequired: boolean;
    beginInvoke(method: Function, args: unknown[]): IAsyncResult;
    endInvoke(result: IAsyncResult): unknown;
    invoke(method: Function, args: unknown[]): unknown;
}


export type ISynchronizeInvoke = ISynchronizeInvoke$instance;

export interface ITypeDescriptorContext$instance extends IServiceProvider {
    readonly container: IContainer;
    readonly instance: unknown;
    readonly propertyDescriptor: PropertyDescriptor;
    getService(serviceType: Type): unknown;
    onComponentChanged(): void;
    onComponentChanging(): boolean;
}


export interface ITypeDescriptorContext$instance extends System_Internal.IServiceProvider$instance {}

export type ITypeDescriptorContext = ITypeDescriptorContext$instance;

export interface ITypedList$instance {
    getItemProperties(listAccessors: PropertyDescriptor[]): PropertyDescriptorCollection;
    getListName(listAccessors: PropertyDescriptor[]): string;
}


export type ITypedList = ITypedList$instance;

export interface AddingNewEventArgs$instance extends EventArgs {
    newObject: unknown;
}


export const AddingNewEventArgs: {
    new(): AddingNewEventArgs$instance;
    new(newObject: unknown): AddingNewEventArgs$instance;
};


export type AddingNewEventArgs = AddingNewEventArgs$instance;

export interface AmbientValueAttribute$instance extends Attribute {
    readonly value: unknown;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const AmbientValueAttribute: {
    new(type_: Type, value: string): AmbientValueAttribute$instance;
    new(value: char): AmbientValueAttribute$instance;
    new(value: byte): AmbientValueAttribute$instance;
    new(value: short): AmbientValueAttribute$instance;
    new(value: int): AmbientValueAttribute$instance;
    new(value: long): AmbientValueAttribute$instance;
    new(value: float): AmbientValueAttribute$instance;
    new(value: double): AmbientValueAttribute$instance;
    new(value: boolean): AmbientValueAttribute$instance;
    new(value: string): AmbientValueAttribute$instance;
    new(value: unknown): AmbientValueAttribute$instance;
};


export type AmbientValueAttribute = AmbientValueAttribute$instance;

export interface ArrayConverter$instance extends CollectionConverter {
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    getProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(value: unknown): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    getPropertiesSupported(context: ITypeDescriptorContext): boolean;
    getPropertiesSupported(): boolean;
}


export const ArrayConverter: {
    new(): ArrayConverter$instance;
};


export type ArrayConverter = ArrayConverter$instance;

export interface AsyncCompletedEventArgs$instance extends EventArgs {
    readonly cancelled: boolean;
    readonly error: Exception;
    readonly userState: unknown;
}


export const AsyncCompletedEventArgs: {
    new(error: Exception, cancelled: boolean, userState: unknown): AsyncCompletedEventArgs$instance;
};


export type AsyncCompletedEventArgs = AsyncCompletedEventArgs$instance;

export interface AsyncOperation$instance {
    readonly synchronizationContext: SynchronizationContext;
    readonly userSuppliedState: unknown;
    operationCompleted(): void;
    post(d: SendOrPostCallback, arg: unknown): void;
    postOperationCompleted(d: SendOrPostCallback, arg: unknown): void;
}


export const AsyncOperation: {
    new(): AsyncOperation$instance;
};


export type AsyncOperation = AsyncOperation$instance;

export interface AttributeCollection$instance {
    readonly count: int;
    contains(attribute: Attribute): boolean;
    contains(attributes: Attribute[]): boolean;
    copyTo(array: ClrArray, index: int): void;
    get_Item(index: int): Attribute;
    get_Item(attributeType: Type): Attribute;
    getEnumerator(): IEnumerator;
    matches(attribute: Attribute): boolean;
    matches(attributes: Attribute[]): boolean;
}


export const AttributeCollection: {
    new(attributes: Attribute[]): AttributeCollection$instance;
    readonly empty: AttributeCollection;
    fromExisting(existing: AttributeCollection, newAttributes: Attribute[]): AttributeCollection;
};


export interface __AttributeCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type AttributeCollection = AttributeCollection$instance & __AttributeCollection$views;


export interface AttributeProviderAttribute$instance extends Attribute {
    readonly propertyName: string;
    readonly typeName: string;
}


export const AttributeProviderAttribute: {
    new(typeName: string): AttributeProviderAttribute$instance;
    new(typeName: string, propertyName: string): AttributeProviderAttribute$instance;
    new(type_: Type): AttributeProviderAttribute$instance;
};


export type AttributeProviderAttribute = AttributeProviderAttribute$instance;

export interface BackgroundWorker$instance extends Component$instance {
    readonly cancellationPending: boolean;
    readonly isBusy: boolean;
    workerReportsProgress: boolean;
    workerSupportsCancellation: boolean;
    cancelAsync(): void;
    dispose(): void;
    reportProgress(percentProgress: int): void;
    reportProgress(percentProgress: int, userState: unknown): void;
    runWorkerAsync(): void;
    runWorkerAsync(argument: unknown): void;
}


export const BackgroundWorker: {
    new(): BackgroundWorker$instance;
};


export interface __BackgroundWorker$views {
    As_IComponent(): IComponent$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface BackgroundWorker$instance extends IComponent$instance {}

export type BackgroundWorker = BackgroundWorker$instance & __BackgroundWorker$views;


export interface BaseNumberConverter$instance extends TypeConverter {
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
}


export const BaseNumberConverter: {
};


export type BaseNumberConverter = BaseNumberConverter$instance;

export interface BindableAttribute$instance extends Attribute {
    readonly bindable: boolean;
    readonly direction: BindingDirection;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
}


export const BindableAttribute: {
    new(bindable: boolean): BindableAttribute$instance;
    new(bindable: boolean, direction: BindingDirection): BindableAttribute$instance;
    new(flags: BindableSupport): BindableAttribute$instance;
    new(flags: BindableSupport, direction: BindingDirection): BindableAttribute$instance;
    readonly yes: BindableAttribute;
    readonly no: BindableAttribute;
    readonly default_: BindableAttribute;
};


export type BindableAttribute = BindableAttribute$instance;

export interface BindingList_1$instance<T> extends Collection_1<T> {
    allowEdit: boolean;
    allowNew: boolean;
    allowRemove: boolean;
    raiseListChangedEvents: boolean;
    add(item: T): void;
    add(value: unknown): int;
    addNew(): T;
    cancelNew(itemIndex: int): void;
    clear(): void;
    contains(item: T): boolean;
    contains(value: unknown): boolean;
    copyTo(array: T[], index: int): void;
    copyTo(array: ClrArray, index: int): void;
    endNew(itemIndex: int): void;
    getEnumerator(): IEnumerator_1<T>;
    getEnumerator(): IEnumerator;
    indexOf(item: T): int;
    insert(index: int, item: T): void;
    insert(index: int, value: unknown): void;
    remove(item: T): boolean;
    remove(value: unknown): void;
    removeAt(index: int): void;
    resetBindings(): void;
    resetItem(position: int): void;
}


export const BindingList_1: {
    new<T>(): BindingList_1$instance<T>;
    new<T>(list: IList_1<T>): BindingList_1$instance<T>;
};


export interface __BindingList_1$views<T> {
    As_IBindingList(): IBindingList$instance;
    As_ICancelAddNew(): ICancelAddNew$instance;
    As_IRaiseItemChangedEvents(): IRaiseItemChangedEvents$instance;
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export interface BindingList_1$instance<T> extends ICancelAddNew$instance, IRaiseItemChangedEvents$instance {}

export type BindingList_1<T> = BindingList_1$instance<T> & __BindingList_1$views<T>;


export interface BooleanConverter$instance extends TypeConverter {
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    getStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    getStandardValues(): ICollection;
    getStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    getStandardValuesExclusive(): boolean;
    getStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    getStandardValuesSupported(): boolean;
}


export const BooleanConverter: {
    new(): BooleanConverter$instance;
};


export type BooleanConverter = BooleanConverter$instance;

export interface BrowsableAttribute$instance extends Attribute {
    readonly browsable: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
}


export const BrowsableAttribute: {
    new(browsable: boolean): BrowsableAttribute$instance;
    readonly yes: BrowsableAttribute;
    readonly no: BrowsableAttribute;
    readonly default_: BrowsableAttribute;
};


export type BrowsableAttribute = BrowsableAttribute$instance;

export interface ByteConverter$instance extends BaseNumberConverter {
}


export const ByteConverter: {
    new(): ByteConverter$instance;
};


export type ByteConverter = ByteConverter$instance;

export interface CancelEventArgs$instance extends EventArgs {
    cancel: boolean;
}


export const CancelEventArgs: {
    new(): CancelEventArgs$instance;
    new(cancel: boolean): CancelEventArgs$instance;
};


export type CancelEventArgs = CancelEventArgs$instance;

export interface CategoryAttribute$instance extends Attribute {
    readonly category: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
}


export const CategoryAttribute: {
    new(): CategoryAttribute$instance;
    new(category: string): CategoryAttribute$instance;
    readonly action: CategoryAttribute;
    readonly appearance: CategoryAttribute;
    readonly asynchronous: CategoryAttribute;
    readonly behavior: CategoryAttribute;
    readonly data: CategoryAttribute;
    readonly default_: CategoryAttribute;
    readonly design: CategoryAttribute;
    readonly dragDrop: CategoryAttribute;
    readonly focus: CategoryAttribute;
    readonly format: CategoryAttribute;
    readonly key: CategoryAttribute;
    readonly layout: CategoryAttribute;
    readonly mouse: CategoryAttribute;
    readonly windowStyle: CategoryAttribute;
};


export type CategoryAttribute = CategoryAttribute$instance;

export interface CharConverter$instance extends TypeConverter {
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
}


export const CharConverter: {
    new(): CharConverter$instance;
};


export type CharConverter = CharConverter$instance;

export interface CollectionChangeEventArgs$instance extends EventArgs {
    readonly action: CollectionChangeAction;
    readonly element: unknown;
}


export const CollectionChangeEventArgs: {
    new(action: CollectionChangeAction, element: unknown): CollectionChangeEventArgs$instance;
};


export type CollectionChangeEventArgs = CollectionChangeEventArgs$instance;

export interface CollectionConverter$instance extends TypeConverter {
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    getProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(value: unknown): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
}


export const CollectionConverter: {
    new(): CollectionConverter$instance;
};


export type CollectionConverter = CollectionConverter$instance;

export interface ComplexBindingPropertiesAttribute$instance extends Attribute {
    readonly dataMember: string;
    readonly dataSource: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const ComplexBindingPropertiesAttribute: {
    new(): ComplexBindingPropertiesAttribute$instance;
    new(dataSource: string): ComplexBindingPropertiesAttribute$instance;
    new(dataSource: string, dataMember: string): ComplexBindingPropertiesAttribute$instance;
    readonly default_: ComplexBindingPropertiesAttribute;
};


export type ComplexBindingPropertiesAttribute = ComplexBindingPropertiesAttribute$instance;

export interface Component$instance extends MarshalByRefObject {
    readonly container: IContainer;
    site: ISite;
    dispose(): void;
    toString(): string;
}


export const Component: {
    new(): Component$instance;
};


export interface __Component$views {
    As_IComponent(): IComponent$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type Component = Component$instance & __Component$views;


export interface ComponentCollection$instance extends ReadOnlyCollectionBase {
    copyTo(array: ClrArray, index: int): void;
    get_Item(name: string): IComponent;
    get_Item(index: int): IComponent;
    getEnumerator(): IEnumerator;
}


export const ComponentCollection: {
    new(components: IComponent[]): ComponentCollection$instance;
};


export interface __ComponentCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export interface ComponentCollection$instance extends System_Collections_Internal.ICollection$instance {}

export type ComponentCollection = ComponentCollection$instance & __ComponentCollection$views;


export interface ComponentConverter$instance extends ReferenceConverter {
    getProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(value: unknown): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    getPropertiesSupported(context: ITypeDescriptorContext): boolean;
    getPropertiesSupported(): boolean;
}


export const ComponentConverter: {
    new(type_: Type): ComponentConverter$instance;
};


export type ComponentConverter = ComponentConverter$instance;

export interface ComponentEditor$instance {
    editComponent(component: unknown): boolean;
    editComponent(context: ITypeDescriptorContext, component: unknown): boolean;
}


export const ComponentEditor: {
};


export type ComponentEditor = ComponentEditor$instance;

export interface ComponentResourceManager$instance extends ResourceManager {
    applyResources(value: unknown, objectName: string): void;
    applyResources(value: unknown, objectName: string, culture: CultureInfo): void;
    applyResourcesToRegisteredType(value: unknown, objectName: string, culture: CultureInfo): void;
}


export const ComponentResourceManager: {
    new(): ComponentResourceManager$instance;
    new(t: Type): ComponentResourceManager$instance;
};


export type ComponentResourceManager = ComponentResourceManager$instance;

export interface Container$instance {
    readonly components: ComponentCollection;
    add(component: IComponent): void;
    add(component: IComponent, name: string): void;
    dispose(): void;
    remove(component: IComponent): void;
}


export const Container: {
    new(): Container$instance;
};


export interface __Container$views {
    As_IContainer(): IContainer$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type Container = Container$instance & __Container$views;


export interface ContainerFilterService$instance {
    filterComponents(components: ComponentCollection): ComponentCollection;
}


export const ContainerFilterService: {
};


export type ContainerFilterService = ContainerFilterService$instance;

export interface CultureInfoConverter$instance extends TypeConverter {
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    getStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    getStandardValues(): ICollection;
    getStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    getStandardValuesExclusive(): boolean;
    getStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    getStandardValuesSupported(): boolean;
}


export const CultureInfoConverter: {
    new(): CultureInfoConverter$instance;
};


export type CultureInfoConverter = CultureInfoConverter$instance;

export interface CustomTypeDescriptor$instance {
    readonly requireRegisteredTypes: Nullable_1<CLROf<boolean>>;
    getAttributes(): AttributeCollection;
    getClassName(): string;
    getComponentName(): string;
    getConverter(): TypeConverter;
    getConverterFromRegisteredType(): TypeConverter;
    getDefaultEvent(): EventDescriptor;
    getDefaultProperty(): PropertyDescriptor;
    getEditor(editorBaseType: Type): unknown;
    getEvents(): EventDescriptorCollection;
    getEvents(attributes: Attribute[]): EventDescriptorCollection;
    getEventsFromRegisteredType(): EventDescriptorCollection;
    getProperties(): PropertyDescriptorCollection;
    getProperties(attributes: Attribute[]): PropertyDescriptorCollection;
    getPropertiesFromRegisteredType(): PropertyDescriptorCollection;
    getPropertyOwner(pd: PropertyDescriptor): unknown;
}


export const CustomTypeDescriptor: {
};


export interface __CustomTypeDescriptor$views {
    As_ICustomTypeDescriptor(): ICustomTypeDescriptor$instance;
}

export interface CustomTypeDescriptor$instance extends ICustomTypeDescriptor$instance {}

export type CustomTypeDescriptor = CustomTypeDescriptor$instance & __CustomTypeDescriptor$views;


export interface DataErrorsChangedEventArgs$instance extends EventArgs {
    readonly propertyName: string;
}


export const DataErrorsChangedEventArgs: {
    new(propertyName: string): DataErrorsChangedEventArgs$instance;
};


export type DataErrorsChangedEventArgs = DataErrorsChangedEventArgs$instance;

export interface DataObjectAttribute$instance extends Attribute {
    readonly isDataObject: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
}


export const DataObjectAttribute: {
    new(): DataObjectAttribute$instance;
    new(isDataObject: boolean): DataObjectAttribute$instance;
    readonly dataObject: DataObjectAttribute;
    readonly nonDataObject: DataObjectAttribute;
    readonly default_: DataObjectAttribute;
};


export type DataObjectAttribute = DataObjectAttribute$instance;

export interface DataObjectFieldAttribute$instance extends Attribute {
    readonly isIdentity: boolean;
    readonly isNullable: boolean;
    readonly length: int;
    readonly primaryKey: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const DataObjectFieldAttribute: {
    new(primaryKey: boolean): DataObjectFieldAttribute$instance;
    new(primaryKey: boolean, isIdentity: boolean): DataObjectFieldAttribute$instance;
    new(primaryKey: boolean, isIdentity: boolean, isNullable: boolean): DataObjectFieldAttribute$instance;
    new(primaryKey: boolean, isIdentity: boolean, isNullable: boolean, length: int): DataObjectFieldAttribute$instance;
};


export type DataObjectFieldAttribute = DataObjectFieldAttribute$instance;

export interface DataObjectMethodAttribute$instance extends Attribute {
    readonly isDefault: boolean;
    readonly methodType: DataObjectMethodType;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    match(obj: unknown): boolean;
}


export const DataObjectMethodAttribute: {
    new(methodType: DataObjectMethodType): DataObjectMethodAttribute$instance;
    new(methodType: DataObjectMethodType, isDefault: boolean): DataObjectMethodAttribute$instance;
};


export type DataObjectMethodAttribute = DataObjectMethodAttribute$instance;

export interface DateOnlyConverter$instance extends TypeConverter {
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
}


export const DateOnlyConverter: {
    new(): DateOnlyConverter$instance;
};


export type DateOnlyConverter = DateOnlyConverter$instance;

export interface DateTimeConverter$instance extends TypeConverter {
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
}


export const DateTimeConverter: {
    new(): DateTimeConverter$instance;
};


export type DateTimeConverter = DateTimeConverter$instance;

export interface DateTimeOffsetConverter$instance extends TypeConverter {
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
}


export const DateTimeOffsetConverter: {
    new(): DateTimeOffsetConverter$instance;
};


export type DateTimeOffsetConverter = DateTimeOffsetConverter$instance;

export interface DecimalConverter$instance extends BaseNumberConverter {
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
}


export const DecimalConverter: {
    new(): DecimalConverter$instance;
};


export type DecimalConverter = DecimalConverter$instance;

export interface DefaultBindingPropertyAttribute$instance extends Attribute {
    readonly name: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const DefaultBindingPropertyAttribute: {
    new(): DefaultBindingPropertyAttribute$instance;
    new(name: string): DefaultBindingPropertyAttribute$instance;
    readonly default_: DefaultBindingPropertyAttribute;
};


export type DefaultBindingPropertyAttribute = DefaultBindingPropertyAttribute$instance;

export interface DefaultEventAttribute$instance extends Attribute {
    readonly name: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const DefaultEventAttribute: {
    new(name: string): DefaultEventAttribute$instance;
    readonly default_: DefaultEventAttribute;
};


export type DefaultEventAttribute = DefaultEventAttribute$instance;

export interface DefaultPropertyAttribute$instance extends Attribute {
    readonly name: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const DefaultPropertyAttribute: {
    new(name: string): DefaultPropertyAttribute$instance;
    readonly default_: DefaultPropertyAttribute;
};


export type DefaultPropertyAttribute = DefaultPropertyAttribute$instance;

export interface DefaultValueAttribute$instance extends Attribute {
    readonly value: unknown;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const DefaultValueAttribute: {
    new(type_: Type, value: string): DefaultValueAttribute$instance;
    new(value: char): DefaultValueAttribute$instance;
    new(value: byte): DefaultValueAttribute$instance;
    new(value: short): DefaultValueAttribute$instance;
    new(value: int): DefaultValueAttribute$instance;
    new(value: long): DefaultValueAttribute$instance;
    new(value: float): DefaultValueAttribute$instance;
    new(value: double): DefaultValueAttribute$instance;
    new(value: boolean): DefaultValueAttribute$instance;
    new(value: string): DefaultValueAttribute$instance;
    new(value: unknown): DefaultValueAttribute$instance;
    new(value: sbyte): DefaultValueAttribute$instance;
    new(value: ushort): DefaultValueAttribute$instance;
    new(value: uint): DefaultValueAttribute$instance;
    new(value: ulong): DefaultValueAttribute$instance;
};


export type DefaultValueAttribute = DefaultValueAttribute$instance;

export interface DescriptionAttribute$instance extends Attribute {
    readonly description: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
}


export const DescriptionAttribute: {
    new(): DescriptionAttribute$instance;
    new(description: string): DescriptionAttribute$instance;
    readonly default_: DescriptionAttribute;
};


export type DescriptionAttribute = DescriptionAttribute$instance;

export interface DesignerAttribute$instance extends Attribute {
    readonly designerBaseTypeName: string;
    readonly designerTypeName: string;
    readonly typeId: unknown;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const DesignerAttribute: {
    new(designerTypeName: string): DesignerAttribute$instance;
    new(designerType: Type): DesignerAttribute$instance;
    new(designerTypeName: string, designerBaseTypeName: string): DesignerAttribute$instance;
    new(designerTypeName: string, designerBaseType: Type): DesignerAttribute$instance;
    new(designerType: Type, designerBaseType: Type): DesignerAttribute$instance;
};


export type DesignerAttribute = DesignerAttribute$instance;

export interface DesignerCategoryAttribute$instance extends Attribute {
    readonly category: string;
    readonly typeId: unknown;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
}


export const DesignerCategoryAttribute: {
    new(): DesignerCategoryAttribute$instance;
    new(category: string): DesignerCategoryAttribute$instance;
    readonly component: DesignerCategoryAttribute;
    readonly default_: DesignerCategoryAttribute;
    readonly form: DesignerCategoryAttribute;
    readonly generic: DesignerCategoryAttribute;
};


export type DesignerCategoryAttribute = DesignerCategoryAttribute$instance;

export interface DesignerSerializationVisibilityAttribute$instance extends Attribute {
    readonly visibility: DesignerSerializationVisibility;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
}


export const DesignerSerializationVisibilityAttribute: {
    new(visibility: DesignerSerializationVisibility): DesignerSerializationVisibilityAttribute$instance;
    readonly content: DesignerSerializationVisibilityAttribute;
    readonly hidden: DesignerSerializationVisibilityAttribute;
    readonly visible: DesignerSerializationVisibilityAttribute;
    readonly default_: DesignerSerializationVisibilityAttribute;
};


export type DesignerSerializationVisibilityAttribute = DesignerSerializationVisibilityAttribute$instance;

export interface DesignOnlyAttribute$instance extends Attribute {
    readonly isDesignOnly: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
}


export const DesignOnlyAttribute: {
    new(isDesignOnly: boolean): DesignOnlyAttribute$instance;
    readonly yes: DesignOnlyAttribute;
    readonly no: DesignOnlyAttribute;
    readonly default_: DesignOnlyAttribute;
};


export type DesignOnlyAttribute = DesignOnlyAttribute$instance;

export interface DesignTimeVisibleAttribute$instance extends Attribute {
    readonly visible: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
}


export const DesignTimeVisibleAttribute: {
    new(visible: boolean): DesignTimeVisibleAttribute$instance;
    new(): DesignTimeVisibleAttribute$instance;
    readonly yes: DesignTimeVisibleAttribute;
    readonly no: DesignTimeVisibleAttribute;
    readonly default_: DesignTimeVisibleAttribute;
};


export type DesignTimeVisibleAttribute = DesignTimeVisibleAttribute$instance;

export interface DisplayNameAttribute$instance extends Attribute {
    readonly displayName: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
}


export const DisplayNameAttribute: {
    new(): DisplayNameAttribute$instance;
    new(displayName: string): DisplayNameAttribute$instance;
    readonly default_: DisplayNameAttribute;
};


export type DisplayNameAttribute = DisplayNameAttribute$instance;

export interface DoubleConverter$instance extends BaseNumberConverter {
}


export const DoubleConverter: {
    new(): DoubleConverter$instance;
};


export type DoubleConverter = DoubleConverter$instance;

export interface DoWorkEventArgs$instance extends CancelEventArgs {
    readonly argument: unknown;
    result: unknown;
}


export const DoWorkEventArgs: {
    new(argument: unknown): DoWorkEventArgs$instance;
};


export type DoWorkEventArgs = DoWorkEventArgs$instance;

export interface EditorAttribute$instance extends Attribute {
    readonly editorBaseTypeName: string;
    readonly editorTypeName: string;
    readonly typeId: unknown;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const EditorAttribute: {
    new(): EditorAttribute$instance;
    new(typeName: string, baseTypeName: string): EditorAttribute$instance;
    new(typeName: string, baseType: Type): EditorAttribute$instance;
    new(type_: Type, baseType: Type): EditorAttribute$instance;
};


export type EditorAttribute = EditorAttribute$instance;

export interface EditorBrowsableAttribute$instance extends Attribute {
    readonly state: EditorBrowsableState;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const EditorBrowsableAttribute: {
    new(state: EditorBrowsableState): EditorBrowsableAttribute$instance;
    new(): EditorBrowsableAttribute$instance;
};


export type EditorBrowsableAttribute = EditorBrowsableAttribute$instance;

export interface EnumConverter$instance extends TypeConverter {
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    getStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    getStandardValues(): ICollection;
    getStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    getStandardValuesExclusive(): boolean;
    getStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    getStandardValuesSupported(): boolean;
    isValid(context: ITypeDescriptorContext, value: unknown): boolean;
    isValid(value: unknown): boolean;
}


export const EnumConverter: {
    new(type_: Type): EnumConverter$instance;
};


export type EnumConverter = EnumConverter$instance;

export interface EventDescriptor$instance extends MemberDescriptor {
    readonly componentType: Type;
    readonly eventType: Type;
    readonly isMulticast: boolean;
    addEventHandler(component: unknown, value: Function): void;
    removeEventHandler(component: unknown, value: Function): void;
}


export const EventDescriptor: {
};


export type EventDescriptor = EventDescriptor$instance;

export interface EventDescriptorCollection$instance {
    readonly count: int;
    add(value: EventDescriptor): int;
    clear(): void;
    contains(value: EventDescriptor): boolean;
    find(name: string, ignoreCase: boolean): EventDescriptor;
    get_Item(index: int): EventDescriptor;
    get_Item(name: string): EventDescriptor;
    getEnumerator(): IEnumerator;
    indexOf(value: EventDescriptor): int;
    insert(index: int, value: EventDescriptor): void;
    remove(value: EventDescriptor): void;
    removeAt(index: int): void;
    sort(): EventDescriptorCollection;
    sort(names: string[]): EventDescriptorCollection;
    sort(names: string[], comparer: IComparer): EventDescriptorCollection;
    sort(comparer: IComparer): EventDescriptorCollection;
}


export const EventDescriptorCollection: {
    new(events: EventDescriptor[]): EventDescriptorCollection$instance;
    new(events: EventDescriptor[], readOnly: boolean): EventDescriptorCollection$instance;
    readonly empty: EventDescriptorCollection;
};


export interface __EventDescriptorCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type EventDescriptorCollection = EventDescriptorCollection$instance & __EventDescriptorCollection$views;


export interface EventHandlerList$instance {
    item: Function;
    addHandler(key: unknown, value: Function): void;
    addHandlers(listToAddFrom: EventHandlerList): void;
    dispose(): void;
    removeHandler(key: unknown, value: Function): void;
}


export const EventHandlerList: {
    new(): EventHandlerList$instance;
};


export interface __EventHandlerList$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface EventHandlerList$instance extends System_Internal.IDisposable$instance {}

export type EventHandlerList = EventHandlerList$instance & __EventHandlerList$views;


export interface ExpandableObjectConverter$instance extends TypeConverter {
    getProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(value: unknown): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    getPropertiesSupported(context: ITypeDescriptorContext): boolean;
    getPropertiesSupported(): boolean;
}


export const ExpandableObjectConverter: {
    new(): ExpandableObjectConverter$instance;
};


export type ExpandableObjectConverter = ExpandableObjectConverter$instance;

export interface ExtenderProvidedPropertyAttribute$instance extends Attribute {
    readonly extenderProperty: PropertyDescriptor;
    readonly provider: IExtenderProvider;
    readonly receiverType: Type;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
}


export const ExtenderProvidedPropertyAttribute: {
    new(): ExtenderProvidedPropertyAttribute$instance;
};


export type ExtenderProvidedPropertyAttribute = ExtenderProvidedPropertyAttribute$instance;

export interface GuidConverter$instance extends TypeConverter {
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
}


export const GuidConverter: {
    new(): GuidConverter$instance;
};


export type GuidConverter = GuidConverter$instance;

export interface HalfConverter$instance extends BaseNumberConverter {
}


export const HalfConverter: {
    new(): HalfConverter$instance;
};


export type HalfConverter = HalfConverter$instance;

export interface HandledEventArgs$instance extends EventArgs {
    handled: boolean;
}


export const HandledEventArgs: {
    new(): HandledEventArgs$instance;
    new(defaultHandledValue: boolean): HandledEventArgs$instance;
};


export type HandledEventArgs = HandledEventArgs$instance;

export interface ImmutableObjectAttribute$instance extends Attribute {
    readonly immutable: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
}


export const ImmutableObjectAttribute: {
    new(immutable: boolean): ImmutableObjectAttribute$instance;
    readonly yes: ImmutableObjectAttribute;
    readonly no: ImmutableObjectAttribute;
    readonly default_: ImmutableObjectAttribute;
};


export type ImmutableObjectAttribute = ImmutableObjectAttribute$instance;

export interface InheritanceAttribute$instance extends Attribute {
    readonly inheritanceLevel: InheritanceLevel;
    equals(value: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
    toString(): string;
}


export const InheritanceAttribute: {
    new(): InheritanceAttribute$instance;
    new(inheritanceLevel: InheritanceLevel): InheritanceAttribute$instance;
    readonly inherited: InheritanceAttribute;
    readonly inheritedReadOnly: InheritanceAttribute;
    readonly notInherited: InheritanceAttribute;
    readonly default_: InheritanceAttribute;
};


export type InheritanceAttribute = InheritanceAttribute$instance;

export interface InitializationEventAttribute$instance extends Attribute {
    readonly eventName: string;
}


export const InitializationEventAttribute: {
    new(eventName: string): InitializationEventAttribute$instance;
};


export type InitializationEventAttribute = InitializationEventAttribute$instance;

export interface InstallerTypeAttribute$instance extends Attribute {
    readonly installerType: Type;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const InstallerTypeAttribute: {
    new(installerType: Type): InstallerTypeAttribute$instance;
    new(typeName: string): InstallerTypeAttribute$instance;
};


export type InstallerTypeAttribute = InstallerTypeAttribute$instance;

export interface InstanceCreationEditor$instance {
    readonly text: string;
    createInstance(context: ITypeDescriptorContext, instanceType: Type): unknown;
}


export const InstanceCreationEditor: {
};


export type InstanceCreationEditor = InstanceCreationEditor$instance;

export interface Int128Converter$instance extends BaseNumberConverter {
}


export const Int128Converter: {
    new(): Int128Converter$instance;
};


export type Int128Converter = Int128Converter$instance;

export interface Int16Converter$instance extends BaseNumberConverter {
}


export const Int16Converter: {
    new(): Int16Converter$instance;
};


export type Int16Converter = Int16Converter$instance;

export interface Int32Converter$instance extends BaseNumberConverter {
}


export const Int32Converter: {
    new(): Int32Converter$instance;
};


export type Int32Converter = Int32Converter$instance;

export interface Int64Converter$instance extends BaseNumberConverter {
}


export const Int64Converter: {
    new(): Int64Converter$instance;
};


export type Int64Converter = Int64Converter$instance;

export interface InvalidAsynchronousStateException$instance extends ArgumentException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const InvalidAsynchronousStateException: {
    new(): InvalidAsynchronousStateException$instance;
    new(message: string): InvalidAsynchronousStateException$instance;
    new(message: string, innerException: Exception): InvalidAsynchronousStateException$instance;
};


export interface __InvalidAsynchronousStateException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidAsynchronousStateException = InvalidAsynchronousStateException$instance & __InvalidAsynchronousStateException$views;


export interface InvalidEnumArgumentException$instance extends ArgumentException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const InvalidEnumArgumentException: {
    new(): InvalidEnumArgumentException$instance;
    new(message: string): InvalidEnumArgumentException$instance;
    new(message: string, innerException: Exception): InvalidEnumArgumentException$instance;
    new(argumentName: string, invalidValue: int, enumClass: Type): InvalidEnumArgumentException$instance;
};


export interface __InvalidEnumArgumentException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidEnumArgumentException = InvalidEnumArgumentException$instance & __InvalidEnumArgumentException$views;


export interface License$instance {
    readonly licenseKey: string;
    dispose(): void;
}


export const License: {
};


export interface __License$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface License$instance extends System_Internal.IDisposable$instance {}

export type License = License$instance & __License$views;


export interface LicenseContext$instance {
    readonly usageMode: LicenseUsageMode;
    getSavedLicenseKey(type_: Type, resourceAssembly: Assembly): string;
    getService(type_: Type): unknown;
    setSavedLicenseKey(type_: Type, key: string): void;
}


export const LicenseContext: {
    new(): LicenseContext$instance;
};


export interface __LicenseContext$views {
    As_IServiceProvider(): System_Internal.IServiceProvider$instance;
}

export interface LicenseContext$instance extends System_Internal.IServiceProvider$instance {}

export type LicenseContext = LicenseContext$instance & __LicenseContext$views;


export interface LicenseException$instance extends SystemException {
    readonly licensedType: Type;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const LicenseException: {
    new(type_: Type): LicenseException$instance;
    new(type_: Type, instance: unknown): LicenseException$instance;
    new(type_: Type, instance: unknown, message: string): LicenseException$instance;
    new(type_: Type, instance: unknown, message: string, innerException: Exception): LicenseException$instance;
};


export interface __LicenseException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type LicenseException = LicenseException$instance & __LicenseException$views;


export interface LicenseManager$instance {
}


export const LicenseManager: {
    new(): LicenseManager$instance;
    currentContext: LicenseContext;
    readonly usageMode: LicenseUsageMode;
    createWithContext(type_: Type, creationContext: LicenseContext, args: unknown[]): unknown;
    createWithContext(type_: Type, creationContext: LicenseContext): unknown;
    isLicensed(type_: Type): boolean;
    isValid(type_: Type, instance: unknown, license: { value: ref<License> }): boolean;
    isValid(type_: Type): boolean;
    lockContext(contextUser: unknown): void;
    unlockContext(contextUser: unknown): void;
    validate(type_: Type, instance: unknown): License;
    validate(type_: Type): void;
};


export type LicenseManager = LicenseManager$instance;

export interface LicenseProvider$instance {
    getLicense(context: LicenseContext, type_: Type, instance: unknown, allowExceptions: boolean): License;
}


export const LicenseProvider: {
};


export type LicenseProvider = LicenseProvider$instance;

export interface LicenseProviderAttribute$instance extends Attribute {
    readonly licenseProvider: Type;
    readonly typeId: unknown;
    equals(value: unknown): boolean;
    getHashCode(): int;
}


export const LicenseProviderAttribute: {
    new(): LicenseProviderAttribute$instance;
    new(typeName: string): LicenseProviderAttribute$instance;
    new(type_: Type): LicenseProviderAttribute$instance;
    readonly default_: LicenseProviderAttribute;
};


export type LicenseProviderAttribute = LicenseProviderAttribute$instance;

export interface LicFileLicenseProvider$instance extends LicenseProvider {
    getLicense(context: LicenseContext, type_: Type, instance: unknown, allowExceptions: boolean): License;
}


export const LicFileLicenseProvider: {
    new(): LicFileLicenseProvider$instance;
};


export type LicFileLicenseProvider = LicFileLicenseProvider$instance;

export interface ListBindableAttribute$instance extends Attribute {
    readonly listBindable: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
}


export const ListBindableAttribute: {
    new(listBindable: boolean): ListBindableAttribute$instance;
    new(flags: BindableSupport): ListBindableAttribute$instance;
    readonly yes: ListBindableAttribute;
    readonly no: ListBindableAttribute;
    readonly default_: ListBindableAttribute;
};


export type ListBindableAttribute = ListBindableAttribute$instance;

export interface ListChangedEventArgs$instance extends EventArgs {
    readonly listChangedType: ListChangedType;
    readonly newIndex: int;
    readonly oldIndex: int;
    readonly propertyDescriptor: PropertyDescriptor;
}


export const ListChangedEventArgs: {
    new(listChangedType: ListChangedType, newIndex: int): ListChangedEventArgs$instance;
    new(listChangedType: ListChangedType, newIndex: int, propDesc: PropertyDescriptor): ListChangedEventArgs$instance;
    new(listChangedType: ListChangedType, propDesc: PropertyDescriptor): ListChangedEventArgs$instance;
    new(listChangedType: ListChangedType, newIndex: int, oldIndex: int): ListChangedEventArgs$instance;
};


export type ListChangedEventArgs = ListChangedEventArgs$instance;

export interface ListSortDescription$instance {
    propertyDescriptor: PropertyDescriptor;
    sortDirection: ListSortDirection;
}


export const ListSortDescription: {
    new(property: PropertyDescriptor, direction: ListSortDirection): ListSortDescription$instance;
};


export type ListSortDescription = ListSortDescription$instance;

export interface ListSortDescriptionCollection$instance {
    readonly count: int;
    item: ListSortDescription;
    contains(value: unknown): boolean;
    copyTo(array: ClrArray, index: int): void;
    indexOf(value: unknown): int;
}


export const ListSortDescriptionCollection: {
    new(): ListSortDescriptionCollection$instance;
    new(sorts: ListSortDescription[]): ListSortDescriptionCollection$instance;
};


export interface __ListSortDescriptionCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type ListSortDescriptionCollection = ListSortDescriptionCollection$instance & __ListSortDescriptionCollection$views;


export interface LocalizableAttribute$instance extends Attribute {
    readonly isLocalizable: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
}


export const LocalizableAttribute: {
    new(isLocalizable: boolean): LocalizableAttribute$instance;
    readonly yes: LocalizableAttribute;
    readonly no: LocalizableAttribute;
    readonly default_: LocalizableAttribute;
};


export type LocalizableAttribute = LocalizableAttribute$instance;

export interface LookupBindingPropertiesAttribute$instance extends Attribute {
    readonly dataSource: string;
    readonly displayMember: string;
    readonly lookupMember: string;
    readonly valueMember: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const LookupBindingPropertiesAttribute: {
    new(): LookupBindingPropertiesAttribute$instance;
    new(dataSource: string, displayMember: string, valueMember: string, lookupMember: string): LookupBindingPropertiesAttribute$instance;
    readonly default_: LookupBindingPropertiesAttribute;
};


export type LookupBindingPropertiesAttribute = LookupBindingPropertiesAttribute$instance;

export interface MarshalByValueComponent$instance {
    readonly container: IContainer;
    readonly designMode: boolean;
    site: ISite;
    dispose(): void;
    getService(service: Type): unknown;
    toString(): string;
}


export const MarshalByValueComponent: {
    new(): MarshalByValueComponent$instance;
};


export interface __MarshalByValueComponent$views {
    As_IServiceProvider(): System_Internal.IServiceProvider$instance;
    As_IComponent(): IComponent$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MarshalByValueComponent$instance extends System_Internal.IServiceProvider$instance {}

export type MarshalByValueComponent = MarshalByValueComponent$instance & __MarshalByValueComponent$views;


export interface MaskedTextProvider$instance {
    readonly allowPromptAsInput: boolean;
    readonly asciiOnly: boolean;
    readonly assignedEditPositionCount: int;
    readonly availableEditPositionCount: int;
    readonly culture: CultureInfo;
    readonly editPositionCount: int;
    readonly editPositions: IEnumerator;
    includeLiterals: boolean;
    includePrompt: boolean;
    isPassword: boolean;
    readonly item: char;
    readonly lastAssignedPosition: int;
    readonly length: int;
    readonly mask: string;
    readonly maskCompleted: boolean;
    readonly maskFull: boolean;
    passwordChar: char;
    promptChar: char;
    resetOnPrompt: boolean;
    resetOnSpace: boolean;
    skipLiterals: boolean;
    add(input: char): boolean;
    add(input: char, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    add(input: string): boolean;
    add(input: string, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    clear(): void;
    clear(resultHint: { value: ref<MaskedTextResultHint> }): void;
    clone(): unknown;
    findAssignedEditPositionFrom(position: int, direction: boolean): int;
    findAssignedEditPositionInRange(startPosition: int, endPosition: int, direction: boolean): int;
    findEditPositionFrom(position: int, direction: boolean): int;
    findEditPositionInRange(startPosition: int, endPosition: int, direction: boolean): int;
    findNonEditPositionFrom(position: int, direction: boolean): int;
    findNonEditPositionInRange(startPosition: int, endPosition: int, direction: boolean): int;
    findUnassignedEditPositionFrom(position: int, direction: boolean): int;
    findUnassignedEditPositionInRange(startPosition: int, endPosition: int, direction: boolean): int;
    insertAt(input: char, position: int): boolean;
    insertAt(input: char, position: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    insertAt(input: string, position: int): boolean;
    insertAt(input: string, position: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    isAvailablePosition(position: int): boolean;
    isEditPosition(position: int): boolean;
    remove(): boolean;
    remove(testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    removeAt(position: int): boolean;
    removeAt(startPosition: int, endPosition: int): boolean;
    removeAt(startPosition: int, endPosition: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    replace(input: char, position: int): boolean;
    replace(input: char, position: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    replace(input: char, startPosition: int, endPosition: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    replace(input: string, position: int): boolean;
    replace(input: string, position: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    replace(input: string, startPosition: int, endPosition: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    set_(input: string): boolean;
    set_(input: string, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    toDisplayString(): string;
    toString(): string;
    toString(ignorePasswordChar: boolean): string;
    toString(startPosition: int, length: int): string;
    toString(ignorePasswordChar: boolean, startPosition: int, length: int): string;
    toString(includePrompt: boolean, includeLiterals: boolean): string;
    toString(includePrompt: boolean, includeLiterals: boolean, startPosition: int, length: int): string;
    toString(ignorePasswordChar: boolean, includePrompt: boolean, includeLiterals: boolean, startPosition: int, length: int): string;
    verifyChar(input: char, position: int, hint: { value: ref<MaskedTextResultHint> }): boolean;
    verifyEscapeChar(input: char, position: int): boolean;
    verifyString(input: string): boolean;
    verifyString(input: string, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
}


export const MaskedTextProvider: {
    new(mask: string): MaskedTextProvider$instance;
    new(mask: string, restrictToAscii: boolean): MaskedTextProvider$instance;
    new(mask: string, culture: CultureInfo): MaskedTextProvider$instance;
    new(mask: string, culture: CultureInfo, restrictToAscii: boolean): MaskedTextProvider$instance;
    new(mask: string, passwordChar: char, allowPromptAsInput: boolean): MaskedTextProvider$instance;
    new(mask: string, culture: CultureInfo, passwordChar: char, allowPromptAsInput: boolean): MaskedTextProvider$instance;
    new(mask: string, culture: CultureInfo, allowPromptAsInput: boolean, promptChar: char, passwordChar: char, restrictToAscii: boolean): MaskedTextProvider$instance;
    readonly defaultPasswordChar: char;
    readonly invalidIndex: int;
    getOperationResultFromHint(hint: MaskedTextResultHint): boolean;
    isValidInputChar(c: char): boolean;
    isValidMaskChar(c: char): boolean;
    isValidPasswordChar(c: char): boolean;
};


export interface __MaskedTextProvider$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface MaskedTextProvider$instance extends System_Internal.ICloneable$instance {}

export type MaskedTextProvider = MaskedTextProvider$instance & __MaskedTextProvider$views;


export interface MemberDescriptor$instance {
    readonly attributes: AttributeCollection;
    readonly category: string;
    readonly description: string;
    readonly designTimeOnly: boolean;
    readonly displayName: string;
    readonly isBrowsable: boolean;
    readonly name: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const MemberDescriptor: {
};


export type MemberDescriptor = MemberDescriptor$instance;

export interface MergablePropertyAttribute$instance extends Attribute {
    readonly allowMerge: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
}


export const MergablePropertyAttribute: {
    new(allowMerge: boolean): MergablePropertyAttribute$instance;
    readonly yes: MergablePropertyAttribute;
    readonly no: MergablePropertyAttribute;
    readonly default_: MergablePropertyAttribute;
};


export type MergablePropertyAttribute = MergablePropertyAttribute$instance;

export interface MultilineStringConverter$instance extends TypeConverter {
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    getProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(value: unknown): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    getPropertiesSupported(context: ITypeDescriptorContext): boolean;
    getPropertiesSupported(): boolean;
}


export const MultilineStringConverter: {
    new(): MultilineStringConverter$instance;
};


export type MultilineStringConverter = MultilineStringConverter$instance;

export interface NestedContainer$instance extends Container$instance {
    readonly owner: IComponent;
    add(component: IComponent): void;
    add(component: IComponent, name: string): void;
    dispose(): void;
}


export const NestedContainer: {
    new(owner: IComponent): NestedContainer$instance;
};


export interface __NestedContainer$views {
    As_IContainer(): IContainer$instance;
    As_INestedContainer(): INestedContainer$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type NestedContainer = NestedContainer$instance & __NestedContainer$views;


export interface NotifyParentPropertyAttribute$instance extends Attribute {
    readonly notifyParent: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
}


export const NotifyParentPropertyAttribute: {
    new(notifyParent: boolean): NotifyParentPropertyAttribute$instance;
    readonly yes: NotifyParentPropertyAttribute;
    readonly no: NotifyParentPropertyAttribute;
    readonly default_: NotifyParentPropertyAttribute;
};


export type NotifyParentPropertyAttribute = NotifyParentPropertyAttribute$instance;

export interface NullableConverter$instance extends TypeConverter {
    readonly nullableType: Type;
    readonly underlyingType: Type;
    readonly underlyingTypeConverter: TypeConverter;
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    createInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): unknown;
    createInstance(propertyValues: IDictionary): unknown;
    getCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    getCreateInstanceSupported(): boolean;
    getProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(value: unknown): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    getPropertiesSupported(context: ITypeDescriptorContext): boolean;
    getPropertiesSupported(): boolean;
    getStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    getStandardValues(): ICollection;
    getStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    getStandardValuesExclusive(): boolean;
    getStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    getStandardValuesSupported(): boolean;
    isValid(context: ITypeDescriptorContext, value: unknown): boolean;
    isValid(value: unknown): boolean;
}


export const NullableConverter: {
    new(type_: Type): NullableConverter$instance;
};


export type NullableConverter = NullableConverter$instance;

export interface ParenthesizePropertyNameAttribute$instance extends Attribute {
    readonly needParenthesis: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
}


export const ParenthesizePropertyNameAttribute: {
    new(): ParenthesizePropertyNameAttribute$instance;
    new(needParenthesis: boolean): ParenthesizePropertyNameAttribute$instance;
    readonly default_: ParenthesizePropertyNameAttribute;
};


export type ParenthesizePropertyNameAttribute = ParenthesizePropertyNameAttribute$instance;

export interface PasswordPropertyTextAttribute$instance extends Attribute {
    readonly password: boolean;
    equals(o: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
}


export const PasswordPropertyTextAttribute: {
    new(): PasswordPropertyTextAttribute$instance;
    new(password: boolean): PasswordPropertyTextAttribute$instance;
    readonly yes: PasswordPropertyTextAttribute;
    readonly no: PasswordPropertyTextAttribute;
    readonly default_: PasswordPropertyTextAttribute;
};


export type PasswordPropertyTextAttribute = PasswordPropertyTextAttribute$instance;

export interface ProgressChangedEventArgs$instance extends EventArgs {
    readonly progressPercentage: int;
    readonly userState: unknown;
}


export const ProgressChangedEventArgs: {
    new(progressPercentage: int, userState: unknown): ProgressChangedEventArgs$instance;
};


export type ProgressChangedEventArgs = ProgressChangedEventArgs$instance;

export interface PropertyChangedEventArgs$instance extends EventArgs {
    readonly propertyName: string;
}


export const PropertyChangedEventArgs: {
    new(propertyName: string): PropertyChangedEventArgs$instance;
};


export type PropertyChangedEventArgs = PropertyChangedEventArgs$instance;

export interface PropertyChangingEventArgs$instance extends EventArgs {
    readonly propertyName: string;
}


export const PropertyChangingEventArgs: {
    new(propertyName: string): PropertyChangingEventArgs$instance;
};


export type PropertyChangingEventArgs = PropertyChangingEventArgs$instance;

export interface PropertyDescriptor$instance extends MemberDescriptor {
    readonly componentType: Type;
    readonly converter: TypeConverter;
    readonly converterFromRegisteredType: TypeConverter;
    readonly isLocalizable: boolean;
    readonly isReadOnly: boolean;
    readonly propertyType: Type;
    readonly serializationVisibility: DesignerSerializationVisibility;
    readonly supportsChangeEvents: boolean;
    addValueChanged(component: unknown, handler: EventHandler): void;
    canResetValue(component: unknown): boolean;
    equals(obj: unknown): boolean;
    getChildProperties(): PropertyDescriptorCollection;
    getChildProperties(filter: Attribute[]): PropertyDescriptorCollection;
    getChildProperties(instance: unknown): PropertyDescriptorCollection;
    getChildProperties(instance: unknown, filter: Attribute[]): PropertyDescriptorCollection;
    getEditor(editorBaseType: Type): unknown;
    getHashCode(): int;
    getValue(component: unknown): unknown;
    removeValueChanged(component: unknown, handler: EventHandler): void;
    resetValue(component: unknown): void;
    setValue(component: unknown, value: unknown): void;
    shouldSerializeValue(component: unknown): boolean;
}


export const PropertyDescriptor: {
};


export type PropertyDescriptor = PropertyDescriptor$instance;

export interface PropertyDescriptorCollection$instance {
    readonly count: int;
    add(value: PropertyDescriptor): int;
    clear(): void;
    contains(value: PropertyDescriptor): boolean;
    copyTo(array: ClrArray, index: int): void;
    find(name: string, ignoreCase: boolean): PropertyDescriptor;
    get_Item(index: int): PropertyDescriptor;
    get_Item(name: string): PropertyDescriptor;
    getEnumerator(): IEnumerator;
    indexOf(value: PropertyDescriptor): int;
    insert(index: int, value: PropertyDescriptor): void;
    remove(value: PropertyDescriptor): void;
    removeAt(index: int): void;
    sort(): PropertyDescriptorCollection;
    sort(names: string[]): PropertyDescriptorCollection;
    sort(names: string[], comparer: IComparer): PropertyDescriptorCollection;
    sort(comparer: IComparer): PropertyDescriptorCollection;
}


export const PropertyDescriptorCollection: {
    new(properties: PropertyDescriptor[]): PropertyDescriptorCollection$instance;
    new(properties: PropertyDescriptor[], readOnly: boolean): PropertyDescriptorCollection$instance;
    readonly empty: PropertyDescriptorCollection;
};


export interface __PropertyDescriptorCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type PropertyDescriptorCollection = PropertyDescriptorCollection$instance & __PropertyDescriptorCollection$views;


export interface PropertyTabAttribute$instance extends Attribute {
    readonly tabClasses: Type[];
    readonly tabScopes: PropertyTabScope[];
    equals(other: unknown): boolean;
    equals(other: PropertyTabAttribute): boolean;
    getHashCode(): int;
}


export const PropertyTabAttribute: {
    new(): PropertyTabAttribute$instance;
    new(tabClass: Type): PropertyTabAttribute$instance;
    new(tabClassName: string): PropertyTabAttribute$instance;
    new(tabClass: Type, tabScope: PropertyTabScope): PropertyTabAttribute$instance;
    new(tabClassName: string, tabScope: PropertyTabScope): PropertyTabAttribute$instance;
};


export type PropertyTabAttribute = PropertyTabAttribute$instance;

export interface ProvidePropertyAttribute$instance extends Attribute {
    readonly propertyName: string;
    readonly receiverTypeName: string;
    readonly typeId: unknown;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const ProvidePropertyAttribute: {
    new(propertyName: string, receiverType: Type): ProvidePropertyAttribute$instance;
    new(propertyName: string, receiverTypeName: string): ProvidePropertyAttribute$instance;
};


export type ProvidePropertyAttribute = ProvidePropertyAttribute$instance;

export interface ReadOnlyAttribute$instance extends Attribute {
    readonly isReadOnly: boolean;
    equals(value: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
}


export const ReadOnlyAttribute: {
    new(isReadOnly: boolean): ReadOnlyAttribute$instance;
    readonly yes: ReadOnlyAttribute;
    readonly no: ReadOnlyAttribute;
    readonly default_: ReadOnlyAttribute;
};


export type ReadOnlyAttribute = ReadOnlyAttribute$instance;

export interface RecommendedAsConfigurableAttribute$instance extends Attribute {
    readonly recommendedAsConfigurable: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
}


export const RecommendedAsConfigurableAttribute: {
    new(recommendedAsConfigurable: boolean): RecommendedAsConfigurableAttribute$instance;
    readonly no: RecommendedAsConfigurableAttribute;
    readonly yes: RecommendedAsConfigurableAttribute;
    readonly default_: RecommendedAsConfigurableAttribute;
};


export type RecommendedAsConfigurableAttribute = RecommendedAsConfigurableAttribute$instance;

export interface ReferenceConverter$instance extends TypeConverter {
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    getStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    getStandardValues(): ICollection;
    getStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    getStandardValuesExclusive(): boolean;
    getStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    getStandardValuesSupported(): boolean;
}


export const ReferenceConverter: {
    new(type_: Type): ReferenceConverter$instance;
};


export type ReferenceConverter = ReferenceConverter$instance;

export interface RefreshEventArgs$instance extends EventArgs {
    readonly componentChanged: unknown;
    readonly typeChanged: Type;
}


export const RefreshEventArgs: {
    new(componentChanged: unknown): RefreshEventArgs$instance;
    new(typeChanged: Type): RefreshEventArgs$instance;
};


export type RefreshEventArgs = RefreshEventArgs$instance;

export interface RefreshPropertiesAttribute$instance extends Attribute {
    readonly refreshProperties: RefreshProperties;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
}


export const RefreshPropertiesAttribute: {
    new(refresh: RefreshProperties): RefreshPropertiesAttribute$instance;
    readonly all: RefreshPropertiesAttribute;
    readonly repaint: RefreshPropertiesAttribute;
    readonly default_: RefreshPropertiesAttribute;
};


export type RefreshPropertiesAttribute = RefreshPropertiesAttribute$instance;

export interface RunInstallerAttribute$instance extends Attribute {
    readonly runInstaller: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
}


export const RunInstallerAttribute: {
    new(runInstaller: boolean): RunInstallerAttribute$instance;
    readonly yes: RunInstallerAttribute;
    readonly no: RunInstallerAttribute;
    readonly default_: RunInstallerAttribute;
};


export type RunInstallerAttribute = RunInstallerAttribute$instance;

export interface RunWorkerCompletedEventArgs$instance extends AsyncCompletedEventArgs {
    readonly result: unknown;
    readonly userState: unknown;
}


export const RunWorkerCompletedEventArgs: {
    new(result: unknown, error: Exception, cancelled: boolean): RunWorkerCompletedEventArgs$instance;
};


export type RunWorkerCompletedEventArgs = RunWorkerCompletedEventArgs$instance;

export interface SByteConverter$instance extends BaseNumberConverter {
}


export const SByteConverter: {
    new(): SByteConverter$instance;
};


export type SByteConverter = SByteConverter$instance;

export interface SettingsBindableAttribute$instance extends Attribute {
    readonly bindable: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const SettingsBindableAttribute: {
    new(bindable: boolean): SettingsBindableAttribute$instance;
    readonly yes: SettingsBindableAttribute;
    readonly no: SettingsBindableAttribute;
};


export type SettingsBindableAttribute = SettingsBindableAttribute$instance;

export interface SingleConverter$instance extends BaseNumberConverter {
}


export const SingleConverter: {
    new(): SingleConverter$instance;
};


export type SingleConverter = SingleConverter$instance;

export interface StringConverter$instance extends TypeConverter {
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
}


export const StringConverter: {
    new(): StringConverter$instance;
};


export type StringConverter = StringConverter$instance;

export interface TimeOnlyConverter$instance extends TypeConverter {
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
}


export const TimeOnlyConverter: {
    new(): TimeOnlyConverter$instance;
};


export type TimeOnlyConverter = TimeOnlyConverter$instance;

export interface TimeSpanConverter$instance extends TypeConverter {
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
}


export const TimeSpanConverter: {
    new(): TimeSpanConverter$instance;
};


export type TimeSpanConverter = TimeSpanConverter$instance;

export interface ToolboxItemAttribute$instance extends Attribute {
    readonly toolboxItemType: Type;
    readonly toolboxItemTypeName: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
}


export const ToolboxItemAttribute: {
    new(defaultType: boolean): ToolboxItemAttribute$instance;
    new(toolboxItemTypeName: string): ToolboxItemAttribute$instance;
    new(toolboxItemType: Type): ToolboxItemAttribute$instance;
    readonly default_: ToolboxItemAttribute;
    readonly none: ToolboxItemAttribute;
};


export type ToolboxItemAttribute = ToolboxItemAttribute$instance;

export interface ToolboxItemFilterAttribute$instance extends Attribute {
    readonly filterString: string;
    readonly filterType: ToolboxItemFilterType;
    readonly typeId: unknown;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    match(obj: unknown): boolean;
    toString(): string;
}


export const ToolboxItemFilterAttribute: {
    new(filterString: string): ToolboxItemFilterAttribute$instance;
    new(filterString: string, filterType: ToolboxItemFilterType): ToolboxItemFilterAttribute$instance;
};


export type ToolboxItemFilterAttribute = ToolboxItemFilterAttribute$instance;

export interface TypeConverter$instance {
    canConvertFrom(sourceType: Type): boolean;
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    convertFrom(value: unknown): unknown;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFromInvariantString(text: string): unknown;
    convertFromInvariantString(context: ITypeDescriptorContext, text: string): unknown;
    convertFromString(text: string): unknown;
    convertFromString(context: ITypeDescriptorContext, text: string): unknown;
    convertFromString(context: ITypeDescriptorContext, culture: CultureInfo, text: string): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertToInvariantString(value: unknown): string;
    convertToInvariantString(context: ITypeDescriptorContext, value: unknown): string;
    convertToString(value: unknown): string;
    convertToString(context: ITypeDescriptorContext, value: unknown): string;
    convertToString(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): string;
    createInstance(propertyValues: IDictionary): unknown;
    createInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): unknown;
    getCreateInstanceSupported(): boolean;
    getCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    getProperties(value: unknown): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    getPropertiesSupported(): boolean;
    getPropertiesSupported(context: ITypeDescriptorContext): boolean;
    getStandardValues(): ICollection;
    getStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    getStandardValuesExclusive(): boolean;
    getStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    getStandardValuesSupported(): boolean;
    getStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    isValid(value: unknown): boolean;
    isValid(context: ITypeDescriptorContext, value: unknown): boolean;
}


export const TypeConverter: {
    new(): TypeConverter$instance;
};


export type TypeConverter = TypeConverter$instance;

export interface TypeConverter_StandardValuesCollection$instance {
    readonly count: int;
    readonly item: unknown;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator;
}


export const TypeConverter_StandardValuesCollection: {
    new(values: ICollection): TypeConverter_StandardValuesCollection$instance;
};


export interface __TypeConverter_StandardValuesCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type TypeConverter_StandardValuesCollection = TypeConverter_StandardValuesCollection$instance & __TypeConverter_StandardValuesCollection$views;


export interface TypeConverterAttribute$instance extends Attribute {
    readonly converterTypeName: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const TypeConverterAttribute: {
    new(): TypeConverterAttribute$instance;
    new(type_: Type): TypeConverterAttribute$instance;
    new(typeName: string): TypeConverterAttribute$instance;
    readonly default_: TypeConverterAttribute;
};


export type TypeConverterAttribute = TypeConverterAttribute$instance;

export interface TypeDescriptionProvider$instance {
    readonly requireRegisteredTypes: Nullable_1<CLROf<boolean>>;
    createInstance(provider: IServiceProvider, objectType: Type, argTypes: Type[], args: unknown[]): unknown;
    getCache(instance: unknown): IDictionary;
    getExtendedTypeDescriptor(instance: unknown): ICustomTypeDescriptor;
    getExtendedTypeDescriptorFromRegisteredType(instance: unknown): ICustomTypeDescriptor;
    getFullComponentName(component: unknown): string;
    getReflectionType(objectType: Type): Type;
    getReflectionType(instance: unknown): Type;
    getReflectionType(objectType: Type, instance: unknown): Type;
    getRuntimeType(reflectionType: Type): Type;
    getTypeDescriptor(objectType: Type): ICustomTypeDescriptor;
    getTypeDescriptor(instance: unknown): ICustomTypeDescriptor;
    getTypeDescriptor(objectType: Type, instance: unknown): ICustomTypeDescriptor;
    getTypeDescriptorFromRegisteredType(objectType: Type): ICustomTypeDescriptor;
    getTypeDescriptorFromRegisteredType(instance: unknown): ICustomTypeDescriptor;
    getTypeDescriptorFromRegisteredType(objectType: Type, instance: unknown): ICustomTypeDescriptor;
    isRegisteredType(type_: Type): boolean;
    isSupportedType(type_: Type): boolean;
    registerType<T>(): void;
}


export const TypeDescriptionProvider: {
};


export type TypeDescriptionProvider = TypeDescriptionProvider$instance;

export interface TypeDescriptionProviderAttribute$instance extends Attribute {
    readonly typeName: string;
}


export const TypeDescriptionProviderAttribute: {
    new(typeName: string): TypeDescriptionProviderAttribute$instance;
    new(type_: Type): TypeDescriptionProviderAttribute$instance;
};


export type TypeDescriptionProviderAttribute = TypeDescriptionProviderAttribute$instance;

export interface TypeDescriptor$instance {
}


export const TypeDescriptor: {
    new(): TypeDescriptor$instance;
    readonly interfaceType: Type;
    readonly comObjectType: Type;
    comNativeDescriptorHandler: IComNativeDescriptorHandler;
    addAttributes(instance: unknown, attributes: Attribute[]): TypeDescriptionProvider;
    addAttributes(type_: Type, attributes: Attribute[]): TypeDescriptionProvider;
    addEditorTable(editorBaseType: Type, table: Hashtable): void;
    addProvider(provider: TypeDescriptionProvider, instance: unknown): void;
    addProvider(provider: TypeDescriptionProvider, type_: Type): void;
    addProviderTransparent(provider: TypeDescriptionProvider, instance: unknown): void;
    addProviderTransparent(provider: TypeDescriptionProvider, type_: Type): void;
    createAssociation(primary: unknown, secondary: unknown): void;
    createDesigner(component: IComponent, designerBaseType: Type): IDesigner;
    createEvent(componentType: Type, oldEventDescriptor: EventDescriptor, attributes: Attribute[]): EventDescriptor;
    createEvent(componentType: Type, name: string, type_: Type, attributes: Attribute[]): EventDescriptor;
    createInstance(provider: IServiceProvider, objectType: Type, argTypes: Type[], args: unknown[]): unknown;
    createProperty(componentType: Type, oldPropertyDescriptor: PropertyDescriptor, attributes: Attribute[]): PropertyDescriptor;
    createProperty(componentType: Type, name: string, type_: Type, attributes: Attribute[]): PropertyDescriptor;
    getAssociation(type_: Type, primary: unknown): unknown;
    getAttributes(component: unknown, noCustomTypeDesc: boolean): AttributeCollection;
    getAttributes(component: unknown): AttributeCollection;
    getAttributes(componentType: Type): AttributeCollection;
    getClassName(component: unknown, noCustomTypeDesc: boolean): string;
    getClassName(component: unknown): string;
    getClassName(componentType: Type): string;
    getComponentName(component: unknown, noCustomTypeDesc: boolean): string;
    getComponentName(component: unknown): string;
    getConverter(component: unknown, noCustomTypeDesc: boolean): TypeConverter;
    getConverter(component: unknown): TypeConverter;
    getConverter(type_: Type): TypeConverter;
    getConverterFromRegisteredType(component: unknown): TypeConverter;
    getConverterFromRegisteredType(type_: Type): TypeConverter;
    getDefaultEvent(component: unknown, noCustomTypeDesc: boolean): EventDescriptor;
    getDefaultEvent(component: unknown): EventDescriptor;
    getDefaultEvent(componentType: Type): EventDescriptor;
    getDefaultProperty(component: unknown, noCustomTypeDesc: boolean): PropertyDescriptor;
    getDefaultProperty(component: unknown): PropertyDescriptor;
    getDefaultProperty(componentType: Type): PropertyDescriptor;
    getEditor(component: unknown, editorBaseType: Type, noCustomTypeDesc: boolean): unknown;
    getEditor(component: unknown, editorBaseType: Type): unknown;
    getEditor(type_: Type, editorBaseType: Type): unknown;
    getEvents(component: unknown, attributes: Attribute[], noCustomTypeDesc: boolean): EventDescriptorCollection;
    getEvents(component: unknown, attributes: Attribute[]): EventDescriptorCollection;
    getEvents(component: unknown, noCustomTypeDesc: boolean): EventDescriptorCollection;
    getEvents(component: unknown): EventDescriptorCollection;
    getEvents(componentType: Type, attributes: Attribute[]): EventDescriptorCollection;
    getEvents(componentType: Type): EventDescriptorCollection;
    getEventsFromRegisteredType(componentType: Type): EventDescriptorCollection;
    getFullComponentName(component: unknown): string;
    getProperties(component: unknown, attributes: Attribute[], noCustomTypeDesc: boolean): PropertyDescriptorCollection;
    getProperties(component: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(component: unknown, noCustomTypeDesc: boolean): PropertyDescriptorCollection;
    getProperties(component: unknown): PropertyDescriptorCollection;
    getProperties(componentType: Type, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(componentType: Type): PropertyDescriptorCollection;
    getPropertiesFromRegisteredType(component: unknown): PropertyDescriptorCollection;
    getPropertiesFromRegisteredType(componentType: Type): PropertyDescriptorCollection;
    getProvider(instance: unknown): TypeDescriptionProvider;
    getProvider(type_: Type): TypeDescriptionProvider;
    getReflectionType(instance: unknown): Type;
    getReflectionType(type_: Type): Type;
    refresh(component: unknown): void;
    refresh(assembly: Assembly): void;
    refresh(module_: Module): void;
    refresh(type_: Type): void;
    registerType<T>(): void;
    removeAssociation(primary: unknown, secondary: unknown): void;
    removeAssociations(primary: unknown): void;
    removeProvider(provider: TypeDescriptionProvider, instance: unknown): void;
    removeProvider(provider: TypeDescriptionProvider, type_: Type): void;
    removeProviderTransparent(provider: TypeDescriptionProvider, instance: unknown): void;
    removeProviderTransparent(provider: TypeDescriptionProvider, type_: Type): void;
    sortDescriptorArray(infos: IList): void;
};


export type TypeDescriptor = TypeDescriptor$instance;

export interface TypeListConverter$instance extends TypeConverter {
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    getStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    getStandardValues(): ICollection;
    getStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    getStandardValuesExclusive(): boolean;
    getStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    getStandardValuesSupported(): boolean;
}


export const TypeListConverter: {
};


export type TypeListConverter = TypeListConverter$instance;

export interface UInt128Converter$instance extends BaseNumberConverter {
}


export const UInt128Converter: {
    new(): UInt128Converter$instance;
};


export type UInt128Converter = UInt128Converter$instance;

export interface UInt16Converter$instance extends BaseNumberConverter {
}


export const UInt16Converter: {
    new(): UInt16Converter$instance;
};


export type UInt16Converter = UInt16Converter$instance;

export interface UInt32Converter$instance extends BaseNumberConverter {
}


export const UInt32Converter: {
    new(): UInt32Converter$instance;
};


export type UInt32Converter = UInt32Converter$instance;

export interface UInt64Converter$instance extends BaseNumberConverter {
}


export const UInt64Converter: {
    new(): UInt64Converter$instance;
};


export type UInt64Converter = UInt64Converter$instance;

export interface VersionConverter$instance extends TypeConverter {
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    isValid(context: ITypeDescriptorContext, value: unknown): boolean;
    isValid(value: unknown): boolean;
}


export const VersionConverter: {
    new(): VersionConverter$instance;
};


export type VersionConverter = VersionConverter$instance;

export interface WarningException$instance extends SystemException {
    readonly helpTopic: string;
    readonly helpUrl: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const WarningException: {
    new(): WarningException$instance;
    new(message: string): WarningException$instance;
    new(message: string, helpUrl: string): WarningException$instance;
    new(message: string, innerException: Exception): WarningException$instance;
    new(message: string, helpUrl: string, helpTopic: string): WarningException$instance;
};


export interface __WarningException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type WarningException = WarningException$instance & __WarningException$views;


export interface Win32Exception$instance extends ExternalException {
    readonly nativeErrorCode: int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    toString(): string;
}


export const Win32Exception: {
    new(): Win32Exception$instance;
    new(error: int): Win32Exception$instance;
    new(error: int, message: string): Win32Exception$instance;
    new(message: string): Win32Exception$instance;
    new(message: string, innerException: Exception): Win32Exception$instance;
};


export interface __Win32Exception$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Win32Exception = Win32Exception$instance & __Win32Exception$views;


export abstract class AsyncOperationManager$instance {
    static synchronizationContext: SynchronizationContext;
    static createOperation(userSuppliedState: unknown): AsyncOperation;
}


export type AsyncOperationManager = AsyncOperationManager$instance;

export abstract class SyntaxCheck$instance {
    static checkMachineName(value: string): boolean;
    static checkPath(value: string): boolean;
    static checkRootedPath(value: string): boolean;
}


export type SyntaxCheck = SyntaxCheck$instance;

