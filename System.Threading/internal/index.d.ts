// Generated by tsbindgen - Architecture
// Namespace: System.Threading
// Assembly: System.Private.CoreLib, System.Threading, System.Threading.AccessControl

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { SafeWaitHandle } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import type { IList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { CultureInfo } from "../../System.Globalization/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_ConstrainedExecution_Internal from "../../System.Runtime.ConstrainedExecution/internal/index.js";
import type { CriticalFinalizerObject } from "../../System.Runtime.ConstrainedExecution/internal/index.js";
import type { SafeHandle } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { EventWaitHandleRights, EventWaitHandleSecurity, MutexRights, MutexSecurity, SemaphoreRights, SemaphoreSecurity } from "../../System.Security.AccessControl/internal/index.js";
import type { IPrincipal } from "../../System.Security.Principal/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action, Action_1, Action_2, AppDomain, ApplicationException, AsyncCallback, Boolean as ClrBoolean, Byte, Delegate, Double, Enum, EventArgs, Exception, Func_1, IAsyncDisposable, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, LocalDataStoreSlot, MarshalByRefObject, MulticastDelegate, Object as ClrObject, ReadOnlySpan_1, SByte, Single, String as ClrString, SystemException, TimeProvider, TimeSpan, Type, TypeCode, UInt16, UInt32, UInt64, UIntPtr, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum ApartmentState {
    STA = 0,
    MTA = 1,
    unknown_ = 2
}


export enum EventResetMode {
    autoReset = 0,
    manualReset = 1
}


export enum LazyThreadSafetyMode {
    none = 0,
    publicationOnly = 1,
    executionAndPublication = 2
}


export enum LockRecursionPolicy {
    noRecursion = 0,
    supportsRecursion = 1
}


export enum ThreadPriority {
    lowest = 0,
    belowNormal = 1,
    normal = 2,
    aboveNormal = 3,
    highest = 4
}


export enum ThreadState {
    running = 0,
    stopRequested = 1,
    suspendRequested = 2,
    background = 4,
    unstarted = 8,
    stopped = 16,
    waitSleepJoin = 32,
    suspended = 64,
    abortRequested = 128,
    aborted = 256
}


export type ContextCallback = (state: unknown) => void;


export type IOCompletionCallback = (errorCode: uint, numBytes: uint, pOVERLAP: ptr<NativeOverlapped>) => void;


export type ParameterizedThreadStart = (obj: unknown) => void;


export type SendOrPostCallback = (state: unknown) => void;


export type ThreadExceptionEventHandler = (sender: unknown, e: ThreadExceptionEventArgs) => void;


export type ThreadStart = () => void;


export type TimerCallback = (state: unknown) => void;


export type WaitCallback = (state: unknown) => void;


export type WaitOrTimerCallback = (state: unknown, timedOut: boolean) => void;


export interface IThreadPoolWorkItem$instance {
    execute(): void;
}


export type IThreadPoolWorkItem = IThreadPoolWorkItem$instance;

export interface ITimer$instance extends IDisposable, IAsyncDisposable {
    change(dueTime: TimeSpan, period: TimeSpan): boolean;
    dispose(): void;
    disposeAsync(): ValueTask;
}


export interface ITimer$instance extends System_Internal.IAsyncDisposable$instance, System_Internal.IDisposable$instance {}

export type ITimer = ITimer$instance;

export interface AsyncFlowControl$instance {
    dispose(): void;
    equals(obj: unknown): boolean;
    equals(obj: AsyncFlowControl): boolean;
    getHashCode(): int;
    undo(): void;
}


export const AsyncFlowControl: {
    new(): AsyncFlowControl$instance;
};


export interface __AsyncFlowControl$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<AsyncFlowControl>;

    // Structural method bridges for numeric interface constraints
    Equals(other: AsyncFlowControl): boolean;
}

export interface AsyncFlowControl$instance extends System_Internal.IDisposable$instance {}

export type AsyncFlowControl = AsyncFlowControl$instance & __AsyncFlowControl$views;


export interface AsyncLocalValueChangedArgs_1$instance<T> {
    readonly currentValue: T;
    readonly previousValue: T;
    readonly threadContextChanged: boolean;
}


export const AsyncLocalValueChangedArgs_1: {
    new<T>(): AsyncLocalValueChangedArgs_1$instance<T>;
};


export type AsyncLocalValueChangedArgs_1<T> = AsyncLocalValueChangedArgs_1$instance<T>;

export interface CancellationToken$instance {
    readonly canBeCanceled: boolean;
    readonly isCancellationRequested: boolean;
    readonly waitHandle: WaitHandle;
    equals(other: CancellationToken): boolean;
    equals(other: unknown): boolean;
    getHashCode(): int;
    register(callback: Action): CancellationTokenRegistration;
    register(callback: Action, useSynchronizationContext: boolean): CancellationTokenRegistration;
    register(callback: Action_1<unknown>, state: unknown): CancellationTokenRegistration;
    register(callback: Action_2<unknown, CancellationToken>, state: unknown): CancellationTokenRegistration;
    register(callback: Action_1<unknown>, state: unknown, useSynchronizationContext: boolean): CancellationTokenRegistration;
    throwIfCancellationRequested(): void;
    unsafeRegister(callback: Action_1<unknown>, state: unknown): CancellationTokenRegistration;
    unsafeRegister(callback: Action_2<unknown, CancellationToken>, state: unknown): CancellationTokenRegistration;
}


export const CancellationToken: {
    new(canceled: boolean): CancellationToken$instance;
    readonly none: CancellationToken;
};


export interface __CancellationToken$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CancellationToken>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CancellationToken): boolean;
}

export type CancellationToken = CancellationToken$instance & __CancellationToken$views;


export interface CancellationTokenRegistration$instance {
    readonly token: CancellationToken;
    dispose(): void;
    disposeAsync(): ValueTask;
    equals(obj: unknown): boolean;
    equals(other: CancellationTokenRegistration): boolean;
    getHashCode(): int;
    unregister(): boolean;
}


export const CancellationTokenRegistration: {
    new(): CancellationTokenRegistration$instance;
};


export interface __CancellationTokenRegistration$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CancellationTokenRegistration>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CancellationTokenRegistration): boolean;
}

export interface CancellationTokenRegistration$instance extends System_Internal.IAsyncDisposable$instance, System_Internal.IDisposable$instance {}

export type CancellationTokenRegistration = CancellationTokenRegistration$instance & __CancellationTokenRegistration$views;


export interface Lock_Scope$instance {
    dispose(): void;
}


export const Lock_Scope: {
    new(): Lock_Scope$instance;
};


export type Lock_Scope = Lock_Scope$instance;

export interface LockCookie$instance {
    equals(obj: unknown): boolean;
    equals(obj: LockCookie): boolean;
    getHashCode(): int;
}


export const LockCookie: {
    new(): LockCookie$instance;
};


export interface __LockCookie$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<LockCookie>;

    // Structural method bridges for numeric interface constraints
    Equals(other: LockCookie): boolean;
}

export type LockCookie = LockCookie$instance & __LockCookie$views;


export interface NamedWaitHandleOptions$instance {
    currentSessionOnly: boolean;
    currentUserOnly: boolean;
}


export const NamedWaitHandleOptions: {
    new(): NamedWaitHandleOptions$instance;
};


export type NamedWaitHandleOptions = NamedWaitHandleOptions$instance;

export interface NativeOverlapped$instance {
    internalLow: nint;
    internalHigh: nint;
    offsetLow: int;
    offsetHigh: int;
    eventHandle: nint;
}


export const NativeOverlapped: {
    new(): NativeOverlapped$instance;
};


export type NativeOverlapped = NativeOverlapped$instance;

export interface SpinLock$instance {
    readonly isHeld: boolean;
    readonly isHeldByCurrentThread: boolean;
    readonly isThreadOwnerTrackingEnabled: boolean;
    enter(lockTaken: { value: ref<boolean> }): void;
    exit(): void;
    exit(useMemoryBarrier: boolean): void;
    tryEnter(lockTaken: { value: ref<boolean> }): void;
    tryEnter(timeout: TimeSpan, lockTaken: { value: ref<boolean> }): void;
    tryEnter(millisecondsTimeout: int, lockTaken: { value: ref<boolean> }): void;
}


export const SpinLock: {
    new(enableThreadOwnerTracking: boolean): SpinLock$instance;
};


export type SpinLock = SpinLock$instance;

export interface SpinWait$instance {
    readonly count: int;
    readonly nextSpinWillYield: boolean;
    reset(): void;
    spinOnce(): void;
    spinOnce(sleep1Threshold: int): void;
}


export const SpinWait: {
    new(): SpinWait$instance;
    spinUntil(condition: Func_1<CLROf<boolean>>, millisecondsTimeout: int): boolean;
    spinUntil(condition: Func_1<CLROf<boolean>>, timeout: TimeSpan): boolean;
    spinUntil(condition: Func_1<CLROf<boolean>>): void;
};


export type SpinWait = SpinWait$instance;

export interface AbandonedMutexException$instance extends SystemException {
    readonly mutex: Mutex;
    readonly mutexIndex: int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const AbandonedMutexException: {
    new(): AbandonedMutexException$instance;
    new(message: string): AbandonedMutexException$instance;
    new(message: string, inner: Exception): AbandonedMutexException$instance;
    new(location: int, handle: WaitHandle): AbandonedMutexException$instance;
    new(message: string, location: int, handle: WaitHandle): AbandonedMutexException$instance;
    new(message: string, inner: Exception, location: int, handle: WaitHandle): AbandonedMutexException$instance;
};


export interface __AbandonedMutexException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AbandonedMutexException = AbandonedMutexException$instance & __AbandonedMutexException$views;


export interface AsyncLocal_1$instance<T> {
    value: T;
}


export const AsyncLocal_1: {
    new<T>(): AsyncLocal_1$instance<T>;
    new<T>(valueChangedHandler: Action_1<AsyncLocalValueChangedArgs_1<T>>): AsyncLocal_1$instance<T>;
};


export type AsyncLocal_1<T> = AsyncLocal_1$instance<T>;

export interface AutoResetEvent$instance extends EventWaitHandle$instance {
    dispose(): void;
}


export const AutoResetEvent: {
    new(initialState: boolean): AutoResetEvent$instance;
};


export interface __AutoResetEvent$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type AutoResetEvent = AutoResetEvent$instance & __AutoResetEvent$views;


export interface Barrier$instance {
    readonly currentPhaseNumber: long;
    readonly participantCount: int;
    readonly participantsRemaining: int;
    addParticipant(): long;
    addParticipants(participantCount: int): long;
    dispose(): void;
    removeParticipant(): void;
    removeParticipants(participantCount: int): void;
    signalAndWait(): void;
    signalAndWait(cancellationToken: CancellationToken): void;
    signalAndWait(timeout: TimeSpan): boolean;
    signalAndWait(timeout: TimeSpan, cancellationToken: CancellationToken): boolean;
    signalAndWait(millisecondsTimeout: int): boolean;
    signalAndWait(millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
}


export const Barrier: {
    new(participantCount: int): Barrier$instance;
    new(participantCount: int, postPhaseAction: Action_1<Barrier>): Barrier$instance;
};


export interface __Barrier$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Barrier$instance extends System_Internal.IDisposable$instance {}

export type Barrier = Barrier$instance & __Barrier$views;


export interface BarrierPostPhaseException$instance extends Exception {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const BarrierPostPhaseException: {
    new(): BarrierPostPhaseException$instance;
    new(innerException: Exception): BarrierPostPhaseException$instance;
    new(message: string): BarrierPostPhaseException$instance;
    new(message: string, innerException: Exception): BarrierPostPhaseException$instance;
};


export interface __BarrierPostPhaseException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type BarrierPostPhaseException = BarrierPostPhaseException$instance & __BarrierPostPhaseException$views;


export interface CancellationTokenSource$instance {
    readonly isCancellationRequested: boolean;
    readonly token: CancellationToken;
    cancel(): void;
    cancel(throwOnFirstException: boolean): void;
    cancelAfter(delay: TimeSpan): void;
    cancelAfter(millisecondsDelay: int): void;
    cancelAsync(): Task;
    dispose(): void;
    tryReset(): boolean;
}


export const CancellationTokenSource: {
    new(): CancellationTokenSource$instance;
    new(delay: TimeSpan): CancellationTokenSource$instance;
    new(delay: TimeSpan, timeProvider: TimeProvider): CancellationTokenSource$instance;
    new(millisecondsDelay: int): CancellationTokenSource$instance;
    createLinkedTokenSource(tokens: ReadOnlySpan_1<CancellationToken>): CancellationTokenSource;
    createLinkedTokenSource(token1: CancellationToken, token2: CancellationToken): CancellationTokenSource;
    createLinkedTokenSource(token: CancellationToken): CancellationTokenSource;
    createLinkedTokenSource(tokens: CancellationToken[]): CancellationTokenSource;
};


export interface __CancellationTokenSource$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface CancellationTokenSource$instance extends System_Internal.IDisposable$instance {}

export type CancellationTokenSource = CancellationTokenSource$instance & __CancellationTokenSource$views;


export interface CompressedStack$instance {
    createCopy(): CompressedStack;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const CompressedStack: {
    new(): CompressedStack$instance;
    capture(): CompressedStack;
    getCompressedStack(): CompressedStack;
    run(compressedStack: CompressedStack, callback: ContextCallback, state: unknown): void;
};


export interface __CompressedStack$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface CompressedStack$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type CompressedStack = CompressedStack$instance & __CompressedStack$views;


export interface CountdownEvent$instance {
    readonly currentCount: int;
    readonly initialCount: int;
    readonly isSet: boolean;
    readonly waitHandle: WaitHandle;
    addCount(): void;
    addCount(signalCount: int): void;
    dispose(): void;
    reset(): void;
    reset(count: int): void;
    signal(): boolean;
    signal(signalCount: int): boolean;
    tryAddCount(): boolean;
    tryAddCount(signalCount: int): boolean;
    wait(): void;
    wait(cancellationToken: CancellationToken): void;
    wait(timeout: TimeSpan): boolean;
    wait(timeout: TimeSpan, cancellationToken: CancellationToken): boolean;
    wait(millisecondsTimeout: int): boolean;
    wait(millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
}


export const CountdownEvent: {
    new(initialCount: int): CountdownEvent$instance;
};


export interface __CountdownEvent$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface CountdownEvent$instance extends System_Internal.IDisposable$instance {}

export type CountdownEvent = CountdownEvent$instance & __CountdownEvent$views;


export interface EventWaitHandle$instance extends WaitHandle$instance {
    dispose(): void;
    reset(): boolean;
    set_(): boolean;
}


export const EventWaitHandle: {
    new(initialState: boolean, mode: EventResetMode): EventWaitHandle$instance;
    new(initialState: boolean, mode: EventResetMode, name: string, options: NamedWaitHandleOptions): EventWaitHandle$instance;
    new(initialState: boolean, mode: EventResetMode, name: string): EventWaitHandle$instance;
    new(initialState: boolean, mode: EventResetMode, name: string, options: NamedWaitHandleOptions, createdNew: ref<boolean>): EventWaitHandle$instance;
    new(initialState: boolean, mode: EventResetMode, name: string, createdNew: ref<boolean>): EventWaitHandle$instance;
    openExisting(name: string, options: NamedWaitHandleOptions): EventWaitHandle;
    openExisting(name: string): EventWaitHandle;
    tryOpenExisting(name: string, result: { value: ref<EventWaitHandle> }): boolean;
    tryOpenExisting(name: string, options: NamedWaitHandleOptions, result: { value: ref<EventWaitHandle> }): boolean;
};


export interface __EventWaitHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type EventWaitHandle = EventWaitHandle$instance & __EventWaitHandle$views;


export interface ExecutionContext$instance {
    createCopy(): ExecutionContext;
    dispose(): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const ExecutionContext: {
    new(): ExecutionContext$instance;
    capture(): ExecutionContext;
    isFlowSuppressed(): boolean;
    restore(executionContext: ExecutionContext): void;
    restoreFlow(): void;
    run(executionContext: ExecutionContext, callback: ContextCallback, state: unknown): void;
    suppressFlow(): AsyncFlowControl;
};


export interface __ExecutionContext$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface ExecutionContext$instance extends System_Internal.IDisposable$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type ExecutionContext = ExecutionContext$instance & __ExecutionContext$views;


export interface HostExecutionContext$instance {
    createCopy(): HostExecutionContext;
    dispose(): void;
    dispose(disposing: boolean): void;
}


export const HostExecutionContext: {
    new(): HostExecutionContext$instance;
    new(state: unknown): HostExecutionContext$instance;
};


export interface __HostExecutionContext$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type HostExecutionContext = HostExecutionContext$instance & __HostExecutionContext$views;


export interface HostExecutionContextManager$instance {
    capture(): HostExecutionContext;
    revert(previousState: unknown): void;
    setHostExecutionContext(hostExecutionContext: HostExecutionContext): unknown;
}


export const HostExecutionContextManager: {
    new(): HostExecutionContextManager$instance;
};


export type HostExecutionContextManager = HostExecutionContextManager$instance;

export interface Lock$instance {
    readonly isHeldByCurrentThread: boolean;
    enter(): void;
    enterScope(): Lock_Scope;
    exit(): void;
    tryEnter(): boolean;
    tryEnter(millisecondsTimeout: int): boolean;
    tryEnter(timeout: TimeSpan): boolean;
}


export const Lock: {
    new(): Lock$instance;
};


export type Lock = Lock$instance;

export interface LockRecursionException$instance extends Exception {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const LockRecursionException: {
    new(): LockRecursionException$instance;
    new(message: string): LockRecursionException$instance;
    new(message: string, innerException: Exception): LockRecursionException$instance;
};


export interface __LockRecursionException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type LockRecursionException = LockRecursionException$instance & __LockRecursionException$views;


export interface ManualResetEvent$instance extends EventWaitHandle$instance {
    dispose(): void;
}


export const ManualResetEvent: {
    new(initialState: boolean): ManualResetEvent$instance;
};


export interface __ManualResetEvent$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ManualResetEvent = ManualResetEvent$instance & __ManualResetEvent$views;


export interface ManualResetEventSlim$instance {
    readonly isSet: boolean;
    readonly spinCount: int;
    readonly waitHandle: WaitHandle;
    dispose(): void;
    reset(): void;
    set_(): void;
    wait(): void;
    wait(cancellationToken: CancellationToken): void;
    wait(timeout: TimeSpan): boolean;
    wait(timeout: TimeSpan, cancellationToken: CancellationToken): boolean;
    wait(millisecondsTimeout: int): boolean;
    wait(millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
}


export const ManualResetEventSlim: {
    new(): ManualResetEventSlim$instance;
    new(initialState: boolean): ManualResetEventSlim$instance;
    new(initialState: boolean, spinCount: int): ManualResetEventSlim$instance;
};


export interface __ManualResetEventSlim$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ManualResetEventSlim$instance extends System_Internal.IDisposable$instance {}

export type ManualResetEventSlim = ManualResetEventSlim$instance & __ManualResetEventSlim$views;


export interface Mutex$instance extends WaitHandle$instance {
    dispose(): void;
    releaseMutex(): void;
}


export const Mutex: {
    new(initiallyOwned: boolean, name: string, options: NamedWaitHandleOptions, createdNew: ref<boolean>): Mutex$instance;
    new(initiallyOwned: boolean, name: string, createdNew: ref<boolean>): Mutex$instance;
    new(initiallyOwned: boolean, name: string, options: NamedWaitHandleOptions): Mutex$instance;
    new(initiallyOwned: boolean, name: string): Mutex$instance;
    new(name: string, options: NamedWaitHandleOptions): Mutex$instance;
    new(initiallyOwned: boolean): Mutex$instance;
    new(): Mutex$instance;
    openExisting(name: string, options: NamedWaitHandleOptions): Mutex;
    openExisting(name: string): Mutex;
    tryOpenExisting(name: string, result: { value: ref<Mutex> }): boolean;
    tryOpenExisting(name: string, options: NamedWaitHandleOptions, result: { value: ref<Mutex> }): boolean;
};


export interface __Mutex$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type Mutex = Mutex$instance & __Mutex$views;


export interface Overlapped$instance {
    asyncResult: IAsyncResult;
    eventHandle: int;
    eventHandleIntPtr: nint;
    offsetHigh: int;
    offsetLow: int;
    pack(iocb: IOCompletionCallback): ptr<NativeOverlapped>;
    pack(iocb: IOCompletionCallback, userData: unknown): ptr<NativeOverlapped>;
    unsafePack(iocb: IOCompletionCallback): ptr<NativeOverlapped>;
    unsafePack(iocb: IOCompletionCallback, userData: unknown): ptr<NativeOverlapped>;
}


export const Overlapped: {
    new(): Overlapped$instance;
    new(offsetLo: int, offsetHi: int, hEvent: nint, ar: IAsyncResult): Overlapped$instance;
    new(offsetLo: int, offsetHi: int, hEvent: int, ar: IAsyncResult): Overlapped$instance;
    free(nativeOverlappedPtr: ptr<NativeOverlapped>): void;
    unpack(nativeOverlappedPtr: ptr<NativeOverlapped>): Overlapped;
};


export type Overlapped = Overlapped$instance;

export interface PeriodicTimer$instance {
    period: TimeSpan;
    dispose(): void;
    waitForNextTickAsync(cancellationToken?: CancellationToken): ValueTask_1<CLROf<boolean>>;
}


export const PeriodicTimer: {
    new(period: TimeSpan): PeriodicTimer$instance;
    new(period: TimeSpan, timeProvider: TimeProvider): PeriodicTimer$instance;
};


export interface __PeriodicTimer$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface PeriodicTimer$instance extends System_Internal.IDisposable$instance {}

export type PeriodicTimer = PeriodicTimer$instance & __PeriodicTimer$views;


export interface PreAllocatedOverlapped$instance {
    dispose(): void;
}


export const PreAllocatedOverlapped: {
    new(callback: IOCompletionCallback, state: unknown, pinData: unknown): PreAllocatedOverlapped$instance;
    unsafeCreate(callback: IOCompletionCallback, state: unknown, pinData: unknown): PreAllocatedOverlapped;
};


export interface __PreAllocatedOverlapped$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface PreAllocatedOverlapped$instance extends System_Internal.IDisposable$instance {}

export type PreAllocatedOverlapped = PreAllocatedOverlapped$instance & __PreAllocatedOverlapped$views;


export interface ReaderWriterLock$instance extends CriticalFinalizerObject {
    readonly isReaderLockHeld: boolean;
    readonly isWriterLockHeld: boolean;
    readonly writerSeqNum: int;
    acquireReaderLock(millisecondsTimeout: int): void;
    acquireReaderLock(timeout: TimeSpan): void;
    acquireWriterLock(millisecondsTimeout: int): void;
    acquireWriterLock(timeout: TimeSpan): void;
    anyWritersSince(seqNum: int): boolean;
    downgradeFromWriterLock(lockCookie: { value: ref<LockCookie> }): void;
    releaseLock(): LockCookie;
    releaseReaderLock(): void;
    releaseWriterLock(): void;
    restoreLock(lockCookie: { value: ref<LockCookie> }): void;
    upgradeToWriterLock(millisecondsTimeout: int): LockCookie;
    upgradeToWriterLock(timeout: TimeSpan): LockCookie;
}


export const ReaderWriterLock: {
    new(): ReaderWriterLock$instance;
};


export type ReaderWriterLock = ReaderWriterLock$instance;

export interface ReaderWriterLockSlim$instance {
    readonly currentReadCount: int;
    readonly isReadLockHeld: boolean;
    readonly isUpgradeableReadLockHeld: boolean;
    readonly isWriteLockHeld: boolean;
    readonly recursionPolicy: LockRecursionPolicy;
    readonly recursiveReadCount: int;
    readonly recursiveUpgradeCount: int;
    readonly recursiveWriteCount: int;
    readonly waitingReadCount: int;
    readonly waitingUpgradeCount: int;
    readonly waitingWriteCount: int;
    dispose(): void;
    enterReadLock(): void;
    enterUpgradeableReadLock(): void;
    enterWriteLock(): void;
    exitReadLock(): void;
    exitUpgradeableReadLock(): void;
    exitWriteLock(): void;
    tryEnterReadLock(timeout: TimeSpan): boolean;
    tryEnterReadLock(millisecondsTimeout: int): boolean;
    tryEnterUpgradeableReadLock(timeout: TimeSpan): boolean;
    tryEnterUpgradeableReadLock(millisecondsTimeout: int): boolean;
    tryEnterWriteLock(timeout: TimeSpan): boolean;
    tryEnterWriteLock(millisecondsTimeout: int): boolean;
}


export const ReaderWriterLockSlim: {
    new(): ReaderWriterLockSlim$instance;
    new(recursionPolicy: LockRecursionPolicy): ReaderWriterLockSlim$instance;
};


export interface __ReaderWriterLockSlim$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ReaderWriterLockSlim$instance extends System_Internal.IDisposable$instance {}

export type ReaderWriterLockSlim = ReaderWriterLockSlim$instance & __ReaderWriterLockSlim$views;


export interface RegisteredWaitHandle$instance extends MarshalByRefObject {
    unregister(waitObject: WaitHandle): boolean;
}


export const RegisteredWaitHandle: {
    new(): RegisteredWaitHandle$instance;
};


export type RegisteredWaitHandle = RegisteredWaitHandle$instance;

export interface Semaphore$instance extends WaitHandle$instance {
    dispose(): void;
    release(): int;
    release(releaseCount: int): int;
}


export const Semaphore: {
    new(initialCount: int, maximumCount: int): Semaphore$instance;
    new(initialCount: int, maximumCount: int, name: string, options: NamedWaitHandleOptions): Semaphore$instance;
    new(initialCount: int, maximumCount: int, name: string): Semaphore$instance;
    new(initialCount: int, maximumCount: int, name: string, options: NamedWaitHandleOptions, createdNew: ref<boolean>): Semaphore$instance;
    new(initialCount: int, maximumCount: int, name: string, createdNew: ref<boolean>): Semaphore$instance;
    openExisting(name: string, options: NamedWaitHandleOptions): Semaphore;
    openExisting(name: string): Semaphore;
    tryOpenExisting(name: string, options: NamedWaitHandleOptions, result: { value: ref<Semaphore> }): boolean;
    tryOpenExisting(name: string, result: { value: ref<Semaphore> }): boolean;
};


export interface __Semaphore$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type Semaphore = Semaphore$instance & __Semaphore$views;


export interface SemaphoreFullException$instance extends SystemException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SemaphoreFullException: {
    new(): SemaphoreFullException$instance;
    new(message: string): SemaphoreFullException$instance;
    new(message: string, innerException: Exception): SemaphoreFullException$instance;
};


export interface __SemaphoreFullException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SemaphoreFullException = SemaphoreFullException$instance & __SemaphoreFullException$views;


export interface SemaphoreSlim$instance {
    readonly availableWaitHandle: WaitHandle;
    readonly currentCount: int;
    dispose(): void;
    release(): int;
    release(releaseCount: int): int;
    wait(): void;
    wait(cancellationToken: CancellationToken): void;
    wait(timeout: TimeSpan): boolean;
    wait(timeout: TimeSpan, cancellationToken: CancellationToken): boolean;
    wait(millisecondsTimeout: int): boolean;
    wait(millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
    waitAsync(): Task;
    waitAsync(cancellationToken: CancellationToken): Task;
    waitAsync(millisecondsTimeout: int): Task_1<CLROf<boolean>>;
    waitAsync(timeout: TimeSpan): Task_1<CLROf<boolean>>;
    waitAsync(timeout: TimeSpan, cancellationToken: CancellationToken): Task_1<CLROf<boolean>>;
    waitAsync(millisecondsTimeout: int, cancellationToken: CancellationToken): Task_1<CLROf<boolean>>;
}


export const SemaphoreSlim: {
    new(initialCount: int): SemaphoreSlim$instance;
    new(initialCount: int, maxCount: int): SemaphoreSlim$instance;
};


export interface __SemaphoreSlim$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface SemaphoreSlim$instance extends System_Internal.IDisposable$instance {}

export type SemaphoreSlim = SemaphoreSlim$instance & __SemaphoreSlim$views;


export interface SynchronizationContext$instance {
    createCopy(): SynchronizationContext;
    isWaitNotificationRequired(): boolean;
    operationCompleted(): void;
    operationStarted(): void;
    post(d: SendOrPostCallback, state: unknown): void;
    send(d: SendOrPostCallback, state: unknown): void;
    wait(waitHandles: nint[], waitAll: boolean, millisecondsTimeout: int): int;
}


export const SynchronizationContext: {
    new(): SynchronizationContext$instance;
    readonly current: SynchronizationContext;
    setSynchronizationContext(syncContext: SynchronizationContext): void;
};


export type SynchronizationContext = SynchronizationContext$instance;

export interface SynchronizationLockException$instance extends SystemException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SynchronizationLockException: {
    new(): SynchronizationLockException$instance;
    new(message: string): SynchronizationLockException$instance;
    new(message: string, innerException: Exception): SynchronizationLockException$instance;
};


export interface __SynchronizationLockException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SynchronizationLockException = SynchronizationLockException$instance & __SynchronizationLockException$views;


export interface Thread$instance extends CriticalFinalizerObject {
    apartmentState: ApartmentState;
    currentCulture: CultureInfo;
    currentUICulture: CultureInfo;
    readonly executionContext: ExecutionContext;
    readonly isAlive: boolean;
    isBackground: boolean;
    readonly isThreadPoolThread: boolean;
    readonly managedThreadId: int;
    name: string;
    priority: ThreadPriority;
    readonly threadState: ThreadState;
    abort(): void;
    abort(stateInfo: unknown): void;
    disableComObjectEagerCleanup(): void;
    getApartmentState(): ApartmentState;
    getCompressedStack(): CompressedStack;
    getHashCode(): int;
    interrupt(): void;
    join(millisecondsTimeout: int): boolean;
    join(): void;
    join(timeout: TimeSpan): boolean;
    resume(): void;
    setApartmentState(state: ApartmentState): void;
    setCompressedStack(stack: CompressedStack): void;
    start(parameter: unknown): void;
    start(): void;
    suspend(): void;
    trySetApartmentState(state: ApartmentState): boolean;
    unsafeStart(parameter: unknown): void;
    unsafeStart(): void;
}


export const Thread: {
    new(start: ThreadStart): Thread$instance;
    new(start: ThreadStart, maxStackSize: int): Thread$instance;
    new(start: ParameterizedThreadStart): Thread$instance;
    new(start: ParameterizedThreadStart, maxStackSize: int): Thread$instance;
    currentPrincipal: IPrincipal;
    readonly currentThread: Thread;
    allocateDataSlot(): LocalDataStoreSlot;
    allocateNamedDataSlot(name: string): LocalDataStoreSlot;
    beginCriticalRegion(): void;
    beginThreadAffinity(): void;
    endCriticalRegion(): void;
    endThreadAffinity(): void;
    freeNamedDataSlot(name: string): void;
    getCurrentProcessorId(): int;
    getData(slot: LocalDataStoreSlot): unknown;
    getDomain(): AppDomain;
    getDomainID(): int;
    getNamedDataSlot(name: string): LocalDataStoreSlot;
    memoryBarrier(): void;
    resetAbort(): void;
    setData(slot: LocalDataStoreSlot, data: unknown): void;
    sleep(millisecondsTimeout: int): void;
    sleep(timeout: TimeSpan): void;
    spinWait(iterations: int): void;
    volatileRead(address: { value: ref<byte> }): byte;
    volatileRead(address: { value: ref<double> }): double;
    volatileRead(address: { value: ref<short> }): short;
    volatileRead(address: { value: ref<int> }): int;
    volatileRead(address: { value: ref<long> }): long;
    volatileRead(address: { value: ref<nint> }): nint;
    volatileRead(address: { value: ref<unknown> }): unknown;
    volatileRead(address: { value: ref<sbyte> }): sbyte;
    volatileRead(address: { value: ref<float> }): float;
    volatileRead(address: { value: ref<ushort> }): ushort;
    volatileRead(address: { value: ref<uint> }): uint;
    volatileRead(address: { value: ref<ulong> }): ulong;
    volatileRead(address: { value: ref<nuint> }): nuint;
    volatileWrite(address: { value: ref<byte> }, value: byte): void;
    volatileWrite(address: { value: ref<double> }, value: double): void;
    volatileWrite(address: { value: ref<short> }, value: short): void;
    volatileWrite(address: { value: ref<int> }, value: int): void;
    volatileWrite(address: { value: ref<long> }, value: long): void;
    volatileWrite(address: { value: ref<nint> }, value: nint): void;
    volatileWrite(address: { value: ref<unknown> }, value: unknown): void;
    volatileWrite(address: { value: ref<sbyte> }, value: sbyte): void;
    volatileWrite(address: { value: ref<float> }, value: float): void;
    volatileWrite(address: { value: ref<ushort> }, value: ushort): void;
    volatileWrite(address: { value: ref<uint> }, value: uint): void;
    volatileWrite(address: { value: ref<ulong> }, value: ulong): void;
    volatileWrite(address: { value: ref<nuint> }, value: nuint): void;
    yield_(): boolean;
};


export type Thread = Thread$instance;

export interface ThreadAbortException$instance extends SystemException {
    readonly exceptionState: unknown;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const ThreadAbortException: {
    new(): ThreadAbortException$instance;
};


export interface __ThreadAbortException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ThreadAbortException = ThreadAbortException$instance & __ThreadAbortException$views;


export interface ThreadExceptionEventArgs$instance extends EventArgs {
    readonly exception: Exception;
}


export const ThreadExceptionEventArgs: {
    new(t: Exception): ThreadExceptionEventArgs$instance;
};


export type ThreadExceptionEventArgs = ThreadExceptionEventArgs$instance;

export interface ThreadInterruptedException$instance extends SystemException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const ThreadInterruptedException: {
    new(): ThreadInterruptedException$instance;
    new(message: string): ThreadInterruptedException$instance;
    new(message: string, innerException: Exception): ThreadInterruptedException$instance;
};


export interface __ThreadInterruptedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ThreadInterruptedException = ThreadInterruptedException$instance & __ThreadInterruptedException$views;


export interface ThreadLocal_1$instance<T> {
    readonly isValueCreated: boolean;
    value: T;
    readonly values: IList_1<T>;
    dispose(): void;
    toString(): string;
}


export const ThreadLocal_1: {
    new<T>(): ThreadLocal_1$instance<T>;
    new<T>(trackAllValues: boolean): ThreadLocal_1$instance<T>;
    new<T>(valueFactory: Func_1<T>): ThreadLocal_1$instance<T>;
    new<T>(valueFactory: Func_1<T>, trackAllValues: boolean): ThreadLocal_1$instance<T>;
};


export interface __ThreadLocal_1$views<T> {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ThreadLocal_1$instance<T> extends System_Internal.IDisposable$instance {}

export type ThreadLocal_1<T> = ThreadLocal_1$instance<T> & __ThreadLocal_1$views<T>;


export interface ThreadPoolBoundHandle$instance {
    readonly handle: SafeHandle;
    allocateNativeOverlapped(callback: IOCompletionCallback, state: unknown, pinData: unknown): ptr<NativeOverlapped>;
    allocateNativeOverlapped(preAllocated: PreAllocatedOverlapped): ptr<NativeOverlapped>;
    dispose(): void;
    freeNativeOverlapped(overlapped: ptr<NativeOverlapped>): void;
    unsafeAllocateNativeOverlapped(callback: IOCompletionCallback, state: unknown, pinData: unknown): ptr<NativeOverlapped>;
}


export const ThreadPoolBoundHandle: {
    new(): ThreadPoolBoundHandle$instance;
    bindHandle(handle: SafeHandle): ThreadPoolBoundHandle;
    getNativeOverlappedState(overlapped: ptr<NativeOverlapped>): unknown;
};


export interface __ThreadPoolBoundHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ThreadPoolBoundHandle$instance extends System_Internal.IDisposable$instance {}

export type ThreadPoolBoundHandle = ThreadPoolBoundHandle$instance & __ThreadPoolBoundHandle$views;


export interface ThreadStartException$instance extends SystemException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const ThreadStartException: {
    new(): ThreadStartException$instance;
};


export interface __ThreadStartException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ThreadStartException = ThreadStartException$instance & __ThreadStartException$views;


export interface ThreadStateException$instance extends SystemException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const ThreadStateException: {
    new(): ThreadStateException$instance;
    new(message: string): ThreadStateException$instance;
    new(message: string, innerException: Exception): ThreadStateException$instance;
};


export interface __ThreadStateException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ThreadStateException = ThreadStateException$instance & __ThreadStateException$views;


export interface Timer$instance extends MarshalByRefObject {
    change(dueTime: int, period: int): boolean;
    change(dueTime: TimeSpan, period: TimeSpan): boolean;
    change(dueTime: uint, period: uint): boolean;
    change(dueTime: long, period: long): boolean;
    dispose(notifyObject: WaitHandle): boolean;
    dispose(): void;
    disposeAsync(): ValueTask;
}


export const Timer: {
    new(callback: TimerCallback, state: unknown, dueTime: int, period: int): Timer$instance;
    new(callback: TimerCallback, state: unknown, dueTime: TimeSpan, period: TimeSpan): Timer$instance;
    new(callback: TimerCallback, state: unknown, dueTime: uint, period: uint): Timer$instance;
    new(callback: TimerCallback, state: unknown, dueTime: long, period: long): Timer$instance;
    new(callback: TimerCallback): Timer$instance;
    readonly activeCount: long;
};


export interface __Timer$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ITimer(): ITimer$instance;
}

export type Timer = Timer$instance & __Timer$views;


export interface WaitHandle$instance extends MarshalByRefObject {
    handle: nint;
    safeWaitHandle: SafeWaitHandle;
    close(): void;
    dispose(): void;
    waitOne(millisecondsTimeout: int): boolean;
    waitOne(timeout: TimeSpan): boolean;
    waitOne(): boolean;
    waitOne(millisecondsTimeout: int, exitContext: boolean): boolean;
    waitOne(timeout: TimeSpan, exitContext: boolean): boolean;
}


export const WaitHandle: {
    readonly waitTimeout: int;
    signalAndWait(toSignal: WaitHandle, toWaitOn: WaitHandle, millisecondsTimeout: int, exitContext: boolean): boolean;
    signalAndWait(toSignal: WaitHandle, toWaitOn: WaitHandle, timeout: TimeSpan, exitContext: boolean): boolean;
    signalAndWait(toSignal: WaitHandle, toWaitOn: WaitHandle): boolean;
    waitAll(waitHandles: WaitHandle[], millisecondsTimeout: int, exitContext: boolean): boolean;
    waitAll(waitHandles: WaitHandle[], millisecondsTimeout: int): boolean;
    waitAll(waitHandles: WaitHandle[], timeout: TimeSpan, exitContext: boolean): boolean;
    waitAll(waitHandles: WaitHandle[], timeout: TimeSpan): boolean;
    waitAll(waitHandles: WaitHandle[]): boolean;
    waitAny(waitHandles: WaitHandle[], millisecondsTimeout: int, exitContext: boolean): int;
    waitAny(waitHandles: WaitHandle[], millisecondsTimeout: int): int;
    waitAny(waitHandles: WaitHandle[], timeout: TimeSpan, exitContext: boolean): int;
    waitAny(waitHandles: WaitHandle[], timeout: TimeSpan): int;
    waitAny(waitHandles: WaitHandle[]): int;
};


export interface __WaitHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface WaitHandle$instance extends System_Internal.IDisposable$instance {}

export type WaitHandle = WaitHandle$instance & __WaitHandle$views;


export interface WaitHandleCannotBeOpenedException$instance extends ApplicationException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const WaitHandleCannotBeOpenedException: {
    new(): WaitHandleCannotBeOpenedException$instance;
    new(message: string): WaitHandleCannotBeOpenedException$instance;
    new(message: string, innerException: Exception): WaitHandleCannotBeOpenedException$instance;
};


export interface __WaitHandleCannotBeOpenedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type WaitHandleCannotBeOpenedException = WaitHandleCannotBeOpenedException$instance & __WaitHandleCannotBeOpenedException$views;


export abstract class EventWaitHandleAcl$instance {
    static create(initialState: boolean, mode: EventResetMode, name: string, createdNew: { value: ref<boolean> }, eventSecurity: EventWaitHandleSecurity): EventWaitHandle;
    static openExisting(name: string, rights: EventWaitHandleRights): EventWaitHandle;
    static tryOpenExisting(name: string, rights: EventWaitHandleRights, result: { value: ref<EventWaitHandle> }): boolean;
}


export type EventWaitHandleAcl = EventWaitHandleAcl$instance;

export abstract class Interlocked$instance {
    static add(location1: { value: ref<int> }, value: int): int;
    static add(location1: { value: ref<long> }, value: long): long;
    static add(location1: { value: ref<uint> }, value: uint): uint;
    static add(location1: { value: ref<ulong> }, value: ulong): ulong;
    static and(location1: { value: ref<int> }, value: int): int;
    static and(location1: { value: ref<long> }, value: long): long;
    static and(location1: { value: ref<uint> }, value: uint): uint;
    static and(location1: { value: ref<ulong> }, value: ulong): ulong;
    static compareExchange(location1: { value: ref<byte> }, value: byte, comparand: byte): byte;
    static compareExchange(location1: { value: ref<double> }, value: double, comparand: double): double;
    static compareExchange(location1: { value: ref<short> }, value: short, comparand: short): short;
    static compareExchange(location1: { value: ref<int> }, value: int, comparand: int): int;
    static compareExchange(location1: { value: ref<long> }, value: long, comparand: long): long;
    static compareExchange(location1: { value: ref<nint> }, value: nint, comparand: nint): nint;
    static compareExchange(location1: { value: ref<unknown> }, value: unknown, comparand: unknown): unknown;
    static compareExchange(location1: { value: ref<sbyte> }, value: sbyte, comparand: sbyte): sbyte;
    static compareExchange(location1: { value: ref<float> }, value: float, comparand: float): float;
    static compareExchange(location1: { value: ref<ushort> }, value: ushort, comparand: ushort): ushort;
    static compareExchange(location1: { value: ref<uint> }, value: uint, comparand: uint): uint;
    static compareExchange(location1: { value: ref<ulong> }, value: ulong, comparand: ulong): ulong;
    static compareExchange(location1: { value: ref<nuint> }, value: nuint, comparand: nuint): nuint;
    static compareExchange<T>(location1: { value: ref<T> }, value: T, comparand: T): T;
    static decrement(location: { value: ref<int> }): int;
    static decrement(location: { value: ref<long> }): long;
    static decrement(location: { value: ref<uint> }): uint;
    static decrement(location: { value: ref<ulong> }): ulong;
    static exchange(location1: { value: ref<byte> }, value: byte): byte;
    static exchange(location1: { value: ref<double> }, value: double): double;
    static exchange(location1: { value: ref<short> }, value: short): short;
    static exchange(location1: { value: ref<int> }, value: int): int;
    static exchange(location1: { value: ref<long> }, value: long): long;
    static exchange(location1: { value: ref<nint> }, value: nint): nint;
    static exchange(location1: { value: ref<unknown> }, value: unknown): unknown;
    static exchange(location1: { value: ref<sbyte> }, value: sbyte): sbyte;
    static exchange(location1: { value: ref<float> }, value: float): float;
    static exchange(location1: { value: ref<ushort> }, value: ushort): ushort;
    static exchange(location1: { value: ref<uint> }, value: uint): uint;
    static exchange(location1: { value: ref<ulong> }, value: ulong): ulong;
    static exchange(location1: { value: ref<nuint> }, value: nuint): nuint;
    static exchange<T>(location1: { value: ref<T> }, value: T): T;
    static increment(location: { value: ref<int> }): int;
    static increment(location: { value: ref<long> }): long;
    static increment(location: { value: ref<uint> }): uint;
    static increment(location: { value: ref<ulong> }): ulong;
    static memoryBarrier(): void;
    static memoryBarrierProcessWide(): void;
    static or(location1: { value: ref<int> }, value: int): int;
    static or(location1: { value: ref<long> }, value: long): long;
    static or(location1: { value: ref<uint> }, value: uint): uint;
    static or(location1: { value: ref<ulong> }, value: ulong): ulong;
    static read(location: { value: ref<long> }): long;
    static read(location: { value: ref<ulong> }): ulong;
}


export type Interlocked = Interlocked$instance;

export abstract class LazyInitializer$instance {
    static ensureInitialized<T>(target: { value: ref<T> }, valueFactory: Func_1<T>): T;
    static ensureInitialized<T>(target: { value: ref<T> }, initialized: { value: ref<boolean> }, syncLock: { value: ref<unknown> }, valueFactory: Func_1<T>): T;
    static ensureInitialized<T>(target: { value: ref<T> }, initialized: { value: ref<boolean> }, syncLock: { value: ref<unknown> }): T;
    static ensureInitialized<T>(target: { value: ref<T> }, syncLock: { value: ref<unknown> }, valueFactory: Func_1<T>): T;
    static ensureInitialized<T>(target: { value: ref<T> }): T;
}


export type LazyInitializer = LazyInitializer$instance;

export abstract class Monitor$instance {
    static readonly lockContentionCount: long;
    static enter(obj: unknown, lockTaken: { value: ref<boolean> }): void;
    static enter(obj: unknown): void;
    static exit(obj: unknown): void;
    static isEntered(obj: unknown): boolean;
    static pulse(obj: unknown): void;
    static pulseAll(obj: unknown): void;
    static tryEnter(obj: unknown, lockTaken: { value: ref<boolean> }): void;
    static tryEnter(obj: unknown, millisecondsTimeout: int, lockTaken: { value: ref<boolean> }): void;
    static tryEnter(obj: unknown, millisecondsTimeout: int): boolean;
    static tryEnter(obj: unknown, timeout: TimeSpan, lockTaken: { value: ref<boolean> }): void;
    static tryEnter(obj: unknown, timeout: TimeSpan): boolean;
    static tryEnter(obj: unknown): boolean;
    static wait(obj: unknown, millisecondsTimeout: int, exitContext: boolean): boolean;
    static wait(obj: unknown, millisecondsTimeout: int): boolean;
    static wait(obj: unknown, timeout: TimeSpan, exitContext: boolean): boolean;
    static wait(obj: unknown, timeout: TimeSpan): boolean;
    static wait(obj: unknown): boolean;
}


export type Monitor = Monitor$instance;

export abstract class MutexAcl$instance {
    static create(initiallyOwned: boolean, name: string, createdNew: { value: ref<boolean> }, mutexSecurity: MutexSecurity): Mutex;
    static openExisting(name: string, rights: MutexRights): Mutex;
    static tryOpenExisting(name: string, rights: MutexRights, result: { value: ref<Mutex> }): boolean;
}


export type MutexAcl = MutexAcl$instance;

export abstract class SemaphoreAcl$instance {
    static create(initialCount: int, maximumCount: int, name: string, createdNew: { value: ref<boolean> }, semaphoreSecurity: SemaphoreSecurity): Semaphore;
    static openExisting(name: string, rights: SemaphoreRights): Semaphore;
    static tryOpenExisting(name: string, rights: SemaphoreRights, result: { value: ref<Semaphore> }): boolean;
}


export type SemaphoreAcl = SemaphoreAcl$instance;

export abstract class ThreadingAclExtensions$instance {
    static getAccessControl(handle: EventWaitHandle): EventWaitHandleSecurity;
    static getAccessControl(mutex: Mutex): MutexSecurity;
    static getAccessControl(semaphore: Semaphore): SemaphoreSecurity;
    static setAccessControl(handle: EventWaitHandle, eventSecurity: EventWaitHandleSecurity): void;
    static setAccessControl(mutex: Mutex, mutexSecurity: MutexSecurity): void;
    static setAccessControl(semaphore: Semaphore, semaphoreSecurity: SemaphoreSecurity): void;
}


export type ThreadingAclExtensions = ThreadingAclExtensions$instance;

export abstract class ThreadPool$instance {
    static readonly pendingWorkItemCount: long;
    static readonly threadCount: int;
    static readonly completedWorkItemCount: long;
    static bindHandle(osHandle: nint): boolean;
    static bindHandle(osHandle: SafeHandle): boolean;
    static getAvailableThreads(workerThreads: { value: ref<int> }, completionPortThreads: { value: ref<int> }): void;
    static getMaxThreads(workerThreads: { value: ref<int> }, completionPortThreads: { value: ref<int> }): void;
    static getMinThreads(workerThreads: { value: ref<int> }, completionPortThreads: { value: ref<int> }): void;
    static queueUserWorkItem<TState>(callBack: Action_1<TState>, state: TState, preferLocal: boolean): boolean;
    static queueUserWorkItem(callBack: WaitCallback, state: unknown): boolean;
    static queueUserWorkItem(callBack: WaitCallback): boolean;
    static registerWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: unknown, millisecondsTimeOutInterval: int, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static registerWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: unknown, millisecondsTimeOutInterval: long, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static registerWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: unknown, timeout: TimeSpan, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static registerWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: unknown, millisecondsTimeOutInterval: uint, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static setMaxThreads(workerThreads: int, completionPortThreads: int): boolean;
    static setMinThreads(workerThreads: int, completionPortThreads: int): boolean;
    static unsafeQueueNativeOverlapped(overlapped: ptr<NativeOverlapped>): boolean;
    static unsafeQueueUserWorkItem<TState>(callBack: Action_1<TState>, state: TState, preferLocal: boolean): boolean;
    static unsafeQueueUserWorkItem(callBack: IThreadPoolWorkItem, preferLocal: boolean): boolean;
    static unsafeQueueUserWorkItem(callBack: WaitCallback, state: unknown): boolean;
    static unsafeRegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: unknown, millisecondsTimeOutInterval: int, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static unsafeRegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: unknown, millisecondsTimeOutInterval: long, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static unsafeRegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: unknown, timeout: TimeSpan, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static unsafeRegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: unknown, millisecondsTimeOutInterval: uint, executeOnlyOnce: boolean): RegisteredWaitHandle;
}


export type ThreadPool = ThreadPool$instance;

export abstract class Timeout$instance {
    static readonly infiniteTimeSpan: TimeSpan;
    static readonly infinite: int;
}


export type Timeout = Timeout$instance;

export abstract class Volatile$instance {
    static read(location: { value: ref<boolean> }): boolean;
    static read(location: { value: ref<byte> }): byte;
    static read(location: { value: ref<double> }): double;
    static read(location: { value: ref<short> }): short;
    static read(location: { value: ref<int> }): int;
    static read(location: { value: ref<long> }): long;
    static read(location: { value: ref<nint> }): nint;
    static read(location: { value: ref<sbyte> }): sbyte;
    static read(location: { value: ref<float> }): float;
    static read(location: { value: ref<ushort> }): ushort;
    static read(location: { value: ref<uint> }): uint;
    static read(location: { value: ref<ulong> }): ulong;
    static read(location: { value: ref<nuint> }): nuint;
    static read<T>(location: { value: ref<T> }): T;
    static readBarrier(): void;
    static write(location: { value: ref<boolean> }, value: boolean): void;
    static write(location: { value: ref<byte> }, value: byte): void;
    static write(location: { value: ref<double> }, value: double): void;
    static write(location: { value: ref<short> }, value: short): void;
    static write(location: { value: ref<int> }, value: int): void;
    static write(location: { value: ref<long> }, value: long): void;
    static write(location: { value: ref<nint> }, value: nint): void;
    static write(location: { value: ref<sbyte> }, value: sbyte): void;
    static write(location: { value: ref<float> }, value: float): void;
    static write(location: { value: ref<ushort> }, value: ushort): void;
    static write(location: { value: ref<uint> }, value: uint): void;
    static write(location: { value: ref<ulong> }, value: ulong): void;
    static write(location: { value: ref<nuint> }, value: nuint): void;
    static write<T>(location: { value: ref<T> }, value: T): void;
    static writeBarrier(): void;
}


export type Volatile = Volatile$instance;

export abstract class WaitHandleExtensions$instance {
    static getSafeWaitHandle(waitHandle: WaitHandle): SafeWaitHandle;
    static setSafeWaitHandle(waitHandle: WaitHandle, value: SafeWaitHandle): void;
}


export type WaitHandleExtensions = WaitHandleExtensions$instance;

