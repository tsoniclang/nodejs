// Generated by tsbindgen - Architecture
// Namespace: System.Linq.Expressions
// Assembly: System.Linq.Expressions

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { IEnumerable_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ReadOnlyCollection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import type { ConstructorInfo, FieldInfo, MemberInfo, MethodInfo, PropertyInfo } from "../../System.Reflection/internal/index.js";
import type { CallSiteBinder, DebugInfoGenerator } from "../../System.Runtime.CompilerServices/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Delegate, Enum, Func_2, Guid, IComparable, IConvertible, IFormatProvider, IFormattable, Int32, ISpanFormattable, Object as ClrObject, String as ClrString, Type, TypeCode } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum ExpressionType {
    add = 0,
    addChecked = 1,
    and = 2,
    andAlso = 3,
    arrayLength = 4,
    arrayIndex = 5,
    call = 6,
    coalesce = 7,
    conditional = 8,
    constant = 9,
    convert = 10,
    convertChecked = 11,
    divide = 12,
    equal = 13,
    exclusiveOr = 14,
    greaterThan = 15,
    greaterThanOrEqual = 16,
    invoke = 17,
    lambda = 18,
    leftShift = 19,
    lessThan = 20,
    lessThanOrEqual = 21,
    listInit = 22,
    memberAccess = 23,
    memberInit = 24,
    modulo = 25,
    multiply = 26,
    multiplyChecked = 27,
    negate = 28,
    unaryPlus = 29,
    negateChecked = 30,
    new_ = 31,
    newArrayInit = 32,
    newArrayBounds = 33,
    not = 34,
    notEqual = 35,
    or = 36,
    orElse = 37,
    parameter = 38,
    power = 39,
    quote = 40,
    rightShift = 41,
    subtract = 42,
    subtractChecked = 43,
    typeAs = 44,
    typeIs = 45,
    assign = 46,
    block = 47,
    debugInfo = 48,
    decrement = 49,
    dynamic = 50,
    default_ = 51,
    extension = 52,
    goto = 53,
    increment = 54,
    index = 55,
    label = 56,
    runtimeVariables = 57,
    loop = 58,
    switch_ = 59,
    throw_ = 60,
    try_ = 61,
    unbox = 62,
    addAssign = 63,
    andAssign = 64,
    divideAssign = 65,
    exclusiveOrAssign = 66,
    leftShiftAssign = 67,
    moduloAssign = 68,
    multiplyAssign = 69,
    orAssign = 70,
    powerAssign = 71,
    rightShiftAssign = 72,
    subtractAssign = 73,
    addAssignChecked = 74,
    multiplyAssignChecked = 75,
    subtractAssignChecked = 76,
    preIncrementAssign = 77,
    preDecrementAssign = 78,
    postIncrementAssign = 79,
    postDecrementAssign = 80,
    typeEqual = 81,
    onesComplement = 82,
    isTrue = 83,
    isFalse = 84
}


export enum GotoExpressionKind {
    goto = 0,
    return_ = 1,
    break_ = 2,
    continue_ = 3
}


export enum MemberBindingType {
    assignment = 0,
    memberBinding = 1,
    listBinding = 2
}


export interface IArgumentProvider$instance {
    readonly argumentCount: int;
    getArgument(index: int): Expression;
}


export type IArgumentProvider = IArgumentProvider$instance;

export interface IDynamicExpression$instance extends IArgumentProvider {
    readonly delegateType: Type;
    readonly argumentCount: int;
    createCallSite(): unknown;
    getArgument(index: int): Expression;
    rewrite(args: Expression[]): Expression;
}


export interface IDynamicExpression$instance extends IArgumentProvider$instance {}

export type IDynamicExpression = IDynamicExpression$instance;

export interface BinaryExpression$instance extends Expression {
    readonly canReduce: boolean;
    readonly conversion: LambdaExpression;
    readonly isLifted: boolean;
    readonly isLiftedToNull: boolean;
    readonly left: Expression;
    readonly method: MethodInfo;
    readonly right: Expression;
    reduce(): Expression;
    update(left: Expression, conversion: LambdaExpression, right: Expression): BinaryExpression;
}


export const BinaryExpression: {
    new(): BinaryExpression$instance;
};


export type BinaryExpression = BinaryExpression$instance;

export interface BlockExpression$instance extends Expression {
    readonly expressions: ReadOnlyCollection_1<Expression>;
    readonly nodeType: ExpressionType;
    readonly result: Expression;
    readonly type_: Type;
    readonly variables: ReadOnlyCollection_1<ParameterExpression>;
    update(variables: IEnumerable_1<ParameterExpression>, expressions: IEnumerable_1<Expression>): BlockExpression;
}


export const BlockExpression: {
    new(): BlockExpression$instance;
};


export type BlockExpression = BlockExpression$instance;

export interface CatchBlock$instance {
    readonly body: Expression;
    readonly filter: Expression;
    readonly test: Type;
    readonly variable: ParameterExpression;
    toString(): string;
    update(variable: ParameterExpression, filter: Expression, body: Expression): CatchBlock;
}


export const CatchBlock: {
    new(): CatchBlock$instance;
};


export type CatchBlock = CatchBlock$instance;

export interface ConditionalExpression$instance extends Expression {
    readonly ifFalse: Expression;
    readonly ifTrue: Expression;
    readonly nodeType: ExpressionType;
    readonly test: Expression;
    readonly type_: Type;
    update(test: Expression, ifTrue: Expression, ifFalse: Expression): ConditionalExpression;
}


export const ConditionalExpression: {
    new(): ConditionalExpression$instance;
};


export type ConditionalExpression = ConditionalExpression$instance;

export interface ConstantExpression$instance extends Expression {
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    readonly value: unknown;
}


export const ConstantExpression: {
    new(): ConstantExpression$instance;
};


export type ConstantExpression = ConstantExpression$instance;

export interface DebugInfoExpression$instance extends Expression {
    readonly document: SymbolDocumentInfo;
    readonly endColumn: int;
    readonly endLine: int;
    readonly isClear: boolean;
    readonly nodeType: ExpressionType;
    readonly startColumn: int;
    readonly startLine: int;
    readonly type_: Type;
}


export const DebugInfoExpression: {
    new(): DebugInfoExpression$instance;
};


export type DebugInfoExpression = DebugInfoExpression$instance;

export interface DefaultExpression$instance extends Expression {
    readonly nodeType: ExpressionType;
    readonly type_: Type;
}


export const DefaultExpression: {
    new(): DefaultExpression$instance;
};


export type DefaultExpression = DefaultExpression$instance;

export interface DynamicExpression$instance extends Expression {
    readonly arguments: ReadOnlyCollection_1<Expression>;
    readonly binder: CallSiteBinder;
    readonly canReduce: boolean;
    readonly delegateType: Type;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    reduce(): Expression;
    update(arguments: IEnumerable_1<Expression>): DynamicExpression;
}


export const DynamicExpression: {
    new(): DynamicExpression$instance;
    dynamic(binder: CallSiteBinder, returnType: Type, arguments: IEnumerable_1<Expression>): DynamicExpression;
    dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): DynamicExpression;
    dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression, arg2: Expression): DynamicExpression;
    dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression): DynamicExpression;
    dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression): DynamicExpression;
    dynamic(binder: CallSiteBinder, returnType: Type, arguments: Expression[]): DynamicExpression;
    makeDynamic(delegateType: Type, binder: CallSiteBinder, arguments: IEnumerable_1<Expression>): DynamicExpression;
    makeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): DynamicExpression;
    makeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression): DynamicExpression;
    makeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression): DynamicExpression;
    makeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression): DynamicExpression;
    makeDynamic(delegateType: Type, binder: CallSiteBinder, arguments: Expression[]): DynamicExpression;
};


export interface __DynamicExpression$views {
    As_IArgumentProvider(): IArgumentProvider$instance;
    As_IDynamicExpression(): IDynamicExpression$instance;
}

export interface DynamicExpression$instance extends IDynamicExpression$instance {}

export type DynamicExpression = DynamicExpression$instance & __DynamicExpression$views;


export interface DynamicExpressionVisitor$instance extends ExpressionVisitor {
}


export const DynamicExpressionVisitor: {
    new(): DynamicExpressionVisitor$instance;
};


export type DynamicExpressionVisitor = DynamicExpressionVisitor$instance;

export interface ElementInit$instance {
    readonly addMethod: MethodInfo;
    readonly argumentCount: int;
    readonly arguments: ReadOnlyCollection_1<Expression>;
    getArgument(index: int): Expression;
    toString(): string;
    update(arguments: IEnumerable_1<Expression>): ElementInit;
}


export const ElementInit: {
    new(): ElementInit$instance;
};


export interface __ElementInit$views {
    As_IArgumentProvider(): IArgumentProvider$instance;
}

export interface ElementInit$instance extends IArgumentProvider$instance {}

export type ElementInit = ElementInit$instance & __ElementInit$views;


export interface Expression$instance {
    readonly canReduce: boolean;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    reduce(): Expression;
    reduceAndCheck(): Expression;
    reduceExtensions(): Expression;
    toString(): string;
}


export const Expression: {
    add(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    add(left: Expression, right: Expression): BinaryExpression;
    addAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    addAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    addAssign(left: Expression, right: Expression): BinaryExpression;
    addAssignChecked(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    addAssignChecked(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    addAssignChecked(left: Expression, right: Expression): BinaryExpression;
    addChecked(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    addChecked(left: Expression, right: Expression): BinaryExpression;
    and(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    and(left: Expression, right: Expression): BinaryExpression;
    andAlso(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    andAlso(left: Expression, right: Expression): BinaryExpression;
    andAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    andAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    andAssign(left: Expression, right: Expression): BinaryExpression;
    arrayAccess(array: Expression, indexes: IEnumerable_1<Expression>): IndexExpression;
    arrayAccess(array: Expression, indexes: Expression[]): IndexExpression;
    arrayIndex(array: Expression, indexes: IEnumerable_1<Expression>): MethodCallExpression;
    arrayIndex(array: Expression, index: Expression): BinaryExpression;
    arrayIndex(array: Expression, indexes: Expression[]): MethodCallExpression;
    arrayLength(array: Expression): UnaryExpression;
    assign(left: Expression, right: Expression): BinaryExpression;
    bind(member: MemberInfo, expression: Expression): MemberAssignment;
    bind(propertyAccessor: MethodInfo, expression: Expression): MemberAssignment;
    block(expressions: IEnumerable_1<Expression>): BlockExpression;
    block(variables: IEnumerable_1<ParameterExpression>, expressions: IEnumerable_1<Expression>): BlockExpression;
    block(variables: IEnumerable_1<ParameterExpression>, expressions: Expression[]): BlockExpression;
    block(arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression, arg4: Expression): BlockExpression;
    block(arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): BlockExpression;
    block(arg0: Expression, arg1: Expression, arg2: Expression): BlockExpression;
    block(arg0: Expression, arg1: Expression): BlockExpression;
    block(expressions: Expression[]): BlockExpression;
    block(type_: Type, expressions: IEnumerable_1<Expression>): BlockExpression;
    block(type_: Type, variables: IEnumerable_1<ParameterExpression>, expressions: IEnumerable_1<Expression>): BlockExpression;
    block(type_: Type, variables: IEnumerable_1<ParameterExpression>, expressions: Expression[]): BlockExpression;
    block(type_: Type, expressions: Expression[]): BlockExpression;
    break_(target: LabelTarget, value: Expression, type_: Type): GotoExpression;
    break_(target: LabelTarget, value: Expression): GotoExpression;
    break_(target: LabelTarget, type_: Type): GotoExpression;
    break_(target: LabelTarget): GotoExpression;
    call(instance: Expression, method: MethodInfo, arguments: IEnumerable_1<Expression>): MethodCallExpression;
    call(instance: Expression, method: MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression): MethodCallExpression;
    call(instance: Expression, method: MethodInfo, arg0: Expression, arg1: Expression): MethodCallExpression;
    call(instance: Expression, method: MethodInfo, arguments: Expression[]): MethodCallExpression;
    call(instance: Expression, method: MethodInfo): MethodCallExpression;
    call(instance: Expression, methodName: string, typeArguments: Type[], arguments: Expression[]): MethodCallExpression;
    call(method: MethodInfo, arguments: IEnumerable_1<Expression>): MethodCallExpression;
    call(method: MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression, arg4: Expression): MethodCallExpression;
    call(method: MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): MethodCallExpression;
    call(method: MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression): MethodCallExpression;
    call(method: MethodInfo, arg0: Expression, arg1: Expression): MethodCallExpression;
    call(method: MethodInfo, arg0: Expression): MethodCallExpression;
    call(method: MethodInfo, arguments: Expression[]): MethodCallExpression;
    call(type_: Type, methodName: string, typeArguments: Type[], arguments: Expression[]): MethodCallExpression;
    catch_(variable: ParameterExpression, body: Expression, filter: Expression): CatchBlock;
    catch_(variable: ParameterExpression, body: Expression): CatchBlock;
    catch_(type_: Type, body: Expression, filter: Expression): CatchBlock;
    catch_(type_: Type, body: Expression): CatchBlock;
    clearDebugInfo(document: SymbolDocumentInfo): DebugInfoExpression;
    coalesce(left: Expression, right: Expression, conversion: LambdaExpression): BinaryExpression;
    coalesce(left: Expression, right: Expression): BinaryExpression;
    condition(test: Expression, ifTrue: Expression, ifFalse: Expression, type_: Type): ConditionalExpression;
    condition(test: Expression, ifTrue: Expression, ifFalse: Expression): ConditionalExpression;
    constant(value: unknown, type_: Type): ConstantExpression;
    constant(value: unknown): ConstantExpression;
    continue_(target: LabelTarget, type_: Type): GotoExpression;
    continue_(target: LabelTarget): GotoExpression;
    convert(expression: Expression, type_: Type, method: MethodInfo): UnaryExpression;
    convert(expression: Expression, type_: Type): UnaryExpression;
    convertChecked(expression: Expression, type_: Type, method: MethodInfo): UnaryExpression;
    convertChecked(expression: Expression, type_: Type): UnaryExpression;
    debugInfo(document: SymbolDocumentInfo, startLine: int, startColumn: int, endLine: int, endColumn: int): DebugInfoExpression;
    decrement(expression: Expression, method: MethodInfo): UnaryExpression;
    decrement(expression: Expression): UnaryExpression;
    default_(type_: Type): DefaultExpression;
    divide(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    divide(left: Expression, right: Expression): BinaryExpression;
    divideAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    divideAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    divideAssign(left: Expression, right: Expression): BinaryExpression;
    dynamic(binder: CallSiteBinder, returnType: Type, arguments: IEnumerable_1<Expression>): DynamicExpression;
    dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): DynamicExpression;
    dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression, arg2: Expression): DynamicExpression;
    dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression): DynamicExpression;
    dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression): DynamicExpression;
    dynamic(binder: CallSiteBinder, returnType: Type, arguments: Expression[]): DynamicExpression;
    elementInit(addMethod: MethodInfo, arguments: IEnumerable_1<Expression>): ElementInit;
    elementInit(addMethod: MethodInfo, arguments: Expression[]): ElementInit;
    empty(): DefaultExpression;
    equal(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    equal(left: Expression, right: Expression): BinaryExpression;
    exclusiveOr(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    exclusiveOr(left: Expression, right: Expression): BinaryExpression;
    exclusiveOrAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    exclusiveOrAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    exclusiveOrAssign(left: Expression, right: Expression): BinaryExpression;
    field(expression: Expression, field: FieldInfo): MemberExpression;
    field(expression: Expression, fieldName: string): MemberExpression;
    field(expression: Expression, type_: Type, fieldName: string): MemberExpression;
    getActionType(typeArgs: Type[]): Type;
    getDelegateType(typeArgs: Type[]): Type;
    getFuncType(typeArgs: Type[]): Type;
    goto(target: LabelTarget, value: Expression, type_: Type): GotoExpression;
    goto(target: LabelTarget, value: Expression): GotoExpression;
    goto(target: LabelTarget, type_: Type): GotoExpression;
    goto(target: LabelTarget): GotoExpression;
    greaterThan(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    greaterThan(left: Expression, right: Expression): BinaryExpression;
    greaterThanOrEqual(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    greaterThanOrEqual(left: Expression, right: Expression): BinaryExpression;
    ifThen(test: Expression, ifTrue: Expression): ConditionalExpression;
    ifThenElse(test: Expression, ifTrue: Expression, ifFalse: Expression): ConditionalExpression;
    increment(expression: Expression, method: MethodInfo): UnaryExpression;
    increment(expression: Expression): UnaryExpression;
    invoke(expression: Expression, arguments: IEnumerable_1<Expression>): InvocationExpression;
    invoke(expression: Expression, arguments: Expression[]): InvocationExpression;
    isFalse(expression: Expression, method: MethodInfo): UnaryExpression;
    isFalse(expression: Expression): UnaryExpression;
    isTrue(expression: Expression, method: MethodInfo): UnaryExpression;
    isTrue(expression: Expression): UnaryExpression;
    label(): LabelTarget;
    label(target: LabelTarget, defaultValue: Expression): LabelExpression;
    label(target: LabelTarget): LabelExpression;
    label(name: string): LabelTarget;
    label(type_: Type, name: string): LabelTarget;
    label(type_: Type): LabelTarget;
    lambda<TDelegate>(body: Expression, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression>): Expression_1<TDelegate>;
    lambda(body: Expression, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    lambda<TDelegate>(body: Expression, tailCall: boolean, parameters: ParameterExpression[]): Expression_1<TDelegate>;
    lambda(body: Expression, tailCall: boolean, parameters: ParameterExpression[]): LambdaExpression;
    lambda<TDelegate>(body: Expression, parameters: IEnumerable_1<ParameterExpression>): Expression_1<TDelegate>;
    lambda(body: Expression, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    lambda<TDelegate>(body: Expression, parameters: ParameterExpression[]): Expression_1<TDelegate>;
    lambda(body: Expression, parameters: ParameterExpression[]): LambdaExpression;
    lambda<TDelegate>(body: Expression, name: string, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression>): Expression_1<TDelegate>;
    lambda(body: Expression, name: string, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    lambda<TDelegate>(body: Expression, name: string, parameters: IEnumerable_1<ParameterExpression>): Expression_1<TDelegate>;
    lambda(body: Expression, name: string, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    lambda(delegateType: Type, body: Expression, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    lambda(delegateType: Type, body: Expression, tailCall: boolean, parameters: ParameterExpression[]): LambdaExpression;
    lambda(delegateType: Type, body: Expression, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    lambda(delegateType: Type, body: Expression, parameters: ParameterExpression[]): LambdaExpression;
    lambda(delegateType: Type, body: Expression, name: string, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    lambda(delegateType: Type, body: Expression, name: string, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    leftShift(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    leftShift(left: Expression, right: Expression): BinaryExpression;
    leftShiftAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    leftShiftAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    leftShiftAssign(left: Expression, right: Expression): BinaryExpression;
    lessThan(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    lessThan(left: Expression, right: Expression): BinaryExpression;
    lessThanOrEqual(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    lessThanOrEqual(left: Expression, right: Expression): BinaryExpression;
    listBind(member: MemberInfo, initializers: IEnumerable_1<ElementInit>): MemberListBinding;
    listBind(member: MemberInfo, initializers: ElementInit[]): MemberListBinding;
    listBind(propertyAccessor: MethodInfo, initializers: IEnumerable_1<ElementInit>): MemberListBinding;
    listBind(propertyAccessor: MethodInfo, initializers: ElementInit[]): MemberListBinding;
    listInit(newExpression: NewExpression, initializers: IEnumerable_1<ElementInit>): ListInitExpression;
    listInit(newExpression: NewExpression, initializers: IEnumerable_1<Expression>): ListInitExpression;
    listInit(newExpression: NewExpression, initializers: ElementInit[]): ListInitExpression;
    listInit(newExpression: NewExpression, initializers: Expression[]): ListInitExpression;
    listInit(newExpression: NewExpression, addMethod: MethodInfo, initializers: IEnumerable_1<Expression>): ListInitExpression;
    listInit(newExpression: NewExpression, addMethod: MethodInfo, initializers: Expression[]): ListInitExpression;
    loop(body: Expression, break_: LabelTarget, continue_: LabelTarget): LoopExpression;
    loop(body: Expression, break_: LabelTarget): LoopExpression;
    loop(body: Expression): LoopExpression;
    makeBinary(binaryType: ExpressionType, left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    makeBinary(binaryType: ExpressionType, left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    makeBinary(binaryType: ExpressionType, left: Expression, right: Expression): BinaryExpression;
    makeCatchBlock(type_: Type, variable: ParameterExpression, body: Expression, filter: Expression): CatchBlock;
    makeDynamic(delegateType: Type, binder: CallSiteBinder, arguments: IEnumerable_1<Expression>): DynamicExpression;
    makeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): DynamicExpression;
    makeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression): DynamicExpression;
    makeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression): DynamicExpression;
    makeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression): DynamicExpression;
    makeDynamic(delegateType: Type, binder: CallSiteBinder, arguments: Expression[]): DynamicExpression;
    makeGoto(kind: GotoExpressionKind, target: LabelTarget, value: Expression, type_: Type): GotoExpression;
    makeIndex(instance: Expression, indexer: PropertyInfo, arguments: IEnumerable_1<Expression>): IndexExpression;
    makeMemberAccess(expression: Expression, member: MemberInfo): MemberExpression;
    makeTry(type_: Type, body: Expression, finally_: Expression, fault: Expression, handlers: IEnumerable_1<CatchBlock>): TryExpression;
    makeUnary(unaryType: ExpressionType, operand: Expression, type_: Type, method: MethodInfo): UnaryExpression;
    makeUnary(unaryType: ExpressionType, operand: Expression, type_: Type): UnaryExpression;
    memberBind(member: MemberInfo, bindings: IEnumerable_1<MemberBinding>): MemberMemberBinding;
    memberBind(member: MemberInfo, bindings: MemberBinding[]): MemberMemberBinding;
    memberBind(propertyAccessor: MethodInfo, bindings: IEnumerable_1<MemberBinding>): MemberMemberBinding;
    memberBind(propertyAccessor: MethodInfo, bindings: MemberBinding[]): MemberMemberBinding;
    memberInit(newExpression: NewExpression, bindings: IEnumerable_1<MemberBinding>): MemberInitExpression;
    memberInit(newExpression: NewExpression, bindings: MemberBinding[]): MemberInitExpression;
    modulo(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    modulo(left: Expression, right: Expression): BinaryExpression;
    moduloAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    moduloAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    moduloAssign(left: Expression, right: Expression): BinaryExpression;
    multiply(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    multiply(left: Expression, right: Expression): BinaryExpression;
    multiplyAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    multiplyAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    multiplyAssign(left: Expression, right: Expression): BinaryExpression;
    multiplyAssignChecked(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    multiplyAssignChecked(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    multiplyAssignChecked(left: Expression, right: Expression): BinaryExpression;
    multiplyChecked(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    multiplyChecked(left: Expression, right: Expression): BinaryExpression;
    negate(expression: Expression, method: MethodInfo): UnaryExpression;
    negate(expression: Expression): UnaryExpression;
    negateChecked(expression: Expression, method: MethodInfo): UnaryExpression;
    negateChecked(expression: Expression): UnaryExpression;
    new_(constructor_: ConstructorInfo, arguments: IEnumerable_1<Expression>, members: IEnumerable_1<MemberInfo>): NewExpression;
    new_(constructor_: ConstructorInfo, arguments: IEnumerable_1<Expression>, members: MemberInfo[]): NewExpression;
    new_(constructor_: ConstructorInfo, arguments: IEnumerable_1<Expression>): NewExpression;
    new_(constructor_: ConstructorInfo, arguments: Expression[]): NewExpression;
    new_(constructor_: ConstructorInfo): NewExpression;
    new_(type_: Type): NewExpression;
    newArrayBounds(type_: Type, bounds: IEnumerable_1<Expression>): NewArrayExpression;
    newArrayBounds(type_: Type, bounds: Expression[]): NewArrayExpression;
    newArrayInit(type_: Type, initializers: IEnumerable_1<Expression>): NewArrayExpression;
    newArrayInit(type_: Type, initializers: Expression[]): NewArrayExpression;
    not(expression: Expression, method: MethodInfo): UnaryExpression;
    not(expression: Expression): UnaryExpression;
    notEqual(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    notEqual(left: Expression, right: Expression): BinaryExpression;
    onesComplement(expression: Expression, method: MethodInfo): UnaryExpression;
    onesComplement(expression: Expression): UnaryExpression;
    or(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    or(left: Expression, right: Expression): BinaryExpression;
    orAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    orAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    orAssign(left: Expression, right: Expression): BinaryExpression;
    orElse(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    orElse(left: Expression, right: Expression): BinaryExpression;
    parameter(type_: Type, name: string): ParameterExpression;
    parameter(type_: Type): ParameterExpression;
    postDecrementAssign(expression: Expression, method: MethodInfo): UnaryExpression;
    postDecrementAssign(expression: Expression): UnaryExpression;
    postIncrementAssign(expression: Expression, method: MethodInfo): UnaryExpression;
    postIncrementAssign(expression: Expression): UnaryExpression;
    power(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    power(left: Expression, right: Expression): BinaryExpression;
    powerAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    powerAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    powerAssign(left: Expression, right: Expression): BinaryExpression;
    preDecrementAssign(expression: Expression, method: MethodInfo): UnaryExpression;
    preDecrementAssign(expression: Expression): UnaryExpression;
    preIncrementAssign(expression: Expression, method: MethodInfo): UnaryExpression;
    preIncrementAssign(expression: Expression): UnaryExpression;
    property(expression: Expression, propertyAccessor: MethodInfo): MemberExpression;
    property(instance: Expression, indexer: PropertyInfo, arguments: IEnumerable_1<Expression>): IndexExpression;
    property(instance: Expression, indexer: PropertyInfo, arguments: Expression[]): IndexExpression;
    property(expression: Expression, property: PropertyInfo): MemberExpression;
    property(instance: Expression, propertyName: string, arguments: Expression[]): IndexExpression;
    property(expression: Expression, propertyName: string): MemberExpression;
    property(expression: Expression, type_: Type, propertyName: string): MemberExpression;
    propertyOrField(expression: Expression, propertyOrFieldName: string): MemberExpression;
    quote(expression: Expression): UnaryExpression;
    referenceEqual(left: Expression, right: Expression): BinaryExpression;
    referenceNotEqual(left: Expression, right: Expression): BinaryExpression;
    rethrow(): UnaryExpression;
    rethrow(type_: Type): UnaryExpression;
    return_(target: LabelTarget, value: Expression, type_: Type): GotoExpression;
    return_(target: LabelTarget, value: Expression): GotoExpression;
    return_(target: LabelTarget, type_: Type): GotoExpression;
    return_(target: LabelTarget): GotoExpression;
    rightShift(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    rightShift(left: Expression, right: Expression): BinaryExpression;
    rightShiftAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    rightShiftAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    rightShiftAssign(left: Expression, right: Expression): BinaryExpression;
    runtimeVariables(variables: IEnumerable_1<ParameterExpression>): RuntimeVariablesExpression;
    runtimeVariables(variables: ParameterExpression[]): RuntimeVariablesExpression;
    subtract(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    subtract(left: Expression, right: Expression): BinaryExpression;
    subtractAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    subtractAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    subtractAssign(left: Expression, right: Expression): BinaryExpression;
    subtractAssignChecked(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    subtractAssignChecked(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    subtractAssignChecked(left: Expression, right: Expression): BinaryExpression;
    subtractChecked(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    subtractChecked(left: Expression, right: Expression): BinaryExpression;
    switch_(switchValue: Expression, defaultBody: Expression, cases: SwitchCase[]): SwitchExpression;
    switch_(switchValue: Expression, defaultBody: Expression, comparison: MethodInfo, cases: IEnumerable_1<SwitchCase>): SwitchExpression;
    switch_(switchValue: Expression, defaultBody: Expression, comparison: MethodInfo, cases: SwitchCase[]): SwitchExpression;
    switch_(switchValue: Expression, cases: SwitchCase[]): SwitchExpression;
    switch_(type_: Type, switchValue: Expression, defaultBody: Expression, comparison: MethodInfo, cases: IEnumerable_1<SwitchCase>): SwitchExpression;
    switch_(type_: Type, switchValue: Expression, defaultBody: Expression, comparison: MethodInfo, cases: SwitchCase[]): SwitchExpression;
    switchCase(body: Expression, testValues: IEnumerable_1<Expression>): SwitchCase;
    switchCase(body: Expression, testValues: Expression[]): SwitchCase;
    symbolDocument(fileName: string, language: Guid, languageVendor: Guid, documentType: Guid): SymbolDocumentInfo;
    symbolDocument(fileName: string, language: Guid, languageVendor: Guid): SymbolDocumentInfo;
    symbolDocument(fileName: string, language: Guid): SymbolDocumentInfo;
    symbolDocument(fileName: string): SymbolDocumentInfo;
    throw_(value: Expression, type_: Type): UnaryExpression;
    throw_(value: Expression): UnaryExpression;
    tryCatch(body: Expression, handlers: CatchBlock[]): TryExpression;
    tryCatchFinally(body: Expression, finally_: Expression, handlers: CatchBlock[]): TryExpression;
    tryFault(body: Expression, fault: Expression): TryExpression;
    tryFinally(body: Expression, finally_: Expression): TryExpression;
    tryGetActionType(typeArgs: Type[], actionType: { value: ref<Type> }): boolean;
    tryGetFuncType(typeArgs: Type[], funcType: { value: ref<Type> }): boolean;
    typeAs(expression: Expression, type_: Type): UnaryExpression;
    typeEqual(expression: Expression, type_: Type): TypeBinaryExpression;
    typeIs(expression: Expression, type_: Type): TypeBinaryExpression;
    unaryPlus(expression: Expression, method: MethodInfo): UnaryExpression;
    unaryPlus(expression: Expression): UnaryExpression;
    unbox(expression: Expression, type_: Type): UnaryExpression;
    variable(type_: Type, name: string): ParameterExpression;
    variable(type_: Type): ParameterExpression;
};


export type Expression = Expression$instance;

export interface Expression_1$instance<TDelegate> extends LambdaExpression {
    compile(): TDelegate;
    compile(preferInterpretation: boolean): TDelegate;
    compile(debugInfoGenerator: DebugInfoGenerator): TDelegate;
    compile(): Function;
    compile(preferInterpretation: boolean): Function;
    compile(debugInfoGenerator: DebugInfoGenerator): Function;
    update(body: Expression, parameters: IEnumerable_1<ParameterExpression>): Expression_1<TDelegate>;
}


export const Expression_1: {
    new<TDelegate>(): Expression_1$instance<TDelegate>;
};


export type Expression_1<TDelegate> = Expression_1$instance<TDelegate>;

export interface ExpressionVisitor$instance {
    visit(node: Expression): Expression;
    visit(nodes: ReadOnlyCollection_1<Expression>): ReadOnlyCollection_1<Expression>;
    visitAndConvert<T extends Expression>(node: T, callerName: string): T;
    visitAndConvert<T extends Expression>(nodes: ReadOnlyCollection_1<T>, callerName: string): ReadOnlyCollection_1<T>;
}


export const ExpressionVisitor: {
    visit<T>(nodes: ReadOnlyCollection_1<T>, elementVisitor: Func_2<T, T>): ReadOnlyCollection_1<T>;
};


export type ExpressionVisitor = ExpressionVisitor$instance;

export interface GotoExpression$instance extends Expression {
    readonly kind: GotoExpressionKind;
    readonly nodeType: ExpressionType;
    readonly target: LabelTarget;
    readonly type_: Type;
    readonly value: Expression;
    update(target: LabelTarget, value: Expression): GotoExpression;
}


export const GotoExpression: {
    new(): GotoExpression$instance;
};


export type GotoExpression = GotoExpression$instance;

export interface IndexExpression$instance extends Expression {
    readonly argumentCount: int;
    readonly arguments: ReadOnlyCollection_1<Expression>;
    readonly indexer: PropertyInfo;
    readonly nodeType: ExpressionType;
    readonly object_: Expression;
    readonly type_: Type;
    getArgument(index: int): Expression;
    update(object_: Expression, arguments: IEnumerable_1<Expression>): IndexExpression;
}


export const IndexExpression: {
    new(): IndexExpression$instance;
};


export interface __IndexExpression$views {
    As_IArgumentProvider(): IArgumentProvider$instance;
}

export interface IndexExpression$instance extends IArgumentProvider$instance {}

export type IndexExpression = IndexExpression$instance & __IndexExpression$views;


export interface InvocationExpression$instance extends Expression {
    readonly argumentCount: int;
    readonly arguments: ReadOnlyCollection_1<Expression>;
    readonly expression: Expression;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    getArgument(index: int): Expression;
    update(expression: Expression, arguments: IEnumerable_1<Expression>): InvocationExpression;
}


export const InvocationExpression: {
    new(): InvocationExpression$instance;
};


export interface __InvocationExpression$views {
    As_IArgumentProvider(): IArgumentProvider$instance;
}

export interface InvocationExpression$instance extends IArgumentProvider$instance {}

export type InvocationExpression = InvocationExpression$instance & __InvocationExpression$views;


export interface LabelExpression$instance extends Expression {
    readonly defaultValue: Expression;
    readonly nodeType: ExpressionType;
    readonly target: LabelTarget;
    readonly type_: Type;
    update(target: LabelTarget, defaultValue: Expression): LabelExpression;
}


export const LabelExpression: {
    new(): LabelExpression$instance;
};


export type LabelExpression = LabelExpression$instance;

export interface LabelTarget$instance {
    readonly name: string;
    readonly type_: Type;
    toString(): string;
}


export const LabelTarget: {
    new(): LabelTarget$instance;
};


export type LabelTarget = LabelTarget$instance;

export interface LambdaExpression$instance extends Expression {
    readonly body: Expression;
    readonly name: string;
    readonly nodeType: ExpressionType;
    readonly parameters: ReadOnlyCollection_1<ParameterExpression>;
    readonly returnType: Type;
    readonly tailCall: boolean;
    readonly type_: Type;
    compile(): Function;
    compile(preferInterpretation: boolean): Function;
    compile(debugInfoGenerator: DebugInfoGenerator): Function;
}


export const LambdaExpression: {
    readonly canCompileToIL: boolean;
    readonly canInterpret: boolean;
};


export type LambdaExpression = LambdaExpression$instance;

export interface ListInitExpression$instance extends Expression {
    readonly canReduce: boolean;
    readonly initializers: ReadOnlyCollection_1<ElementInit>;
    readonly newExpression: NewExpression;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    reduce(): Expression;
    update(newExpression: NewExpression, initializers: IEnumerable_1<ElementInit>): ListInitExpression;
}


export const ListInitExpression: {
    new(): ListInitExpression$instance;
};


export type ListInitExpression = ListInitExpression$instance;

export interface LoopExpression$instance extends Expression {
    readonly body: Expression;
    readonly breakLabel: LabelTarget;
    readonly continueLabel: LabelTarget;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    update(breakLabel: LabelTarget, continueLabel: LabelTarget, body: Expression): LoopExpression;
}


export const LoopExpression: {
    new(): LoopExpression$instance;
};


export type LoopExpression = LoopExpression$instance;

export interface MemberAssignment$instance extends MemberBinding {
    readonly expression: Expression;
    update(expression: Expression): MemberAssignment;
}


export const MemberAssignment: {
    new(): MemberAssignment$instance;
};


export type MemberAssignment = MemberAssignment$instance;

export interface MemberBinding$instance {
    readonly bindingType: MemberBindingType;
    readonly member: MemberInfo;
    toString(): string;
}


export const MemberBinding: {
};


export type MemberBinding = MemberBinding$instance;

export interface MemberExpression$instance extends Expression {
    readonly expression: Expression;
    readonly member: MemberInfo;
    readonly nodeType: ExpressionType;
    update(expression: Expression): MemberExpression;
}


export const MemberExpression: {
    new(): MemberExpression$instance;
};


export type MemberExpression = MemberExpression$instance;

export interface MemberInitExpression$instance extends Expression {
    readonly bindings: ReadOnlyCollection_1<MemberBinding>;
    readonly canReduce: boolean;
    readonly newExpression: NewExpression;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    reduce(): Expression;
    update(newExpression: NewExpression, bindings: IEnumerable_1<MemberBinding>): MemberInitExpression;
}


export const MemberInitExpression: {
    new(): MemberInitExpression$instance;
};


export type MemberInitExpression = MemberInitExpression$instance;

export interface MemberListBinding$instance extends MemberBinding {
    readonly initializers: ReadOnlyCollection_1<ElementInit>;
    update(initializers: IEnumerable_1<ElementInit>): MemberListBinding;
}


export const MemberListBinding: {
    new(): MemberListBinding$instance;
};


export type MemberListBinding = MemberListBinding$instance;

export interface MemberMemberBinding$instance extends MemberBinding {
    readonly bindings: ReadOnlyCollection_1<MemberBinding>;
    update(bindings: IEnumerable_1<MemberBinding>): MemberMemberBinding;
}


export const MemberMemberBinding: {
    new(): MemberMemberBinding$instance;
};


export type MemberMemberBinding = MemberMemberBinding$instance;

export interface MethodCallExpression$instance extends Expression {
    readonly argumentCount: int;
    readonly arguments: ReadOnlyCollection_1<Expression>;
    readonly method: MethodInfo;
    readonly nodeType: ExpressionType;
    readonly object_: Expression;
    readonly type_: Type;
    getArgument(index: int): Expression;
    update(object_: Expression, arguments: IEnumerable_1<Expression>): MethodCallExpression;
}


export const MethodCallExpression: {
    new(): MethodCallExpression$instance;
};


export interface __MethodCallExpression$views {
    As_IArgumentProvider(): IArgumentProvider$instance;
}

export interface MethodCallExpression$instance extends IArgumentProvider$instance {}

export type MethodCallExpression = MethodCallExpression$instance & __MethodCallExpression$views;


export interface NewArrayExpression$instance extends Expression {
    readonly expressions: ReadOnlyCollection_1<Expression>;
    readonly type_: Type;
    update(expressions: IEnumerable_1<Expression>): NewArrayExpression;
}


export const NewArrayExpression: {
    new(): NewArrayExpression$instance;
};


export type NewArrayExpression = NewArrayExpression$instance;

export interface NewExpression$instance extends Expression {
    readonly argumentCount: int;
    readonly arguments: ReadOnlyCollection_1<Expression>;
    readonly constructor_: ConstructorInfo;
    readonly members: ReadOnlyCollection_1<MemberInfo>;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    getArgument(index: int): Expression;
    update(arguments: IEnumerable_1<Expression>): NewExpression;
}


export const NewExpression: {
    new(): NewExpression$instance;
};


export interface __NewExpression$views {
    As_IArgumentProvider(): IArgumentProvider$instance;
}

export interface NewExpression$instance extends IArgumentProvider$instance {}

export type NewExpression = NewExpression$instance & __NewExpression$views;


export interface ParameterExpression$instance extends Expression {
    readonly isByRef: boolean;
    readonly name: string;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
}


export const ParameterExpression: {
    new(): ParameterExpression$instance;
};


export type ParameterExpression = ParameterExpression$instance;

export interface RuntimeVariablesExpression$instance extends Expression {
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    readonly variables: ReadOnlyCollection_1<ParameterExpression>;
    update(variables: IEnumerable_1<ParameterExpression>): RuntimeVariablesExpression;
}


export const RuntimeVariablesExpression: {
    new(): RuntimeVariablesExpression$instance;
};


export type RuntimeVariablesExpression = RuntimeVariablesExpression$instance;

export interface SwitchCase$instance {
    readonly body: Expression;
    readonly testValues: ReadOnlyCollection_1<Expression>;
    toString(): string;
    update(testValues: IEnumerable_1<Expression>, body: Expression): SwitchCase;
}


export const SwitchCase: {
    new(): SwitchCase$instance;
};


export type SwitchCase = SwitchCase$instance;

export interface SwitchExpression$instance extends Expression {
    readonly cases: ReadOnlyCollection_1<SwitchCase>;
    readonly comparison: MethodInfo;
    readonly defaultBody: Expression;
    readonly nodeType: ExpressionType;
    readonly switchValue: Expression;
    readonly type_: Type;
    update(switchValue: Expression, cases: IEnumerable_1<SwitchCase>, defaultBody: Expression): SwitchExpression;
}


export const SwitchExpression: {
    new(): SwitchExpression$instance;
};


export type SwitchExpression = SwitchExpression$instance;

export interface SymbolDocumentInfo$instance {
    readonly documentType: Guid;
    readonly fileName: string;
    readonly language: Guid;
    readonly languageVendor: Guid;
}


export const SymbolDocumentInfo: {
    new(): SymbolDocumentInfo$instance;
};


export type SymbolDocumentInfo = SymbolDocumentInfo$instance;

export interface TryExpression$instance extends Expression {
    readonly body: Expression;
    readonly fault: Expression;
    readonly finally_: Expression;
    readonly handlers: ReadOnlyCollection_1<CatchBlock>;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    update(body: Expression, handlers: IEnumerable_1<CatchBlock>, finally_: Expression, fault: Expression): TryExpression;
}


export const TryExpression: {
    new(): TryExpression$instance;
};


export type TryExpression = TryExpression$instance;

export interface TypeBinaryExpression$instance extends Expression {
    readonly expression: Expression;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    readonly typeOperand: Type;
    update(expression: Expression): TypeBinaryExpression;
}


export const TypeBinaryExpression: {
    new(): TypeBinaryExpression$instance;
};


export type TypeBinaryExpression = TypeBinaryExpression$instance;

export interface UnaryExpression$instance extends Expression {
    readonly canReduce: boolean;
    readonly isLifted: boolean;
    readonly isLiftedToNull: boolean;
    readonly method: MethodInfo;
    readonly nodeType: ExpressionType;
    readonly operand: Expression;
    readonly type_: Type;
    reduce(): Expression;
    update(operand: Expression): UnaryExpression;
}


export const UnaryExpression: {
    new(): UnaryExpression$instance;
};


export type UnaryExpression = UnaryExpression$instance;

