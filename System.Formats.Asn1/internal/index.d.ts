// Generated by tsbindgen - Architecture
// Namespace: System.Formats.Asn1
// Assembly: System.Formats.Asn1

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { BitArray, IDictionary } from "../../System.Collections/internal/index.js";
import type { BigInteger } from "../../System.Numerics/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_2, Boolean as ClrBoolean, Byte, Char, DateTimeOffset, Enum, Exception, Func_2, Func_3, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int32, Int64, ISpanFormattable, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, Span_1, String as ClrString, Type, TypeCode, UInt32, UInt64, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum AsnEncodingRules {
    BER = 0,
    CER = 1,
    DER = 2
}


export enum TagClass {
    universal = 0,
    application = 64,
    contextSpecific = 128,
    private_ = 192
}


export enum UniversalTagNumber {
    endOfContents = 0,
    boolean_ = 1,
    integer = 2,
    bitString = 3,
    octetString = 4,
    null_ = 5,
    objectIdentifier = 6,
    objectDescriptor = 7,
    external = 8,
    instanceOf = 8,
    real = 9,
    enumerated = 10,
    embedded = 11,
    utF8String = 12,
    relativeObjectIdentifier = 13,
    time = 14,
    sequence = 16,
    sequenceOf = 16,
    set_ = 17,
    setOf = 17,
    numericString = 18,
    printableString = 19,
    teletexString = 20,
    t61String = 20,
    videotexString = 21,
    iA5String = 22,
    utcTime = 23,
    generalizedTime = 24,
    graphicString = 25,
    visibleString = 26,
    isO646String = 26,
    generalString = 27,
    universalString = 28,
    unrestrictedCharacterString = 29,
    bmpString = 30,
    date = 31,
    timeOfDay = 32,
    dateTime = 33,
    duration = 34,
    objectIdentifierIRI = 35,
    relativeObjectIdentifierIRI = 36
}


export interface Asn1Tag$instance {
    readonly isConstructed: boolean;
    readonly tagClass: TagClass;
    readonly tagValue: int;
    asConstructed(): Asn1Tag;
    asPrimitive(): Asn1Tag;
    calculateEncodedSize(): int;
    encode(destination: Span_1<CLROf<byte>>): int;
    equals(other: Asn1Tag): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    hasSameClassAndValue(other: Asn1Tag): boolean;
    toString(): string;
    tryEncode(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export const Asn1Tag: {
    new(universalTagNumber: UniversalTagNumber, isConstructed: boolean): Asn1Tag$instance;
    new(tagClass: TagClass, tagValue: int, isConstructed: boolean): Asn1Tag$instance;
    readonly boolean_: Asn1Tag;
    readonly integer: Asn1Tag;
    readonly primitiveBitString: Asn1Tag;
    readonly constructedBitString: Asn1Tag;
    readonly primitiveOctetString: Asn1Tag;
    readonly constructedOctetString: Asn1Tag;
    readonly null_: Asn1Tag;
    readonly objectIdentifier: Asn1Tag;
    readonly enumerated: Asn1Tag;
    readonly sequence: Asn1Tag;
    readonly setOf: Asn1Tag;
    readonly utcTime: Asn1Tag;
    readonly generalizedTime: Asn1Tag;
    decode(source: ReadOnlySpan_1<CLROf<byte>>, bytesConsumed: { value: ref<int> }): Asn1Tag;
    tryDecode(source: ReadOnlySpan_1<CLROf<byte>>, tag: { value: ref<Asn1Tag> }, bytesConsumed: { value: ref<int> }): boolean;
};


export interface __Asn1Tag$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Asn1Tag>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Asn1Tag): boolean;
}

export type Asn1Tag = Asn1Tag$instance & __Asn1Tag$views;


export interface AsnReaderOptions$instance {
    skipSetSortOrderVerification: boolean;
    utcTimeTwoDigitYearMax: int;
}


export const AsnReaderOptions: {
    new(): AsnReaderOptions$instance;
};


export type AsnReaderOptions = AsnReaderOptions$instance;

export interface AsnWriter_Scope$instance {
    dispose(): void;
}


export const AsnWriter_Scope: {
    new(): AsnWriter_Scope$instance;
};


export interface __AsnWriter_Scope$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface AsnWriter_Scope$instance extends System_Internal.IDisposable$instance {}

export type AsnWriter_Scope = AsnWriter_Scope$instance & __AsnWriter_Scope$views;


export interface AsnContentException$instance extends Exception {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const AsnContentException: {
    new(): AsnContentException$instance;
    new(message: string): AsnContentException$instance;
    new(message: string, inner: Exception): AsnContentException$instance;
};


export interface __AsnContentException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AsnContentException = AsnContentException$instance & __AsnContentException$views;


export interface AsnReader$instance {
    readonly hasData: boolean;
    readonly ruleSet: AsnEncodingRules;
    clone(): AsnReader;
    peekContentBytes(): ReadOnlyMemory_1<CLROf<byte>>;
    peekEncodedValue(): ReadOnlyMemory_1<CLROf<byte>>;
    peekTag(): Asn1Tag;
    readBitString(unusedBitCount: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): byte[];
    readBoolean(expectedTag?: Nullable_1<Asn1Tag>): boolean;
    readCharacterString(encodingType: UniversalTagNumber, expectedTag?: Nullable_1<Asn1Tag>): string;
    readEncodedValue(): ReadOnlyMemory_1<CLROf<byte>>;
    readEnumeratedBytes(expectedTag?: Nullable_1<Asn1Tag>): ReadOnlyMemory_1<CLROf<byte>>;
    readEnumeratedValue<TEnum extends number>(expectedTag?: Nullable_1<Asn1Tag>): TEnum;
    readEnumeratedValue(enumType: Type, expectedTag?: Nullable_1<Asn1Tag>): number;
    readGeneralizedTime(expectedTag?: Nullable_1<Asn1Tag>): DateTimeOffset;
    readInteger(expectedTag?: Nullable_1<Asn1Tag>): BigInteger;
    readIntegerBytes(expectedTag?: Nullable_1<Asn1Tag>): ReadOnlyMemory_1<CLROf<byte>>;
    readNamedBitList(expectedTag?: Nullable_1<Asn1Tag>): BitArray;
    readNamedBitListValue<TFlagsEnum extends number>(expectedTag?: Nullable_1<Asn1Tag>): TFlagsEnum;
    readNamedBitListValue(flagsEnumType: Type, expectedTag?: Nullable_1<Asn1Tag>): number;
    readNull(expectedTag?: Nullable_1<Asn1Tag>): void;
    readObjectIdentifier(expectedTag?: Nullable_1<Asn1Tag>): string;
    readOctetString(expectedTag?: Nullable_1<Asn1Tag>): byte[];
    readSequence(expectedTag?: Nullable_1<Asn1Tag>): AsnReader;
    readSetOf(expectedTag?: Nullable_1<Asn1Tag>): AsnReader;
    readSetOf(skipSortOrderValidation: boolean, expectedTag?: Nullable_1<Asn1Tag>): AsnReader;
    readUtcTime(expectedTag?: Nullable_1<Asn1Tag>): DateTimeOffset;
    readUtcTime(twoDigitYearMax: int, expectedTag?: Nullable_1<Asn1Tag>): DateTimeOffset;
    throwIfNotEmpty(): void;
    tryReadBitString(destination: Span_1<CLROf<byte>>, unusedBitCount: { value: ref<int> }, bytesWritten: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    tryReadCharacterString(destination: Span_1<CLROf<char>>, encodingType: UniversalTagNumber, charsWritten: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    tryReadCharacterStringBytes(destination: Span_1<CLROf<byte>>, expectedTag: Asn1Tag, bytesWritten: { value: ref<int> }): boolean;
    tryReadInt32(value: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    tryReadInt64(value: { value: ref<long> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    tryReadOctetString(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    tryReadPrimitiveBitString(unusedBitCount: { value: ref<int> }, value: { value: ref<ReadOnlyMemory_1<CLROf<byte>>> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    tryReadPrimitiveCharacterStringBytes(expectedTag: Asn1Tag, contents: { value: ref<ReadOnlyMemory_1<CLROf<byte>>> }): boolean;
    tryReadPrimitiveOctetString(contents: { value: ref<ReadOnlyMemory_1<CLROf<byte>>> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    tryReadUInt32(value: { value: ref<uint> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    tryReadUInt64(value: { value: ref<ulong> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
}


export const AsnReader: {
    new(data: ReadOnlyMemory_1<CLROf<byte>>, ruleSet: AsnEncodingRules, options: AsnReaderOptions): AsnReader$instance;
};


export type AsnReader = AsnReader$instance;

export interface AsnWriter$instance {
    readonly ruleSet: AsnEncodingRules;
    copyTo(destination: AsnWriter): void;
    encode(destination: Span_1<CLROf<byte>>): int;
    encode(): byte[];
    encode<TReturn>(encodeCallback: Func_2<ReadOnlySpan_1<CLROf<byte>>, TReturn>): TReturn;
    encode<TState, TReturn>(state: TState, encodeCallback: Func_3<TState, ReadOnlySpan_1<CLROf<byte>>, TReturn>): TReturn;
    encode<TState>(state: TState, encodeCallback: Action_2<TState, ReadOnlySpan_1<CLROf<byte>>>): void;
    encodedValueEquals(other: ReadOnlySpan_1<CLROf<byte>>): boolean;
    encodedValueEquals(other: AsnWriter): boolean;
    getEncodedLength(): int;
    popOctetString(tag?: Nullable_1<Asn1Tag>): void;
    popSequence(tag?: Nullable_1<Asn1Tag>): void;
    popSetOf(tag?: Nullable_1<Asn1Tag>): void;
    pushOctetString(tag?: Nullable_1<Asn1Tag>): AsnWriter_Scope;
    pushSequence(tag?: Nullable_1<Asn1Tag>): AsnWriter_Scope;
    pushSetOf(tag?: Nullable_1<Asn1Tag>): AsnWriter_Scope;
    reset(): void;
    tryEncode(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    writeBitString(value: ReadOnlySpan_1<CLROf<byte>>, unusedBitCount?: int, tag?: Nullable_1<Asn1Tag>): void;
    writeBoolean(value: boolean, tag?: Nullable_1<Asn1Tag>): void;
    writeCharacterString(encodingType: UniversalTagNumber, value: string, tag?: Nullable_1<Asn1Tag>): void;
    writeCharacterString(encodingType: UniversalTagNumber, str: ReadOnlySpan_1<CLROf<char>>, tag?: Nullable_1<Asn1Tag>): void;
    writeEncodedValue(value: ReadOnlySpan_1<CLROf<byte>>): void;
    writeEnumeratedValue(value: number, tag?: Nullable_1<Asn1Tag>): void;
    writeEnumeratedValue<TEnum extends number>(value: TEnum, tag?: Nullable_1<Asn1Tag>): void;
    writeGeneralizedTime(value: DateTimeOffset, omitFractionalSeconds?: boolean, tag?: Nullable_1<Asn1Tag>): void;
    writeInteger(value: long, tag?: Nullable_1<Asn1Tag>): void;
    writeInteger(value: ulong, tag?: Nullable_1<Asn1Tag>): void;
    writeInteger(value: BigInteger, tag?: Nullable_1<Asn1Tag>): void;
    writeInteger(value: ReadOnlySpan_1<CLROf<byte>>, tag?: Nullable_1<Asn1Tag>): void;
    writeIntegerUnsigned(value: ReadOnlySpan_1<CLROf<byte>>, tag?: Nullable_1<Asn1Tag>): void;
    writeNamedBitList(value: number, tag?: Nullable_1<Asn1Tag>): void;
    writeNamedBitList<TEnum extends number>(value: TEnum, tag?: Nullable_1<Asn1Tag>): void;
    writeNamedBitList(value: BitArray, tag?: Nullable_1<Asn1Tag>): void;
    writeNull(tag?: Nullable_1<Asn1Tag>): void;
    writeObjectIdentifier(oidValue: string, tag?: Nullable_1<Asn1Tag>): void;
    writeObjectIdentifier(oidValue: ReadOnlySpan_1<CLROf<char>>, tag?: Nullable_1<Asn1Tag>): void;
    writeOctetString(value: ReadOnlySpan_1<CLROf<byte>>, tag?: Nullable_1<Asn1Tag>): void;
    writeUtcTime(value: DateTimeOffset, tag?: Nullable_1<Asn1Tag>): void;
    writeUtcTime(value: DateTimeOffset, twoDigitYearMax: int, tag?: Nullable_1<Asn1Tag>): void;
}


export const AsnWriter: {
    new(ruleSet: AsnEncodingRules): AsnWriter$instance;
    new(ruleSet: AsnEncodingRules, initialCapacity: int): AsnWriter$instance;
};


export type AsnWriter = AsnWriter$instance;

export abstract class AsnDecoder$instance {
    static decodeLength(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: ref<int> }): Nullable_1<CLROf<int>>;
    static readBitString(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, unusedBitCount: { value: ref<int> }, bytesConsumed: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): byte[];
    static readBoolean(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static readCharacterString(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, encodingType: UniversalTagNumber, bytesConsumed: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): string;
    static readEncodedValue(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, contentOffset: { value: ref<int> }, contentLength: { value: ref<int> }, bytesConsumed: { value: ref<int> }): Asn1Tag;
    static readEnumeratedBytes(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): ReadOnlySpan_1<CLROf<byte>>;
    static readEnumeratedValue<TEnum extends number>(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): TEnum;
    static readEnumeratedValue(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, enumType: Type, bytesConsumed: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): number;
    static readGeneralizedTime(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): DateTimeOffset;
    static readInteger(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): BigInteger;
    static readIntegerBytes(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): ReadOnlySpan_1<CLROf<byte>>;
    static readNamedBitList(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): BitArray;
    static readNamedBitListValue<TFlagsEnum extends number>(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): TFlagsEnum;
    static readNamedBitListValue(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, flagsEnumType: Type, bytesConsumed: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): number;
    static readNull(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): void;
    static readObjectIdentifier(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): string;
    static readOctetString(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): byte[];
    static readSequence(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, contentOffset: { value: ref<int> }, contentLength: { value: ref<int> }, bytesConsumed: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): void;
    static readSetOf(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, contentOffset: { value: ref<int> }, contentLength: { value: ref<int> }, bytesConsumed: { value: ref<int> }, skipSortOrderValidation?: boolean, expectedTag?: Nullable_1<Asn1Tag>): void;
    static readUtcTime(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: ref<int> }, twoDigitYearMax?: int, expectedTag?: Nullable_1<Asn1Tag>): DateTimeOffset;
    static tryDecodeLength(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, decodedLength: { value: ref<Nullable_1<CLROf<int>>> }, bytesConsumed: { value: ref<int> }): boolean;
    static tryReadBitString(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, ruleSet: AsnEncodingRules, unusedBitCount: { value: ref<int> }, bytesConsumed: { value: ref<int> }, bytesWritten: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static tryReadCharacterString(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<char>>, ruleSet: AsnEncodingRules, encodingType: UniversalTagNumber, bytesConsumed: { value: ref<int> }, charsWritten: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static tryReadCharacterStringBytes(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, ruleSet: AsnEncodingRules, expectedTag: Asn1Tag, bytesConsumed: { value: ref<int> }, bytesWritten: { value: ref<int> }): boolean;
    static tryReadEncodedValue(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, tag: { value: ref<Asn1Tag> }, contentOffset: { value: ref<int> }, contentLength: { value: ref<int> }, bytesConsumed: { value: ref<int> }): boolean;
    static tryReadInt32(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, value: { value: ref<int> }, bytesConsumed: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static tryReadInt64(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, value: { value: ref<long> }, bytesConsumed: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static tryReadOctetString(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: ref<int> }, bytesWritten: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static tryReadPrimitiveBitString(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, unusedBitCount: { value: ref<int> }, value: { value: ref<ReadOnlySpan_1<CLROf<byte>>> }, bytesConsumed: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static tryReadPrimitiveCharacterStringBytes(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, expectedTag: Asn1Tag, value: { value: ref<ReadOnlySpan_1<CLROf<byte>>> }, bytesConsumed: { value: ref<int> }): boolean;
    static tryReadPrimitiveOctetString(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, value: { value: ref<ReadOnlySpan_1<CLROf<byte>>> }, bytesConsumed: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static tryReadUInt32(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, value: { value: ref<uint> }, bytesConsumed: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static tryReadUInt64(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, value: { value: ref<ulong> }, bytesConsumed: { value: ref<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
}


export type AsnDecoder = AsnDecoder$instance;

