// Generated by tsbindgen - Architecture
// Namespace: System.Collections.Generic
// Assembly: System.Collections, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { ReadOnlyCollection_1, ReadOnlyDictionary_2, ReadOnlySet_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { DictionaryEntry, ICollection, IComparer, IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator, IEqualityComparer, IList } from "../../System.Collections/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Array as ClrArray, Boolean as ClrBoolean, Byte, Comparison_1, Converter_2, Enum, Exception, Func_2, Func_3, IAsyncDisposable, IComparable_1, IDisposable, IEquatable_1, Int32, Nullable_1, Object as ClrObject, Predicate_1, ReadOnlySpan_1, Span_1, String as ClrString, SystemException, Type, ValueTuple_2, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface IAlternateEqualityComparer_2$instance<TAlternate, T> {
    create(alternate: TAlternate): T;
    equals(alternate: TAlternate, other: T): boolean;
    getHashCode(alternate: TAlternate): int;
}


export type IAlternateEqualityComparer_2<TAlternate, T> = IAlternateEqualityComparer_2$instance<TAlternate, T>;

export interface IAsyncEnumerable_1$instance<T> {
    getAsyncEnumerator(cancellationToken?: CancellationToken): IAsyncEnumerator_1<T>;
}


export type IAsyncEnumerable_1<T> = IAsyncEnumerable_1$instance<T>;

export interface IAsyncEnumerator_1$instance<T> extends IAsyncDisposable {
    readonly current: T;
    disposeAsync(): ValueTask;
    moveNextAsync(): ValueTask_1<CLROf<boolean>>;
}


export interface IAsyncEnumerator_1$instance<T> extends System_Internal.IAsyncDisposable$instance {}

export type IAsyncEnumerator_1<T> = IAsyncEnumerator_1$instance<T>;

export interface ICollection_1$instance<T> extends IEnumerable_1<T>, IEnumerable {
    readonly count: int;
    readonly isReadOnly: boolean;
    add(item: T): void;
    clear(): void;
    contains(item: T): boolean;
    copyTo(array: T[], arrayIndex: int): void;
    getEnumerator(): IEnumerator_1<T>;
    getEnumerator(): IEnumerator;
}


export type ICollection_1<T> = ICollection_1$instance<T>;

export interface IComparer_1$instance<T> {
    compare(x: T, y: T): int;
}


export type IComparer_1<T> = IComparer_1$instance<T>;

export interface IDictionary_2$instance<TKey, TValue> extends ICollection_1<KeyValuePair_2<TKey, TValue>>, IEnumerable_1<KeyValuePair_2<TKey, TValue>>, IEnumerable {
    item: TValue;
    readonly keys: ICollection_1<TKey>;
    readonly values: ICollection_1<TValue>;
    readonly count: int;
    readonly isReadOnly: boolean;
    add(item: KeyValuePair_2<TKey, TValue>): void;
    add(key: TKey, value: TValue): void;
    clear(): void;
    contains(item: KeyValuePair_2<TKey, TValue>): boolean;
    containsKey(key: TKey): boolean;
    copyTo(array: KeyValuePair_2<TKey, TValue>[], arrayIndex: int): void;
    getEnumerator(): IEnumerator_1<KeyValuePair_2<TKey, TValue>>;
    getEnumerator(): IEnumerator;
    tryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
}


export type IDictionary_2<TKey, TValue> = IDictionary_2$instance<TKey, TValue>;

export interface IEnumerable_1$instance<T> extends IEnumerable {
    getEnumerator(): IEnumerator_1<T>;
    getEnumerator(): IEnumerator;
}


export type IEnumerable_1<T> = IEnumerable_1$instance<T>;

export interface IEnumerator_1$instance<T> extends IDisposable, IEnumerator {
    readonly current: T;
    dispose(): void;
    moveNext(): boolean;
}


export interface IEnumerator_1$instance<T> extends System_Internal.IDisposable$instance {}

export type IEnumerator_1<T> = IEnumerator_1$instance<T>;

export interface IEqualityComparer_1$instance<T> {
    equals(x: T, y: T): boolean;
    getHashCode(obj: T): int;
}


export type IEqualityComparer_1<T> = IEqualityComparer_1$instance<T>;

export interface IList_1$instance<T> extends ICollection_1<T>, IEnumerable_1<T>, IEnumerable {
    item: T;
    readonly count: int;
    readonly isReadOnly: boolean;
    add(item: T): void;
    clear(): void;
    contains(item: T): boolean;
    copyTo(array: T[], arrayIndex: int): void;
    getEnumerator(): IEnumerator_1<T>;
    getEnumerator(): IEnumerator;
    indexOf(item: T): int;
    insert(index: int, item: T): void;
    removeAt(index: int): void;
}


export type IList_1<T> = IList_1$instance<T>;

export interface IReadOnlyCollection_1$instance<T> extends IEnumerable_1<T>, IEnumerable {
    readonly count: int;
    getEnumerator(): IEnumerator_1<T>;
    getEnumerator(): IEnumerator;
}


export type IReadOnlyCollection_1<T> = IReadOnlyCollection_1$instance<T>;

export interface IReadOnlyDictionary_2$instance<TKey, TValue> extends IReadOnlyCollection_1<KeyValuePair_2<TKey, TValue>>, IEnumerable_1<KeyValuePair_2<TKey, TValue>>, IEnumerable {
    readonly item: TValue;
    readonly keys: IEnumerable_1<TKey>;
    readonly values: IEnumerable_1<TValue>;
    readonly count: int;
    containsKey(key: TKey): boolean;
    getEnumerator(): IEnumerator_1<KeyValuePair_2<TKey, TValue>>;
    getEnumerator(): IEnumerator;
    tryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
}


export type IReadOnlyDictionary_2<TKey, TValue> = IReadOnlyDictionary_2$instance<TKey, TValue>;

export interface IReadOnlyList_1$instance<T> extends IReadOnlyCollection_1<T>, IEnumerable_1<T>, IEnumerable {
    readonly item: T;
    readonly count: int;
    getEnumerator(): IEnumerator_1<T>;
    getEnumerator(): IEnumerator;
}


export type IReadOnlyList_1<T> = IReadOnlyList_1$instance<T>;

export interface IReadOnlySet_1$instance<T> extends IReadOnlyCollection_1<T>, IEnumerable_1<T>, IEnumerable {
    readonly count: int;
    contains(item: T): boolean;
    getEnumerator(): IEnumerator_1<T>;
    getEnumerator(): IEnumerator;
    isProperSubsetOf(other: IEnumerable_1<T>): boolean;
}


export type IReadOnlySet_1<T> = IReadOnlySet_1$instance<T>;

export interface ISet_1$instance<T> extends ICollection_1<T>, IEnumerable_1<T>, IEnumerable {
    readonly count: int;
    readonly isReadOnly: boolean;
    add(item: T): void;
    add(item: T): boolean;
    clear(): void;
    copyTo(array: T[], arrayIndex: int): void;
    getEnumerator(): IEnumerator_1<T>;
    getEnumerator(): IEnumerator;
    isSubsetOf(other: IEnumerable_1<T>): boolean;
    unionWith(other: IEnumerable_1<T>): void;
}


export type ISet_1<T> = ISet_1$instance<T>;

export interface Dictionary_2_AlternateLookup_1$instance<TKey, TValue, TAlternateKey> {
    readonly dictionary: Dictionary_2<TKey, TValue>;
    item: TValue;
    containsKey(key: TAlternateKey): boolean;
    remove(key: TAlternateKey): boolean;
    remove(key: TAlternateKey, actualKey: { value: ref<TKey> }, value: { value: ref<TValue> }): boolean;
    tryAdd(key: TAlternateKey, value: TValue): boolean;
    tryGetValue(key: TAlternateKey, value: { value: ref<TValue> }): boolean;
    tryGetValue(key: TAlternateKey, actualKey: { value: ref<TKey> }, value: { value: ref<TValue> }): boolean;
}


export const Dictionary_2_AlternateLookup_1: {
    new<TKey, TValue, TAlternateKey>(): Dictionary_2_AlternateLookup_1$instance<TKey, TValue, TAlternateKey>;
};


export type Dictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey> = Dictionary_2_AlternateLookup_1$instance<TKey, TValue, TAlternateKey>;

export interface Dictionary_2_Enumerator$instance<TKey, TValue> extends IDisposable {
    readonly current: KeyValuePair_2<TKey, TValue>;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const Dictionary_2_Enumerator: {
    new<TKey, TValue>(): Dictionary_2_Enumerator$instance<TKey, TValue>;
};


export interface __Dictionary_2_Enumerator$views<TKey, TValue> {
    As_IEnumerator_1(): IEnumerator_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionaryEnumerator(): System_Collections_Internal.IDictionaryEnumerator$instance;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type Dictionary_2_Enumerator<TKey, TValue> = Dictionary_2_Enumerator$instance<TKey, TValue> & __Dictionary_2_Enumerator$views<TKey, TValue>;


export interface Dictionary_2_KeyCollection_Enumerator$instance<TKey, TValue> extends IDisposable {
    readonly current: TKey;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const Dictionary_2_KeyCollection_Enumerator: {
    new<TKey, TValue>(): Dictionary_2_KeyCollection_Enumerator$instance<TKey, TValue>;
};


export interface __Dictionary_2_KeyCollection_Enumerator$views<TKey, TValue> {
    As_IEnumerator_1(): IEnumerator_1$instance<TKey>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type Dictionary_2_KeyCollection_Enumerator<TKey, TValue> = Dictionary_2_KeyCollection_Enumerator$instance<TKey, TValue> & __Dictionary_2_KeyCollection_Enumerator$views<TKey, TValue>;


export interface Dictionary_2_ValueCollection_Enumerator$instance<TKey, TValue> extends IDisposable {
    readonly current: TValue;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const Dictionary_2_ValueCollection_Enumerator: {
    new<TKey, TValue>(): Dictionary_2_ValueCollection_Enumerator$instance<TKey, TValue>;
};


export interface __Dictionary_2_ValueCollection_Enumerator$views<TKey, TValue> {
    As_IEnumerator_1(): IEnumerator_1$instance<TValue>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type Dictionary_2_ValueCollection_Enumerator<TKey, TValue> = Dictionary_2_ValueCollection_Enumerator$instance<TKey, TValue> & __Dictionary_2_ValueCollection_Enumerator$views<TKey, TValue>;


export interface HashSet_1_AlternateLookup_1$instance<T, TAlternate> {
    readonly set_: HashSet_1<T>;
    add(item: TAlternate): boolean;
    contains(item: TAlternate): boolean;
    remove(item: TAlternate): boolean;
    tryGetValue(equalValue: TAlternate, actualValue: { value: ref<T> }): boolean;
}


export const HashSet_1_AlternateLookup_1: {
    new<T, TAlternate>(): HashSet_1_AlternateLookup_1$instance<T, TAlternate>;
};


export type HashSet_1_AlternateLookup_1<T, TAlternate> = HashSet_1_AlternateLookup_1$instance<T, TAlternate>;

export interface HashSet_1_Enumerator$instance<T> extends IDisposable {
    readonly current: T;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const HashSet_1_Enumerator: {
    new<T>(): HashSet_1_Enumerator$instance<T>;
};


export interface __HashSet_1_Enumerator$views<T> {
    As_IEnumerator_1(): IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type HashSet_1_Enumerator<T> = HashSet_1_Enumerator$instance<T> & __HashSet_1_Enumerator$views<T>;


export interface KeyValuePair_2$instance<TKey, TValue> {
    readonly key: TKey;
    readonly value: TValue;
    deconstruct(key: { value: ref<TKey> }, value: { value: ref<TValue> }): void;
    toString(): string;
}


export const KeyValuePair_2: {
    new<TKey, TValue>(key: TKey, value: TValue): KeyValuePair_2$instance<TKey, TValue>;
};


export type KeyValuePair_2<TKey, TValue> = KeyValuePair_2$instance<TKey, TValue>;

export interface LinkedList_1_Enumerator$instance<T> extends IDisposable {
    readonly current: T;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const LinkedList_1_Enumerator: {
    new<T>(): LinkedList_1_Enumerator$instance<T>;
};


export interface __LinkedList_1_Enumerator$views<T> {
    As_IEnumerator_1(): IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface LinkedList_1_Enumerator$instance<T> extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type LinkedList_1_Enumerator<T> = LinkedList_1_Enumerator$instance<T> & __LinkedList_1_Enumerator$views<T>;


export interface List_1_Enumerator$instance<T> extends IDisposable {
    readonly current: T;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const List_1_Enumerator: {
    new<T>(): List_1_Enumerator$instance<T>;
};


export interface __List_1_Enumerator$views<T> {
    As_IEnumerator_1(): IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type List_1_Enumerator<T> = List_1_Enumerator$instance<T> & __List_1_Enumerator$views<T>;


export interface OrderedDictionary_2_Enumerator$instance<TKey, TValue> {
    readonly current: KeyValuePair_2<TKey, TValue>;
    moveNext(): boolean;
    reset(): void;
}


export const OrderedDictionary_2_Enumerator: {
    new<TKey, TValue>(): OrderedDictionary_2_Enumerator$instance<TKey, TValue>;
};


export interface __OrderedDictionary_2_Enumerator$views<TKey, TValue> {
    As_IEnumerator_1(): IEnumerator_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionaryEnumerator(): System_Collections_Internal.IDictionaryEnumerator$instance;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type OrderedDictionary_2_Enumerator<TKey, TValue> = OrderedDictionary_2_Enumerator$instance<TKey, TValue> & __OrderedDictionary_2_Enumerator$views<TKey, TValue>;


export interface OrderedDictionary_2_KeyCollection_Enumerator$instance<TKey, TValue> {
    readonly current: TKey;
    moveNext(): boolean;
    reset(): void;
}


export const OrderedDictionary_2_KeyCollection_Enumerator: {
    new<TKey, TValue>(): OrderedDictionary_2_KeyCollection_Enumerator$instance<TKey, TValue>;
};


export interface __OrderedDictionary_2_KeyCollection_Enumerator$views<TKey, TValue> {
    As_IEnumerator_1(): IEnumerator_1$instance<TKey>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type OrderedDictionary_2_KeyCollection_Enumerator<TKey, TValue> = OrderedDictionary_2_KeyCollection_Enumerator$instance<TKey, TValue> & __OrderedDictionary_2_KeyCollection_Enumerator$views<TKey, TValue>;


export interface OrderedDictionary_2_ValueCollection_Enumerator$instance<TKey, TValue> {
    readonly current: TValue;
    moveNext(): boolean;
    reset(): void;
}


export const OrderedDictionary_2_ValueCollection_Enumerator: {
    new<TKey, TValue>(): OrderedDictionary_2_ValueCollection_Enumerator$instance<TKey, TValue>;
};


export interface __OrderedDictionary_2_ValueCollection_Enumerator$views<TKey, TValue> {
    As_IEnumerator_1(): IEnumerator_1$instance<TValue>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type OrderedDictionary_2_ValueCollection_Enumerator<TKey, TValue> = OrderedDictionary_2_ValueCollection_Enumerator$instance<TKey, TValue> & __OrderedDictionary_2_ValueCollection_Enumerator$views<TKey, TValue>;


export interface PriorityQueue_2_UnorderedItemsCollection_Enumerator$instance<TElement, TPriority> extends IDisposable {
    readonly current: ValueTuple_2<TElement, TPriority>;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const PriorityQueue_2_UnorderedItemsCollection_Enumerator: {
    new<TElement, TPriority>(): PriorityQueue_2_UnorderedItemsCollection_Enumerator$instance<TElement, TPriority>;
};


export interface __PriorityQueue_2_UnorderedItemsCollection_Enumerator$views<TElement, TPriority> {
    As_IEnumerator_1(): IEnumerator_1$instance<ValueTuple_2<TElement, TPriority>>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type PriorityQueue_2_UnorderedItemsCollection_Enumerator<TElement, TPriority> = PriorityQueue_2_UnorderedItemsCollection_Enumerator$instance<TElement, TPriority> & __PriorityQueue_2_UnorderedItemsCollection_Enumerator$views<TElement, TPriority>;


export interface Queue_1_Enumerator$instance<T> extends IDisposable {
    readonly current: T;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const Queue_1_Enumerator: {
    new<T>(): Queue_1_Enumerator$instance<T>;
};


export interface __Queue_1_Enumerator$views<T> {
    As_IEnumerator_1(): IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type Queue_1_Enumerator<T> = Queue_1_Enumerator$instance<T> & __Queue_1_Enumerator$views<T>;


export interface SortedDictionary_2_Enumerator$instance<TKey, TValue> extends IDisposable {
    readonly current: KeyValuePair_2<TKey, TValue>;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const SortedDictionary_2_Enumerator: {
    new<TKey, TValue>(): SortedDictionary_2_Enumerator$instance<TKey, TValue>;
};


export interface __SortedDictionary_2_Enumerator$views<TKey, TValue> {
    As_IEnumerator_1(): IEnumerator_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionaryEnumerator(): System_Collections_Internal.IDictionaryEnumerator$instance;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type SortedDictionary_2_Enumerator<TKey, TValue> = SortedDictionary_2_Enumerator$instance<TKey, TValue> & __SortedDictionary_2_Enumerator$views<TKey, TValue>;


export interface SortedDictionary_2_KeyCollection_Enumerator$instance<TKey, TValue> extends IDisposable {
    readonly current: TKey;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const SortedDictionary_2_KeyCollection_Enumerator: {
    new<TKey, TValue>(): SortedDictionary_2_KeyCollection_Enumerator$instance<TKey, TValue>;
};


export interface __SortedDictionary_2_KeyCollection_Enumerator$views<TKey, TValue> {
    As_IEnumerator_1(): IEnumerator_1$instance<TKey>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type SortedDictionary_2_KeyCollection_Enumerator<TKey, TValue> = SortedDictionary_2_KeyCollection_Enumerator$instance<TKey, TValue> & __SortedDictionary_2_KeyCollection_Enumerator$views<TKey, TValue>;


export interface SortedDictionary_2_ValueCollection_Enumerator$instance<TKey, TValue> extends IDisposable {
    readonly current: TValue;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const SortedDictionary_2_ValueCollection_Enumerator: {
    new<TKey, TValue>(): SortedDictionary_2_ValueCollection_Enumerator$instance<TKey, TValue>;
};


export interface __SortedDictionary_2_ValueCollection_Enumerator$views<TKey, TValue> {
    As_IEnumerator_1(): IEnumerator_1$instance<TValue>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type SortedDictionary_2_ValueCollection_Enumerator<TKey, TValue> = SortedDictionary_2_ValueCollection_Enumerator$instance<TKey, TValue> & __SortedDictionary_2_ValueCollection_Enumerator$views<TKey, TValue>;


export interface SortedSet_1_Enumerator$instance<T> extends IDisposable {
    readonly current: T;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const SortedSet_1_Enumerator: {
    new<T>(): SortedSet_1_Enumerator$instance<T>;
};


export interface __SortedSet_1_Enumerator$views<T> {
    As_IEnumerator_1(): IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface SortedSet_1_Enumerator$instance<T> extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type SortedSet_1_Enumerator<T> = SortedSet_1_Enumerator$instance<T> & __SortedSet_1_Enumerator$views<T>;


export interface Stack_1_Enumerator$instance<T> extends IDisposable {
    readonly current: T;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const Stack_1_Enumerator: {
    new<T>(): Stack_1_Enumerator$instance<T>;
};


export interface __Stack_1_Enumerator$views<T> {
    As_IEnumerator_1(): IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type Stack_1_Enumerator<T> = Stack_1_Enumerator$instance<T> & __Stack_1_Enumerator$views<T>;


export interface ByteEqualityComparer$instance extends EqualityComparer_1$instance<CLROf<byte>> {
    equals(x: unknown, y: unknown): boolean;
    getHashCode(obj: unknown): int;
}


export const ByteEqualityComparer: {
    new(): ByteEqualityComparer$instance;
};


export interface __ByteEqualityComparer$views {
    As_IEqualityComparer_1(): IEqualityComparer_1$instance<CLROf<byte>>;
    As_IEqualityComparer(): System_Collections_Internal.IEqualityComparer$instance;
}

export type ByteEqualityComparer = ByteEqualityComparer$instance & __ByteEqualityComparer$views;


export interface Comparer_1$instance<T> {
    compare(x: T, y: T): int;
}


export const Comparer_1: {
    readonly default_: unknown;
    create<T>(comparison: Comparison_1<T>): Comparer_1<T>;
};


export interface __Comparer_1$views<T> {
    As_IComparer_1(): IComparer_1$instance<T>;
    As_IComparer(): System_Collections_Internal.IComparer$instance;
}

export interface Comparer_1$instance<T> extends IComparer_1$instance<T> {}

export type Comparer_1<T> = Comparer_1$instance<T> & __Comparer_1$views<T>;


export interface Dictionary_2$instance<TKey, TValue> {
    readonly capacity: int;
    readonly comparer: IEqualityComparer_1<TKey>;
    readonly count: int;
    item: TValue;
    readonly keys: Dictionary_2_KeyCollection<TKey, TValue>;
    readonly values: Dictionary_2_ValueCollection<TKey, TValue>;
    add(key: TKey, value: TValue): void;
    clear(): void;
    containsKey(key: TKey): boolean;
    containsValue(value: TValue): boolean;
    ensureCapacity(capacity: int): int;
    getAlternateLookup<TAlternateKey>(): Dictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>;
    getEnumerator(): Dictionary_2_Enumerator<TKey, TValue>;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    onDeserialization(sender: unknown): void;
    remove(key: TKey): boolean;
    remove(key: TKey, value: { value: ref<TValue> }): boolean;
    trimExcess(): void;
    trimExcess(capacity: int): void;
    tryAdd(key: TKey, value: TValue): boolean;
    tryGetAlternateLookup<TAlternateKey>(lookup: { value: ref<Dictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>> }): boolean;
    tryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
}


export const Dictionary_2: {
    new<TKey, TValue>(): Dictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(capacity: int): Dictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(comparer: IEqualityComparer_1<TKey>): Dictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(capacity: int, comparer: IEqualityComparer_1<TKey>): Dictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>): Dictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>, comparer: IEqualityComparer_1<TKey>): Dictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(collection: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): Dictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(collection: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, comparer: IEqualityComparer_1<TKey>): Dictionary_2$instance<TKey, TValue>;
};


export interface __Dictionary_2$views<TKey, TValue> {
    As_ICollection_1(): ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionary_2(): IDictionary_2$instance<TKey, TValue>;
    As_IEnumerable_1(): IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyDictionary_2(): IReadOnlyDictionary_2$instance<TKey, TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Dictionary_2$instance<TKey, TValue> extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Dictionary_2<TKey, TValue> = Dictionary_2$instance<TKey, TValue> & __Dictionary_2$views<TKey, TValue>;


export interface Dictionary_2_KeyCollection$instance<TKey, TValue> {
    readonly count: int;
    contains(item: TKey): boolean;
    copyTo(array: TKey[], index: int): void;
    getEnumerator(): Dictionary_2_KeyCollection_Enumerator<TKey, TValue>;
}


export const Dictionary_2_KeyCollection: {
    new<TKey, TValue>(dictionary: Dictionary_2<TKey, TValue>): Dictionary_2_KeyCollection$instance<TKey, TValue>;
};


export interface __Dictionary_2_KeyCollection$views<TKey, TValue> {
    As_ICollection_1(): ICollection_1$instance<TKey>;
    As_IEnumerable_1(): IEnumerable_1$instance<TKey>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<TKey>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type Dictionary_2_KeyCollection<TKey, TValue> = Dictionary_2_KeyCollection$instance<TKey, TValue> & __Dictionary_2_KeyCollection$views<TKey, TValue>;


export interface Dictionary_2_ValueCollection$instance<TKey, TValue> {
    readonly count: int;
    copyTo(array: TValue[], index: int): void;
    getEnumerator(): Dictionary_2_ValueCollection_Enumerator<TKey, TValue>;
}


export const Dictionary_2_ValueCollection: {
    new<TKey, TValue>(dictionary: Dictionary_2<TKey, TValue>): Dictionary_2_ValueCollection$instance<TKey, TValue>;
};


export interface __Dictionary_2_ValueCollection$views<TKey, TValue> {
    As_ICollection_1(): ICollection_1$instance<TValue>;
    As_IEnumerable_1(): IEnumerable_1$instance<TValue>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type Dictionary_2_ValueCollection<TKey, TValue> = Dictionary_2_ValueCollection$instance<TKey, TValue> & __Dictionary_2_ValueCollection$views<TKey, TValue>;


export interface EnumEqualityComparer_1$instance<T extends number> extends EqualityComparer_1$instance<T> {
    equals(x: unknown, y: unknown): boolean;
    getHashCode(obj: unknown): int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const EnumEqualityComparer_1: {
    new<T extends number>(): EnumEqualityComparer_1$instance<T>;
};


export interface __EnumEqualityComparer_1$views<T extends number & unknown> {
    As_IEqualityComparer_1(): IEqualityComparer_1$instance<T>;
    As_IEqualityComparer(): System_Collections_Internal.IEqualityComparer$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface EnumEqualityComparer_1$instance<T extends number & unknown> extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type EnumEqualityComparer_1<T extends number> = EnumEqualityComparer_1$instance<T> & __EnumEqualityComparer_1$views<T>;


export interface EqualityComparer_1$instance<T> {
    equals(x: T, y: T): boolean;
    getHashCode(obj: T): int;
}


export const EqualityComparer_1: {
    readonly default_: unknown;
    create<T>(equals: Func_3<T, T, CLROf<boolean>>, getHashCode?: Func_2<T, CLROf<int>>): EqualityComparer_1<T>;
};


export interface __EqualityComparer_1$views<T> {
    As_IEqualityComparer_1(): IEqualityComparer_1$instance<T>;
    As_IEqualityComparer(): System_Collections_Internal.IEqualityComparer$instance;
}

export type EqualityComparer_1<T> = EqualityComparer_1$instance<T> & __EqualityComparer_1$views<T>;


export interface GenericComparer_1$instance<T extends (IComparable_1<T> | number | string | boolean)> extends Comparer_1$instance<T> {
    compare(x: unknown, y: unknown): int;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const GenericComparer_1: {
    new<T extends (IComparable_1<T> | number | string | boolean)>(): GenericComparer_1$instance<T>;
};


export interface __GenericComparer_1$views<T extends (IComparable_1<T> | number | string | boolean)> {
    As_IComparer_1(): IComparer_1$instance<T>;
    As_IComparer(): System_Collections_Internal.IComparer$instance;
}

export type GenericComparer_1<T extends (IComparable_1<T> | number | string | boolean)> = GenericComparer_1$instance<T> & __GenericComparer_1$views<T>;


export interface GenericEqualityComparer_1$instance<T extends (IEquatable_1<T> | number | string | boolean)> extends EqualityComparer_1$instance<T> {
    equals(x: unknown, y: unknown): boolean;
    getHashCode(obj: unknown): int;
}


export const GenericEqualityComparer_1: {
    new<T extends (IEquatable_1<T> | number | string | boolean)>(): GenericEqualityComparer_1$instance<T>;
};


export interface __GenericEqualityComparer_1$views<T extends (IEquatable_1<T> | number | string | boolean)> {
    As_IEqualityComparer_1(): IEqualityComparer_1$instance<T>;
    As_IEqualityComparer(): System_Collections_Internal.IEqualityComparer$instance;
}

export type GenericEqualityComparer_1<T extends (IEquatable_1<T> | number | string | boolean)> = GenericEqualityComparer_1$instance<T> & __GenericEqualityComparer_1$views<T>;


export interface HashSet_1$instance<T> {
    readonly capacity: int;
    readonly comparer: IEqualityComparer_1<T>;
    readonly count: int;
    add(item: T): boolean;
    clear(): void;
    contains(item: T): boolean;
    copyTo(array: T[]): void;
    copyTo(array: T[], arrayIndex: int): void;
    copyTo(array: T[], arrayIndex: int, count: int): void;
    ensureCapacity(capacity: int): int;
    exceptWith(other: IEnumerable_1<T>): void;
    getAlternateLookup<TAlternate>(): HashSet_1_AlternateLookup_1<T, TAlternate>;
    getEnumerator(): HashSet_1_Enumerator<T>;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    intersectWith(other: IEnumerable_1<T>): void;
    isProperSubsetOf(other: IEnumerable_1<T>): boolean;
    isProperSupersetOf(other: IEnumerable_1<T>): boolean;
    isSubsetOf(other: IEnumerable_1<T>): boolean;
    isSupersetOf(other: IEnumerable_1<T>): boolean;
    onDeserialization(sender: unknown): void;
    overlaps(other: IEnumerable_1<T>): boolean;
    remove(item: T): boolean;
    removeWhere(match: Predicate_1<T>): int;
    setEquals(other: IEnumerable_1<T>): boolean;
    symmetricExceptWith(other: IEnumerable_1<T>): void;
    trimExcess(): void;
    trimExcess(capacity: int): void;
    tryGetAlternateLookup<TAlternate>(lookup: { value: ref<HashSet_1_AlternateLookup_1<T, TAlternate>> }): boolean;
    tryGetValue(equalValue: T, actualValue: { value: ref<T> }): boolean;
    unionWith(other: IEnumerable_1<T>): void;
}


export const HashSet_1: {
    new<T>(): HashSet_1$instance<T>;
    new<T>(comparer: IEqualityComparer_1<T>): HashSet_1$instance<T>;
    new<T>(capacity: int): HashSet_1$instance<T>;
    new<T>(collection: IEnumerable_1<T>): HashSet_1$instance<T>;
    new<T>(collection: IEnumerable_1<T>, comparer: IEqualityComparer_1<T>): HashSet_1$instance<T>;
    new<T>(capacity: int, comparer: IEqualityComparer_1<T>): HashSet_1$instance<T>;
    createSetComparer<T>(): IEqualityComparer_1<HashSet_1<T>>;
};


export interface __HashSet_1$views<T> {
    As_ICollection_1(): ICollection_1$instance<T>;
    As_IEnumerable_1(): IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<T>;
    As_IReadOnlySet_1(): IReadOnlySet_1$instance<T>;
    As_ISet_1(): ISet_1$instance<T>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface HashSet_1$instance<T> extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type HashSet_1<T> = HashSet_1$instance<T> & __HashSet_1$views<T>;


export interface KeyNotFoundException$instance extends SystemException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const KeyNotFoundException: {
    new(): KeyNotFoundException$instance;
    new(message: string): KeyNotFoundException$instance;
    new(message: string, innerException: Exception): KeyNotFoundException$instance;
};


export interface __KeyNotFoundException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type KeyNotFoundException = KeyNotFoundException$instance & __KeyNotFoundException$views;


export interface LinkedList_1$instance<T> {
    readonly count: int;
    readonly first: LinkedListNode_1<T>;
    readonly last: LinkedListNode_1<T>;
    addAfter(node: LinkedListNode_1<T>, value: T): LinkedListNode_1<T>;
    addAfter(node: LinkedListNode_1<T>, newNode: LinkedListNode_1<T>): void;
    addBefore(node: LinkedListNode_1<T>, value: T): LinkedListNode_1<T>;
    addBefore(node: LinkedListNode_1<T>, newNode: LinkedListNode_1<T>): void;
    addFirst(value: T): LinkedListNode_1<T>;
    addFirst(node: LinkedListNode_1<T>): void;
    addLast(value: T): LinkedListNode_1<T>;
    addLast(node: LinkedListNode_1<T>): void;
    clear(): void;
    contains(value: T): boolean;
    copyTo(array: T[], index: int): void;
    find(value: T): LinkedListNode_1<T>;
    findLast(value: T): LinkedListNode_1<T>;
    getEnumerator(): LinkedList_1_Enumerator<T>;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    onDeserialization(sender: unknown): void;
    remove(value: T): boolean;
    remove(node: LinkedListNode_1<T>): void;
    removeFirst(): void;
    removeLast(): void;
}


export const LinkedList_1: {
    new<T>(): LinkedList_1$instance<T>;
    new<T>(collection: IEnumerable_1<T>): LinkedList_1$instance<T>;
};


export interface __LinkedList_1$views<T> {
    As_ICollection_1(): ICollection_1$instance<T>;
    As_IEnumerable_1(): IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface LinkedList_1$instance<T> extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type LinkedList_1<T> = LinkedList_1$instance<T> & __LinkedList_1$views<T>;


export interface LinkedListNode_1$instance<T> {
    readonly list: LinkedList_1<T>;
    readonly next: LinkedListNode_1<T>;
    readonly previous: LinkedListNode_1<T>;
    value: T;
    readonly valueRef: ref<T>;
}


export const LinkedListNode_1: {
    new<T>(value: T): LinkedListNode_1$instance<T>;
};


export type LinkedListNode_1<T> = LinkedListNode_1$instance<T>;

export interface List_1$instance<T> {
    capacity: int;
    readonly count: int;
    item: T;
    add(item: T): void;
    addRange(collection: IEnumerable_1<T>): void;
    asReadOnly(): ReadOnlyCollection_1<T>;
    binarySearch(index: int, count: int, item: T, comparer: IComparer_1<T>): int;
    binarySearch(item: T): int;
    binarySearch(item: T, comparer: IComparer_1<T>): int;
    clear(): void;
    contains(item: T): boolean;
    convertAll<TOutput>(converter: Converter_2<T, TOutput>): List_1<TOutput>;
    copyTo(array: T[]): void;
    copyTo(index: int, array: T[], arrayIndex: int, count: int): void;
    copyTo(array: T[], arrayIndex: int): void;
    ensureCapacity(capacity: int): int;
    exists(match: Predicate_1<T>): boolean;
    find(match: Predicate_1<T>): T;
    findAll(match: Predicate_1<T>): List_1<T>;
    findIndex(match: Predicate_1<T>): int;
    findIndex(startIndex: int, match: Predicate_1<T>): int;
    findIndex(startIndex: int, count: int, match: Predicate_1<T>): int;
    findLast(match: Predicate_1<T>): T;
    findLastIndex(match: Predicate_1<T>): int;
    findLastIndex(startIndex: int, match: Predicate_1<T>): int;
    findLastIndex(startIndex: int, count: int, match: Predicate_1<T>): int;
    forEach(action: Action_1<T>): void;
    getEnumerator(): List_1_Enumerator<T>;
    getRange(index: int, count: int): List_1<T>;
    indexOf(item: T): int;
    indexOf(item: T, index: int): int;
    indexOf(item: T, index: int, count: int): int;
    insert(index: int, item: T): void;
    insertRange(index: int, collection: IEnumerable_1<T>): void;
    lastIndexOf(item: T): int;
    lastIndexOf(item: T, index: int): int;
    lastIndexOf(item: T, index: int, count: int): int;
    remove(item: T): boolean;
    removeAll(match: Predicate_1<T>): int;
    removeAt(index: int): void;
    removeRange(index: int, count: int): void;
    reverse(): void;
    reverse(index: int, count: int): void;
    slice(start: int, length: int): List_1<T>;
    sort(): void;
    sort(comparer: IComparer_1<T>): void;
    sort(index: int, count: int, comparer: IComparer_1<T>): void;
    sort(comparison: Comparison_1<T>): void;
    toArray(): T[];
    trimExcess(): void;
    trueForAll(match: Predicate_1<T>): boolean;
}


export const List_1: {
    new<T>(): List_1$instance<T>;
    new<T>(capacity: int): List_1$instance<T>;
    new<T>(collection: IEnumerable_1<T>): List_1$instance<T>;
};


export interface __List_1$views<T> {
    As_ICollection_1(): ICollection_1$instance<T>;
    As_IEnumerable_1(): IEnumerable_1$instance<T>;
    As_IList_1(): IList_1$instance<T>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type List_1<T> = List_1$instance<T> & __List_1$views<T>;


export interface NonRandomizedStringEqualityComparer$instance {
    equals(x: string, y: string): boolean;
    getHashCode(obj: string): int;
    getUnderlyingEqualityComparer(): IEqualityComparer_1<CLROf<string>>;
}


export const NonRandomizedStringEqualityComparer: {
    new(): NonRandomizedStringEqualityComparer$instance;
    getStringComparer(comparer: unknown): IEqualityComparer_1<CLROf<string>>;
};


export interface __NonRandomizedStringEqualityComparer$views {
    As_IEqualityComparer_1(): IEqualityComparer_1$instance<CLROf<string>>;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface NonRandomizedStringEqualityComparer$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type NonRandomizedStringEqualityComparer = NonRandomizedStringEqualityComparer$instance & __NonRandomizedStringEqualityComparer$views;


export interface NullableComparer_1$instance<T extends unknown> extends Comparer_1$instance<Nullable_1<T>> {
    compare(x: unknown, y: unknown): int;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const NullableComparer_1: {
    new<T extends unknown>(): NullableComparer_1$instance<T>;
};


export interface __NullableComparer_1$views<T extends unknown> {
    As_IComparer_1(): IComparer_1$instance<Nullable_1<T>>;
    As_IComparer(): System_Collections_Internal.IComparer$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface NullableComparer_1$instance<T extends unknown> extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type NullableComparer_1<T> = NullableComparer_1$instance<T> & __NullableComparer_1$views<T>;


export interface NullableEqualityComparer_1$instance<T extends unknown> extends EqualityComparer_1$instance<Nullable_1<T>> {
    equals(x: unknown, y: unknown): boolean;
    getHashCode(obj: unknown): int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const NullableEqualityComparer_1: {
    new<T extends unknown>(): NullableEqualityComparer_1$instance<T>;
};


export interface __NullableEqualityComparer_1$views<T extends unknown> {
    As_IEqualityComparer_1(): IEqualityComparer_1$instance<Nullable_1<T>>;
    As_IEqualityComparer(): System_Collections_Internal.IEqualityComparer$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface NullableEqualityComparer_1$instance<T extends unknown> extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type NullableEqualityComparer_1<T> = NullableEqualityComparer_1$instance<T> & __NullableEqualityComparer_1$views<T>;


export interface ObjectComparer_1$instance<T> extends Comparer_1$instance<T> {
    compare(x: unknown, y: unknown): int;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const ObjectComparer_1: {
    new<T>(): ObjectComparer_1$instance<T>;
};


export interface __ObjectComparer_1$views<T> {
    As_IComparer_1(): IComparer_1$instance<T>;
    As_IComparer(): System_Collections_Internal.IComparer$instance;
}

export type ObjectComparer_1<T> = ObjectComparer_1$instance<T> & __ObjectComparer_1$views<T>;


export interface ObjectEqualityComparer_1$instance<T> extends EqualityComparer_1$instance<T> {
    equals(x: unknown, y: unknown): boolean;
    getHashCode(obj: unknown): int;
}


export const ObjectEqualityComparer_1: {
    new<T>(): ObjectEqualityComparer_1$instance<T>;
};


export interface __ObjectEqualityComparer_1$views<T> {
    As_IEqualityComparer_1(): IEqualityComparer_1$instance<T>;
    As_IEqualityComparer(): System_Collections_Internal.IEqualityComparer$instance;
}

export type ObjectEqualityComparer_1<T> = ObjectEqualityComparer_1$instance<T> & __ObjectEqualityComparer_1$views<T>;


export interface OrderedDictionary_2$instance<TKey, TValue> {
    readonly capacity: int;
    readonly comparer: IEqualityComparer_1<TKey>;
    readonly count: int;
    item: TValue;
    readonly keys: OrderedDictionary_2_KeyCollection<TKey, TValue>;
    readonly values: OrderedDictionary_2_ValueCollection<TKey, TValue>;
    add(key: TKey, value: TValue): void;
    clear(): void;
    containsKey(key: TKey): boolean;
    containsValue(value: TValue): boolean;
    ensureCapacity(capacity: int): int;
    getAt(index: int): KeyValuePair_2<TKey, TValue>;
    getEnumerator(): OrderedDictionary_2_Enumerator<TKey, TValue>;
    indexOf(key: TKey): int;
    insert(index: int, key: TKey, value: TValue): void;
    remove(key: TKey): boolean;
    remove(key: TKey, value: { value: ref<TValue> }): boolean;
    removeAt(index: int): void;
    setAt(index: int, value: TValue): void;
    setAt(index: int, key: TKey, value: TValue): void;
    trimExcess(): void;
    trimExcess(capacity: int): void;
    tryAdd(key: TKey, value: TValue): boolean;
    tryAdd(key: TKey, value: TValue, index: { value: ref<int> }): boolean;
    tryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
    tryGetValue(key: TKey, value: { value: ref<TValue> }, index: { value: ref<int> }): boolean;
}


export const OrderedDictionary_2: {
    new<TKey, TValue>(): OrderedDictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(capacity: int): OrderedDictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(comparer: IEqualityComparer_1<TKey>): OrderedDictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(capacity: int, comparer: IEqualityComparer_1<TKey>): OrderedDictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>): OrderedDictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>, comparer: IEqualityComparer_1<TKey>): OrderedDictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(collection: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): OrderedDictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(collection: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, comparer: IEqualityComparer_1<TKey>): OrderedDictionary_2$instance<TKey, TValue>;
};


export interface __OrderedDictionary_2$views<TKey, TValue> {
    As_ICollection_1(): ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionary_2(): IDictionary_2$instance<TKey, TValue>;
    As_IEnumerable_1(): IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IList_1(): IList_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyDictionary_2(): IReadOnlyDictionary_2$instance<TKey, TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type OrderedDictionary_2<TKey, TValue> = OrderedDictionary_2$instance<TKey, TValue> & __OrderedDictionary_2$views<TKey, TValue>;


export interface OrderedDictionary_2_KeyCollection$instance<TKey, TValue> {
    readonly count: int;
    contains(key: TKey): boolean;
    copyTo(array: TKey[], arrayIndex: int): void;
    getEnumerator(): OrderedDictionary_2_KeyCollection_Enumerator<TKey, TValue>;
}


export const OrderedDictionary_2_KeyCollection: {
    new<TKey, TValue>(): OrderedDictionary_2_KeyCollection$instance<TKey, TValue>;
};


export interface __OrderedDictionary_2_KeyCollection$views<TKey, TValue> {
    As_ICollection_1(): ICollection_1$instance<TKey>;
    As_IEnumerable_1(): IEnumerable_1$instance<TKey>;
    As_IList_1(): IList_1$instance<TKey>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<TKey>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type OrderedDictionary_2_KeyCollection<TKey, TValue> = OrderedDictionary_2_KeyCollection$instance<TKey, TValue> & __OrderedDictionary_2_KeyCollection$views<TKey, TValue>;


export interface OrderedDictionary_2_ValueCollection$instance<TKey, TValue> {
    readonly count: int;
    copyTo(array: TValue[], arrayIndex: int): void;
    getEnumerator(): OrderedDictionary_2_ValueCollection_Enumerator<TKey, TValue>;
}


export const OrderedDictionary_2_ValueCollection: {
    new<TKey, TValue>(): OrderedDictionary_2_ValueCollection$instance<TKey, TValue>;
};


export interface __OrderedDictionary_2_ValueCollection$views<TKey, TValue> {
    As_ICollection_1(): ICollection_1$instance<TValue>;
    As_IEnumerable_1(): IEnumerable_1$instance<TValue>;
    As_IList_1(): IList_1$instance<TValue>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type OrderedDictionary_2_ValueCollection<TKey, TValue> = OrderedDictionary_2_ValueCollection$instance<TKey, TValue> & __OrderedDictionary_2_ValueCollection$views<TKey, TValue>;


export interface PriorityQueue_2$instance<TElement, TPriority> {
    readonly capacity: int;
    readonly comparer: IComparer_1<TPriority>;
    readonly count: int;
    readonly unorderedItems: PriorityQueue_2_UnorderedItemsCollection<TElement, TPriority>;
    clear(): void;
    dequeue(): TElement;
    dequeueEnqueue(element: TElement, priority: TPriority): TElement;
    enqueue(element: TElement, priority: TPriority): void;
    enqueueDequeue(element: TElement, priority: TPriority): TElement;
    enqueueRange(items: IEnumerable_1<ValueTuple_2<TElement, TPriority>>): void;
    enqueueRange(elements: IEnumerable_1<TElement>, priority: TPriority): void;
    ensureCapacity(capacity: int): int;
    peek(): TElement;
    remove(element: TElement, removedElement: { value: ref<TElement> }, priority: { value: ref<TPriority> }, equalityComparer?: IEqualityComparer_1<TElement>): boolean;
    trimExcess(): void;
    tryDequeue(element: { value: ref<TElement> }, priority: { value: ref<TPriority> }): boolean;
    tryPeek(element: { value: ref<TElement> }, priority: { value: ref<TPriority> }): boolean;
}


export const PriorityQueue_2: {
    new<TElement, TPriority>(): PriorityQueue_2$instance<TElement, TPriority>;
    new<TElement, TPriority>(initialCapacity: int): PriorityQueue_2$instance<TElement, TPriority>;
    new<TElement, TPriority>(comparer: IComparer_1<TPriority>): PriorityQueue_2$instance<TElement, TPriority>;
    new<TElement, TPriority>(initialCapacity: int, comparer: IComparer_1<TPriority>): PriorityQueue_2$instance<TElement, TPriority>;
    new<TElement, TPriority>(items: IEnumerable_1<ValueTuple_2<TElement, TPriority>>): PriorityQueue_2$instance<TElement, TPriority>;
    new<TElement, TPriority>(items: IEnumerable_1<ValueTuple_2<TElement, TPriority>>, comparer: IComparer_1<TPriority>): PriorityQueue_2$instance<TElement, TPriority>;
};


export type PriorityQueue_2<TElement, TPriority> = PriorityQueue_2$instance<TElement, TPriority>;

export interface PriorityQueue_2_UnorderedItemsCollection$instance<TElement, TPriority> {
    readonly count: int;
    getEnumerator(): PriorityQueue_2_UnorderedItemsCollection_Enumerator<TElement, TPriority>;
}


export const PriorityQueue_2_UnorderedItemsCollection: {
    new<TElement, TPriority>(): PriorityQueue_2_UnorderedItemsCollection$instance<TElement, TPriority>;
};


export interface __PriorityQueue_2_UnorderedItemsCollection$views<TElement, TPriority> {
    As_IEnumerable_1(): IEnumerable_1$instance<ValueTuple_2<TElement, TPriority>>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<ValueTuple_2<TElement, TPriority>>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type PriorityQueue_2_UnorderedItemsCollection<TElement, TPriority> = PriorityQueue_2_UnorderedItemsCollection$instance<TElement, TPriority> & __PriorityQueue_2_UnorderedItemsCollection$views<TElement, TPriority>;


export interface Queue_1$instance<T> {
    readonly capacity: int;
    readonly count: int;
    clear(): void;
    contains(item: T): boolean;
    copyTo(array: T[], arrayIndex: int): void;
    dequeue(): T;
    enqueue(item: T): void;
    ensureCapacity(capacity: int): int;
    getEnumerator(): Queue_1_Enumerator<T>;
    peek(): T;
    toArray(): T[];
    trimExcess(): void;
    trimExcess(capacity: int): void;
    tryDequeue(result: { value: ref<T> }): boolean;
    tryPeek(result: { value: ref<T> }): boolean;
}


export const Queue_1: {
    new<T>(): Queue_1$instance<T>;
    new<T>(capacity: int): Queue_1$instance<T>;
    new<T>(collection: IEnumerable_1<T>): Queue_1$instance<T>;
};


export interface __Queue_1$views<T> {
    As_IEnumerable_1(): IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type Queue_1<T> = Queue_1$instance<T> & __Queue_1$views<T>;


export interface ReferenceEqualityComparer$instance {
    equals(x: unknown, y: unknown): boolean;
    getHashCode(obj: unknown): int;
}


export const ReferenceEqualityComparer: {
    new(): ReferenceEqualityComparer$instance;
    readonly instance: ReferenceEqualityComparer;
};


export interface __ReferenceEqualityComparer$views {
    As_IEqualityComparer_1(): IEqualityComparer_1$instance<unknown>;
    As_IEqualityComparer(): System_Collections_Internal.IEqualityComparer$instance;
}

export type ReferenceEqualityComparer = ReferenceEqualityComparer$instance & __ReferenceEqualityComparer$views;


export interface SortedDictionary_2$instance<TKey, TValue> {
    readonly comparer: IComparer_1<TKey>;
    readonly count: int;
    item: TValue;
    readonly keys: SortedDictionary_2_KeyCollection<TKey, TValue>;
    readonly values: SortedDictionary_2_ValueCollection<TKey, TValue>;
    add(key: TKey, value: TValue): void;
    clear(): void;
    containsKey(key: TKey): boolean;
    containsValue(value: TValue): boolean;
    copyTo(array: KeyValuePair_2<TKey, TValue>[], index: int): void;
    getEnumerator(): SortedDictionary_2_Enumerator<TKey, TValue>;
    remove(key: TKey): boolean;
    tryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
}


export const SortedDictionary_2: {
    new<TKey, TValue>(): SortedDictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>): SortedDictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>, comparer: IComparer_1<TKey>): SortedDictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(comparer: IComparer_1<TKey>): SortedDictionary_2$instance<TKey, TValue>;
};


export interface __SortedDictionary_2$views<TKey, TValue> {
    As_ICollection_1(): ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionary_2(): IDictionary_2$instance<TKey, TValue>;
    As_IEnumerable_1(): IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyDictionary_2(): IReadOnlyDictionary_2$instance<TKey, TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type SortedDictionary_2<TKey, TValue> = SortedDictionary_2$instance<TKey, TValue> & __SortedDictionary_2$views<TKey, TValue>;


export interface SortedDictionary_2_KeyCollection$instance<TKey, TValue> {
    readonly count: int;
    contains(item: TKey): boolean;
    copyTo(array: TKey[], index: int): void;
    getEnumerator(): SortedDictionary_2_KeyCollection_Enumerator<TKey, TValue>;
}


export const SortedDictionary_2_KeyCollection: {
    new<TKey, TValue>(dictionary: SortedDictionary_2<TKey, TValue>): SortedDictionary_2_KeyCollection$instance<TKey, TValue>;
};


export interface __SortedDictionary_2_KeyCollection$views<TKey, TValue> {
    As_ICollection_1(): ICollection_1$instance<TKey>;
    As_IEnumerable_1(): IEnumerable_1$instance<TKey>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<TKey>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type SortedDictionary_2_KeyCollection<TKey, TValue> = SortedDictionary_2_KeyCollection$instance<TKey, TValue> & __SortedDictionary_2_KeyCollection$views<TKey, TValue>;


export interface SortedDictionary_2_KeyValuePairComparer$instance<TKey, TValue> extends Comparer_1$instance<KeyValuePair_2<TKey, TValue>> {
    compare(x: unknown, y: unknown): int;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const SortedDictionary_2_KeyValuePairComparer: {
    new<TKey, TValue>(keyComparer: IComparer_1<TKey>): SortedDictionary_2_KeyValuePairComparer$instance<TKey, TValue>;
};


export interface __SortedDictionary_2_KeyValuePairComparer$views<TKey, TValue> {
    As_IComparer_1(): IComparer_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IComparer(): System_Collections_Internal.IComparer$instance;
}

export type SortedDictionary_2_KeyValuePairComparer<TKey, TValue> = SortedDictionary_2_KeyValuePairComparer$instance<TKey, TValue> & __SortedDictionary_2_KeyValuePairComparer$views<TKey, TValue>;


export interface SortedDictionary_2_ValueCollection$instance<TKey, TValue> {
    readonly count: int;
    copyTo(array: TValue[], index: int): void;
    getEnumerator(): SortedDictionary_2_ValueCollection_Enumerator<TKey, TValue>;
}


export const SortedDictionary_2_ValueCollection: {
    new<TKey, TValue>(dictionary: SortedDictionary_2<TKey, TValue>): SortedDictionary_2_ValueCollection$instance<TKey, TValue>;
};


export interface __SortedDictionary_2_ValueCollection$views<TKey, TValue> {
    As_ICollection_1(): ICollection_1$instance<TValue>;
    As_IEnumerable_1(): IEnumerable_1$instance<TValue>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type SortedDictionary_2_ValueCollection<TKey, TValue> = SortedDictionary_2_ValueCollection$instance<TKey, TValue> & __SortedDictionary_2_ValueCollection$views<TKey, TValue>;


export interface SortedList_2$instance<TKey, TValue> {
    capacity: int;
    readonly comparer: IComparer_1<TKey>;
    readonly count: int;
    item: TValue;
    readonly keys: IList_1<TKey>;
    readonly values: IList_1<TValue>;
    add(key: TKey, value: TValue): void;
    clear(): void;
    containsKey(key: TKey): boolean;
    containsValue(value: TValue): boolean;
    getEnumerator(): IEnumerator_1<KeyValuePair_2<TKey, TValue>>;
    getKeyAtIndex(index: int): TKey;
    getValueAtIndex(index: int): TValue;
    indexOfKey(key: TKey): int;
    indexOfValue(value: TValue): int;
    remove(key: TKey): boolean;
    removeAt(index: int): void;
    setValueAtIndex(index: int, value: TValue): void;
    trimExcess(): void;
    tryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
}


export const SortedList_2: {
    new<TKey, TValue>(): SortedList_2$instance<TKey, TValue>;
    new<TKey, TValue>(capacity: int): SortedList_2$instance<TKey, TValue>;
    new<TKey, TValue>(comparer: IComparer_1<TKey>): SortedList_2$instance<TKey, TValue>;
    new<TKey, TValue>(capacity: int, comparer: IComparer_1<TKey>): SortedList_2$instance<TKey, TValue>;
    new<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>): SortedList_2$instance<TKey, TValue>;
    new<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>, comparer: IComparer_1<TKey>): SortedList_2$instance<TKey, TValue>;
};


export interface __SortedList_2$views<TKey, TValue> {
    As_ICollection_1(): ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionary_2(): IDictionary_2$instance<TKey, TValue>;
    As_IEnumerable_1(): IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyDictionary_2(): IReadOnlyDictionary_2$instance<TKey, TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type SortedList_2<TKey, TValue> = SortedList_2$instance<TKey, TValue> & __SortedList_2$views<TKey, TValue>;


export interface SortedList_2_KeyList$instance<TKey, TValue> {
    readonly count: int;
    readonly isReadOnly: boolean;
    item: TKey;
    add(key: TKey): void;
    clear(): void;
    contains(key: TKey): boolean;
    copyTo(array: TKey[], arrayIndex: int): void;
    getEnumerator(): IEnumerator_1<TKey>;
    indexOf(key: TKey): int;
    insert(index: int, value: TKey): void;
    remove(key: TKey): boolean;
    removeAt(index: int): void;
}


export const SortedList_2_KeyList: {
    new<TKey, TValue>(): SortedList_2_KeyList$instance<TKey, TValue>;
};


export interface __SortedList_2_KeyList$views<TKey, TValue> {
    As_ICollection_1(): ICollection_1$instance<TKey>;
    As_IEnumerable_1(): IEnumerable_1$instance<TKey>;
    As_IList_1(): IList_1$instance<TKey>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type SortedList_2_KeyList<TKey, TValue> = SortedList_2_KeyList$instance<TKey, TValue> & __SortedList_2_KeyList$views<TKey, TValue>;


export interface SortedList_2_ValueList$instance<TKey, TValue> {
    readonly count: int;
    readonly isReadOnly: boolean;
    item: TValue;
    add(key: TValue): void;
    clear(): void;
    contains(value: TValue): boolean;
    copyTo(array: TValue[], arrayIndex: int): void;
    getEnumerator(): IEnumerator_1<TValue>;
    indexOf(value: TValue): int;
    insert(index: int, value: TValue): void;
    remove(value: TValue): boolean;
    removeAt(index: int): void;
}


export const SortedList_2_ValueList: {
    new<TKey, TValue>(): SortedList_2_ValueList$instance<TKey, TValue>;
};


export interface __SortedList_2_ValueList$views<TKey, TValue> {
    As_ICollection_1(): ICollection_1$instance<TValue>;
    As_IEnumerable_1(): IEnumerable_1$instance<TValue>;
    As_IList_1(): IList_1$instance<TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type SortedList_2_ValueList<TKey, TValue> = SortedList_2_ValueList$instance<TKey, TValue> & __SortedList_2_ValueList$views<TKey, TValue>;


export interface SortedSet_1$instance<T> {
    readonly comparer: IComparer_1<T>;
    readonly count: int;
    readonly max: T;
    readonly min: T;
    add(item: T): boolean;
    clear(): void;
    contains(item: T): boolean;
    copyTo(array: T[]): void;
    copyTo(array: T[], index: int): void;
    copyTo(array: T[], index: int, count: int): void;
    exceptWith(other: IEnumerable_1<T>): void;
    getEnumerator(): SortedSet_1_Enumerator<T>;
    getViewBetween(lowerValue: T, upperValue: T): SortedSet_1<T>;
    intersectWith(other: IEnumerable_1<T>): void;
    isProperSubsetOf(other: IEnumerable_1<T>): boolean;
    isProperSupersetOf(other: IEnumerable_1<T>): boolean;
    isSubsetOf(other: IEnumerable_1<T>): boolean;
    isSupersetOf(other: IEnumerable_1<T>): boolean;
    overlaps(other: IEnumerable_1<T>): boolean;
    remove(item: T): boolean;
    removeWhere(match: Predicate_1<T>): int;
    reverse(): IEnumerable_1<T>;
    setEquals(other: IEnumerable_1<T>): boolean;
    symmetricExceptWith(other: IEnumerable_1<T>): void;
    tryGetValue(equalValue: T, actualValue: { value: ref<T> }): boolean;
    unionWith(other: IEnumerable_1<T>): void;
}


export const SortedSet_1: {
    new<T>(): SortedSet_1$instance<T>;
    new<T>(comparer: IComparer_1<T>): SortedSet_1$instance<T>;
    new<T>(collection: IEnumerable_1<T>): SortedSet_1$instance<T>;
    new<T>(collection: IEnumerable_1<T>, comparer: IComparer_1<T>): SortedSet_1$instance<T>;
    createSetComparer<T>(): IEqualityComparer_1<SortedSet_1<T>>;
    createSetComparer<T>(memberEqualityComparer: IEqualityComparer_1<T>): IEqualityComparer_1<SortedSet_1<T>>;
};


export interface __SortedSet_1$views<T> {
    As_ICollection_1(): ICollection_1$instance<T>;
    As_IEnumerable_1(): IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<T>;
    As_IReadOnlySet_1(): IReadOnlySet_1$instance<T>;
    As_ISet_1(): ISet_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface SortedSet_1$instance<T> extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type SortedSet_1<T> = SortedSet_1$instance<T> & __SortedSet_1$views<T>;


export interface Stack_1$instance<T> {
    readonly capacity: int;
    readonly count: int;
    clear(): void;
    contains(item: T): boolean;
    copyTo(array: T[], arrayIndex: int): void;
    ensureCapacity(capacity: int): int;
    getEnumerator(): Stack_1_Enumerator<T>;
    peek(): T;
    pop(): T;
    push(item: T): void;
    toArray(): T[];
    trimExcess(): void;
    trimExcess(capacity: int): void;
    tryPeek(result: { value: ref<T> }): boolean;
    tryPop(result: { value: ref<T> }): boolean;
}


export const Stack_1: {
    new<T>(): Stack_1$instance<T>;
    new<T>(capacity: int): Stack_1$instance<T>;
    new<T>(collection: IEnumerable_1<T>): Stack_1$instance<T>;
};


export interface __Stack_1$views<T> {
    As_IEnumerable_1(): IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type Stack_1<T> = Stack_1$instance<T> & __Stack_1$views<T>;


export interface TreeSet_1$instance<T> extends SortedSet_1$instance<T> {
    add(item: T): boolean;
    add(item: T): void;
    clear(): void;
    contains(item: T): boolean;
    copyTo(array: T[]): void;
    copyTo(array: T[], index: int): void;
    copyTo(array: T[], index: int, count: int): void;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): SortedSet_1_Enumerator<T>;
    getEnumerator(): IEnumerator_1<T>;
    getEnumerator(): IEnumerator;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    isProperSubsetOf(other: IEnumerable_1<T>): boolean;
    isSubsetOf(other: IEnumerable_1<T>): boolean;
    onDeserialization(sender: unknown): void;
    unionWith(other: IEnumerable_1<T>): void;
}


export const TreeSet_1: {
    new<T>(): TreeSet_1$instance<T>;
    new<T>(comparer: IComparer_1<T>): TreeSet_1$instance<T>;
};


export interface __TreeSet_1$views<T> {
    As_ICollection_1(): ICollection_1$instance<T>;
    As_IEnumerable_1(): IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<T>;
    As_IReadOnlySet_1(): IReadOnlySet_1$instance<T>;
    As_ISet_1(): ISet_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface TreeSet_1$instance<T> extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type TreeSet_1<T> = TreeSet_1$instance<T> & __TreeSet_1$views<T>;


export abstract class CollectionExtensions$instance {
    static addRange<T>(list: List_1<T>, source: ReadOnlySpan_1<T>): void;
    static asReadOnly<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>): ReadOnlyDictionary_2<TKey, TValue>;
    static asReadOnly<T>(list: IList_1<T>): ReadOnlyCollection_1<T>;
    static asReadOnly<T>(set_: ISet_1<T>): ReadOnlySet_1<T>;
    static copyTo<T>(list: List_1<T>, destination: Span_1<T>): void;
    static getValueOrDefault<TKey, TValue>(dictionary: IReadOnlyDictionary_2<TKey, TValue>, key: TKey, defaultValue: TValue): TValue;
    static getValueOrDefault<TKey, TValue>(dictionary: IReadOnlyDictionary_2<TKey, TValue>, key: TKey): TValue;
    static insertRange<T>(list: List_1<T>, index: int, source: ReadOnlySpan_1<T>): void;
    static remove<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>, key: TKey, value: { value: ref<TValue> }): boolean;
    static tryAdd<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>, key: TKey, value: TValue): boolean;
}


export type CollectionExtensions = CollectionExtensions$instance;

export abstract class KeyValuePair$instance {
    static create<TKey, TValue>(key: TKey, value: TValue): KeyValuePair_2<TKey, TValue>;
}


export type KeyValuePair = KeyValuePair$instance;

