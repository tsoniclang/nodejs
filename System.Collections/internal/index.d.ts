// Generated by tsbindgen - Architecture
// Namespace: System.Collections
// Assembly: System.Collections, System.Collections.NonGeneric, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { CultureInfo } from "../../System.Globalization/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Boolean as ClrBoolean, Byte, ICloneable, Int32, Object as ClrObject, Single, String as ClrString, Type, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface ICollection$instance extends IEnumerable {
    readonly count: int;
    readonly syncRoot: unknown;
    readonly isSynchronized: boolean;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator;
}


export interface ICollection$instance extends IEnumerable$instance {}

export type ICollection = ICollection$instance;

export interface IComparer$instance {
    compare(x: unknown, y: unknown): int;
}


export type IComparer = IComparer$instance;

export interface IDictionary$instance extends ICollection, IEnumerable {
    item: unknown;
    readonly keys: ICollection;
    readonly values: ICollection;
    readonly isReadOnly: boolean;
    readonly isFixedSize: boolean;
    readonly count: int;
    readonly syncRoot: unknown;
    readonly isSynchronized: boolean;
    add(key: unknown, value: unknown): void;
    clear(): void;
    contains(key: unknown): boolean;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IDictionaryEnumerator;
    getEnumerator(): IEnumerator;
    remove(key: unknown): void;
}


export type IDictionary = IDictionary$instance;

export interface IDictionaryEnumerator$instance extends IEnumerator {
    readonly key: unknown;
    readonly value: unknown;
    readonly entry: DictionaryEntry;
    readonly current: unknown;
    moveNext(): boolean;
    reset(): void;
}


export interface IDictionaryEnumerator$instance extends IEnumerator$instance {}

export type IDictionaryEnumerator = IDictionaryEnumerator$instance;

export interface IEnumerable$instance {
    getEnumerator(): IEnumerator;
}


export type IEnumerable = IEnumerable$instance;

export interface IEnumerator$instance {
    readonly current: unknown;
    moveNext(): boolean;
    reset(): void;
}


export type IEnumerator = IEnumerator$instance;

export interface IEqualityComparer$instance {
    equals(x: unknown, y: unknown): boolean;
    getHashCode(obj: unknown): int;
}


export type IEqualityComparer = IEqualityComparer$instance;

export interface IHashCodeProvider$instance {
    getHashCode(obj: unknown): int;
}


export type IHashCodeProvider = IHashCodeProvider$instance;

export interface IList$instance extends ICollection, IEnumerable {
    item: unknown;
    readonly isReadOnly: boolean;
    readonly isFixedSize: boolean;
    readonly count: int;
    readonly syncRoot: unknown;
    readonly isSynchronized: boolean;
    add(value: unknown): int;
    clear(): void;
    contains(value: unknown): boolean;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator;
    insert(index: int, value: unknown): void;
    remove(value: unknown): void;
    removeAt(index: int): void;
}


export type IList = IList$instance;

export interface IStructuralComparable$instance {
    compareTo(other: unknown, comparer: IComparer): int;
}


export type IStructuralComparable = IStructuralComparable$instance;

export interface IStructuralEquatable$instance {
    equals(other: unknown, comparer: IEqualityComparer): boolean;
    getHashCode(comparer: IEqualityComparer): int;
}


export type IStructuralEquatable = IStructuralEquatable$instance;

export interface DictionaryEntry$instance {
    key: unknown;
    value: unknown;
    deconstruct(key: { value: ref<unknown> }, value: { value: ref<unknown> }): void;
    toString(): string;
}


export const DictionaryEntry: {
    new(key: unknown, value: unknown): DictionaryEntry$instance;
};


export type DictionaryEntry = DictionaryEntry$instance;

export interface ArrayList$instance {
    capacity: int;
    readonly count: int;
    readonly isFixedSize: boolean;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    item: unknown;
    readonly syncRoot: unknown;
    add(value: unknown): int;
    addRange(c: ICollection): void;
    binarySearch(index: int, count: int, value: unknown, comparer: IComparer): int;
    binarySearch(value: unknown): int;
    binarySearch(value: unknown, comparer: IComparer): int;
    clear(): void;
    clone(): unknown;
    contains(item: unknown): boolean;
    copyTo(array: ClrArray): void;
    copyTo(array: ClrArray, arrayIndex: int): void;
    copyTo(index: int, array: ClrArray, arrayIndex: int, count: int): void;
    getEnumerator(): IEnumerator;
    getEnumerator(index: int, count: int): IEnumerator;
    getRange(index: int, count: int): ArrayList;
    indexOf(value: unknown): int;
    indexOf(value: unknown, startIndex: int): int;
    indexOf(value: unknown, startIndex: int, count: int): int;
    insert(index: int, value: unknown): void;
    insertRange(index: int, c: ICollection): void;
    lastIndexOf(value: unknown): int;
    lastIndexOf(value: unknown, startIndex: int): int;
    lastIndexOf(value: unknown, startIndex: int, count: int): int;
    remove(obj: unknown): void;
    removeAt(index: int): void;
    removeRange(index: int, count: int): void;
    reverse(): void;
    reverse(index: int, count: int): void;
    setRange(index: int, c: ICollection): void;
    sort(): void;
    sort(comparer: IComparer): void;
    sort(index: int, count: int, comparer: IComparer): void;
    toArray(): unknown[];
    toArray(type_: Type): ClrArray;
    trimToSize(): void;
}


export const ArrayList: {
    new(): ArrayList$instance;
    new(capacity: int): ArrayList$instance;
    new(c: ICollection): ArrayList$instance;
    adapter(list: IList): ArrayList;
    fixedSize(list: ArrayList): ArrayList;
    fixedSize(list: IList): IList;
    readOnly(list: ArrayList): ArrayList;
    readOnly(list: IList): IList;
    repeat(value: unknown, count: int): ArrayList;
    synchronized(list: ArrayList): ArrayList;
    synchronized(list: IList): IList;
};


export interface __ArrayList$views {
    As_ICollection(): ICollection$instance;
    As_IEnumerable(): IEnumerable$instance;
    As_IList(): IList$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface ArrayList$instance extends System_Internal.ICloneable$instance {}

export type ArrayList = ArrayList$instance & __ArrayList$views;


export interface BitArray$instance {
    readonly count: int;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    item: boolean;
    length: int;
    readonly syncRoot: unknown;
    and(value: BitArray): BitArray;
    clone(): unknown;
    copyTo(array: ClrArray, index: int): void;
    get_(index: int): boolean;
    getEnumerator(): IEnumerator;
    hasAllSet(): boolean;
    hasAnySet(): boolean;
    leftShift(count: int): BitArray;
    not(): BitArray;
    or(value: BitArray): BitArray;
    rightShift(count: int): BitArray;
    set_(index: int, value: boolean): void;
    setAll(value: boolean): void;
    xor(value: BitArray): BitArray;
}


export const BitArray: {
    new(length: int): BitArray$instance;
    new(length: int, defaultValue: boolean): BitArray$instance;
    new(bytes: byte[]): BitArray$instance;
    new(values: boolean[]): BitArray$instance;
    new(values: int[]): BitArray$instance;
    new(bits: BitArray): BitArray$instance;
};


export interface __BitArray$views {
    As_ICollection(): ICollection$instance;
    As_IEnumerable(): IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface BitArray$instance extends System_Internal.ICloneable$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type BitArray = BitArray$instance & __BitArray$views;


export interface CaseInsensitiveComparer$instance {
    compare(a: unknown, b: unknown): int;
}


export const CaseInsensitiveComparer: {
    new(): CaseInsensitiveComparer$instance;
    new(culture: CultureInfo): CaseInsensitiveComparer$instance;
    readonly default_: CaseInsensitiveComparer;
    readonly defaultInvariant: CaseInsensitiveComparer;
};


export interface __CaseInsensitiveComparer$views {
    As_IComparer(): IComparer$instance;
}

export interface CaseInsensitiveComparer$instance extends IComparer$instance {}

export type CaseInsensitiveComparer = CaseInsensitiveComparer$instance & __CaseInsensitiveComparer$views;


export interface CaseInsensitiveHashCodeProvider$instance {
    getHashCode(obj: unknown): int;
}


export const CaseInsensitiveHashCodeProvider: {
    new(): CaseInsensitiveHashCodeProvider$instance;
    new(culture: CultureInfo): CaseInsensitiveHashCodeProvider$instance;
    readonly default_: CaseInsensitiveHashCodeProvider;
    readonly defaultInvariant: CaseInsensitiveHashCodeProvider;
};


export interface __CaseInsensitiveHashCodeProvider$views {
    As_IHashCodeProvider(): IHashCodeProvider$instance;
}

export type CaseInsensitiveHashCodeProvider = CaseInsensitiveHashCodeProvider$instance & __CaseInsensitiveHashCodeProvider$views;


export interface CollectionBase$instance {
    capacity: int;
    readonly count: int;
    clear(): void;
    getEnumerator(): IEnumerator;
    removeAt(index: int): void;
}


export const CollectionBase: {
};


export interface __CollectionBase$views {
    As_ICollection(): ICollection$instance;
    As_IEnumerable(): IEnumerable$instance;
    As_IList(): IList$instance;
}

export type CollectionBase = CollectionBase$instance & __CollectionBase$views;


export interface Comparer$instance {
    compare(a: unknown, b: unknown): int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const Comparer: {
    new(culture: CultureInfo): Comparer$instance;
    readonly default_: Comparer;
    readonly defaultInvariant: Comparer;
};


export interface __Comparer$views {
    As_IComparer(): IComparer$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Comparer$instance extends IComparer$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Comparer = Comparer$instance & __Comparer$views;


export interface DictionaryBase$instance {
    readonly count: int;
    clear(): void;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IDictionaryEnumerator;
}


export const DictionaryBase: {
};


export interface __DictionaryBase$views {
    As_ICollection(): ICollection$instance;
    As_IDictionary(): IDictionary$instance;
    As_IEnumerable(): IEnumerable$instance;
}

export type DictionaryBase = DictionaryBase$instance & __DictionaryBase$views;


export interface Hashtable$instance {
    readonly count: int;
    readonly isFixedSize: boolean;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    item: unknown;
    readonly keys: ICollection;
    readonly syncRoot: unknown;
    readonly values: ICollection;
    add(key: unknown, value: unknown): void;
    clear(): void;
    clone(): unknown;
    contains(key: unknown): boolean;
    containsKey(key: unknown): boolean;
    containsValue(value: unknown): boolean;
    copyTo(array: ClrArray, arrayIndex: int): void;
    getEnumerator(): IDictionaryEnumerator;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    onDeserialization(sender: unknown): void;
    remove(key: unknown): void;
}


export const Hashtable: {
    new(): Hashtable$instance;
    new(capacity: int): Hashtable$instance;
    new(capacity: int, loadFactor: float): Hashtable$instance;
    new(capacity: int, loadFactor: float, equalityComparer: IEqualityComparer): Hashtable$instance;
    new(hcp: IHashCodeProvider, comparer: IComparer): Hashtable$instance;
    new(equalityComparer: IEqualityComparer): Hashtable$instance;
    new(capacity: int, hcp: IHashCodeProvider, comparer: IComparer): Hashtable$instance;
    new(capacity: int, equalityComparer: IEqualityComparer): Hashtable$instance;
    new(d: IDictionary): Hashtable$instance;
    new(d: IDictionary, loadFactor: float): Hashtable$instance;
    new(d: IDictionary, hcp: IHashCodeProvider, comparer: IComparer): Hashtable$instance;
    new(d: IDictionary, equalityComparer: IEqualityComparer): Hashtable$instance;
    new(capacity: int, loadFactor: float, hcp: IHashCodeProvider, comparer: IComparer): Hashtable$instance;
    new(d: IDictionary, loadFactor: float, hcp: IHashCodeProvider, comparer: IComparer): Hashtable$instance;
    new(d: IDictionary, loadFactor: float, equalityComparer: IEqualityComparer): Hashtable$instance;
    synchronized(table: Hashtable): Hashtable;
};


export interface __Hashtable$views {
    As_ICollection(): ICollection$instance;
    As_IDictionary(): IDictionary$instance;
    As_IEnumerable(): IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Hashtable$instance extends System_Internal.ICloneable$instance, System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Hashtable = Hashtable$instance & __Hashtable$views;


export interface ListDictionaryInternal$instance {
    readonly count: int;
    readonly isFixedSize: boolean;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    item: unknown;
    readonly keys: ICollection;
    readonly syncRoot: unknown;
    readonly values: ICollection;
    add(key: unknown, value: unknown): void;
    clear(): void;
    contains(key: unknown): boolean;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IDictionaryEnumerator;
    remove(key: unknown): void;
}


export const ListDictionaryInternal: {
    new(): ListDictionaryInternal$instance;
};


export interface __ListDictionaryInternal$views {
    As_ICollection(): ICollection$instance;
    As_IDictionary(): IDictionary$instance;
    As_IEnumerable(): IEnumerable$instance;
}

export type ListDictionaryInternal = ListDictionaryInternal$instance & __ListDictionaryInternal$views;


export interface Queue$instance {
    readonly count: int;
    readonly isSynchronized: boolean;
    readonly syncRoot: unknown;
    clear(): void;
    clone(): unknown;
    contains(obj: unknown): boolean;
    copyTo(array: ClrArray, index: int): void;
    dequeue(): unknown;
    enqueue(obj: unknown): void;
    getEnumerator(): IEnumerator;
    peek(): unknown;
    toArray(): unknown[];
    trimToSize(): void;
}


export const Queue: {
    new(): Queue$instance;
    new(capacity: int): Queue$instance;
    new(capacity: int, growFactor: float): Queue$instance;
    new(col: ICollection): Queue$instance;
    synchronized(queue: Queue): Queue;
};


export interface __Queue$views {
    As_ICollection(): ICollection$instance;
    As_IEnumerable(): IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface Queue$instance extends System_Internal.ICloneable$instance {}

export type Queue = Queue$instance & __Queue$views;


export interface ReadOnlyCollectionBase$instance {
    readonly count: int;
    getEnumerator(): IEnumerator;
}


export const ReadOnlyCollectionBase: {
};


export interface __ReadOnlyCollectionBase$views {
    As_ICollection(): ICollection$instance;
    As_IEnumerable(): IEnumerable$instance;
}

export type ReadOnlyCollectionBase = ReadOnlyCollectionBase$instance & __ReadOnlyCollectionBase$views;


export interface SortedList$instance {
    capacity: int;
    readonly count: int;
    readonly isFixedSize: boolean;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    item: unknown;
    readonly keys: ICollection;
    readonly syncRoot: unknown;
    readonly values: ICollection;
    add(key: unknown, value: unknown): void;
    clear(): void;
    clone(): unknown;
    contains(key: unknown): boolean;
    containsKey(key: unknown): boolean;
    containsValue(value: unknown): boolean;
    copyTo(array: ClrArray, arrayIndex: int): void;
    getByIndex(index: int): unknown;
    getEnumerator(): IDictionaryEnumerator;
    getKey(index: int): unknown;
    getKeyList(): IList;
    getValueList(): IList;
    indexOfKey(key: unknown): int;
    indexOfValue(value: unknown): int;
    remove(key: unknown): void;
    removeAt(index: int): void;
    setByIndex(index: int, value: unknown): void;
    trimToSize(): void;
}


export const SortedList: {
    new(): SortedList$instance;
    new(initialCapacity: int): SortedList$instance;
    new(comparer: IComparer): SortedList$instance;
    new(comparer: IComparer, capacity: int): SortedList$instance;
    new(d: IDictionary): SortedList$instance;
    new(d: IDictionary, comparer: IComparer): SortedList$instance;
    synchronized(list: SortedList): SortedList;
};


export interface __SortedList$views {
    As_ICollection(): ICollection$instance;
    As_IDictionary(): IDictionary$instance;
    As_IEnumerable(): IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface SortedList$instance extends System_Internal.ICloneable$instance {}

export type SortedList = SortedList$instance & __SortedList$views;


export interface Stack$instance {
    readonly count: int;
    readonly isSynchronized: boolean;
    readonly syncRoot: unknown;
    clear(): void;
    clone(): unknown;
    contains(obj: unknown): boolean;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator;
    peek(): unknown;
    pop(): unknown;
    push(obj: unknown): void;
    toArray(): unknown[];
}


export const Stack: {
    new(): Stack$instance;
    new(initialCapacity: int): Stack$instance;
    new(col: ICollection): Stack$instance;
    synchronized(stack: Stack): Stack;
};


export interface __Stack$views {
    As_ICollection(): ICollection$instance;
    As_IEnumerable(): IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface Stack$instance extends System_Internal.ICloneable$instance {}

export type Stack = Stack$instance & __Stack$views;


export abstract class StructuralComparisons$instance {
    static readonly structuralComparer: IComparer;
    static readonly structuralEqualityComparer: IEqualityComparer;
}


export type StructuralComparisons = StructuralComparisons$instance;

