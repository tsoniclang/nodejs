// Generated by tsbindgen - Architecture
// Namespace: System.Linq
// Assembly: System.Collections.Immutable, System.Linq, System.Linq.AsyncEnumerable, System.Linq.Expressions, System.Linq.Parallel, System.Linq.Queryable

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { Partitioner_1 } from "../../System.Collections.Concurrent/internal/index.js";
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { Dictionary_2, HashSet_1, IAsyncEnumerable_1, IAsyncEnumerator_1, IComparer_1, IEnumerable_1, IEnumerator_1, IEqualityComparer_1, KeyValuePair_2, List_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ImmutableArray_1, ImmutableArray_1_Builder } from "../../System.Collections.Immutable/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { Expression, Expression_1 } from "../../System.Linq.Expressions/internal/index.js";
import type { IAdditionOperators_3, INumber_1 } from "../../System.Numerics/internal/index.js";
import type { ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Boolean as ClrBoolean, Decimal, Double, Enum, Func_1, Func_2, Func_3, Func_4, IComparable, IConvertible, IFormatProvider, IFormattable, Index, Int32, Int64, ISpanFormattable, Nullable_1, Object as ClrObject, Range, Single, String as ClrString, Type, TypeCode, ValueTuple_2, ValueTuple_3, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum ParallelExecutionMode {
    default_ = 0,
    forceParallelism = 1
}


export enum ParallelMergeOptions {
    default_ = 0,
    notBuffered = 1,
    autoBuffered = 2,
    fullyBuffered = 3
}


export interface IGrouping_2$instance<TKey, TElement> extends IEnumerable_1<TElement>, IEnumerable {
    readonly key: TKey;
    getEnumerator(): IEnumerator_1<TElement>;
    getEnumerator(): IEnumerator;
}


export type IGrouping_2<TKey, TElement> = IGrouping_2$instance<TKey, TElement>;

export interface ILookup_2$instance<TKey, TElement> extends IEnumerable_1<IGrouping_2<TKey, TElement>>, IEnumerable {
    readonly count: int;
    readonly item: IEnumerable_1<TElement>;
    contains(key: TKey): boolean;
    getEnumerator(): IEnumerator_1<IGrouping_2<TKey, TElement>>;
    getEnumerator(): IEnumerator;
}


export type ILookup_2<TKey, TElement> = ILookup_2$instance<TKey, TElement>;

export interface IOrderedAsyncEnumerable_1$instance<TElement> extends IAsyncEnumerable_1<TElement> {
    createOrderedAsyncEnumerable<TKey>(keySelector: Func_2<TElement, TKey>, comparer: IComparer_1<TKey>, descending: boolean): IOrderedAsyncEnumerable_1<TElement>;
    createOrderedAsyncEnumerable<TKey>(keySelector: Func_3<TElement, CancellationToken, ValueTask_1<TKey>>, comparer: IComparer_1<TKey>, descending: boolean): IOrderedAsyncEnumerable_1<TElement>;
    getAsyncEnumerator(cancellationToken?: CancellationToken): IAsyncEnumerator_1<TElement>;
}


export interface IOrderedAsyncEnumerable_1$instance<TElement> extends System_Collections_Generic_Internal.IAsyncEnumerable_1$instance<TElement> {}

export type IOrderedAsyncEnumerable_1<TElement> = IOrderedAsyncEnumerable_1$instance<TElement>;

export interface IOrderedEnumerable_1$instance<TElement> extends IEnumerable_1<TElement>, IEnumerable {
    createOrderedEnumerable<TKey>(keySelector: Func_2<TElement, TKey>, comparer: IComparer_1<TKey>, descending: boolean): IOrderedEnumerable_1<TElement>;
    getEnumerator(): IEnumerator_1<TElement>;
    getEnumerator(): IEnumerator;
}


export type IOrderedEnumerable_1<TElement> = IOrderedEnumerable_1$instance<TElement>;

export interface IOrderedQueryable$instance extends IQueryable, IEnumerable {
    readonly expression: Expression;
    readonly elementType: Type;
    readonly provider: IQueryProvider;
    getEnumerator(): IEnumerator;
}


export type IOrderedQueryable = IOrderedQueryable$instance;

export interface IOrderedQueryable_1$instance<T> extends IQueryable_1<T>, IEnumerable_1<T>, IEnumerable, IQueryable, IOrderedQueryable {
    readonly expression: Expression;
    readonly elementType: Type;
    readonly provider: IQueryProvider;
    getEnumerator(): IEnumerator_1<T>;
    getEnumerator(): IEnumerator;
}


export type IOrderedQueryable_1<T> = IOrderedQueryable_1$instance<T>;

export interface IQueryable$instance extends IEnumerable {
    readonly expression: Expression;
    readonly elementType: Type;
    readonly provider: IQueryProvider;
    getEnumerator(): IEnumerator;
}


export interface IQueryable$instance extends System_Collections_Internal.IEnumerable$instance {}

export type IQueryable = IQueryable$instance;

export interface IQueryable_1$instance<T> extends IEnumerable_1<T>, IEnumerable, IQueryable {
    readonly expression: Expression;
    readonly elementType: Type;
    readonly provider: IQueryProvider;
    getEnumerator(): IEnumerator_1<T>;
    getEnumerator(): IEnumerator;
}


export type IQueryable_1<T> = IQueryable_1$instance<T>;

export interface IQueryProvider$instance {
    createQuery<TElement>(expression: Expression): IQueryable_1<TElement>;
    createQuery(expression: Expression): IQueryable;
    execute(expression: Expression): unknown;
    execute<TResult>(expression: Expression): TResult;
}


export type IQueryProvider = IQueryProvider$instance;

export interface EnumerableExecutor$instance {
}


export const EnumerableExecutor: {
};


export type EnumerableExecutor = EnumerableExecutor$instance;

export interface EnumerableExecutor_1$instance<T> extends EnumerableExecutor {
}


export const EnumerableExecutor_1: {
    new<T>(expression: Expression): EnumerableExecutor_1$instance<T>;
};


export type EnumerableExecutor_1<T> = EnumerableExecutor_1$instance<T>;

export interface EnumerableQuery$instance {
}


export const EnumerableQuery: {
};


export type EnumerableQuery = EnumerableQuery$instance;

export interface EnumerableQuery_1$instance<T> extends EnumerableQuery {
    toString(): string;
}


export const EnumerableQuery_1: {
    new<T>(enumerable: IEnumerable_1<T>): EnumerableQuery_1$instance<T>;
    new<T>(expression: Expression): EnumerableQuery_1$instance<T>;
};


export interface __EnumerableQuery_1$views<T> {
    As_IQueryable(): IQueryable$instance;
    As_IQueryProvider(): IQueryProvider$instance;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export interface EnumerableQuery_1$instance<T> extends IOrderedQueryable_1$instance<T>, IQueryProvider$instance {}

export type EnumerableQuery_1<T> = EnumerableQuery_1$instance<T> & __EnumerableQuery_1$views<T>;


export interface Lookup_2$instance<TKey, TElement> {
    readonly count: int;
    readonly item: IEnumerable_1<TElement>;
    applyResultSelector<TResult>(resultSelector: Func_3<TKey, IEnumerable_1<TElement>, TResult>): IEnumerable_1<TResult>;
    contains(key: TKey): boolean;
    getEnumerator(): IEnumerator_1<IGrouping_2<TKey, TElement>>;
}


export const Lookup_2: {
    new<TKey, TElement>(): Lookup_2$instance<TKey, TElement>;
};


export interface __Lookup_2$views<TKey, TElement> {
    As_ILookup_2(): ILookup_2$instance<TKey, TElement>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<IGrouping_2<TKey, TElement>>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type Lookup_2<TKey, TElement> = Lookup_2$instance<TKey, TElement> & __Lookup_2$views<TKey, TElement>;


export interface OrderedParallelQuery_1$instance<TSource> extends ParallelQuery_1$instance<TSource> {
    getEnumerator(): IEnumerator_1<TSource>;
    getEnumerator(): IEnumerator_1<TSource>;
    getEnumerator(): IEnumerator;
}


export const OrderedParallelQuery_1: {
    new<TSource>(): OrderedParallelQuery_1$instance<TSource>;
};


export interface __OrderedParallelQuery_1$views<TSource> {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<TSource>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type OrderedParallelQuery_1<TSource> = OrderedParallelQuery_1$instance<TSource> & __OrderedParallelQuery_1$views<TSource>;


export interface ParallelQuery$instance {
}


export const ParallelQuery: {
    new(): ParallelQuery$instance;
};


export interface __ParallelQuery$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export interface ParallelQuery$instance extends System_Collections_Internal.IEnumerable$instance {}

export type ParallelQuery = ParallelQuery$instance & __ParallelQuery$views;


export interface ParallelQuery_1$instance<TSource> extends ParallelQuery$instance {
    getEnumerator(): IEnumerator;
}


export const ParallelQuery_1: {
    new<TSource>(): ParallelQuery_1$instance<TSource>;
};


export interface __ParallelQuery_1$views<TSource> {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<TSource>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ParallelQuery_1<TSource> = ParallelQuery_1$instance<TSource> & __ParallelQuery_1$views<TSource>;


export abstract class AsyncEnumerable$instance {
    static aggregateAsync<TSource>(source: IAsyncEnumerable_1<TSource>, func: Func_3<TSource, TSource, TSource>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static aggregateAsync<TSource>(source: IAsyncEnumerable_1<TSource>, func: Func_4<TSource, TSource, CancellationToken, ValueTask_1<TSource>>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static aggregateAsync<TSource, TAccumulate, TResult>(source: IAsyncEnumerable_1<TSource>, seed: TAccumulate, func: Func_3<TAccumulate, TSource, TAccumulate>, resultSelector: Func_2<TAccumulate, TResult>, cancellationToken?: CancellationToken): ValueTask_1<TResult>;
    static aggregateAsync<TSource, TAccumulate>(source: IAsyncEnumerable_1<TSource>, seed: TAccumulate, func: Func_3<TAccumulate, TSource, TAccumulate>, cancellationToken?: CancellationToken): ValueTask_1<TAccumulate>;
    static aggregateAsync<TSource, TAccumulate, TResult>(source: IAsyncEnumerable_1<TSource>, seed: TAccumulate, func: Func_4<TAccumulate, TSource, CancellationToken, ValueTask_1<TAccumulate>>, resultSelector: Func_3<TAccumulate, CancellationToken, ValueTask_1<TResult>>, cancellationToken?: CancellationToken): ValueTask_1<TResult>;
    static aggregateAsync<TSource, TAccumulate>(source: IAsyncEnumerable_1<TSource>, seed: TAccumulate, func: Func_4<TAccumulate, TSource, CancellationToken, ValueTask_1<TAccumulate>>, cancellationToken?: CancellationToken): ValueTask_1<TAccumulate>;
    static aggregateBy<TSource, TKey, TAccumulate>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, seedSelector: Func_2<TKey, TAccumulate>, func: Func_3<TAccumulate, TSource, TAccumulate>, keyComparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<KeyValuePair_2<TKey, TAccumulate>>;
    static aggregateBy<TSource, TKey, TAccumulate>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, seed: TAccumulate, func: Func_3<TAccumulate, TSource, TAccumulate>, keyComparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<KeyValuePair_2<TKey, TAccumulate>>;
    static aggregateBy<TSource, TKey, TAccumulate>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_3<TSource, CancellationToken, ValueTask_1<TKey>>, seedSelector: Func_3<TKey, CancellationToken, ValueTask_1<TAccumulate>>, func: Func_4<TAccumulate, TSource, CancellationToken, ValueTask_1<TAccumulate>>, keyComparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<KeyValuePair_2<TKey, TAccumulate>>;
    static aggregateBy<TSource, TKey, TAccumulate>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_3<TSource, CancellationToken, ValueTask_1<TKey>>, seed: TAccumulate, func: Func_4<TAccumulate, TSource, CancellationToken, ValueTask_1<TAccumulate>>, keyComparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<KeyValuePair_2<TKey, TAccumulate>>;
    static allAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<boolean>>;
    static allAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_3<TSource, CancellationToken, ValueTask_1<CLROf<boolean>>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<boolean>>;
    static anyAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<boolean>>;
    static anyAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_3<TSource, CancellationToken, ValueTask_1<CLROf<boolean>>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<boolean>>;
    static anyAsync<TSource>(source: IAsyncEnumerable_1<TSource>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<boolean>>;
    static append<TSource>(source: IAsyncEnumerable_1<TSource>, element: TSource): IAsyncEnumerable_1<TSource>;
    static averageAsync(source: IAsyncEnumerable_1<CLROf<decimal>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<decimal>>;
    static averageAsync(source: IAsyncEnumerable_1<CLROf<double>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<double>>;
    static averageAsync(source: IAsyncEnumerable_1<CLROf<int>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<double>>;
    static averageAsync(source: IAsyncEnumerable_1<CLROf<long>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<double>>;
    static averageAsync(source: IAsyncEnumerable_1<Nullable_1<CLROf<decimal>>>, cancellationToken?: CancellationToken): ValueTask_1<Nullable_1<CLROf<decimal>>>;
    static averageAsync(source: IAsyncEnumerable_1<Nullable_1<CLROf<double>>>, cancellationToken?: CancellationToken): ValueTask_1<Nullable_1<CLROf<double>>>;
    static averageAsync(source: IAsyncEnumerable_1<Nullable_1<CLROf<int>>>, cancellationToken?: CancellationToken): ValueTask_1<Nullable_1<CLROf<double>>>;
    static averageAsync(source: IAsyncEnumerable_1<Nullable_1<CLROf<long>>>, cancellationToken?: CancellationToken): ValueTask_1<Nullable_1<CLROf<double>>>;
    static averageAsync(source: IAsyncEnumerable_1<Nullable_1<CLROf<float>>>, cancellationToken?: CancellationToken): ValueTask_1<Nullable_1<CLROf<float>>>;
    static averageAsync(source: IAsyncEnumerable_1<CLROf<float>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<float>>;
    static cast<TResult>(source: IAsyncEnumerable_1<unknown>): IAsyncEnumerable_1<TResult>;
    static chunk<TSource>(source: IAsyncEnumerable_1<TSource>, size: int): IAsyncEnumerable_1<TSource[]>;
    static concat<TSource>(first: IAsyncEnumerable_1<TSource>, second: IAsyncEnumerable_1<TSource>): IAsyncEnumerable_1<TSource>;
    static containsAsync<TSource>(source: IAsyncEnumerable_1<TSource>, value: TSource, comparer?: IEqualityComparer_1<TSource>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<boolean>>;
    static countAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static countAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_3<TSource, CancellationToken, ValueTask_1<CLROf<boolean>>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static countAsync<TSource>(source: IAsyncEnumerable_1<TSource>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static countBy<TSource, TKey>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, keyComparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<KeyValuePair_2<TKey, CLROf<int>>>;
    static countBy<TSource, TKey>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_3<TSource, CancellationToken, ValueTask_1<TKey>>, keyComparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<KeyValuePair_2<TKey, CLROf<int>>>;
    static defaultIfEmpty<TSource>(source: IAsyncEnumerable_1<TSource>, defaultValue: TSource): IAsyncEnumerable_1<TSource>;
    static defaultIfEmpty<TSource>(source: IAsyncEnumerable_1<TSource>): IAsyncEnumerable_1<TSource>;
    static distinct<TSource>(source: IAsyncEnumerable_1<TSource>, comparer?: IEqualityComparer_1<TSource>): IAsyncEnumerable_1<TSource>;
    static distinctBy<TSource, TKey>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<TSource>;
    static distinctBy<TSource, TKey>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_3<TSource, CancellationToken, ValueTask_1<TKey>>, comparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<TSource>;
    static elementAtAsync<TSource>(source: IAsyncEnumerable_1<TSource>, index: Index, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static elementAtAsync<TSource>(source: IAsyncEnumerable_1<TSource>, index: int, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static elementAtOrDefaultAsync<TSource>(source: IAsyncEnumerable_1<TSource>, index: Index, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static elementAtOrDefaultAsync<TSource>(source: IAsyncEnumerable_1<TSource>, index: int, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static empty<TResult>(): IAsyncEnumerable_1<TResult>;
    static except<TSource>(first: IAsyncEnumerable_1<TSource>, second: IAsyncEnumerable_1<TSource>, comparer?: IEqualityComparer_1<TSource>): IAsyncEnumerable_1<TSource>;
    static exceptBy<TSource, TKey>(first: IAsyncEnumerable_1<TSource>, second: IAsyncEnumerable_1<TKey>, keySelector: Func_2<TSource, TKey>, comparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<TSource>;
    static exceptBy<TSource, TKey>(first: IAsyncEnumerable_1<TSource>, second: IAsyncEnumerable_1<TKey>, keySelector: Func_3<TSource, CancellationToken, ValueTask_1<TKey>>, comparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<TSource>;
    static firstAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static firstAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_3<TSource, CancellationToken, ValueTask_1<CLROf<boolean>>>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static firstAsync<TSource>(source: IAsyncEnumerable_1<TSource>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static firstOrDefaultAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static firstOrDefaultAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>, defaultValue: TSource, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static firstOrDefaultAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_3<TSource, CancellationToken, ValueTask_1<CLROf<boolean>>>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static firstOrDefaultAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_3<TSource, CancellationToken, ValueTask_1<CLROf<boolean>>>, defaultValue: TSource, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static firstOrDefaultAsync<TSource>(source: IAsyncEnumerable_1<TSource>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static firstOrDefaultAsync<TSource>(source: IAsyncEnumerable_1<TSource>, defaultValue: TSource, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static groupBy<TSource, TKey, TElement, TResult>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TElement>, resultSelector: Func_3<TKey, IEnumerable_1<TElement>, TResult>, comparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<TResult>;
    static groupBy<TSource, TKey, TElement>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TElement>, comparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<IGrouping_2<TKey, TElement>>;
    static groupBy<TSource, TKey, TResult>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, resultSelector: Func_3<TKey, IEnumerable_1<TSource>, TResult>, comparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<TResult>;
    static groupBy<TSource, TKey>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<IGrouping_2<TKey, TSource>>;
    static groupBy<TSource, TKey, TElement, TResult>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_3<TSource, CancellationToken, ValueTask_1<TKey>>, elementSelector: Func_3<TSource, CancellationToken, ValueTask_1<TElement>>, resultSelector: Func_4<TKey, IEnumerable_1<TElement>, CancellationToken, ValueTask_1<TResult>>, comparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<TResult>;
    static groupBy<TSource, TKey, TElement>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_3<TSource, CancellationToken, ValueTask_1<TKey>>, elementSelector: Func_3<TSource, CancellationToken, ValueTask_1<TElement>>, comparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<IGrouping_2<TKey, TElement>>;
    static groupBy<TSource, TKey, TResult>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_3<TSource, CancellationToken, ValueTask_1<TKey>>, resultSelector: Func_4<TKey, IEnumerable_1<TSource>, CancellationToken, ValueTask_1<TResult>>, comparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<TResult>;
    static groupBy<TSource, TKey>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_3<TSource, CancellationToken, ValueTask_1<TKey>>, comparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<IGrouping_2<TKey, TSource>>;
    static groupJoin<TOuter, TInner, TKey, TResult>(outer: IAsyncEnumerable_1<TOuter>, inner: IAsyncEnumerable_1<TInner>, outerKeySelector: Func_2<TOuter, TKey>, innerKeySelector: Func_2<TInner, TKey>, resultSelector: Func_3<TOuter, IEnumerable_1<TInner>, TResult>, comparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<TResult>;
    static groupJoin<TOuter, TInner, TKey, TResult>(outer: IAsyncEnumerable_1<TOuter>, inner: IAsyncEnumerable_1<TInner>, outerKeySelector: Func_3<TOuter, CancellationToken, ValueTask_1<TKey>>, innerKeySelector: Func_3<TInner, CancellationToken, ValueTask_1<TKey>>, resultSelector: Func_4<TOuter, IEnumerable_1<TInner>, CancellationToken, ValueTask_1<TResult>>, comparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<TResult>;
    static index<TSource>(source: IAsyncEnumerable_1<TSource>): IAsyncEnumerable_1<ValueTuple_2<CLROf<int>, TSource>>;
    static infiniteSequence<T extends IAdditionOperators_3<T, T, T>>(start: T, step: T): IAsyncEnumerable_1<T>;
    static intersect<TSource>(first: IAsyncEnumerable_1<TSource>, second: IAsyncEnumerable_1<TSource>, comparer?: IEqualityComparer_1<TSource>): IAsyncEnumerable_1<TSource>;
    static intersectBy<TSource, TKey>(first: IAsyncEnumerable_1<TSource>, second: IAsyncEnumerable_1<TKey>, keySelector: Func_2<TSource, TKey>, comparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<TSource>;
    static intersectBy<TSource, TKey>(first: IAsyncEnumerable_1<TSource>, second: IAsyncEnumerable_1<TKey>, keySelector: Func_3<TSource, CancellationToken, ValueTask_1<TKey>>, comparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<TSource>;
    static join<TOuter, TInner, TKey, TResult>(outer: IAsyncEnumerable_1<TOuter>, inner: IAsyncEnumerable_1<TInner>, outerKeySelector: Func_2<TOuter, TKey>, innerKeySelector: Func_2<TInner, TKey>, resultSelector: Func_3<TOuter, TInner, TResult>, comparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<TResult>;
    static join<TOuter, TInner, TKey, TResult>(outer: IAsyncEnumerable_1<TOuter>, inner: IAsyncEnumerable_1<TInner>, outerKeySelector: Func_3<TOuter, CancellationToken, ValueTask_1<TKey>>, innerKeySelector: Func_3<TInner, CancellationToken, ValueTask_1<TKey>>, resultSelector: Func_4<TOuter, TInner, CancellationToken, ValueTask_1<TResult>>, comparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<TResult>;
    static lastAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static lastAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_3<TSource, CancellationToken, ValueTask_1<CLROf<boolean>>>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static lastAsync<TSource>(source: IAsyncEnumerable_1<TSource>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static lastOrDefaultAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static lastOrDefaultAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>, defaultValue: TSource, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static lastOrDefaultAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_3<TSource, CancellationToken, ValueTask_1<CLROf<boolean>>>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static lastOrDefaultAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_3<TSource, CancellationToken, ValueTask_1<CLROf<boolean>>>, defaultValue: TSource, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static lastOrDefaultAsync<TSource>(source: IAsyncEnumerable_1<TSource>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static lastOrDefaultAsync<TSource>(source: IAsyncEnumerable_1<TSource>, defaultValue: TSource, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static leftJoin<TOuter, TInner, TKey, TResult>(outer: IAsyncEnumerable_1<TOuter>, inner: IAsyncEnumerable_1<TInner>, outerKeySelector: Func_2<TOuter, TKey>, innerKeySelector: Func_2<TInner, TKey>, resultSelector: Func_3<TOuter, TInner, TResult>, comparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<TResult>;
    static leftJoin<TOuter, TInner, TKey, TResult>(outer: IAsyncEnumerable_1<TOuter>, inner: IAsyncEnumerable_1<TInner>, outerKeySelector: Func_3<TOuter, CancellationToken, ValueTask_1<TKey>>, innerKeySelector: Func_3<TInner, CancellationToken, ValueTask_1<TKey>>, resultSelector: Func_4<TOuter, TInner, CancellationToken, ValueTask_1<TResult>>, comparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<TResult>;
    static longCountAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<long>>;
    static longCountAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_3<TSource, CancellationToken, ValueTask_1<CLROf<boolean>>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<long>>;
    static longCountAsync<TSource>(source: IAsyncEnumerable_1<TSource>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<long>>;
    static maxAsync<TSource>(source: IAsyncEnumerable_1<TSource>, comparer?: IComparer_1<TSource>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static maxByAsync<TSource, TKey>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer?: IComparer_1<TKey>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static maxByAsync<TSource, TKey>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_3<TSource, CancellationToken, ValueTask_1<TKey>>, comparer?: IComparer_1<TKey>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static minAsync<TSource>(source: IAsyncEnumerable_1<TSource>, comparer?: IComparer_1<TSource>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static minByAsync<TSource, TKey>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer?: IComparer_1<TKey>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static minByAsync<TSource, TKey>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_3<TSource, CancellationToken, ValueTask_1<TKey>>, comparer?: IComparer_1<TKey>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static ofType<TResult>(source: IAsyncEnumerable_1<unknown>): IAsyncEnumerable_1<TResult>;
    static order<T>(source: IAsyncEnumerable_1<T>, comparer?: IComparer_1<T>): IOrderedAsyncEnumerable_1<T>;
    static orderBy<TSource, TKey>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer?: IComparer_1<TKey>): IOrderedAsyncEnumerable_1<TSource>;
    static orderBy<TSource, TKey>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_3<TSource, CancellationToken, ValueTask_1<TKey>>, comparer?: IComparer_1<TKey>): IOrderedAsyncEnumerable_1<TSource>;
    static orderByDescending<TSource, TKey>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer?: IComparer_1<TKey>): IOrderedAsyncEnumerable_1<TSource>;
    static orderByDescending<TSource, TKey>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_3<TSource, CancellationToken, ValueTask_1<TKey>>, comparer?: IComparer_1<TKey>): IOrderedAsyncEnumerable_1<TSource>;
    static orderDescending<T>(source: IAsyncEnumerable_1<T>, comparer?: IComparer_1<T>): IOrderedAsyncEnumerable_1<T>;
    static prepend<TSource>(source: IAsyncEnumerable_1<TSource>, element: TSource): IAsyncEnumerable_1<TSource>;
    static range(start: int, count: int): IAsyncEnumerable_1<CLROf<int>>;
    static repeat<TResult>(element: TResult, count: int): IAsyncEnumerable_1<TResult>;
    static reverse<TSource>(source: IAsyncEnumerable_1<TSource>): IAsyncEnumerable_1<TSource>;
    static rightJoin<TOuter, TInner, TKey, TResult>(outer: IAsyncEnumerable_1<TOuter>, inner: IAsyncEnumerable_1<TInner>, outerKeySelector: Func_2<TOuter, TKey>, innerKeySelector: Func_2<TInner, TKey>, resultSelector: Func_3<TOuter, TInner, TResult>, comparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<TResult>;
    static rightJoin<TOuter, TInner, TKey, TResult>(outer: IAsyncEnumerable_1<TOuter>, inner: IAsyncEnumerable_1<TInner>, outerKeySelector: Func_3<TOuter, CancellationToken, ValueTask_1<TKey>>, innerKeySelector: Func_3<TInner, CancellationToken, ValueTask_1<TKey>>, resultSelector: Func_4<TOuter, TInner, CancellationToken, ValueTask_1<TResult>>, comparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<TResult>;
    static select<TSource, TResult>(source: IAsyncEnumerable_1<TSource>, selector: Func_2<TSource, TResult>): IAsyncEnumerable_1<TResult>;
    static select<TSource, TResult>(source: IAsyncEnumerable_1<TSource>, selector: Func_3<TSource, CancellationToken, ValueTask_1<TResult>>): IAsyncEnumerable_1<TResult>;
    static select<TSource, TResult>(source: IAsyncEnumerable_1<TSource>, selector: Func_4<TSource, CLROf<int>, CancellationToken, ValueTask_1<TResult>>): IAsyncEnumerable_1<TResult>;
    static selectMany<TSource, TCollection, TResult>(source: IAsyncEnumerable_1<TSource>, collectionSelector: Func_2<TSource, IEnumerable_1<TCollection>>, resultSelector: Func_3<TSource, TCollection, TResult>): IAsyncEnumerable_1<TResult>;
    static selectMany<TSource, TCollection, TResult>(source: IAsyncEnumerable_1<TSource>, collectionSelector: Func_2<TSource, IAsyncEnumerable_1<TCollection>>, resultSelector: Func_4<TSource, TCollection, CancellationToken, ValueTask_1<TResult>>): IAsyncEnumerable_1<TResult>;
    static selectMany<TSource, TResult>(source: IAsyncEnumerable_1<TSource>, selector: Func_2<TSource, IEnumerable_1<TResult>>): IAsyncEnumerable_1<TResult>;
    static selectMany<TSource, TCollection, TResult>(source: IAsyncEnumerable_1<TSource>, collectionSelector: Func_3<TSource, CLROf<int>, IEnumerable_1<TCollection>>, resultSelector: Func_3<TSource, TCollection, TResult>): IAsyncEnumerable_1<TResult>;
    static selectMany<TSource, TCollection, TResult>(source: IAsyncEnumerable_1<TSource>, collectionSelector: Func_3<TSource, CancellationToken, ValueTask_1<IEnumerable_1<TCollection>>>, resultSelector: Func_4<TSource, TCollection, CancellationToken, ValueTask_1<TResult>>): IAsyncEnumerable_1<TResult>;
    static selectMany<TSource, TResult>(source: IAsyncEnumerable_1<TSource>, selector: Func_3<TSource, CancellationToken, ValueTask_1<IEnumerable_1<TResult>>>): IAsyncEnumerable_1<TResult>;
    static selectMany<TSource, TCollection, TResult>(source: IAsyncEnumerable_1<TSource>, collectionSelector: Func_4<TSource, CLROf<int>, CancellationToken, ValueTask_1<IEnumerable_1<TCollection>>>, resultSelector: Func_4<TSource, TCollection, CancellationToken, ValueTask_1<TResult>>): IAsyncEnumerable_1<TResult>;
    static selectMany<TSource, TResult>(source: IAsyncEnumerable_1<TSource>, selector: Func_4<TSource, CLROf<int>, CancellationToken, ValueTask_1<IEnumerable_1<TResult>>>): IAsyncEnumerable_1<TResult>;
    static sequence<T extends INumber_1<T>>(start: T, endInclusive: T, step: T): IAsyncEnumerable_1<T>;
    static sequenceEqualAsync<TSource>(first: IAsyncEnumerable_1<TSource>, second: IAsyncEnumerable_1<TSource>, comparer?: IEqualityComparer_1<TSource>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<boolean>>;
    static shuffle<TSource>(source: IAsyncEnumerable_1<TSource>): IAsyncEnumerable_1<TSource>;
    static singleAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static singleAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_3<TSource, CancellationToken, ValueTask_1<CLROf<boolean>>>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static singleAsync<TSource>(source: IAsyncEnumerable_1<TSource>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static singleOrDefaultAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static singleOrDefaultAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>, defaultValue: TSource, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static singleOrDefaultAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_3<TSource, CancellationToken, ValueTask_1<CLROf<boolean>>>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static singleOrDefaultAsync<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_3<TSource, CancellationToken, ValueTask_1<CLROf<boolean>>>, defaultValue: TSource, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static singleOrDefaultAsync<TSource>(source: IAsyncEnumerable_1<TSource>, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static singleOrDefaultAsync<TSource>(source: IAsyncEnumerable_1<TSource>, defaultValue: TSource, cancellationToken?: CancellationToken): ValueTask_1<TSource>;
    static skip<TSource>(source: IAsyncEnumerable_1<TSource>, count: int): IAsyncEnumerable_1<TSource>;
    static skipLast<TSource>(source: IAsyncEnumerable_1<TSource>, count: int): IAsyncEnumerable_1<TSource>;
    static skipWhile<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): IAsyncEnumerable_1<TSource>;
    static skipWhile<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_3<TSource, CancellationToken, ValueTask_1<CLROf<boolean>>>): IAsyncEnumerable_1<TSource>;
    static skipWhile<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_4<TSource, CLROf<int>, CancellationToken, ValueTask_1<CLROf<boolean>>>): IAsyncEnumerable_1<TSource>;
    static sumAsync(source: IAsyncEnumerable_1<CLROf<decimal>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<decimal>>;
    static sumAsync(source: IAsyncEnumerable_1<CLROf<double>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<double>>;
    static sumAsync(source: IAsyncEnumerable_1<CLROf<int>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static sumAsync(source: IAsyncEnumerable_1<CLROf<long>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<long>>;
    static sumAsync(source: IAsyncEnumerable_1<Nullable_1<CLROf<decimal>>>, cancellationToken?: CancellationToken): ValueTask_1<Nullable_1<CLROf<decimal>>>;
    static sumAsync(source: IAsyncEnumerable_1<Nullable_1<CLROf<double>>>, cancellationToken?: CancellationToken): ValueTask_1<Nullable_1<CLROf<double>>>;
    static sumAsync(source: IAsyncEnumerable_1<Nullable_1<CLROf<int>>>, cancellationToken?: CancellationToken): ValueTask_1<Nullable_1<CLROf<int>>>;
    static sumAsync(source: IAsyncEnumerable_1<Nullable_1<CLROf<long>>>, cancellationToken?: CancellationToken): ValueTask_1<Nullable_1<CLROf<long>>>;
    static sumAsync(source: IAsyncEnumerable_1<Nullable_1<CLROf<float>>>, cancellationToken?: CancellationToken): ValueTask_1<Nullable_1<CLROf<float>>>;
    static sumAsync(source: IAsyncEnumerable_1<CLROf<float>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<float>>;
    static take<TSource>(source: IAsyncEnumerable_1<TSource>, count: int): IAsyncEnumerable_1<TSource>;
    static take<TSource>(source: IAsyncEnumerable_1<TSource>, range: Range): IAsyncEnumerable_1<TSource>;
    static takeLast<TSource>(source: IAsyncEnumerable_1<TSource>, count: int): IAsyncEnumerable_1<TSource>;
    static takeWhile<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): IAsyncEnumerable_1<TSource>;
    static takeWhile<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_3<TSource, CancellationToken, ValueTask_1<CLROf<boolean>>>): IAsyncEnumerable_1<TSource>;
    static takeWhile<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_4<TSource, CLROf<int>, CancellationToken, ValueTask_1<CLROf<boolean>>>): IAsyncEnumerable_1<TSource>;
    static thenBy<TSource, TKey>(source: IOrderedAsyncEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer?: IComparer_1<TKey>): IOrderedAsyncEnumerable_1<TSource>;
    static thenBy<TSource, TKey>(source: IOrderedAsyncEnumerable_1<TSource>, keySelector: Func_3<TSource, CancellationToken, ValueTask_1<TKey>>, comparer?: IComparer_1<TKey>): IOrderedAsyncEnumerable_1<TSource>;
    static thenByDescending<TSource, TKey>(source: IOrderedAsyncEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer?: IComparer_1<TKey>): IOrderedAsyncEnumerable_1<TSource>;
    static thenByDescending<TSource, TKey>(source: IOrderedAsyncEnumerable_1<TSource>, keySelector: Func_3<TSource, CancellationToken, ValueTask_1<TKey>>, comparer?: IComparer_1<TKey>): IOrderedAsyncEnumerable_1<TSource>;
    static toArrayAsync<TSource>(source: IAsyncEnumerable_1<TSource>, cancellationToken?: CancellationToken): ValueTask_1<TSource[]>;
    static toAsyncEnumerable<TSource>(source: IEnumerable_1<TSource>): IAsyncEnumerable_1<TSource>;
    static toDictionaryAsync<TSource, TKey, TElement>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TElement>, comparer?: IEqualityComparer_1<TKey>, cancellationToken?: CancellationToken): ValueTask_1<Dictionary_2<TKey, TElement>>;
    static toDictionaryAsync<TSource, TKey>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer?: IEqualityComparer_1<TKey>, cancellationToken?: CancellationToken): ValueTask_1<Dictionary_2<TKey, TSource>>;
    static toDictionaryAsync<TSource, TKey, TElement>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_3<TSource, CancellationToken, ValueTask_1<TKey>>, elementSelector: Func_3<TSource, CancellationToken, ValueTask_1<TElement>>, comparer?: IEqualityComparer_1<TKey>, cancellationToken?: CancellationToken): ValueTask_1<Dictionary_2<TKey, TElement>>;
    static toDictionaryAsync<TSource, TKey>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_3<TSource, CancellationToken, ValueTask_1<TKey>>, comparer?: IEqualityComparer_1<TKey>, cancellationToken?: CancellationToken): ValueTask_1<Dictionary_2<TKey, TSource>>;
    static toDictionaryAsync<TKey, TValue>(source: IAsyncEnumerable_1<KeyValuePair_2<TKey, TValue>>, comparer?: IEqualityComparer_1<TKey>, cancellationToken?: CancellationToken): ValueTask_1<Dictionary_2<TKey, TValue>>;
    static toHashSetAsync<TSource>(source: IAsyncEnumerable_1<TSource>, comparer?: IEqualityComparer_1<TSource>, cancellationToken?: CancellationToken): ValueTask_1<HashSet_1<TSource>>;
    static toListAsync<TSource>(source: IAsyncEnumerable_1<TSource>, cancellationToken?: CancellationToken): ValueTask_1<List_1<TSource>>;
    static toLookupAsync<TSource, TKey, TElement>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TElement>, comparer?: IEqualityComparer_1<TKey>, cancellationToken?: CancellationToken): ValueTask_1<ILookup_2<TKey, TElement>>;
    static toLookupAsync<TSource, TKey>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer?: IEqualityComparer_1<TKey>, cancellationToken?: CancellationToken): ValueTask_1<ILookup_2<TKey, TSource>>;
    static toLookupAsync<TSource, TKey, TElement>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_3<TSource, CancellationToken, ValueTask_1<TKey>>, elementSelector: Func_3<TSource, CancellationToken, ValueTask_1<TElement>>, comparer?: IEqualityComparer_1<TKey>, cancellationToken?: CancellationToken): ValueTask_1<ILookup_2<TKey, TElement>>;
    static toLookupAsync<TSource, TKey>(source: IAsyncEnumerable_1<TSource>, keySelector: Func_3<TSource, CancellationToken, ValueTask_1<TKey>>, comparer?: IEqualityComparer_1<TKey>, cancellationToken?: CancellationToken): ValueTask_1<ILookup_2<TKey, TSource>>;
    static union<TSource>(first: IAsyncEnumerable_1<TSource>, second: IAsyncEnumerable_1<TSource>, comparer?: IEqualityComparer_1<TSource>): IAsyncEnumerable_1<TSource>;
    static unionBy<TSource, TKey>(first: IAsyncEnumerable_1<TSource>, second: IAsyncEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<TSource>;
    static unionBy<TSource, TKey>(first: IAsyncEnumerable_1<TSource>, second: IAsyncEnumerable_1<TSource>, keySelector: Func_3<TSource, CancellationToken, ValueTask_1<TKey>>, comparer?: IEqualityComparer_1<TKey>): IAsyncEnumerable_1<TSource>;
    static where<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): IAsyncEnumerable_1<TSource>;
    static where<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_3<TSource, CancellationToken, ValueTask_1<CLROf<boolean>>>): IAsyncEnumerable_1<TSource>;
    static where<TSource>(source: IAsyncEnumerable_1<TSource>, predicate: Func_4<TSource, CLROf<int>, CancellationToken, ValueTask_1<CLROf<boolean>>>): IAsyncEnumerable_1<TSource>;
    static zip<TFirst, TSecond, TResult>(first: IAsyncEnumerable_1<TFirst>, second: IAsyncEnumerable_1<TSecond>, resultSelector: Func_3<TFirst, TSecond, TResult>): IAsyncEnumerable_1<TResult>;
    static zip<TFirst, TSecond, TResult>(first: IAsyncEnumerable_1<TFirst>, second: IAsyncEnumerable_1<TSecond>, resultSelector: Func_4<TFirst, TSecond, CancellationToken, ValueTask_1<TResult>>): IAsyncEnumerable_1<TResult>;
    static zip<TFirst, TSecond, TThird>(first: IAsyncEnumerable_1<TFirst>, second: IAsyncEnumerable_1<TSecond>, third: IAsyncEnumerable_1<TThird>): IAsyncEnumerable_1<ValueTuple_3<TFirst, TSecond, TThird>>;
    static zip<TFirst, TSecond>(first: IAsyncEnumerable_1<TFirst>, second: IAsyncEnumerable_1<TSecond>): IAsyncEnumerable_1<ValueTuple_2<TFirst, TSecond>>;
}


export type AsyncEnumerable = AsyncEnumerable$instance;

export abstract class Enumerable$instance {
    static aggregate<TSource>(source: IEnumerable_1<TSource>, func: Func_3<TSource, TSource, TSource>): TSource;
    static aggregate<TSource, TAccumulate, TResult>(source: IEnumerable_1<TSource>, seed: TAccumulate, func: Func_3<TAccumulate, TSource, TAccumulate>, resultSelector: Func_2<TAccumulate, TResult>): TResult;
    static aggregate<TSource, TAccumulate>(source: IEnumerable_1<TSource>, seed: TAccumulate, func: Func_3<TAccumulate, TSource, TAccumulate>): TAccumulate;
    static aggregateBy<TSource, TKey, TAccumulate>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, seedSelector: Func_2<TKey, TAccumulate>, func: Func_3<TAccumulate, TSource, TAccumulate>, keyComparer?: IEqualityComparer_1<TKey>): IEnumerable_1<KeyValuePair_2<TKey, TAccumulate>>;
    static aggregateBy<TSource, TKey, TAccumulate>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, seed: TAccumulate, func: Func_3<TAccumulate, TSource, TAccumulate>, keyComparer?: IEqualityComparer_1<TKey>): IEnumerable_1<KeyValuePair_2<TKey, TAccumulate>>;
    static all<TSource>(source: IEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): boolean;
    static any_<TSource>(source: IEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): boolean;
    static any_<TSource>(source: IEnumerable_1<TSource>): boolean;
    static append<TSource>(source: IEnumerable_1<TSource>, element: TSource): IEnumerable_1<TSource>;
    static asEnumerable<TSource>(source: IEnumerable_1<TSource>): IEnumerable_1<TSource>;
    static average<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, CLROf<decimal>>): decimal;
    static average<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, CLROf<int>>): double;
    static average<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<decimal>>>): Nullable_1<CLROf<decimal>>;
    static average<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<int>>>): Nullable_1<CLROf<double>>;
    static average<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<float>>>): Nullable_1<CLROf<float>>;
    static average<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, CLROf<float>>): float;
    static average(source: IEnumerable_1<CLROf<decimal>>): decimal;
    static average(source: IEnumerable_1<CLROf<double>>): double;
    static average(source: IEnumerable_1<CLROf<int>>): double;
    static average(source: IEnumerable_1<CLROf<long>>): double;
    static average(source: IEnumerable_1<Nullable_1<CLROf<decimal>>>): Nullable_1<CLROf<decimal>>;
    static average(source: IEnumerable_1<Nullable_1<CLROf<double>>>): Nullable_1<CLROf<double>>;
    static average(source: IEnumerable_1<Nullable_1<CLROf<int>>>): Nullable_1<CLROf<double>>;
    static average(source: IEnumerable_1<Nullable_1<CLROf<long>>>): Nullable_1<CLROf<double>>;
    static average(source: IEnumerable_1<Nullable_1<CLROf<float>>>): Nullable_1<CLROf<float>>;
    static average(source: IEnumerable_1<CLROf<float>>): float;
    static cast<TResult>(source: IEnumerable): IEnumerable_1<TResult>;
    static chunk<TSource>(source: IEnumerable_1<TSource>, size: int): IEnumerable_1<TSource[]>;
    static concat<TSource>(first: IEnumerable_1<TSource>, second: IEnumerable_1<TSource>): IEnumerable_1<TSource>;
    static contains<TSource>(source: IEnumerable_1<TSource>, value: TSource, comparer: IEqualityComparer_1<TSource>): boolean;
    static contains<TSource>(source: IEnumerable_1<TSource>, value: TSource): boolean;
    static count<TSource>(source: IEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): int;
    static count<TSource>(source: IEnumerable_1<TSource>): int;
    static countBy<TSource, TKey>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, keyComparer?: IEqualityComparer_1<TKey>): IEnumerable_1<KeyValuePair_2<TKey, CLROf<int>>>;
    static defaultIfEmpty<TSource>(source: IEnumerable_1<TSource>, defaultValue: TSource): IEnumerable_1<TSource>;
    static defaultIfEmpty<TSource>(source: IEnumerable_1<TSource>): IEnumerable_1<TSource>;
    static distinct<TSource>(source: IEnumerable_1<TSource>, comparer: IEqualityComparer_1<TSource>): IEnumerable_1<TSource>;
    static distinct<TSource>(source: IEnumerable_1<TSource>): IEnumerable_1<TSource>;
    static distinctBy<TSource, TKey>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer: IEqualityComparer_1<TKey>): IEnumerable_1<TSource>;
    static distinctBy<TSource, TKey>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>): IEnumerable_1<TSource>;
    static elementAt<TSource>(source: IEnumerable_1<TSource>, index: Index): TSource;
    static elementAt<TSource>(source: IEnumerable_1<TSource>, index: int): TSource;
    static elementAtOrDefault<TSource>(source: IEnumerable_1<TSource>, index: Index): TSource;
    static elementAtOrDefault<TSource>(source: IEnumerable_1<TSource>, index: int): TSource;
    static empty<TResult>(): IEnumerable_1<TResult>;
    static except<TSource>(first: IEnumerable_1<TSource>, second: IEnumerable_1<TSource>, comparer: IEqualityComparer_1<TSource>): IEnumerable_1<TSource>;
    static except<TSource>(first: IEnumerable_1<TSource>, second: IEnumerable_1<TSource>): IEnumerable_1<TSource>;
    static exceptBy<TSource, TKey>(first: IEnumerable_1<TSource>, second: IEnumerable_1<TKey>, keySelector: Func_2<TSource, TKey>, comparer: IEqualityComparer_1<TKey>): IEnumerable_1<TSource>;
    static exceptBy<TSource, TKey>(first: IEnumerable_1<TSource>, second: IEnumerable_1<TKey>, keySelector: Func_2<TSource, TKey>): IEnumerable_1<TSource>;
    static first<TSource>(source: IEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): TSource;
    static first<TSource>(source: IEnumerable_1<TSource>): TSource;
    static firstOrDefault<TSource>(source: IEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>, defaultValue: TSource): TSource;
    static firstOrDefault<TSource>(source: IEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): TSource;
    static firstOrDefault<TSource>(source: IEnumerable_1<TSource>, defaultValue: TSource): TSource;
    static firstOrDefault<TSource>(source: IEnumerable_1<TSource>): TSource;
    static groupBy<TSource, TKey, TElement, TResult>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TElement>, resultSelector: Func_3<TKey, IEnumerable_1<TElement>, TResult>, comparer: IEqualityComparer_1<TKey>): IEnumerable_1<TResult>;
    static groupBy<TSource, TKey, TElement, TResult>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TElement>, resultSelector: Func_3<TKey, IEnumerable_1<TElement>, TResult>): IEnumerable_1<TResult>;
    static groupBy<TSource, TKey, TElement>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TElement>, comparer: IEqualityComparer_1<TKey>): IEnumerable_1<IGrouping_2<TKey, TElement>>;
    static groupBy<TSource, TKey, TElement>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TElement>): IEnumerable_1<IGrouping_2<TKey, TElement>>;
    static groupBy<TSource, TKey, TResult>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, resultSelector: Func_3<TKey, IEnumerable_1<TSource>, TResult>, comparer: IEqualityComparer_1<TKey>): IEnumerable_1<TResult>;
    static groupBy<TSource, TKey, TResult>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, resultSelector: Func_3<TKey, IEnumerable_1<TSource>, TResult>): IEnumerable_1<TResult>;
    static groupBy<TSource, TKey>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer: IEqualityComparer_1<TKey>): IEnumerable_1<IGrouping_2<TKey, TSource>>;
    static groupBy<TSource, TKey>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>): IEnumerable_1<IGrouping_2<TKey, TSource>>;
    static groupJoin<TOuter, TInner, TKey, TResult>(outer: IEnumerable_1<TOuter>, inner: IEnumerable_1<TInner>, outerKeySelector: Func_2<TOuter, TKey>, innerKeySelector: Func_2<TInner, TKey>, resultSelector: Func_3<TOuter, IEnumerable_1<TInner>, TResult>, comparer: IEqualityComparer_1<TKey>): IEnumerable_1<TResult>;
    static groupJoin<TOuter, TInner, TKey, TResult>(outer: IEnumerable_1<TOuter>, inner: IEnumerable_1<TInner>, outerKeySelector: Func_2<TOuter, TKey>, innerKeySelector: Func_2<TInner, TKey>, resultSelector: Func_3<TOuter, IEnumerable_1<TInner>, TResult>): IEnumerable_1<TResult>;
    static index<TSource>(source: IEnumerable_1<TSource>): IEnumerable_1<ValueTuple_2<CLROf<int>, TSource>>;
    static infiniteSequence<T extends IAdditionOperators_3<T, T, T>>(start: T, step: T): IEnumerable_1<T>;
    static intersect<TSource>(first: IEnumerable_1<TSource>, second: IEnumerable_1<TSource>, comparer: IEqualityComparer_1<TSource>): IEnumerable_1<TSource>;
    static intersect<TSource>(first: IEnumerable_1<TSource>, second: IEnumerable_1<TSource>): IEnumerable_1<TSource>;
    static intersectBy<TSource, TKey>(first: IEnumerable_1<TSource>, second: IEnumerable_1<TKey>, keySelector: Func_2<TSource, TKey>, comparer: IEqualityComparer_1<TKey>): IEnumerable_1<TSource>;
    static intersectBy<TSource, TKey>(first: IEnumerable_1<TSource>, second: IEnumerable_1<TKey>, keySelector: Func_2<TSource, TKey>): IEnumerable_1<TSource>;
    static join<TOuter, TInner, TKey, TResult>(outer: IEnumerable_1<TOuter>, inner: IEnumerable_1<TInner>, outerKeySelector: Func_2<TOuter, TKey>, innerKeySelector: Func_2<TInner, TKey>, resultSelector: Func_3<TOuter, TInner, TResult>, comparer: IEqualityComparer_1<TKey>): IEnumerable_1<TResult>;
    static join<TOuter, TInner, TKey, TResult>(outer: IEnumerable_1<TOuter>, inner: IEnumerable_1<TInner>, outerKeySelector: Func_2<TOuter, TKey>, innerKeySelector: Func_2<TInner, TKey>, resultSelector: Func_3<TOuter, TInner, TResult>): IEnumerable_1<TResult>;
    static last<TSource>(source: IEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): TSource;
    static last<TSource>(source: IEnumerable_1<TSource>): TSource;
    static lastOrDefault<TSource>(source: IEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>, defaultValue: TSource): TSource;
    static lastOrDefault<TSource>(source: IEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): TSource;
    static lastOrDefault<TSource>(source: IEnumerable_1<TSource>, defaultValue: TSource): TSource;
    static lastOrDefault<TSource>(source: IEnumerable_1<TSource>): TSource;
    static leftJoin<TOuter, TInner, TKey, TResult>(outer: IEnumerable_1<TOuter>, inner: IEnumerable_1<TInner>, outerKeySelector: Func_2<TOuter, TKey>, innerKeySelector: Func_2<TInner, TKey>, resultSelector: Func_3<TOuter, TInner, TResult>, comparer: IEqualityComparer_1<TKey>): IEnumerable_1<TResult>;
    static leftJoin<TOuter, TInner, TKey, TResult>(outer: IEnumerable_1<TOuter>, inner: IEnumerable_1<TInner>, outerKeySelector: Func_2<TOuter, TKey>, innerKeySelector: Func_2<TInner, TKey>, resultSelector: Func_3<TOuter, TInner, TResult>): IEnumerable_1<TResult>;
    static longCount<TSource>(source: IEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): long;
    static longCount<TSource>(source: IEnumerable_1<TSource>): long;
    static max<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, CLROf<decimal>>): decimal;
    static max<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, CLROf<double>>): double;
    static max<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, CLROf<int>>): int;
    static max<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, CLROf<long>>): long;
    static max<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<decimal>>>): Nullable_1<CLROf<decimal>>;
    static max<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<double>>>): Nullable_1<CLROf<double>>;
    static max<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<int>>>): Nullable_1<CLROf<int>>;
    static max<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<long>>>): Nullable_1<CLROf<long>>;
    static max<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<float>>>): Nullable_1<CLROf<float>>;
    static max<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, CLROf<float>>): float;
    static max<TSource, TResult>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, TResult>): TResult;
    static max<TSource>(source: IEnumerable_1<TSource>, comparer: IComparer_1<TSource>): TSource;
    static max<TSource>(source: IEnumerable_1<TSource>): TSource;
    static max(source: IEnumerable_1<CLROf<decimal>>): decimal;
    static max(source: IEnumerable_1<CLROf<double>>): double;
    static max(source: IEnumerable_1<CLROf<int>>): int;
    static max(source: IEnumerable_1<CLROf<long>>): long;
    static max(source: IEnumerable_1<Nullable_1<CLROf<decimal>>>): Nullable_1<CLROf<decimal>>;
    static max(source: IEnumerable_1<Nullable_1<CLROf<double>>>): Nullable_1<CLROf<double>>;
    static max(source: IEnumerable_1<Nullable_1<CLROf<int>>>): Nullable_1<CLROf<int>>;
    static max(source: IEnumerable_1<Nullable_1<CLROf<long>>>): Nullable_1<CLROf<long>>;
    static max(source: IEnumerable_1<Nullable_1<CLROf<float>>>): Nullable_1<CLROf<float>>;
    static max(source: IEnumerable_1<CLROf<float>>): float;
    static maxBy<TSource, TKey>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer: IComparer_1<TKey>): TSource;
    static maxBy<TSource, TKey>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>): TSource;
    static min<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, CLROf<decimal>>): decimal;
    static min<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, CLROf<double>>): double;
    static min<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, CLROf<int>>): int;
    static min<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, CLROf<long>>): long;
    static min<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<decimal>>>): Nullable_1<CLROf<decimal>>;
    static min<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<double>>>): Nullable_1<CLROf<double>>;
    static min<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<int>>>): Nullable_1<CLROf<int>>;
    static min<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<long>>>): Nullable_1<CLROf<long>>;
    static min<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<float>>>): Nullable_1<CLROf<float>>;
    static min<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, CLROf<float>>): float;
    static min<TSource, TResult>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, TResult>): TResult;
    static min<TSource>(source: IEnumerable_1<TSource>, comparer: IComparer_1<TSource>): TSource;
    static min<TSource>(source: IEnumerable_1<TSource>): TSource;
    static min(source: IEnumerable_1<CLROf<decimal>>): decimal;
    static min(source: IEnumerable_1<CLROf<double>>): double;
    static min(source: IEnumerable_1<CLROf<int>>): int;
    static min(source: IEnumerable_1<CLROf<long>>): long;
    static min(source: IEnumerable_1<Nullable_1<CLROf<decimal>>>): Nullable_1<CLROf<decimal>>;
    static min(source: IEnumerable_1<Nullable_1<CLROf<double>>>): Nullable_1<CLROf<double>>;
    static min(source: IEnumerable_1<Nullable_1<CLROf<int>>>): Nullable_1<CLROf<int>>;
    static min(source: IEnumerable_1<Nullable_1<CLROf<long>>>): Nullable_1<CLROf<long>>;
    static min(source: IEnumerable_1<Nullable_1<CLROf<float>>>): Nullable_1<CLROf<float>>;
    static min(source: IEnumerable_1<CLROf<float>>): float;
    static minBy<TSource, TKey>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer: IComparer_1<TKey>): TSource;
    static minBy<TSource, TKey>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>): TSource;
    static ofType<TResult>(source: IEnumerable): IEnumerable_1<TResult>;
    static order<T>(source: IEnumerable_1<T>, comparer: IComparer_1<T>): IOrderedEnumerable_1<T>;
    static order<T>(source: IEnumerable_1<T>): IOrderedEnumerable_1<T>;
    static orderBy<TSource, TKey>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer: IComparer_1<TKey>): IOrderedEnumerable_1<TSource>;
    static orderBy<TSource, TKey>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>): IOrderedEnumerable_1<TSource>;
    static orderByDescending<TSource, TKey>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer: IComparer_1<TKey>): IOrderedEnumerable_1<TSource>;
    static orderByDescending<TSource, TKey>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>): IOrderedEnumerable_1<TSource>;
    static orderDescending<T>(source: IEnumerable_1<T>, comparer: IComparer_1<T>): IOrderedEnumerable_1<T>;
    static orderDescending<T>(source: IEnumerable_1<T>): IOrderedEnumerable_1<T>;
    static prepend<TSource>(source: IEnumerable_1<TSource>, element: TSource): IEnumerable_1<TSource>;
    static range(start: int, count: int): IEnumerable_1<CLROf<int>>;
    static repeat<TResult>(element: TResult, count: int): IEnumerable_1<TResult>;
    static reverse<TSource>(source: IEnumerable_1<TSource>): IEnumerable_1<TSource>;
    static reverse<TSource>(source: TSource[]): IEnumerable_1<TSource>;
    static rightJoin<TOuter, TInner, TKey, TResult>(outer: IEnumerable_1<TOuter>, inner: IEnumerable_1<TInner>, outerKeySelector: Func_2<TOuter, TKey>, innerKeySelector: Func_2<TInner, TKey>, resultSelector: Func_3<TOuter, TInner, TResult>, comparer: IEqualityComparer_1<TKey>): IEnumerable_1<TResult>;
    static rightJoin<TOuter, TInner, TKey, TResult>(outer: IEnumerable_1<TOuter>, inner: IEnumerable_1<TInner>, outerKeySelector: Func_2<TOuter, TKey>, innerKeySelector: Func_2<TInner, TKey>, resultSelector: Func_3<TOuter, TInner, TResult>): IEnumerable_1<TResult>;
    static select<TSource, TResult>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, TResult>): IEnumerable_1<TResult>;
    static select<TSource, TResult>(source: IEnumerable_1<TSource>, selector: Func_3<TSource, CLROf<int>, TResult>): IEnumerable_1<TResult>;
    static selectMany<TSource, TCollection, TResult>(source: IEnumerable_1<TSource>, collectionSelector: Func_2<TSource, IEnumerable_1<TCollection>>, resultSelector: Func_3<TSource, TCollection, TResult>): IEnumerable_1<TResult>;
    static selectMany<TSource, TResult>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, IEnumerable_1<TResult>>): IEnumerable_1<TResult>;
    static selectMany<TSource, TCollection, TResult>(source: IEnumerable_1<TSource>, collectionSelector: Func_3<TSource, CLROf<int>, IEnumerable_1<TCollection>>, resultSelector: Func_3<TSource, TCollection, TResult>): IEnumerable_1<TResult>;
    static selectMany<TSource, TResult>(source: IEnumerable_1<TSource>, selector: Func_3<TSource, CLROf<int>, IEnumerable_1<TResult>>): IEnumerable_1<TResult>;
    static sequence<T extends INumber_1<T>>(start: T, endInclusive: T, step: T): IEnumerable_1<T>;
    static sequenceEqual<TSource>(first: IEnumerable_1<TSource>, second: IEnumerable_1<TSource>, comparer: IEqualityComparer_1<TSource>): boolean;
    static sequenceEqual<TSource>(first: IEnumerable_1<TSource>, second: IEnumerable_1<TSource>): boolean;
    static shuffle<TSource>(source: IEnumerable_1<TSource>): IEnumerable_1<TSource>;
    static single<TSource>(source: IEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): TSource;
    static single<TSource>(source: IEnumerable_1<TSource>): TSource;
    static singleOrDefault<TSource>(source: IEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>, defaultValue: TSource): TSource;
    static singleOrDefault<TSource>(source: IEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): TSource;
    static singleOrDefault<TSource>(source: IEnumerable_1<TSource>, defaultValue: TSource): TSource;
    static singleOrDefault<TSource>(source: IEnumerable_1<TSource>): TSource;
    static skip<TSource>(source: IEnumerable_1<TSource>, count: int): IEnumerable_1<TSource>;
    static skipLast<TSource>(source: IEnumerable_1<TSource>, count: int): IEnumerable_1<TSource>;
    static skipWhile<TSource>(source: IEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): IEnumerable_1<TSource>;
    static skipWhile<TSource>(source: IEnumerable_1<TSource>, predicate: Func_3<TSource, CLROf<int>, CLROf<boolean>>): IEnumerable_1<TSource>;
    static sum<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, CLROf<decimal>>): decimal;
    static sum<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, CLROf<double>>): double;
    static sum<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, CLROf<int>>): int;
    static sum<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, CLROf<long>>): long;
    static sum<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<decimal>>>): Nullable_1<CLROf<decimal>>;
    static sum<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<double>>>): Nullable_1<CLROf<double>>;
    static sum<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<int>>>): Nullable_1<CLROf<int>>;
    static sum<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<long>>>): Nullable_1<CLROf<long>>;
    static sum<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<float>>>): Nullable_1<CLROf<float>>;
    static sum<TSource>(source: IEnumerable_1<TSource>, selector: Func_2<TSource, CLROf<float>>): float;
    static sum(source: IEnumerable_1<CLROf<decimal>>): decimal;
    static sum(source: IEnumerable_1<CLROf<double>>): double;
    static sum(source: IEnumerable_1<CLROf<int>>): int;
    static sum(source: IEnumerable_1<CLROf<long>>): long;
    static sum(source: IEnumerable_1<Nullable_1<CLROf<decimal>>>): Nullable_1<CLROf<decimal>>;
    static sum(source: IEnumerable_1<Nullable_1<CLROf<double>>>): Nullable_1<CLROf<double>>;
    static sum(source: IEnumerable_1<Nullable_1<CLROf<int>>>): Nullable_1<CLROf<int>>;
    static sum(source: IEnumerable_1<Nullable_1<CLROf<long>>>): Nullable_1<CLROf<long>>;
    static sum(source: IEnumerable_1<Nullable_1<CLROf<float>>>): Nullable_1<CLROf<float>>;
    static sum(source: IEnumerable_1<CLROf<float>>): float;
    static take<TSource>(source: IEnumerable_1<TSource>, count: int): IEnumerable_1<TSource>;
    static take<TSource>(source: IEnumerable_1<TSource>, range: Range): IEnumerable_1<TSource>;
    static takeLast<TSource>(source: IEnumerable_1<TSource>, count: int): IEnumerable_1<TSource>;
    static takeWhile<TSource>(source: IEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): IEnumerable_1<TSource>;
    static takeWhile<TSource>(source: IEnumerable_1<TSource>, predicate: Func_3<TSource, CLROf<int>, CLROf<boolean>>): IEnumerable_1<TSource>;
    static thenBy<TSource, TKey>(source: IOrderedEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer: IComparer_1<TKey>): IOrderedEnumerable_1<TSource>;
    static thenBy<TSource, TKey>(source: IOrderedEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>): IOrderedEnumerable_1<TSource>;
    static thenByDescending<TSource, TKey>(source: IOrderedEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer: IComparer_1<TKey>): IOrderedEnumerable_1<TSource>;
    static thenByDescending<TSource, TKey>(source: IOrderedEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>): IOrderedEnumerable_1<TSource>;
    static toArray<TSource>(source: IEnumerable_1<TSource>): TSource[];
    static toDictionary<TSource, TKey, TElement>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TElement>, comparer: IEqualityComparer_1<TKey>): Dictionary_2<TKey, TElement>;
    static toDictionary<TSource, TKey, TElement>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TElement>): Dictionary_2<TKey, TElement>;
    static toDictionary<TSource, TKey>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer: IEqualityComparer_1<TKey>): Dictionary_2<TKey, TSource>;
    static toDictionary<TSource, TKey>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>): Dictionary_2<TKey, TSource>;
    static toDictionary<TKey, TValue>(source: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, comparer: IEqualityComparer_1<TKey>): Dictionary_2<TKey, TValue>;
    static toDictionary<TKey, TValue>(source: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): Dictionary_2<TKey, TValue>;
    static toHashSet<TSource>(source: IEnumerable_1<TSource>, comparer: IEqualityComparer_1<TSource>): HashSet_1<TSource>;
    static toHashSet<TSource>(source: IEnumerable_1<TSource>): HashSet_1<TSource>;
    static toList<TSource>(source: IEnumerable_1<TSource>): List_1<TSource>;
    static toLookup<TSource, TKey, TElement>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TElement>, comparer: IEqualityComparer_1<TKey>): ILookup_2<TKey, TElement>;
    static toLookup<TSource, TKey, TElement>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TElement>): ILookup_2<TKey, TElement>;
    static toLookup<TSource, TKey>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer: IEqualityComparer_1<TKey>): ILookup_2<TKey, TSource>;
    static toLookup<TSource, TKey>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>): ILookup_2<TKey, TSource>;
    static tryGetNonEnumeratedCount<TSource>(source: IEnumerable_1<TSource>, count: { value: ref<int> }): boolean;
    static union<TSource>(first: IEnumerable_1<TSource>, second: IEnumerable_1<TSource>, comparer: IEqualityComparer_1<TSource>): IEnumerable_1<TSource>;
    static union<TSource>(first: IEnumerable_1<TSource>, second: IEnumerable_1<TSource>): IEnumerable_1<TSource>;
    static unionBy<TSource, TKey>(first: IEnumerable_1<TSource>, second: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer: IEqualityComparer_1<TKey>): IEnumerable_1<TSource>;
    static unionBy<TSource, TKey>(first: IEnumerable_1<TSource>, second: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>): IEnumerable_1<TSource>;
    static where<TSource>(source: IEnumerable_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): IEnumerable_1<TSource>;
    static where<TSource>(source: IEnumerable_1<TSource>, predicate: Func_3<TSource, CLROf<int>, CLROf<boolean>>): IEnumerable_1<TSource>;
    static zip<TFirst, TSecond, TResult>(first: IEnumerable_1<TFirst>, second: IEnumerable_1<TSecond>, resultSelector: Func_3<TFirst, TSecond, TResult>): IEnumerable_1<TResult>;
    static zip<TFirst, TSecond, TThird>(first: IEnumerable_1<TFirst>, second: IEnumerable_1<TSecond>, third: IEnumerable_1<TThird>): IEnumerable_1<ValueTuple_3<TFirst, TSecond, TThird>>;
    static zip<TFirst, TSecond>(first: IEnumerable_1<TFirst>, second: IEnumerable_1<TSecond>): IEnumerable_1<ValueTuple_2<TFirst, TSecond>>;
}


export type Enumerable = Enumerable$instance;

export abstract class ImmutableArrayExtensions$instance {
    static aggregate<T>(immutableArray: ImmutableArray_1<T>, func: Func_3<T, T, T>): T;
    static aggregate<TAccumulate, TResult, T>(immutableArray: ImmutableArray_1<T>, seed: TAccumulate, func: Func_3<TAccumulate, T, TAccumulate>, resultSelector: Func_2<TAccumulate, TResult>): TResult;
    static aggregate<TAccumulate, T>(immutableArray: ImmutableArray_1<T>, seed: TAccumulate, func: Func_3<TAccumulate, T, TAccumulate>): TAccumulate;
    static all<T>(immutableArray: ImmutableArray_1<T>, predicate: Func_2<T, CLROf<boolean>>): boolean;
    static any_<T>(builder: ImmutableArray_1_Builder<T>): boolean;
    static any_<T>(immutableArray: ImmutableArray_1<T>, predicate: Func_2<T, CLROf<boolean>>): boolean;
    static any_<T>(immutableArray: ImmutableArray_1<T>): boolean;
    static elementAt<T>(immutableArray: ImmutableArray_1<T>, index: int): T;
    static elementAtOrDefault<T>(immutableArray: ImmutableArray_1<T>, index: int): T;
    static first<T>(builder: ImmutableArray_1_Builder<T>): T;
    static first<T>(immutableArray: ImmutableArray_1<T>, predicate: Func_2<T, CLROf<boolean>>): T;
    static first<T>(immutableArray: ImmutableArray_1<T>): T;
    static firstOrDefault<T>(builder: ImmutableArray_1_Builder<T>): T;
    static firstOrDefault<T>(immutableArray: ImmutableArray_1<T>, predicate: Func_2<T, CLROf<boolean>>): T;
    static firstOrDefault<T>(immutableArray: ImmutableArray_1<T>): T;
    static last<T>(builder: ImmutableArray_1_Builder<T>): T;
    static last<T>(immutableArray: ImmutableArray_1<T>, predicate: Func_2<T, CLROf<boolean>>): T;
    static last<T>(immutableArray: ImmutableArray_1<T>): T;
    static lastOrDefault<T>(builder: ImmutableArray_1_Builder<T>): T;
    static lastOrDefault<T>(immutableArray: ImmutableArray_1<T>, predicate: Func_2<T, CLROf<boolean>>): T;
    static lastOrDefault<T>(immutableArray: ImmutableArray_1<T>): T;
    static select<T, TResult>(immutableArray: ImmutableArray_1<T>, selector: Func_2<T, TResult>): IEnumerable_1<TResult>;
    static selectMany<TSource, TCollection, TResult>(immutableArray: ImmutableArray_1<TSource>, collectionSelector: Func_2<TSource, IEnumerable_1<TCollection>>, resultSelector: Func_3<TSource, TCollection, TResult>): IEnumerable_1<TResult>;
    static sequenceEqual<TDerived extends TBase, TBase>(immutableArray: ImmutableArray_1<TBase>, items: IEnumerable_1<TDerived>, comparer?: IEqualityComparer_1<TBase>): boolean;
    static sequenceEqual<TDerived extends TBase, TBase>(immutableArray: ImmutableArray_1<TBase>, items: ImmutableArray_1<TDerived>, predicate: Func_3<TBase, TBase, CLROf<boolean>>): boolean;
    static sequenceEqual<TDerived extends TBase, TBase>(immutableArray: ImmutableArray_1<TBase>, items: ImmutableArray_1<TDerived>, comparer?: IEqualityComparer_1<TBase>): boolean;
    static single<T>(immutableArray: ImmutableArray_1<T>, predicate: Func_2<T, CLROf<boolean>>): T;
    static single<T>(immutableArray: ImmutableArray_1<T>): T;
    static singleOrDefault<T>(immutableArray: ImmutableArray_1<T>, predicate: Func_2<T, CLROf<boolean>>): T;
    static singleOrDefault<T>(immutableArray: ImmutableArray_1<T>): T;
    static toArray<T>(immutableArray: ImmutableArray_1<T>): T[];
    static toDictionary<TKey, TElement, T>(immutableArray: ImmutableArray_1<T>, keySelector: Func_2<T, TKey>, elementSelector: Func_2<T, TElement>, comparer: IEqualityComparer_1<TKey>): Dictionary_2<TKey, TElement>;
    static toDictionary<TKey, TElement, T>(immutableArray: ImmutableArray_1<T>, keySelector: Func_2<T, TKey>, elementSelector: Func_2<T, TElement>): Dictionary_2<TKey, TElement>;
    static toDictionary<TKey, T>(immutableArray: ImmutableArray_1<T>, keySelector: Func_2<T, TKey>, comparer: IEqualityComparer_1<TKey>): Dictionary_2<TKey, T>;
    static toDictionary<TKey, T>(immutableArray: ImmutableArray_1<T>, keySelector: Func_2<T, TKey>): Dictionary_2<TKey, T>;
    static where<T>(immutableArray: ImmutableArray_1<T>, predicate: Func_2<T, CLROf<boolean>>): IEnumerable_1<T>;
}


export type ImmutableArrayExtensions = ImmutableArrayExtensions$instance;

export abstract class ParallelEnumerable$instance {
    static aggregate<TSource, TAccumulate, TResult>(source: ParallelQuery_1<TSource>, seedFactory: Func_1<TAccumulate>, updateAccumulatorFunc: Func_3<TAccumulate, TSource, TAccumulate>, combineAccumulatorsFunc: Func_3<TAccumulate, TAccumulate, TAccumulate>, resultSelector: Func_2<TAccumulate, TResult>): TResult;
    static aggregate<TSource>(source: ParallelQuery_1<TSource>, func: Func_3<TSource, TSource, TSource>): TSource;
    static aggregate<TSource, TAccumulate, TResult>(source: ParallelQuery_1<TSource>, seed: TAccumulate, func: Func_3<TAccumulate, TSource, TAccumulate>, resultSelector: Func_2<TAccumulate, TResult>): TResult;
    static aggregate<TSource, TAccumulate, TResult>(source: ParallelQuery_1<TSource>, seed: TAccumulate, updateAccumulatorFunc: Func_3<TAccumulate, TSource, TAccumulate>, combineAccumulatorsFunc: Func_3<TAccumulate, TAccumulate, TAccumulate>, resultSelector: Func_2<TAccumulate, TResult>): TResult;
    static aggregate<TSource, TAccumulate>(source: ParallelQuery_1<TSource>, seed: TAccumulate, func: Func_3<TAccumulate, TSource, TAccumulate>): TAccumulate;
    static all<TSource>(source: ParallelQuery_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): boolean;
    static any_<TSource>(source: ParallelQuery_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): boolean;
    static any_<TSource>(source: ParallelQuery_1<TSource>): boolean;
    static asEnumerable<TSource>(source: ParallelQuery_1<TSource>): IEnumerable_1<TSource>;
    static asOrdered<TSource>(source: ParallelQuery_1<TSource>): ParallelQuery_1<TSource>;
    static asOrdered(source: ParallelQuery): ParallelQuery;
    static asParallel<TSource>(source: IEnumerable_1<TSource>): ParallelQuery_1<TSource>;
    static asParallel<TSource>(source: Partitioner_1<TSource>): ParallelQuery_1<TSource>;
    static asParallel(source: IEnumerable): ParallelQuery;
    static asSequential<TSource>(source: ParallelQuery_1<TSource>): IEnumerable_1<TSource>;
    static asUnordered<TSource>(source: ParallelQuery_1<TSource>): ParallelQuery_1<TSource>;
    static average<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, CLROf<decimal>>): decimal;
    static average<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, CLROf<int>>): double;
    static average<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<decimal>>>): Nullable_1<CLROf<decimal>>;
    static average<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<int>>>): Nullable_1<CLROf<double>>;
    static average<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<float>>>): Nullable_1<CLROf<float>>;
    static average<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, CLROf<float>>): float;
    static average(source: ParallelQuery_1<CLROf<decimal>>): decimal;
    static average(source: ParallelQuery_1<CLROf<double>>): double;
    static average(source: ParallelQuery_1<CLROf<int>>): double;
    static average(source: ParallelQuery_1<CLROf<long>>): double;
    static average(source: ParallelQuery_1<Nullable_1<CLROf<decimal>>>): Nullable_1<CLROf<decimal>>;
    static average(source: ParallelQuery_1<Nullable_1<CLROf<double>>>): Nullable_1<CLROf<double>>;
    static average(source: ParallelQuery_1<Nullable_1<CLROf<int>>>): Nullable_1<CLROf<double>>;
    static average(source: ParallelQuery_1<Nullable_1<CLROf<long>>>): Nullable_1<CLROf<double>>;
    static average(source: ParallelQuery_1<Nullable_1<CLROf<float>>>): Nullable_1<CLROf<float>>;
    static average(source: ParallelQuery_1<CLROf<float>>): float;
    static cast<TResult>(source: ParallelQuery): ParallelQuery_1<TResult>;
    static concat<TSource>(first: ParallelQuery_1<TSource>, second: IEnumerable_1<TSource>): ParallelQuery_1<TSource>;
    static concat<TSource>(first: ParallelQuery_1<TSource>, second: ParallelQuery_1<TSource>): ParallelQuery_1<TSource>;
    static contains<TSource>(source: ParallelQuery_1<TSource>, value: TSource, comparer: IEqualityComparer_1<TSource>): boolean;
    static contains<TSource>(source: ParallelQuery_1<TSource>, value: TSource): boolean;
    static count<TSource>(source: ParallelQuery_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): int;
    static count<TSource>(source: ParallelQuery_1<TSource>): int;
    static defaultIfEmpty<TSource>(source: ParallelQuery_1<TSource>, defaultValue: TSource): ParallelQuery_1<TSource>;
    static defaultIfEmpty<TSource>(source: ParallelQuery_1<TSource>): ParallelQuery_1<TSource>;
    static distinct<TSource>(source: ParallelQuery_1<TSource>, comparer: IEqualityComparer_1<TSource>): ParallelQuery_1<TSource>;
    static distinct<TSource>(source: ParallelQuery_1<TSource>): ParallelQuery_1<TSource>;
    static elementAt<TSource>(source: ParallelQuery_1<TSource>, index: int): TSource;
    static elementAtOrDefault<TSource>(source: ParallelQuery_1<TSource>, index: int): TSource;
    static empty<TResult>(): ParallelQuery_1<TResult>;
    static except<TSource>(first: ParallelQuery_1<TSource>, second: IEnumerable_1<TSource>, comparer: IEqualityComparer_1<TSource>): ParallelQuery_1<TSource>;
    static except<TSource>(first: ParallelQuery_1<TSource>, second: IEnumerable_1<TSource>): ParallelQuery_1<TSource>;
    static except<TSource>(first: ParallelQuery_1<TSource>, second: ParallelQuery_1<TSource>, comparer: IEqualityComparer_1<TSource>): ParallelQuery_1<TSource>;
    static except<TSource>(first: ParallelQuery_1<TSource>, second: ParallelQuery_1<TSource>): ParallelQuery_1<TSource>;
    static first<TSource>(source: ParallelQuery_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): TSource;
    static first<TSource>(source: ParallelQuery_1<TSource>): TSource;
    static firstOrDefault<TSource>(source: ParallelQuery_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): TSource;
    static firstOrDefault<TSource>(source: ParallelQuery_1<TSource>): TSource;
    static forAll<TSource>(source: ParallelQuery_1<TSource>, action: Action_1<TSource>): void;
    static groupBy<TSource, TKey, TElement, TResult>(source: ParallelQuery_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TElement>, resultSelector: Func_3<TKey, IEnumerable_1<TElement>, TResult>, comparer: IEqualityComparer_1<TKey>): ParallelQuery_1<TResult>;
    static groupBy<TSource, TKey, TElement, TResult>(source: ParallelQuery_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TElement>, resultSelector: Func_3<TKey, IEnumerable_1<TElement>, TResult>): ParallelQuery_1<TResult>;
    static groupBy<TSource, TKey, TElement>(source: ParallelQuery_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TElement>, comparer: IEqualityComparer_1<TKey>): ParallelQuery_1<IGrouping_2<TKey, TElement>>;
    static groupBy<TSource, TKey, TElement>(source: ParallelQuery_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TElement>): ParallelQuery_1<IGrouping_2<TKey, TElement>>;
    static groupBy<TSource, TKey, TResult>(source: ParallelQuery_1<TSource>, keySelector: Func_2<TSource, TKey>, resultSelector: Func_3<TKey, IEnumerable_1<TSource>, TResult>, comparer: IEqualityComparer_1<TKey>): ParallelQuery_1<TResult>;
    static groupBy<TSource, TKey, TResult>(source: ParallelQuery_1<TSource>, keySelector: Func_2<TSource, TKey>, resultSelector: Func_3<TKey, IEnumerable_1<TSource>, TResult>): ParallelQuery_1<TResult>;
    static groupBy<TSource, TKey>(source: ParallelQuery_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer: IEqualityComparer_1<TKey>): ParallelQuery_1<IGrouping_2<TKey, TSource>>;
    static groupBy<TSource, TKey>(source: ParallelQuery_1<TSource>, keySelector: Func_2<TSource, TKey>): ParallelQuery_1<IGrouping_2<TKey, TSource>>;
    static groupJoin<TOuter, TInner, TKey, TResult>(outer: ParallelQuery_1<TOuter>, inner: IEnumerable_1<TInner>, outerKeySelector: Func_2<TOuter, TKey>, innerKeySelector: Func_2<TInner, TKey>, resultSelector: Func_3<TOuter, IEnumerable_1<TInner>, TResult>, comparer: IEqualityComparer_1<TKey>): ParallelQuery_1<TResult>;
    static groupJoin<TOuter, TInner, TKey, TResult>(outer: ParallelQuery_1<TOuter>, inner: IEnumerable_1<TInner>, outerKeySelector: Func_2<TOuter, TKey>, innerKeySelector: Func_2<TInner, TKey>, resultSelector: Func_3<TOuter, IEnumerable_1<TInner>, TResult>): ParallelQuery_1<TResult>;
    static groupJoin<TOuter, TInner, TKey, TResult>(outer: ParallelQuery_1<TOuter>, inner: ParallelQuery_1<TInner>, outerKeySelector: Func_2<TOuter, TKey>, innerKeySelector: Func_2<TInner, TKey>, resultSelector: Func_3<TOuter, IEnumerable_1<TInner>, TResult>, comparer: IEqualityComparer_1<TKey>): ParallelQuery_1<TResult>;
    static groupJoin<TOuter, TInner, TKey, TResult>(outer: ParallelQuery_1<TOuter>, inner: ParallelQuery_1<TInner>, outerKeySelector: Func_2<TOuter, TKey>, innerKeySelector: Func_2<TInner, TKey>, resultSelector: Func_3<TOuter, IEnumerable_1<TInner>, TResult>): ParallelQuery_1<TResult>;
    static intersect<TSource>(first: ParallelQuery_1<TSource>, second: IEnumerable_1<TSource>, comparer: IEqualityComparer_1<TSource>): ParallelQuery_1<TSource>;
    static intersect<TSource>(first: ParallelQuery_1<TSource>, second: IEnumerable_1<TSource>): ParallelQuery_1<TSource>;
    static intersect<TSource>(first: ParallelQuery_1<TSource>, second: ParallelQuery_1<TSource>, comparer: IEqualityComparer_1<TSource>): ParallelQuery_1<TSource>;
    static intersect<TSource>(first: ParallelQuery_1<TSource>, second: ParallelQuery_1<TSource>): ParallelQuery_1<TSource>;
    static join<TOuter, TInner, TKey, TResult>(outer: ParallelQuery_1<TOuter>, inner: IEnumerable_1<TInner>, outerKeySelector: Func_2<TOuter, TKey>, innerKeySelector: Func_2<TInner, TKey>, resultSelector: Func_3<TOuter, TInner, TResult>, comparer: IEqualityComparer_1<TKey>): ParallelQuery_1<TResult>;
    static join<TOuter, TInner, TKey, TResult>(outer: ParallelQuery_1<TOuter>, inner: IEnumerable_1<TInner>, outerKeySelector: Func_2<TOuter, TKey>, innerKeySelector: Func_2<TInner, TKey>, resultSelector: Func_3<TOuter, TInner, TResult>): ParallelQuery_1<TResult>;
    static join<TOuter, TInner, TKey, TResult>(outer: ParallelQuery_1<TOuter>, inner: ParallelQuery_1<TInner>, outerKeySelector: Func_2<TOuter, TKey>, innerKeySelector: Func_2<TInner, TKey>, resultSelector: Func_3<TOuter, TInner, TResult>, comparer: IEqualityComparer_1<TKey>): ParallelQuery_1<TResult>;
    static join<TOuter, TInner, TKey, TResult>(outer: ParallelQuery_1<TOuter>, inner: ParallelQuery_1<TInner>, outerKeySelector: Func_2<TOuter, TKey>, innerKeySelector: Func_2<TInner, TKey>, resultSelector: Func_3<TOuter, TInner, TResult>): ParallelQuery_1<TResult>;
    static last<TSource>(source: ParallelQuery_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): TSource;
    static last<TSource>(source: ParallelQuery_1<TSource>): TSource;
    static lastOrDefault<TSource>(source: ParallelQuery_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): TSource;
    static lastOrDefault<TSource>(source: ParallelQuery_1<TSource>): TSource;
    static longCount<TSource>(source: ParallelQuery_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): long;
    static longCount<TSource>(source: ParallelQuery_1<TSource>): long;
    static max<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, CLROf<decimal>>): decimal;
    static max<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, CLROf<double>>): double;
    static max<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, CLROf<int>>): int;
    static max<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, CLROf<long>>): long;
    static max<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<decimal>>>): Nullable_1<CLROf<decimal>>;
    static max<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<double>>>): Nullable_1<CLROf<double>>;
    static max<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<int>>>): Nullable_1<CLROf<int>>;
    static max<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<long>>>): Nullable_1<CLROf<long>>;
    static max<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<float>>>): Nullable_1<CLROf<float>>;
    static max<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, CLROf<float>>): float;
    static max<TSource, TResult>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, TResult>): TResult;
    static max<TSource>(source: ParallelQuery_1<TSource>): TSource;
    static max(source: ParallelQuery_1<CLROf<decimal>>): decimal;
    static max(source: ParallelQuery_1<CLROf<double>>): double;
    static max(source: ParallelQuery_1<CLROf<int>>): int;
    static max(source: ParallelQuery_1<CLROf<long>>): long;
    static max(source: ParallelQuery_1<Nullable_1<CLROf<decimal>>>): Nullable_1<CLROf<decimal>>;
    static max(source: ParallelQuery_1<Nullable_1<CLROf<double>>>): Nullable_1<CLROf<double>>;
    static max(source: ParallelQuery_1<Nullable_1<CLROf<int>>>): Nullable_1<CLROf<int>>;
    static max(source: ParallelQuery_1<Nullable_1<CLROf<long>>>): Nullable_1<CLROf<long>>;
    static max(source: ParallelQuery_1<Nullable_1<CLROf<float>>>): Nullable_1<CLROf<float>>;
    static max(source: ParallelQuery_1<CLROf<float>>): float;
    static min<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, CLROf<decimal>>): decimal;
    static min<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, CLROf<double>>): double;
    static min<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, CLROf<int>>): int;
    static min<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, CLROf<long>>): long;
    static min<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<decimal>>>): Nullable_1<CLROf<decimal>>;
    static min<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<double>>>): Nullable_1<CLROf<double>>;
    static min<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<int>>>): Nullable_1<CLROf<int>>;
    static min<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<long>>>): Nullable_1<CLROf<long>>;
    static min<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<float>>>): Nullable_1<CLROf<float>>;
    static min<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, CLROf<float>>): float;
    static min<TSource, TResult>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, TResult>): TResult;
    static min<TSource>(source: ParallelQuery_1<TSource>): TSource;
    static min(source: ParallelQuery_1<CLROf<decimal>>): decimal;
    static min(source: ParallelQuery_1<CLROf<double>>): double;
    static min(source: ParallelQuery_1<CLROf<int>>): int;
    static min(source: ParallelQuery_1<CLROf<long>>): long;
    static min(source: ParallelQuery_1<Nullable_1<CLROf<decimal>>>): Nullable_1<CLROf<decimal>>;
    static min(source: ParallelQuery_1<Nullable_1<CLROf<double>>>): Nullable_1<CLROf<double>>;
    static min(source: ParallelQuery_1<Nullable_1<CLROf<int>>>): Nullable_1<CLROf<int>>;
    static min(source: ParallelQuery_1<Nullable_1<CLROf<long>>>): Nullable_1<CLROf<long>>;
    static min(source: ParallelQuery_1<Nullable_1<CLROf<float>>>): Nullable_1<CLROf<float>>;
    static min(source: ParallelQuery_1<CLROf<float>>): float;
    static ofType<TResult>(source: ParallelQuery): ParallelQuery_1<TResult>;
    static orderBy<TSource, TKey>(source: ParallelQuery_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer: IComparer_1<TKey>): OrderedParallelQuery_1<TSource>;
    static orderBy<TSource, TKey>(source: ParallelQuery_1<TSource>, keySelector: Func_2<TSource, TKey>): OrderedParallelQuery_1<TSource>;
    static orderByDescending<TSource, TKey>(source: ParallelQuery_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer: IComparer_1<TKey>): OrderedParallelQuery_1<TSource>;
    static orderByDescending<TSource, TKey>(source: ParallelQuery_1<TSource>, keySelector: Func_2<TSource, TKey>): OrderedParallelQuery_1<TSource>;
    static range(start: int, count: int): ParallelQuery_1<CLROf<int>>;
    static repeat<TResult>(element: TResult, count: int): ParallelQuery_1<TResult>;
    static reverse<TSource>(source: ParallelQuery_1<TSource>): ParallelQuery_1<TSource>;
    static select<TSource, TResult>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, TResult>): ParallelQuery_1<TResult>;
    static select<TSource, TResult>(source: ParallelQuery_1<TSource>, selector: Func_3<TSource, CLROf<int>, TResult>): ParallelQuery_1<TResult>;
    static selectMany<TSource, TCollection, TResult>(source: ParallelQuery_1<TSource>, collectionSelector: Func_2<TSource, IEnumerable_1<TCollection>>, resultSelector: Func_3<TSource, TCollection, TResult>): ParallelQuery_1<TResult>;
    static selectMany<TSource, TResult>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, IEnumerable_1<TResult>>): ParallelQuery_1<TResult>;
    static selectMany<TSource, TCollection, TResult>(source: ParallelQuery_1<TSource>, collectionSelector: Func_3<TSource, CLROf<int>, IEnumerable_1<TCollection>>, resultSelector: Func_3<TSource, TCollection, TResult>): ParallelQuery_1<TResult>;
    static selectMany<TSource, TResult>(source: ParallelQuery_1<TSource>, selector: Func_3<TSource, CLROf<int>, IEnumerable_1<TResult>>): ParallelQuery_1<TResult>;
    static sequenceEqual<TSource>(first: ParallelQuery_1<TSource>, second: IEnumerable_1<TSource>, comparer: IEqualityComparer_1<TSource>): boolean;
    static sequenceEqual<TSource>(first: ParallelQuery_1<TSource>, second: IEnumerable_1<TSource>): boolean;
    static sequenceEqual<TSource>(first: ParallelQuery_1<TSource>, second: ParallelQuery_1<TSource>, comparer: IEqualityComparer_1<TSource>): boolean;
    static sequenceEqual<TSource>(first: ParallelQuery_1<TSource>, second: ParallelQuery_1<TSource>): boolean;
    static single<TSource>(source: ParallelQuery_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): TSource;
    static single<TSource>(source: ParallelQuery_1<TSource>): TSource;
    static singleOrDefault<TSource>(source: ParallelQuery_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): TSource;
    static singleOrDefault<TSource>(source: ParallelQuery_1<TSource>): TSource;
    static skip<TSource>(source: ParallelQuery_1<TSource>, count: int): ParallelQuery_1<TSource>;
    static skipWhile<TSource>(source: ParallelQuery_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): ParallelQuery_1<TSource>;
    static skipWhile<TSource>(source: ParallelQuery_1<TSource>, predicate: Func_3<TSource, CLROf<int>, CLROf<boolean>>): ParallelQuery_1<TSource>;
    static sum<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, CLROf<decimal>>): decimal;
    static sum<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, CLROf<double>>): double;
    static sum<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, CLROf<int>>): int;
    static sum<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, CLROf<long>>): long;
    static sum<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<decimal>>>): Nullable_1<CLROf<decimal>>;
    static sum<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<double>>>): Nullable_1<CLROf<double>>;
    static sum<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<int>>>): Nullable_1<CLROf<int>>;
    static sum<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<long>>>): Nullable_1<CLROf<long>>;
    static sum<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, Nullable_1<CLROf<float>>>): Nullable_1<CLROf<float>>;
    static sum<TSource>(source: ParallelQuery_1<TSource>, selector: Func_2<TSource, CLROf<float>>): float;
    static sum(source: ParallelQuery_1<CLROf<decimal>>): decimal;
    static sum(source: ParallelQuery_1<CLROf<double>>): double;
    static sum(source: ParallelQuery_1<CLROf<int>>): int;
    static sum(source: ParallelQuery_1<CLROf<long>>): long;
    static sum(source: ParallelQuery_1<Nullable_1<CLROf<decimal>>>): Nullable_1<CLROf<decimal>>;
    static sum(source: ParallelQuery_1<Nullable_1<CLROf<double>>>): Nullable_1<CLROf<double>>;
    static sum(source: ParallelQuery_1<Nullable_1<CLROf<int>>>): Nullable_1<CLROf<int>>;
    static sum(source: ParallelQuery_1<Nullable_1<CLROf<long>>>): Nullable_1<CLROf<long>>;
    static sum(source: ParallelQuery_1<Nullable_1<CLROf<float>>>): Nullable_1<CLROf<float>>;
    static sum(source: ParallelQuery_1<CLROf<float>>): float;
    static take<TSource>(source: ParallelQuery_1<TSource>, count: int): ParallelQuery_1<TSource>;
    static takeWhile<TSource>(source: ParallelQuery_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): ParallelQuery_1<TSource>;
    static takeWhile<TSource>(source: ParallelQuery_1<TSource>, predicate: Func_3<TSource, CLROf<int>, CLROf<boolean>>): ParallelQuery_1<TSource>;
    static thenBy<TSource, TKey>(source: OrderedParallelQuery_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer: IComparer_1<TKey>): OrderedParallelQuery_1<TSource>;
    static thenBy<TSource, TKey>(source: OrderedParallelQuery_1<TSource>, keySelector: Func_2<TSource, TKey>): OrderedParallelQuery_1<TSource>;
    static thenByDescending<TSource, TKey>(source: OrderedParallelQuery_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer: IComparer_1<TKey>): OrderedParallelQuery_1<TSource>;
    static thenByDescending<TSource, TKey>(source: OrderedParallelQuery_1<TSource>, keySelector: Func_2<TSource, TKey>): OrderedParallelQuery_1<TSource>;
    static toArray<TSource>(source: ParallelQuery_1<TSource>): TSource[];
    static toDictionary<TSource, TKey, TElement>(source: ParallelQuery_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TElement>, comparer: IEqualityComparer_1<TKey>): Dictionary_2<TKey, TElement>;
    static toDictionary<TSource, TKey, TElement>(source: ParallelQuery_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TElement>): Dictionary_2<TKey, TElement>;
    static toDictionary<TSource, TKey>(source: ParallelQuery_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer: IEqualityComparer_1<TKey>): Dictionary_2<TKey, TSource>;
    static toDictionary<TSource, TKey>(source: ParallelQuery_1<TSource>, keySelector: Func_2<TSource, TKey>): Dictionary_2<TKey, TSource>;
    static toList<TSource>(source: ParallelQuery_1<TSource>): List_1<TSource>;
    static toLookup<TSource, TKey, TElement>(source: ParallelQuery_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TElement>, comparer: IEqualityComparer_1<TKey>): ILookup_2<TKey, TElement>;
    static toLookup<TSource, TKey, TElement>(source: ParallelQuery_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TElement>): ILookup_2<TKey, TElement>;
    static toLookup<TSource, TKey>(source: ParallelQuery_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer: IEqualityComparer_1<TKey>): ILookup_2<TKey, TSource>;
    static toLookup<TSource, TKey>(source: ParallelQuery_1<TSource>, keySelector: Func_2<TSource, TKey>): ILookup_2<TKey, TSource>;
    static union<TSource>(first: ParallelQuery_1<TSource>, second: IEnumerable_1<TSource>, comparer: IEqualityComparer_1<TSource>): ParallelQuery_1<TSource>;
    static union<TSource>(first: ParallelQuery_1<TSource>, second: IEnumerable_1<TSource>): ParallelQuery_1<TSource>;
    static union<TSource>(first: ParallelQuery_1<TSource>, second: ParallelQuery_1<TSource>, comparer: IEqualityComparer_1<TSource>): ParallelQuery_1<TSource>;
    static union<TSource>(first: ParallelQuery_1<TSource>, second: ParallelQuery_1<TSource>): ParallelQuery_1<TSource>;
    static where<TSource>(source: ParallelQuery_1<TSource>, predicate: Func_2<TSource, CLROf<boolean>>): ParallelQuery_1<TSource>;
    static where<TSource>(source: ParallelQuery_1<TSource>, predicate: Func_3<TSource, CLROf<int>, CLROf<boolean>>): ParallelQuery_1<TSource>;
    static withCancellation<TSource>(source: ParallelQuery_1<TSource>, cancellationToken: CancellationToken): ParallelQuery_1<TSource>;
    static withDegreeOfParallelism<TSource>(source: ParallelQuery_1<TSource>, degreeOfParallelism: int): ParallelQuery_1<TSource>;
    static withExecutionMode<TSource>(source: ParallelQuery_1<TSource>, executionMode: ParallelExecutionMode): ParallelQuery_1<TSource>;
    static withMergeOptions<TSource>(source: ParallelQuery_1<TSource>, mergeOptions: ParallelMergeOptions): ParallelQuery_1<TSource>;
    static zip<TFirst, TSecond, TResult>(first: ParallelQuery_1<TFirst>, second: IEnumerable_1<TSecond>, resultSelector: Func_3<TFirst, TSecond, TResult>): ParallelQuery_1<TResult>;
    static zip<TFirst, TSecond, TResult>(first: ParallelQuery_1<TFirst>, second: ParallelQuery_1<TSecond>, resultSelector: Func_3<TFirst, TSecond, TResult>): ParallelQuery_1<TResult>;
}


export type ParallelEnumerable = ParallelEnumerable$instance;

export abstract class Queryable$instance {
    static aggregate<TSource>(source: IQueryable_1<TSource>, func: Expression_1<Func_3<TSource, TSource, TSource>>): TSource;
    static aggregate<TSource, TAccumulate, TResult>(source: IQueryable_1<TSource>, seed: TAccumulate, func: Expression_1<Func_3<TAccumulate, TSource, TAccumulate>>, selector: Expression_1<Func_2<TAccumulate, TResult>>): TResult;
    static aggregate<TSource, TAccumulate>(source: IQueryable_1<TSource>, seed: TAccumulate, func: Expression_1<Func_3<TAccumulate, TSource, TAccumulate>>): TAccumulate;
    static aggregateBy<TSource, TKey, TAccumulate>(source: IQueryable_1<TSource>, keySelector: Expression_1<Func_2<TSource, TKey>>, seedSelector: Expression_1<Func_2<TKey, TAccumulate>>, func: Expression_1<Func_3<TAccumulate, TSource, TAccumulate>>, keyComparer?: IEqualityComparer_1<TKey>): IQueryable_1<KeyValuePair_2<TKey, TAccumulate>>;
    static aggregateBy<TSource, TKey, TAccumulate>(source: IQueryable_1<TSource>, keySelector: Expression_1<Func_2<TSource, TKey>>, seed: TAccumulate, func: Expression_1<Func_3<TAccumulate, TSource, TAccumulate>>, keyComparer?: IEqualityComparer_1<TKey>): IQueryable_1<KeyValuePair_2<TKey, TAccumulate>>;
    static all<TSource>(source: IQueryable_1<TSource>, predicate: Expression_1<Func_2<TSource, CLROf<boolean>>>): boolean;
    static any_<TSource>(source: IQueryable_1<TSource>, predicate: Expression_1<Func_2<TSource, CLROf<boolean>>>): boolean;
    static any_<TSource>(source: IQueryable_1<TSource>): boolean;
    static append<TSource>(source: IQueryable_1<TSource>, element: TSource): IQueryable_1<TSource>;
    static asQueryable<TElement>(source: IEnumerable_1<TElement>): IQueryable_1<TElement>;
    static asQueryable(source: IEnumerable): IQueryable;
    static average<TSource>(source: IQueryable_1<TSource>, selector: Expression_1<Func_2<TSource, CLROf<decimal>>>): decimal;
    static average<TSource>(source: IQueryable_1<TSource>, selector: Expression_1<Func_2<TSource, CLROf<int>>>): double;
    static average<TSource>(source: IQueryable_1<TSource>, selector: Expression_1<Func_2<TSource, Nullable_1<CLROf<decimal>>>>): Nullable_1<CLROf<decimal>>;
    static average<TSource>(source: IQueryable_1<TSource>, selector: Expression_1<Func_2<TSource, Nullable_1<CLROf<int>>>>): Nullable_1<CLROf<double>>;
    static average<TSource>(source: IQueryable_1<TSource>, selector: Expression_1<Func_2<TSource, Nullable_1<CLROf<float>>>>): Nullable_1<CLROf<float>>;
    static average<TSource>(source: IQueryable_1<TSource>, selector: Expression_1<Func_2<TSource, CLROf<float>>>): float;
    static average(source: IQueryable_1<CLROf<decimal>>): decimal;
    static average(source: IQueryable_1<CLROf<double>>): double;
    static average(source: IQueryable_1<CLROf<int>>): double;
    static average(source: IQueryable_1<CLROf<long>>): double;
    static average(source: IQueryable_1<Nullable_1<CLROf<decimal>>>): Nullable_1<CLROf<decimal>>;
    static average(source: IQueryable_1<Nullable_1<CLROf<double>>>): Nullable_1<CLROf<double>>;
    static average(source: IQueryable_1<Nullable_1<CLROf<int>>>): Nullable_1<CLROf<double>>;
    static average(source: IQueryable_1<Nullable_1<CLROf<long>>>): Nullable_1<CLROf<double>>;
    static average(source: IQueryable_1<Nullable_1<CLROf<float>>>): Nullable_1<CLROf<float>>;
    static average(source: IQueryable_1<CLROf<float>>): float;
    static cast<TResult>(source: IQueryable): IQueryable_1<TResult>;
    static chunk<TSource>(source: IQueryable_1<TSource>, size: int): IQueryable_1<TSource[]>;
    static concat<TSource>(source1: IQueryable_1<TSource>, source2: IEnumerable_1<TSource>): IQueryable_1<TSource>;
    static contains<TSource>(source: IQueryable_1<TSource>, item: TSource, comparer: IEqualityComparer_1<TSource>): boolean;
    static contains<TSource>(source: IQueryable_1<TSource>, item: TSource): boolean;
    static count<TSource>(source: IQueryable_1<TSource>, predicate: Expression_1<Func_2<TSource, CLROf<boolean>>>): int;
    static count<TSource>(source: IQueryable_1<TSource>): int;
    static countBy<TSource, TKey>(source: IQueryable_1<TSource>, keySelector: Expression_1<Func_2<TSource, TKey>>, comparer?: IEqualityComparer_1<TKey>): IQueryable_1<KeyValuePair_2<TKey, CLROf<int>>>;
    static defaultIfEmpty<TSource>(source: IQueryable_1<TSource>, defaultValue: TSource): IQueryable_1<TSource>;
    static defaultIfEmpty<TSource>(source: IQueryable_1<TSource>): IQueryable_1<TSource>;
    static distinct<TSource>(source: IQueryable_1<TSource>, comparer: IEqualityComparer_1<TSource>): IQueryable_1<TSource>;
    static distinct<TSource>(source: IQueryable_1<TSource>): IQueryable_1<TSource>;
    static distinctBy<TSource, TKey>(source: IQueryable_1<TSource>, keySelector: Expression_1<Func_2<TSource, TKey>>, comparer: IEqualityComparer_1<TKey>): IQueryable_1<TSource>;
    static distinctBy<TSource, TKey>(source: IQueryable_1<TSource>, keySelector: Expression_1<Func_2<TSource, TKey>>): IQueryable_1<TSource>;
    static elementAt<TSource>(source: IQueryable_1<TSource>, index: Index): TSource;
    static elementAt<TSource>(source: IQueryable_1<TSource>, index: int): TSource;
    static elementAtOrDefault<TSource>(source: IQueryable_1<TSource>, index: Index): TSource;
    static elementAtOrDefault<TSource>(source: IQueryable_1<TSource>, index: int): TSource;
    static except<TSource>(source1: IQueryable_1<TSource>, source2: IEnumerable_1<TSource>, comparer: IEqualityComparer_1<TSource>): IQueryable_1<TSource>;
    static except<TSource>(source1: IQueryable_1<TSource>, source2: IEnumerable_1<TSource>): IQueryable_1<TSource>;
    static exceptBy<TSource, TKey>(source1: IQueryable_1<TSource>, source2: IEnumerable_1<TKey>, keySelector: Expression_1<Func_2<TSource, TKey>>, comparer: IEqualityComparer_1<TKey>): IQueryable_1<TSource>;
    static exceptBy<TSource, TKey>(source1: IQueryable_1<TSource>, source2: IEnumerable_1<TKey>, keySelector: Expression_1<Func_2<TSource, TKey>>): IQueryable_1<TSource>;
    static first<TSource>(source: IQueryable_1<TSource>, predicate: Expression_1<Func_2<TSource, CLROf<boolean>>>): TSource;
    static first<TSource>(source: IQueryable_1<TSource>): TSource;
    static firstOrDefault<TSource>(source: IQueryable_1<TSource>, predicate: Expression_1<Func_2<TSource, CLROf<boolean>>>, defaultValue: TSource): TSource;
    static firstOrDefault<TSource>(source: IQueryable_1<TSource>, predicate: Expression_1<Func_2<TSource, CLROf<boolean>>>): TSource;
    static firstOrDefault<TSource>(source: IQueryable_1<TSource>, defaultValue: TSource): TSource;
    static firstOrDefault<TSource>(source: IQueryable_1<TSource>): TSource;
    static groupBy<TSource, TKey, TElement, TResult>(source: IQueryable_1<TSource>, keySelector: Expression_1<Func_2<TSource, TKey>>, elementSelector: Expression_1<Func_2<TSource, TElement>>, resultSelector: Expression_1<Func_3<TKey, IEnumerable_1<TElement>, TResult>>, comparer: IEqualityComparer_1<TKey>): IQueryable_1<TResult>;
    static groupBy<TSource, TKey, TElement, TResult>(source: IQueryable_1<TSource>, keySelector: Expression_1<Func_2<TSource, TKey>>, elementSelector: Expression_1<Func_2<TSource, TElement>>, resultSelector: Expression_1<Func_3<TKey, IEnumerable_1<TElement>, TResult>>): IQueryable_1<TResult>;
    static groupBy<TSource, TKey, TElement>(source: IQueryable_1<TSource>, keySelector: Expression_1<Func_2<TSource, TKey>>, elementSelector: Expression_1<Func_2<TSource, TElement>>, comparer: IEqualityComparer_1<TKey>): IQueryable_1<IGrouping_2<TKey, TElement>>;
    static groupBy<TSource, TKey, TElement>(source: IQueryable_1<TSource>, keySelector: Expression_1<Func_2<TSource, TKey>>, elementSelector: Expression_1<Func_2<TSource, TElement>>): IQueryable_1<IGrouping_2<TKey, TElement>>;
    static groupBy<TSource, TKey>(source: IQueryable_1<TSource>, keySelector: Expression_1<Func_2<TSource, TKey>>, comparer: IEqualityComparer_1<TKey>): IQueryable_1<IGrouping_2<TKey, TSource>>;
    static groupBy<TSource, TKey>(source: IQueryable_1<TSource>, keySelector: Expression_1<Func_2<TSource, TKey>>): IQueryable_1<IGrouping_2<TKey, TSource>>;
    static groupJoin<TOuter, TInner, TKey, TResult>(outer: IQueryable_1<TOuter>, inner: IEnumerable_1<TInner>, outerKeySelector: Expression_1<Func_2<TOuter, TKey>>, innerKeySelector: Expression_1<Func_2<TInner, TKey>>, resultSelector: Expression_1<Func_3<TOuter, IEnumerable_1<TInner>, TResult>>, comparer: IEqualityComparer_1<TKey>): IQueryable_1<TResult>;
    static groupJoin<TOuter, TInner, TKey, TResult>(outer: IQueryable_1<TOuter>, inner: IEnumerable_1<TInner>, outerKeySelector: Expression_1<Func_2<TOuter, TKey>>, innerKeySelector: Expression_1<Func_2<TInner, TKey>>, resultSelector: Expression_1<Func_3<TOuter, IEnumerable_1<TInner>, TResult>>): IQueryable_1<TResult>;
    static index<TSource>(source: IQueryable_1<TSource>): IQueryable_1<ValueTuple_2<CLROf<int>, TSource>>;
    static intersect<TSource>(source1: IQueryable_1<TSource>, source2: IEnumerable_1<TSource>, comparer: IEqualityComparer_1<TSource>): IQueryable_1<TSource>;
    static intersect<TSource>(source1: IQueryable_1<TSource>, source2: IEnumerable_1<TSource>): IQueryable_1<TSource>;
    static intersectBy<TSource, TKey>(source1: IQueryable_1<TSource>, source2: IEnumerable_1<TKey>, keySelector: Expression_1<Func_2<TSource, TKey>>, comparer: IEqualityComparer_1<TKey>): IQueryable_1<TSource>;
    static intersectBy<TSource, TKey>(source1: IQueryable_1<TSource>, source2: IEnumerable_1<TKey>, keySelector: Expression_1<Func_2<TSource, TKey>>): IQueryable_1<TSource>;
    static join<TOuter, TInner, TKey, TResult>(outer: IQueryable_1<TOuter>, inner: IEnumerable_1<TInner>, outerKeySelector: Expression_1<Func_2<TOuter, TKey>>, innerKeySelector: Expression_1<Func_2<TInner, TKey>>, resultSelector: Expression_1<Func_3<TOuter, TInner, TResult>>, comparer: IEqualityComparer_1<TKey>): IQueryable_1<TResult>;
    static join<TOuter, TInner, TKey, TResult>(outer: IQueryable_1<TOuter>, inner: IEnumerable_1<TInner>, outerKeySelector: Expression_1<Func_2<TOuter, TKey>>, innerKeySelector: Expression_1<Func_2<TInner, TKey>>, resultSelector: Expression_1<Func_3<TOuter, TInner, TResult>>): IQueryable_1<TResult>;
    static last<TSource>(source: IQueryable_1<TSource>, predicate: Expression_1<Func_2<TSource, CLROf<boolean>>>): TSource;
    static last<TSource>(source: IQueryable_1<TSource>): TSource;
    static lastOrDefault<TSource>(source: IQueryable_1<TSource>, predicate: Expression_1<Func_2<TSource, CLROf<boolean>>>, defaultValue: TSource): TSource;
    static lastOrDefault<TSource>(source: IQueryable_1<TSource>, predicate: Expression_1<Func_2<TSource, CLROf<boolean>>>): TSource;
    static lastOrDefault<TSource>(source: IQueryable_1<TSource>, defaultValue: TSource): TSource;
    static lastOrDefault<TSource>(source: IQueryable_1<TSource>): TSource;
    static leftJoin<TOuter, TInner, TKey, TResult>(outer: IQueryable_1<TOuter>, inner: IEnumerable_1<TInner>, outerKeySelector: Expression_1<Func_2<TOuter, TKey>>, innerKeySelector: Expression_1<Func_2<TInner, TKey>>, resultSelector: Expression_1<Func_3<TOuter, TInner, TResult>>, comparer: IEqualityComparer_1<TKey>): IQueryable_1<TResult>;
    static leftJoin<TOuter, TInner, TKey, TResult>(outer: IQueryable_1<TOuter>, inner: IEnumerable_1<TInner>, outerKeySelector: Expression_1<Func_2<TOuter, TKey>>, innerKeySelector: Expression_1<Func_2<TInner, TKey>>, resultSelector: Expression_1<Func_3<TOuter, TInner, TResult>>): IQueryable_1<TResult>;
    static longCount<TSource>(source: IQueryable_1<TSource>, predicate: Expression_1<Func_2<TSource, CLROf<boolean>>>): long;
    static longCount<TSource>(source: IQueryable_1<TSource>): long;
    static max<TSource, TResult>(source: IQueryable_1<TSource>, selector: Expression_1<Func_2<TSource, TResult>>): TResult;
    static max<TSource>(source: IQueryable_1<TSource>, comparer: IComparer_1<TSource>): TSource;
    static max<TSource>(source: IQueryable_1<TSource>): TSource;
    static maxBy<TSource, TKey>(source: IQueryable_1<TSource>, keySelector: Expression_1<Func_2<TSource, TKey>>, comparer: IComparer_1<TSource>): TSource;
    static maxBy<TSource, TKey>(source: IQueryable_1<TSource>, keySelector: Expression_1<Func_2<TSource, TKey>>): TSource;
    static min<TSource, TResult>(source: IQueryable_1<TSource>, selector: Expression_1<Func_2<TSource, TResult>>): TResult;
    static min<TSource>(source: IQueryable_1<TSource>, comparer: IComparer_1<TSource>): TSource;
    static min<TSource>(source: IQueryable_1<TSource>): TSource;
    static minBy<TSource, TKey>(source: IQueryable_1<TSource>, keySelector: Expression_1<Func_2<TSource, TKey>>, comparer: IComparer_1<TSource>): TSource;
    static minBy<TSource, TKey>(source: IQueryable_1<TSource>, keySelector: Expression_1<Func_2<TSource, TKey>>): TSource;
    static ofType<TResult>(source: IQueryable): IQueryable_1<TResult>;
    static order<T>(source: IQueryable_1<T>, comparer: IComparer_1<T>): IOrderedQueryable_1<T>;
    static order<T>(source: IQueryable_1<T>): IOrderedQueryable_1<T>;
    static orderBy<TSource, TKey>(source: IQueryable_1<TSource>, keySelector: Expression_1<Func_2<TSource, TKey>>, comparer: IComparer_1<TKey>): IOrderedQueryable_1<TSource>;
    static orderBy<TSource, TKey>(source: IQueryable_1<TSource>, keySelector: Expression_1<Func_2<TSource, TKey>>): IOrderedQueryable_1<TSource>;
    static orderByDescending<TSource, TKey>(source: IQueryable_1<TSource>, keySelector: Expression_1<Func_2<TSource, TKey>>, comparer: IComparer_1<TKey>): IOrderedQueryable_1<TSource>;
    static orderByDescending<TSource, TKey>(source: IQueryable_1<TSource>, keySelector: Expression_1<Func_2<TSource, TKey>>): IOrderedQueryable_1<TSource>;
    static orderDescending<T>(source: IQueryable_1<T>, comparer: IComparer_1<T>): IOrderedQueryable_1<T>;
    static orderDescending<T>(source: IQueryable_1<T>): IOrderedQueryable_1<T>;
    static prepend<TSource>(source: IQueryable_1<TSource>, element: TSource): IQueryable_1<TSource>;
    static reverse<TSource>(source: IQueryable_1<TSource>): IQueryable_1<TSource>;
    static rightJoin<TOuter, TInner, TKey, TResult>(outer: IQueryable_1<TOuter>, inner: IEnumerable_1<TInner>, outerKeySelector: Expression_1<Func_2<TOuter, TKey>>, innerKeySelector: Expression_1<Func_2<TInner, TKey>>, resultSelector: Expression_1<Func_3<TOuter, TInner, TResult>>, comparer: IEqualityComparer_1<TKey>): IQueryable_1<TResult>;
    static rightJoin<TOuter, TInner, TKey, TResult>(outer: IQueryable_1<TOuter>, inner: IEnumerable_1<TInner>, outerKeySelector: Expression_1<Func_2<TOuter, TKey>>, innerKeySelector: Expression_1<Func_2<TInner, TKey>>, resultSelector: Expression_1<Func_3<TOuter, TInner, TResult>>): IQueryable_1<TResult>;
    static select<TSource, TResult>(source: IQueryable_1<TSource>, selector: Expression_1<Func_2<TSource, TResult>>): IQueryable_1<TResult>;
    static selectMany<TSource, TCollection, TResult>(source: IQueryable_1<TSource>, collectionSelector: Expression_1<Func_3<TSource, CLROf<int>, IEnumerable_1<TCollection>>>, resultSelector: Expression_1<Func_3<TSource, TCollection, TResult>>): IQueryable_1<TResult>;
    static selectMany<TSource, TResult>(source: IQueryable_1<TSource>, selector: Expression_1<Func_2<TSource, IEnumerable_1<TResult>>>): IQueryable_1<TResult>;
    static sequenceEqual<TSource>(source1: IQueryable_1<TSource>, source2: IEnumerable_1<TSource>, comparer: IEqualityComparer_1<TSource>): boolean;
    static sequenceEqual<TSource>(source1: IQueryable_1<TSource>, source2: IEnumerable_1<TSource>): boolean;
    static shuffle<TSource>(source: IQueryable_1<TSource>): IQueryable_1<TSource>;
    static single<TSource>(source: IQueryable_1<TSource>, predicate: Expression_1<Func_2<TSource, CLROf<boolean>>>): TSource;
    static single<TSource>(source: IQueryable_1<TSource>): TSource;
    static singleOrDefault<TSource>(source: IQueryable_1<TSource>, predicate: Expression_1<Func_2<TSource, CLROf<boolean>>>, defaultValue: TSource): TSource;
    static singleOrDefault<TSource>(source: IQueryable_1<TSource>, predicate: Expression_1<Func_2<TSource, CLROf<boolean>>>): TSource;
    static singleOrDefault<TSource>(source: IQueryable_1<TSource>, defaultValue: TSource): TSource;
    static singleOrDefault<TSource>(source: IQueryable_1<TSource>): TSource;
    static skip<TSource>(source: IQueryable_1<TSource>, count: int): IQueryable_1<TSource>;
    static skipLast<TSource>(source: IQueryable_1<TSource>, count: int): IQueryable_1<TSource>;
    static skipWhile<TSource>(source: IQueryable_1<TSource>, predicate: Expression_1<Func_2<TSource, CLROf<boolean>>>): IQueryable_1<TSource>;
    static sum<TSource>(source: IQueryable_1<TSource>, selector: Expression_1<Func_2<TSource, CLROf<decimal>>>): decimal;
    static sum<TSource>(source: IQueryable_1<TSource>, selector: Expression_1<Func_2<TSource, CLROf<double>>>): double;
    static sum<TSource>(source: IQueryable_1<TSource>, selector: Expression_1<Func_2<TSource, CLROf<int>>>): int;
    static sum<TSource>(source: IQueryable_1<TSource>, selector: Expression_1<Func_2<TSource, CLROf<long>>>): long;
    static sum<TSource>(source: IQueryable_1<TSource>, selector: Expression_1<Func_2<TSource, Nullable_1<CLROf<decimal>>>>): Nullable_1<CLROf<decimal>>;
    static sum<TSource>(source: IQueryable_1<TSource>, selector: Expression_1<Func_2<TSource, Nullable_1<CLROf<double>>>>): Nullable_1<CLROf<double>>;
    static sum<TSource>(source: IQueryable_1<TSource>, selector: Expression_1<Func_2<TSource, Nullable_1<CLROf<int>>>>): Nullable_1<CLROf<int>>;
    static sum<TSource>(source: IQueryable_1<TSource>, selector: Expression_1<Func_2<TSource, Nullable_1<CLROf<long>>>>): Nullable_1<CLROf<long>>;
    static sum<TSource>(source: IQueryable_1<TSource>, selector: Expression_1<Func_2<TSource, Nullable_1<CLROf<float>>>>): Nullable_1<CLROf<float>>;
    static sum<TSource>(source: IQueryable_1<TSource>, selector: Expression_1<Func_2<TSource, CLROf<float>>>): float;
    static sum(source: IQueryable_1<CLROf<decimal>>): decimal;
    static sum(source: IQueryable_1<CLROf<double>>): double;
    static sum(source: IQueryable_1<CLROf<int>>): int;
    static sum(source: IQueryable_1<CLROf<long>>): long;
    static sum(source: IQueryable_1<Nullable_1<CLROf<decimal>>>): Nullable_1<CLROf<decimal>>;
    static sum(source: IQueryable_1<Nullable_1<CLROf<double>>>): Nullable_1<CLROf<double>>;
    static sum(source: IQueryable_1<Nullable_1<CLROf<int>>>): Nullable_1<CLROf<int>>;
    static sum(source: IQueryable_1<Nullable_1<CLROf<long>>>): Nullable_1<CLROf<long>>;
    static sum(source: IQueryable_1<Nullable_1<CLROf<float>>>): Nullable_1<CLROf<float>>;
    static sum(source: IQueryable_1<CLROf<float>>): float;
    static take<TSource>(source: IQueryable_1<TSource>, count: int): IQueryable_1<TSource>;
    static take<TSource>(source: IQueryable_1<TSource>, range: Range): IQueryable_1<TSource>;
    static takeLast<TSource>(source: IQueryable_1<TSource>, count: int): IQueryable_1<TSource>;
    static takeWhile<TSource>(source: IQueryable_1<TSource>, predicate: Expression_1<Func_2<TSource, CLROf<boolean>>>): IQueryable_1<TSource>;
    static thenBy<TSource, TKey>(source: IOrderedQueryable_1<TSource>, keySelector: Expression_1<Func_2<TSource, TKey>>, comparer: IComparer_1<TKey>): IOrderedQueryable_1<TSource>;
    static thenBy<TSource, TKey>(source: IOrderedQueryable_1<TSource>, keySelector: Expression_1<Func_2<TSource, TKey>>): IOrderedQueryable_1<TSource>;
    static thenByDescending<TSource, TKey>(source: IOrderedQueryable_1<TSource>, keySelector: Expression_1<Func_2<TSource, TKey>>, comparer: IComparer_1<TKey>): IOrderedQueryable_1<TSource>;
    static thenByDescending<TSource, TKey>(source: IOrderedQueryable_1<TSource>, keySelector: Expression_1<Func_2<TSource, TKey>>): IOrderedQueryable_1<TSource>;
    static union<TSource>(source1: IQueryable_1<TSource>, source2: IEnumerable_1<TSource>, comparer: IEqualityComparer_1<TSource>): IQueryable_1<TSource>;
    static union<TSource>(source1: IQueryable_1<TSource>, source2: IEnumerable_1<TSource>): IQueryable_1<TSource>;
    static unionBy<TSource, TKey>(source1: IQueryable_1<TSource>, source2: IEnumerable_1<TSource>, keySelector: Expression_1<Func_2<TSource, TKey>>, comparer: IEqualityComparer_1<TKey>): IQueryable_1<TSource>;
    static unionBy<TSource, TKey>(source1: IQueryable_1<TSource>, source2: IEnumerable_1<TSource>, keySelector: Expression_1<Func_2<TSource, TKey>>): IQueryable_1<TSource>;
    static where<TSource>(source: IQueryable_1<TSource>, predicate: Expression_1<Func_2<TSource, CLROf<boolean>>>): IQueryable_1<TSource>;
    static zip<TFirst, TSecond, TResult>(source1: IQueryable_1<TFirst>, source2: IEnumerable_1<TSecond>, resultSelector: Expression_1<Func_3<TFirst, TSecond, TResult>>): IQueryable_1<TResult>;
    static zip<TFirst, TSecond, TThird>(source1: IQueryable_1<TFirst>, source2: IEnumerable_1<TSecond>, source3: IEnumerable_1<TThird>): IQueryable_1<ValueTuple_3<TFirst, TSecond, TThird>>;
    static zip<TFirst, TSecond>(source1: IQueryable_1<TFirst>, source2: IEnumerable_1<TSecond>): IQueryable_1<ValueTuple_2<TFirst, TSecond>>;
}


export type Queryable = Queryable$instance;

