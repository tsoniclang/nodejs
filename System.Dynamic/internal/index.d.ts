// Generated by tsbindgen - Architecture
// Namespace: System.Dynamic
// Assembly: System.Linq.Expressions

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IDictionary_2, IEnumerable_1, IEnumerator_1, IList_1, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import type { ReadOnlyCollection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { INotifyPropertyChanged } from "../../System.ComponentModel/internal/index.js";
import type { Expression, ExpressionType, LabelTarget, ParameterExpression } from "../../System.Linq.Expressions/internal/index.js";
import * as System_Runtime_CompilerServices_Internal from "../../System.Runtime.CompilerServices/internal/index.js";
import type { CallSite_1, CallSiteBinder } from "../../System.Runtime.CompilerServices/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Int32, Object as ClrObject, String as ClrString, Type, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface IDynamicMetaObjectProvider$instance {
    getMetaObject(parameter: Expression): DynamicMetaObject;
}


export type IDynamicMetaObjectProvider = IDynamicMetaObjectProvider$instance;

export interface IInvokeOnGetBinder$instance {
    readonly invokeOnGet: boolean;
}


export type IInvokeOnGetBinder = IInvokeOnGetBinder$instance;

export interface BinaryOperationBinder$instance extends DynamicMetaObjectBinder {
    readonly operation: ExpressionType;
    readonly returnType: Type;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: unknown[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    fallbackBinaryOperation(target: DynamicMetaObject, arg: DynamicMetaObject): DynamicMetaObject;
    fallbackBinaryOperation(target: DynamicMetaObject, arg: DynamicMetaObject, errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export const BinaryOperationBinder: {
};


export type BinaryOperationBinder = BinaryOperationBinder$instance;

export interface BindingRestrictions$instance {
    merge(restrictions: BindingRestrictions): BindingRestrictions;
    toExpression(): Expression;
}


export const BindingRestrictions: {
    readonly empty: BindingRestrictions;
    combine(contributingObjects: IList_1<DynamicMetaObject>): BindingRestrictions;
    getExpressionRestriction(expression: Expression): BindingRestrictions;
    getInstanceRestriction(expression: Expression, instance: unknown): BindingRestrictions;
    getTypeRestriction(expression: Expression, type_: Type): BindingRestrictions;
};


export type BindingRestrictions = BindingRestrictions$instance;

export interface CallInfo$instance {
    readonly argumentCount: int;
    readonly argumentNames: ReadOnlyCollection_1<CLROf<string>>;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const CallInfo: {
    new(argCount: int, argNames: string[]): CallInfo$instance;
    new(argCount: int, argNames: IEnumerable_1<CLROf<string>>): CallInfo$instance;
};


export type CallInfo = CallInfo$instance;

export interface ConvertBinder$instance extends DynamicMetaObjectBinder {
    readonly explicit: boolean;
    readonly returnType: Type;
    readonly type_: Type;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: unknown[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    fallbackConvert(target: DynamicMetaObject): DynamicMetaObject;
    fallbackConvert(target: DynamicMetaObject, errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export const ConvertBinder: {
};


export type ConvertBinder = ConvertBinder$instance;

export interface CreateInstanceBinder$instance extends DynamicMetaObjectBinder {
    readonly callInfo: CallInfo;
    readonly returnType: Type;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: unknown[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    fallbackCreateInstance(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    fallbackCreateInstance(target: DynamicMetaObject, args: DynamicMetaObject[], errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export const CreateInstanceBinder: {
};


export type CreateInstanceBinder = CreateInstanceBinder$instance;

export interface DeleteIndexBinder$instance extends DynamicMetaObjectBinder {
    readonly callInfo: CallInfo;
    readonly returnType: Type;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: unknown[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    fallbackDeleteIndex(target: DynamicMetaObject, indexes: DynamicMetaObject[]): DynamicMetaObject;
    fallbackDeleteIndex(target: DynamicMetaObject, indexes: DynamicMetaObject[], errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export const DeleteIndexBinder: {
};


export type DeleteIndexBinder = DeleteIndexBinder$instance;

export interface DeleteMemberBinder$instance extends DynamicMetaObjectBinder {
    readonly ignoreCase: boolean;
    readonly name: string;
    readonly returnType: Type;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: unknown[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    fallbackDeleteMember(target: DynamicMetaObject): DynamicMetaObject;
    fallbackDeleteMember(target: DynamicMetaObject, errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export const DeleteMemberBinder: {
};


export type DeleteMemberBinder = DeleteMemberBinder$instance;

export interface DynamicMetaObject$instance {
    readonly expression: Expression;
    readonly hasValue: boolean;
    readonly limitType: Type;
    readonly restrictions: BindingRestrictions;
    readonly runtimeType: Type;
    readonly value: unknown;
    bindBinaryOperation(binder: BinaryOperationBinder, arg: DynamicMetaObject): DynamicMetaObject;
    bindConvert(binder: ConvertBinder): DynamicMetaObject;
    bindCreateInstance(binder: CreateInstanceBinder, args: DynamicMetaObject[]): DynamicMetaObject;
    bindDeleteIndex(binder: DeleteIndexBinder, indexes: DynamicMetaObject[]): DynamicMetaObject;
    bindDeleteMember(binder: DeleteMemberBinder): DynamicMetaObject;
    bindGetIndex(binder: GetIndexBinder, indexes: DynamicMetaObject[]): DynamicMetaObject;
    bindGetMember(binder: GetMemberBinder): DynamicMetaObject;
    bindInvoke(binder: InvokeBinder, args: DynamicMetaObject[]): DynamicMetaObject;
    bindInvokeMember(binder: InvokeMemberBinder, args: DynamicMetaObject[]): DynamicMetaObject;
    bindSetIndex(binder: SetIndexBinder, indexes: DynamicMetaObject[], value: DynamicMetaObject): DynamicMetaObject;
    bindSetMember(binder: SetMemberBinder, value: DynamicMetaObject): DynamicMetaObject;
    bindUnaryOperation(binder: UnaryOperationBinder): DynamicMetaObject;
    getDynamicMemberNames(): IEnumerable_1<CLROf<string>>;
}


export const DynamicMetaObject: {
    new(expression: Expression, restrictions: BindingRestrictions): DynamicMetaObject$instance;
    new(expression: Expression, restrictions: BindingRestrictions, value: unknown): DynamicMetaObject$instance;
    readonly emptyMetaObjects: DynamicMetaObject[];
    create(value: unknown, expression: Expression): DynamicMetaObject;
};


export type DynamicMetaObject = DynamicMetaObject$instance;

export interface DynamicMetaObjectBinder$instance extends CallSiteBinder {
    readonly returnType: Type;
    bind(args: unknown[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: unknown[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    defer(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    defer(args: DynamicMetaObject[]): DynamicMetaObject;
    getUpdateExpression(type_: Type): Expression;
}


export const DynamicMetaObjectBinder: {
};


export type DynamicMetaObjectBinder = DynamicMetaObjectBinder$instance;

export interface DynamicObject$instance {
    getDynamicMemberNames(): IEnumerable_1<CLROf<string>>;
    getMetaObject(parameter: Expression): DynamicMetaObject;
    tryBinaryOperation(binder: BinaryOperationBinder, arg: unknown, result: { value: ref<unknown> }): boolean;
    tryConvert(binder: ConvertBinder, result: { value: ref<unknown> }): boolean;
    tryCreateInstance(binder: CreateInstanceBinder, args: unknown[], result: { value: ref<unknown> }): boolean;
    tryDeleteIndex(binder: DeleteIndexBinder, indexes: unknown[]): boolean;
    tryDeleteMember(binder: DeleteMemberBinder): boolean;
    tryGetIndex(binder: GetIndexBinder, indexes: unknown[], result: { value: ref<unknown> }): boolean;
    tryGetMember(binder: GetMemberBinder, result: { value: ref<unknown> }): boolean;
    tryInvoke(binder: InvokeBinder, args: unknown[], result: { value: ref<unknown> }): boolean;
    tryInvokeMember(binder: InvokeMemberBinder, args: unknown[], result: { value: ref<unknown> }): boolean;
    trySetIndex(binder: SetIndexBinder, indexes: unknown[], value: unknown): boolean;
    trySetMember(binder: SetMemberBinder, value: unknown): boolean;
    tryUnaryOperation(binder: UnaryOperationBinder, result: { value: ref<unknown> }): boolean;
}


export const DynamicObject: {
    new(): DynamicObject$instance;
};


export interface __DynamicObject$views {
    As_IDynamicMetaObjectProvider(): IDynamicMetaObjectProvider$instance;
}

export interface DynamicObject$instance extends IDynamicMetaObjectProvider$instance {}

export type DynamicObject = DynamicObject$instance & __DynamicObject$views;


export interface ExpandoObject$instance extends INotifyPropertyChanged {
}


export const ExpandoObject: {
    new(): ExpandoObject$instance;
};


export interface __ExpandoObject$views {
    As_IDynamicMetaObjectProvider(): IDynamicMetaObjectProvider$instance;
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<CLROf<string>, unknown>>;
    As_IDictionary_2(): System_Collections_Generic_Internal.IDictionary_2$instance<CLROf<string>, unknown>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<CLROf<string>, unknown>>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export interface ExpandoObject$instance extends System_Collections_Generic_Internal.IDictionary_2$instance<CLROf<string>, unknown>, System_ComponentModel_Internal.INotifyPropertyChanged$instance, IDynamicMetaObjectProvider$instance {}

export type ExpandoObject = ExpandoObject$instance & __ExpandoObject$views;


export interface GetIndexBinder$instance extends DynamicMetaObjectBinder {
    readonly callInfo: CallInfo;
    readonly returnType: Type;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: unknown[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    fallbackGetIndex(target: DynamicMetaObject, indexes: DynamicMetaObject[]): DynamicMetaObject;
    fallbackGetIndex(target: DynamicMetaObject, indexes: DynamicMetaObject[], errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export const GetIndexBinder: {
};


export type GetIndexBinder = GetIndexBinder$instance;

export interface GetMemberBinder$instance extends DynamicMetaObjectBinder {
    readonly ignoreCase: boolean;
    readonly name: string;
    readonly returnType: Type;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: unknown[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    fallbackGetMember(target: DynamicMetaObject): DynamicMetaObject;
    fallbackGetMember(target: DynamicMetaObject, errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export const GetMemberBinder: {
};


export type GetMemberBinder = GetMemberBinder$instance;

export interface InvokeBinder$instance extends DynamicMetaObjectBinder {
    readonly callInfo: CallInfo;
    readonly returnType: Type;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: unknown[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    fallbackInvoke(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    fallbackInvoke(target: DynamicMetaObject, args: DynamicMetaObject[], errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export const InvokeBinder: {
};


export type InvokeBinder = InvokeBinder$instance;

export interface InvokeMemberBinder$instance extends DynamicMetaObjectBinder {
    readonly callInfo: CallInfo;
    readonly ignoreCase: boolean;
    readonly name: string;
    readonly returnType: Type;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: unknown[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    fallbackInvoke(target: DynamicMetaObject, args: DynamicMetaObject[], errorSuggestion: DynamicMetaObject): DynamicMetaObject;
    fallbackInvokeMember(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    fallbackInvokeMember(target: DynamicMetaObject, args: DynamicMetaObject[], errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export const InvokeMemberBinder: {
};


export type InvokeMemberBinder = InvokeMemberBinder$instance;

export interface SetIndexBinder$instance extends DynamicMetaObjectBinder {
    readonly callInfo: CallInfo;
    readonly returnType: Type;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: unknown[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    fallbackSetIndex(target: DynamicMetaObject, indexes: DynamicMetaObject[], value: DynamicMetaObject): DynamicMetaObject;
    fallbackSetIndex(target: DynamicMetaObject, indexes: DynamicMetaObject[], value: DynamicMetaObject, errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export const SetIndexBinder: {
};


export type SetIndexBinder = SetIndexBinder$instance;

export interface SetMemberBinder$instance extends DynamicMetaObjectBinder {
    readonly ignoreCase: boolean;
    readonly name: string;
    readonly returnType: Type;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: unknown[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    fallbackSetMember(target: DynamicMetaObject, value: DynamicMetaObject): DynamicMetaObject;
    fallbackSetMember(target: DynamicMetaObject, value: DynamicMetaObject, errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export const SetMemberBinder: {
};


export type SetMemberBinder = SetMemberBinder$instance;

export interface UnaryOperationBinder$instance extends DynamicMetaObjectBinder {
    readonly operation: ExpressionType;
    readonly returnType: Type;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: unknown[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    fallbackUnaryOperation(target: DynamicMetaObject): DynamicMetaObject;
    fallbackUnaryOperation(target: DynamicMetaObject, errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export const UnaryOperationBinder: {
};


export type UnaryOperationBinder = UnaryOperationBinder$instance;

