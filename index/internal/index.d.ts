// Generated by tsbindgen - Architecture
// Namespace: nodejs
// Assembly: nodejs

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "@tsonic/dotnet/System.Collections.Generic.js";
import type { Dictionary, IAsyncEnumerable, ICollection, IDictionary, IEnumerable as IEnumerable__System_Collections_Generic, IEnumerator, KeyValuePair } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Collections_Internal from "@tsonic/dotnet/System.Collections.js";
import type { IEnumerable } from "@tsonic/dotnet/System.Collections.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Action, AsyncCallback, Boolean as ClrBoolean, Byte, DateTime, Delegate, Double, Exception, Func, IAsyncResult, ICloneable, IDisposable, Int16, Int32, Int64, IntPtr, MulticastDelegate, Nullable, Object as ClrObject, SByte, Single, String as ClrString, UInt16, UInt32, UInt64, ValueTuple, Void } from "@tsonic/dotnet/System.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { ISerializable } from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { SslProtocols } from "@tsonic/dotnet/System.Security.Authentication.js";
import type { X509Certificate2, X509Certificate2Collection } from "@tsonic/dotnet/System.Security.Cryptography.X509Certificates.js";
import type { Regex } from "@tsonic/dotnet/System.Text.RegularExpressions.js";
import type { Task } from "@tsonic/dotnet/System.Threading.Tasks.js";

export type DebugLogFunction = (message: string, args: unknown[]) => void;


export interface AddressInfo$instance {
    address: string;
    family: string;
    port: int;
}


export const AddressInfo: {
    new(): AddressInfo;
};


export type AddressInfo = AddressInfo$instance;

export interface AnyAaaaRecord$instance extends RecordWithTtl {
    readonly type_: string;
}


export const AnyAaaaRecord: {
    new(): AnyAaaaRecord;
};


export type AnyAaaaRecord = AnyAaaaRecord$instance;

export interface AnyARecord$instance extends RecordWithTtl {
    readonly type_: string;
}


export const AnyARecord: {
    new(): AnyARecord;
};


export type AnyARecord = AnyARecord$instance;

export interface AnyCaaRecord$instance extends CaaRecord {
    readonly type_: string;
}


export const AnyCaaRecord: {
    new(): AnyCaaRecord;
};


export type AnyCaaRecord = AnyCaaRecord$instance;

export interface AnyCnameRecord$instance {
    readonly type_: string;
    value: string;
}


export const AnyCnameRecord: {
    new(): AnyCnameRecord;
};


export type AnyCnameRecord = AnyCnameRecord$instance;

export interface AnyMxRecord$instance extends MxRecord {
    readonly type_: string;
}


export const AnyMxRecord: {
    new(): AnyMxRecord;
};


export type AnyMxRecord = AnyMxRecord$instance;

export interface AnyNaptrRecord$instance extends NaptrRecord {
    readonly type_: string;
}


export const AnyNaptrRecord: {
    new(): AnyNaptrRecord;
};


export type AnyNaptrRecord = AnyNaptrRecord$instance;

export interface AnyNsRecord$instance {
    readonly type_: string;
    value: string;
}


export const AnyNsRecord: {
    new(): AnyNsRecord;
};


export type AnyNsRecord = AnyNsRecord$instance;

export interface AnyPtrRecord$instance {
    readonly type_: string;
    value: string;
}


export const AnyPtrRecord: {
    new(): AnyPtrRecord;
};


export type AnyPtrRecord = AnyPtrRecord$instance;

export interface AnyRecord$instance {
    readonly type_: string;
}


export const AnyRecord: {
};


export type AnyRecord = AnyRecord$instance;

export interface AnySoaRecord$instance extends SoaRecord {
    readonly type_: string;
}


export const AnySoaRecord: {
    new(): AnySoaRecord;
};


export type AnySoaRecord = AnySoaRecord$instance;

export interface AnySrvRecord$instance extends SrvRecord {
    readonly type_: string;
}


export const AnySrvRecord: {
    new(): AnySrvRecord;
};


export type AnySrvRecord = AnySrvRecord$instance;

export interface AnyTlsaRecord$instance extends TlsaRecord {
    readonly type_: string;
}


export const AnyTlsaRecord: {
    new(): AnyTlsaRecord;
};


export type AnyTlsaRecord = AnyTlsaRecord$instance;

export interface AnyTxtRecord$instance {
    entries: string[];
    readonly type_: string;
}


export const AnyTxtRecord: {
    new(): AnyTxtRecord;
};


export type AnyTxtRecord = AnyTxtRecord$instance;

export interface AssertionError$instance extends Exception {
    get actual(): unknown | undefined;
    set actual(value: unknown);
    readonly code: string;
    get expected(): unknown | undefined;
    set expected(value: unknown);
    generatedMessage: boolean;
    operator: string;
}


export const AssertionError: {
    new(message: string, actual: unknown, expected: unknown, operator: string): AssertionError;
};


export type AssertionError = AssertionError$instance;

export interface BindOptions$instance {
    address: string;
    exclusive: boolean;
    fd: Nullable<System_Internal.Int32>;
    port: Nullable<System_Internal.Int32>;
}


export const BindOptions: {
    new(): BindOptions;
};


export type BindOptions = BindOptions$instance;

export interface BlockList$instance {
    addAddress(address: string, type_?: string): void;
    addRange(start: string, end: string, type_?: string): void;
    addSubnet(network: string, prefix: int, type_?: string): void;
    check(address: string, type_?: string): boolean;
    getRules(): string[];
}


export const BlockList: {
    new(): BlockList;
};


export type BlockList = BlockList$instance;

export interface BrotliOptions$instance {
    chunkSize: Nullable<System_Internal.Int32>;
    maxOutputLength: Nullable<System_Internal.Int32>;
    quality: Nullable<System_Internal.Int32>;
}


export const BrotliOptions: {
    new(): BrotliOptions;
};


export type BrotliOptions = BrotliOptions$instance;

export interface Buffer$instance {
    item: byte;
    readonly length: int;
    compare(target: Buffer, targetStart?: Nullable<System_Internal.Int32>, targetEnd?: Nullable<System_Internal.Int32>, sourceStart?: Nullable<System_Internal.Int32>, sourceEnd?: Nullable<System_Internal.Int32>): int;
    copy(target: Buffer, targetStart?: int, sourceStart?: Nullable<System_Internal.Int32>, sourceEnd?: Nullable<System_Internal.Int32>): int;
    equals(otherBuffer: Buffer): boolean;
    fill(value: unknown, offset?: int, end?: Nullable<System_Internal.Int32>, encoding?: string): Buffer;
    includes(value: unknown, byteOffset?: int, encoding?: string): boolean;
    indexOf(value: unknown, byteOffset?: int, encoding?: string): int;
    lastIndexOf(value: unknown, byteOffset?: Nullable<System_Internal.Int32>, encoding?: string): int;
    readBigInt64BE(offset?: int): long;
    readBigInt64LE(offset?: int): long;
    readBigUint64BE(offset?: int): ulong;
    readBigUInt64BE(offset?: int): ulong;
    readBigUint64LE(offset?: int): ulong;
    readBigUInt64LE(offset?: int): ulong;
    readDoubleBE(offset?: int): double;
    readDoubleLE(offset?: int): double;
    readFloatBE(offset?: int): float;
    readFloatLE(offset?: int): float;
    readInt16BE(offset?: int): short;
    readInt16LE(offset?: int): short;
    readInt32BE(offset?: int): int;
    readInt32LE(offset?: int): int;
    readInt8(offset?: int): sbyte;
    readIntBE(offset: int, byteLength: int): long;
    readIntLE(offset: int, byteLength: int): long;
    readUint16BE(offset?: int): ushort;
    readUInt16BE(offset?: int): ushort;
    readUint16LE(offset?: int): ushort;
    readUInt16LE(offset?: int): ushort;
    readUint32BE(offset?: int): uint;
    readUInt32BE(offset?: int): uint;
    readUint32LE(offset?: int): uint;
    readUInt32LE(offset?: int): uint;
    readUint8(offset?: int): byte;
    readUInt8(offset?: int): byte;
    readUintBE(offset: int, byteLength: int): ulong;
    readUIntBE(offset: int, byteLength: int): ulong;
    readUintLE(offset: int, byteLength: int): ulong;
    readUIntLE(offset: int, byteLength: int): ulong;
    reverse(): Buffer;
    slice(start?: Nullable<System_Internal.Int32>, end?: Nullable<System_Internal.Int32>): Buffer;
    subarray(start?: Nullable<System_Internal.Int32>, end?: Nullable<System_Internal.Int32>): Buffer;
    swap16(): Buffer;
    swap32(): Buffer;
    swap64(): Buffer;
    toJSON(): unknown;
    toString(encoding?: string, start?: int, end?: Nullable<System_Internal.Int32>): string;
    write(str: string, offset?: int, length?: Nullable<System_Internal.Int32>, encoding?: string): int;
    writeBigInt64BE(value: long, offset?: int): int;
    writeBigInt64LE(value: long, offset?: int): int;
    writeBigUint64BE(value: ulong, offset?: int): int;
    writeBigUInt64BE(value: ulong, offset?: int): int;
    writeBigUint64LE(value: ulong, offset?: int): int;
    writeBigUInt64LE(value: ulong, offset?: int): int;
    writeDoubleBE(value: double, offset?: int): int;
    writeDoubleLE(value: double, offset?: int): int;
    writeFloatBE(value: float, offset?: int): int;
    writeFloatLE(value: float, offset?: int): int;
    writeInt16BE(value: short, offset?: int): int;
    writeInt16LE(value: short, offset?: int): int;
    writeInt32BE(value: int, offset?: int): int;
    writeInt32LE(value: int, offset?: int): int;
    writeInt8(value: sbyte, offset?: int): int;
    writeIntBE(value: long, offset: int, byteLength: int): int;
    writeIntLE(value: long, offset: int, byteLength: int): int;
    writeUint16BE(value: ushort, offset?: int): int;
    writeUInt16BE(value: ushort, offset?: int): int;
    writeUint16LE(value: ushort, offset?: int): int;
    writeUInt16LE(value: ushort, offset?: int): int;
    writeUint32BE(value: uint, offset?: int): int;
    writeUInt32BE(value: uint, offset?: int): int;
    writeUint32LE(value: uint, offset?: int): int;
    writeUInt32LE(value: uint, offset?: int): int;
    writeUint8(value: byte, offset?: int): int;
    writeUInt8(value: byte, offset?: int): int;
    writeUintBE(value: ulong, offset: int, byteLength: int): int;
    writeUIntBE(value: ulong, offset: int, byteLength: int): int;
    writeUintLE(value: ulong, offset: int, byteLength: int): int;
    writeUIntLE(value: ulong, offset: int, byteLength: int): int;
}


export const Buffer: {
    new(): Buffer;
    poolSize: int;
    alloc(size: int, fill?: unknown, encoding?: string): Buffer;
    allocUnsafe(size: int): Buffer;
    allocUnsafeSlow(size: int): Buffer;
    byteLength(str: string, encoding?: string): int;
    compare(buf1: Buffer, buf2: Buffer): int;
    concat(list: Buffer[], totalLength?: Nullable<System_Internal.Int32>): Buffer;
    from_(buffer: Buffer): Buffer;
    from_(array: byte[]): Buffer;
    from_(array: int[]): Buffer;
    from_(str: string, encoding?: string): Buffer;
    isBuffer(obj: unknown): boolean;
    isEncoding(encoding: string): boolean;
    of_(...items: int[]): Buffer;
};


export type Buffer = Buffer$instance;

export interface CaaRecord$instance {
    get contactemail(): string | undefined;
    set contactemail(value: string);
    get contactphone(): string | undefined;
    set contactphone(value: string);
    critical: int;
    get iodef(): string | undefined;
    set iodef(value: string);
    get issue(): string | undefined;
    set issue(value: string);
    get issuewild(): string | undefined;
    set issuewild(value: string);
}


export const CaaRecord: {
    new(): CaaRecord;
};


export type CaaRecord = CaaRecord$instance;

export interface ChildProcess$instance extends EventEmitter {
    readonly connected: boolean;
    readonly exitCode: Nullable<System_Internal.Int32>;
    readonly killed: boolean;
    readonly pid: int;
    readonly referenced: boolean;
    readonly signalCode: string | undefined;
    readonly spawnargs: string[];
    readonly spawnfile: string;
    readonly stderr: Readable;
    readonly stdin: Writable | undefined;
    readonly stdout: Readable;
    disconnect(): void;
    kill(signal?: string): boolean;
    ref(): void;
    send(message: unknown, sendHandle?: unknown, options?: unknown, callback?: Action<Exception>): boolean;
    unref(): void;
}


export const ChildProcess: {
    new(): ChildProcess;
};


export type ChildProcess = ChildProcess$instance;

export interface Cipher$instance extends Transform {
    dispose(): void;
    final(outputEncoding?: string): string;
    final(): byte[];
    getAuthTag(): byte[];
    setAAD(buffer: byte[]): void;
    setAuthTag(tagLength: int): void;
    update(data: string, inputEncoding?: string, outputEncoding?: string): string;
    update(data: byte[], outputEncoding?: string): string;
}


export const Cipher: {
    new(): Cipher;
};


export type Cipher = Cipher$instance;

export interface CipherNameAndProtocol$instance {
    name: string;
    standardName: string;
    version: string;
}


export const CipherNameAndProtocol: {
    new(): CipherNameAndProtocol;
};


export type CipherNameAndProtocol = CipherNameAndProtocol$instance;

export interface CommonConnectionOptions$instance {
    get alpnProtocols(): string[] | undefined;
    set alpnProtocols(value: string[]);
    enableTrace: Nullable<System_Internal.Boolean>;
    rejectUnauthorized: Nullable<System_Internal.Boolean>;
    requestCert: Nullable<System_Internal.Boolean>;
    get secureContext(): SecureContext | undefined;
    set secureContext(value: SecureContext);
}


export const CommonConnectionOptions: {
    new(): CommonConnectionOptions;
};


export type CommonConnectionOptions = CommonConnectionOptions$instance;

export interface ConnectionOptions$instance extends CommonConnectionOptions {
    get ca(): unknown | undefined;
    set ca(value: unknown);
    get cert(): unknown | undefined;
    set cert(value: unknown);
    host: string;
    get key(): unknown | undefined;
    set key(value: unknown);
    get passphrase(): string | undefined;
    set passphrase(value: string);
    port: Nullable<System_Internal.Int32>;
    get servername(): string | undefined;
    set servername(value: string);
    timeout: Nullable<System_Internal.Int32>;
}


export const ConnectionOptions: {
    new(): ConnectionOptions;
};


export type ConnectionOptions = ConnectionOptions$instance;

export interface CpuInfo$instance {
    model: string;
    speed: int;
    times: CpuTimes;
}


export const CpuInfo: {
    new(): CpuInfo;
};


export type CpuInfo = CpuInfo$instance;

export interface CpuTimes$instance {
    idle: long;
    irq: long;
    nice: long;
    sys: long;
    user: long;
}


export const CpuTimes: {
    new(): CpuTimes;
};


export type CpuTimes = CpuTimes$instance;

export interface CursorPosition$instance {
    cols: int;
    rows: int;
}


export const CursorPosition: {
    new(): CursorPosition;
};


export type CursorPosition = CursorPosition$instance;

export interface Decipher$instance extends Transform {
    dispose(): void;
    final(outputEncoding?: string): string;
    final(): byte[];
    setAAD(buffer: byte[]): void;
    setAuthTag(buffer: byte[]): void;
    update(data: string, inputEncoding?: string, outputEncoding?: string): string;
    update(data: byte[], outputEncoding?: string): string;
}


export const Decipher: {
    new(): Decipher;
};


export type Decipher = Decipher$instance;

export interface DetailedPeerCertificate$instance extends PeerCertificate {
    get issuerCertificate(): DetailedPeerCertificate | undefined;
    set issuerCertificate(value: DetailedPeerCertificate);
}


export const DetailedPeerCertificate: {
    new(): DetailedPeerCertificate;
};


export type DetailedPeerCertificate = DetailedPeerCertificate$instance;

export interface DgramSocket$instance extends EventEmitter {
    addMembership(multicastAddress: string, multicastInterface?: string): void;
    address(): AddressInfo;
    addSourceSpecificMembership(sourceAddress: string, groupAddress: string, multicastInterface?: string): void;
    bind(port?: int, address?: string, callback?: Action): DgramSocket;
    bind(port: int, callback: Action): DgramSocket;
    bind(callback: Action): DgramSocket;
    bind(options: BindOptions, callback?: Action): DgramSocket;
    close(callback?: Action): DgramSocket;
    connect(port: int, address?: string, callback?: Action): void;
    connect(port: int, callback: Action): void;
    disconnect(): void;
    dropMembership(multicastAddress: string): void;
    dropSourceSpecificMembership(sourceAddress: string, groupAddress: string, multicastInterface?: string): void;
    getRecvBufferSize(): int;
    getSendBufferSize(): int;
    getSendQueueCount(): int;
    getSendQueueSize(): int;
    ref(): DgramSocket;
    remoteAddress(): AddressInfo;
    send(msg: byte[], port?: Nullable<System_Internal.Int32>, address?: string, callback?: Action<Exception, System_Internal.Int32>): void;
    send(msg: string, port?: Nullable<System_Internal.Int32>, address?: string, callback?: Action<Exception, System_Internal.Int32>): void;
    send(msg: byte[], port: int, callback: Action<Exception, System_Internal.Int32>): void;
    send(msg: string, port: int, callback: Action<Exception, System_Internal.Int32>): void;
    send(msg: byte[], callback: Action<Exception, System_Internal.Int32>): void;
    send(msg: string, callback: Action<Exception, System_Internal.Int32>): void;
    send(msg: byte[], offset: int, length: int, port?: Nullable<System_Internal.Int32>, address?: string, callback?: Action<Exception, System_Internal.Int32>): void;
    send(msg: byte[], offset: int, length: int, port: int, callback: Action<Exception, System_Internal.Int32>): void;
    send(msg: byte[], offset: int, length: int, callback: Action<Exception, System_Internal.Int32>): void;
    setBroadcast(flag: boolean): void;
    setMulticastInterface(multicastInterface: string): void;
    setMulticastLoopback(flag: boolean): boolean;
    setMulticastTTL(ttl: int): int;
    setRecvBufferSize(size: int): void;
    setSendBufferSize(size: int): void;
    setTTL(ttl: int): int;
    unref(): DgramSocket;
}


export const DgramSocket: {
    new(): DgramSocket;
};


export type DgramSocket = DgramSocket$instance;

export interface DiffieHellman$instance {
    computeSecret(otherPublicKey: string, inputEncoding?: string, outputEncoding?: string): string;
    computeSecret(otherPublicKey: byte[], outputEncoding?: string): string;
    computeSecret(otherPublicKey: byte[]): byte[];
    dispose(): void;
    generateKeys(encoding?: string): string;
    generateKeys(): byte[];
    getGenerator(encoding?: string): string;
    getGenerator(): byte[];
    getPrime(encoding?: string): string;
    getPrime(): byte[];
    getPrivateKey(encoding?: string): string;
    getPrivateKey(): byte[];
    getPublicKey(encoding?: string): string;
    getPublicKey(): byte[];
    getVerifyError(): int;
    setPrivateKey(privateKey: string, encoding?: string): void;
    setPrivateKey(privateKey: byte[]): void;
    setPublicKey(publicKey: string, encoding?: string): void;
    setPublicKey(publicKey: byte[]): void;
}


export const DiffieHellman: {
    new(): DiffieHellman;
};


export type DiffieHellman = DiffieHellman$instance;

export interface DSAPrivateKeyObject$instance extends KeyObject {
    readonly asymmetricKeyType: string | undefined;
    readonly symmetricKeySize: Nullable<System_Internal.Int32>;
    readonly type_: string;
    dispose(): void;
    export_(options?: unknown): unknown;
}


export const DSAPrivateKeyObject: {
    new(): DSAPrivateKeyObject;
};


export type DSAPrivateKeyObject = DSAPrivateKeyObject$instance;

export interface DSAPublicKeyObject$instance extends KeyObject {
    readonly asymmetricKeyType: string | undefined;
    readonly symmetricKeySize: Nullable<System_Internal.Int32>;
    readonly type_: string;
    dispose(): void;
    export_(options?: unknown): unknown;
}


export const DSAPublicKeyObject: {
    new(): DSAPublicKeyObject;
};


export type DSAPublicKeyObject = DSAPublicKeyObject$instance;

export interface Duplex$instance extends Readable {
    readonly writable: boolean;
    readonly writableCorked: boolean;
    readonly writableEnded: boolean;
    readonly writableLength: int;
    cork(): void;
    destroy(error?: Exception): void;
    end(chunk?: unknown, encoding?: string, callback?: Action): void;
    uncork(): void;
    write(chunk: unknown, encoding?: string, callback?: Action): boolean;
}


export const Duplex: {
    new(): Duplex;
};


export type Duplex = Duplex$instance;

export interface ECDH$instance {
    computeSecret(otherPublicKey: string, inputEncoding?: string, outputEncoding?: string): string;
    computeSecret(otherPublicKey: byte[], outputEncoding?: string): string;
    computeSecret(otherPublicKey: byte[]): byte[];
    dispose(): void;
    generateKeys(encoding?: string, format?: string): string;
    generateKeys(): byte[];
    getPrivateKey(encoding?: string): string;
    getPrivateKey(): byte[];
    getPublicKey(encoding?: string, format?: string): string;
    getPublicKey(): byte[];
    setPrivateKey(privateKey: string, encoding?: string): void;
    setPrivateKey(privateKey: byte[]): void;
    setPublicKey(publicKey: string, encoding?: string): void;
    setPublicKey(publicKey: byte[]): void;
}


export const ECDH: {
    new(): ECDH;
};


export type ECDH = ECDH$instance;

export interface EdDSAPrivateKeyObject$instance extends KeyObject {
    readonly asymmetricKeyType: string | undefined;
    readonly symmetricKeySize: Nullable<System_Internal.Int32>;
    readonly type_: string;
    dispose(): void;
    export_(options?: unknown): unknown;
}


export const EdDSAPrivateKeyObject: {
    new(): EdDSAPrivateKeyObject;
};


export type EdDSAPrivateKeyObject = EdDSAPrivateKeyObject$instance;

export interface EdDSAPublicKeyObject$instance extends KeyObject {
    readonly asymmetricKeyType: string | undefined;
    readonly symmetricKeySize: Nullable<System_Internal.Int32>;
    readonly type_: string;
    dispose(): void;
    export_(options?: unknown): unknown;
}


export const EdDSAPublicKeyObject: {
    new(): EdDSAPublicKeyObject;
};


export type EdDSAPublicKeyObject = EdDSAPublicKeyObject$instance;

export interface EphemeralKeyInfo$instance {
    name: string;
    size: int;
    type_: string;
}


export const EphemeralKeyInfo: {
    new(): EphemeralKeyInfo;
};


export type EphemeralKeyInfo = EphemeralKeyInfo$instance;

export interface EventEmitter$instance {
    addListener(eventName: string, listener: Function): EventEmitter;
    emit(eventName: string, ...args: unknown[]): boolean;
    eventNames(): string[];
    getMaxListeners(): int;
    listenerCount(eventName: string): int;
    listeners(eventName: string): Function[];
    off(eventName: string, listener: Function): EventEmitter;
    on(eventName: string, listener: Function): EventEmitter;
    once(eventName: string, listener: Function): EventEmitter;
    prependListener(eventName: string, listener: Function): EventEmitter;
    prependOnceListener(eventName: string, listener: Function): EventEmitter;
    rawListeners(eventName: string): Function[];
    removeAllListeners(eventName?: string): EventEmitter;
    removeListener(eventName: string, listener: Function): EventEmitter;
    setMaxListeners(n: int): EventEmitter;
}


export const EventEmitter: {
    new(): EventEmitter;
    defaultMaxListeners: int;
    once(emitter: EventEmitter, eventName: string): Task<(unknown | undefined)[]>;
};


export type EventEmitter = EventEmitter$instance;

export interface ExecOptions$instance {
    get argv0(): string | undefined;
    set argv0(value: string);
    get cwd(): string | undefined;
    set cwd(value: string);
    detached: boolean;
    get encoding(): string | undefined;
    set encoding(value: string);
    get env(): unknown | undefined;
    set env(value: unknown);
    gid: Nullable<System_Internal.Int32>;
    get input(): string | undefined;
    set input(value: string);
    get killSignal(): string | undefined;
    set killSignal(value: string);
    maxBuffer: int;
    get shell(): string | undefined;
    set shell(value: string);
    get stdio(): string | undefined;
    set stdio(value: string);
    timeout: int;
    uid: Nullable<System_Internal.Int32>;
    windowsHide: boolean;
    windowsVerbatimArguments: boolean;
}


export const ExecOptions: {
    new(): ExecOptions;
};


export type ExecOptions = ExecOptions$instance;

export interface Hash$instance extends Transform {
    copy(): Hash;
    digest(encoding: string): string;
    digest(): byte[];
    digest(outputLength: int): byte[];
    dispose(): void;
    update(data: string, inputEncoding?: string): Hash;
    update(data: byte[]): Hash;
}


export const Hash: {
    new(): Hash;
};


export type Hash = Hash$instance;

export interface Hmac$instance extends Transform {
    digest(encoding?: string): string;
    digest(): byte[];
    dispose(): void;
    update(data: string, inputEncoding?: string): Hmac;
    update(data: byte[]): Hmac;
}


export const Hmac: {
    new(): Hmac;
};


export type Hmac = Hmac$instance;

export interface Immediate$instance {
    dispose(): void;
    hasRef(): boolean;
    ref(): Immediate;
    unref(): Immediate;
}


export const Immediate: {
    new(): Immediate;
};


export type Immediate = Immediate$instance;

export interface Interface$instance extends EventEmitter {
    readonly cursor: int;
    readonly line: string;
    close(): void;
    getCursorPos(): CursorPosition;
    getPrompt(): string;
    pause(): Interface;
    prompt(preserveCursor?: boolean): void;
    question(query: string, callback: Action<System_Internal.String>): void;
    questionAsync(query: string): Task<System_Internal.String>;
    resume(): Interface;
    setPrompt(prompt: string): void;
    write(data: unknown, key?: unknown): void;
}


export const Interface: {
    new(): Interface;
};


export type Interface = Interface$instance;

export interface InterfaceOptions$instance {
    escapeCodeTimeout: Nullable<System_Internal.Int32>;
    get history(): string[] | undefined;
    set history(value: string[]);
    historySize: Nullable<System_Internal.Int32>;
    get input(): Readable | undefined;
    set input(value: Readable);
    output: Writable;
    get prompt(): string | undefined;
    set prompt(value: string);
    removeHistoryDuplicates: Nullable<System_Internal.Boolean>;
    tabSize: Nullable<System_Internal.Int32>;
    terminal: Nullable<System_Internal.Boolean>;
}


export const InterfaceOptions: {
    new(): InterfaceOptions;
};


export type InterfaceOptions = InterfaceOptions$instance;

export interface IpcSocketConnectOpts$instance {
    path: string;
}


export const IpcSocketConnectOpts: {
    new(): IpcSocketConnectOpts;
};


export type IpcSocketConnectOpts = IpcSocketConnectOpts$instance;

export interface KeyObject$instance {
    readonly asymmetricKeyType: string | undefined;
    readonly symmetricKeySize: Nullable<System_Internal.Int32>;
    readonly type_: string;
    dispose(): void;
    export_(options?: unknown): unknown;
}


export const KeyObject: {
};


export type KeyObject = KeyObject$instance;

export interface ListenOptions$instance {
    backlog: Nullable<System_Internal.Int32>;
    host: string;
    ipv6Only: Nullable<System_Internal.Boolean>;
    path: string;
    port: Nullable<System_Internal.Int32>;
}


export const ListenOptions: {
    new(): ListenOptions;
};


export type ListenOptions = ListenOptions$instance;

export interface LookupAddress$instance {
    address: string;
    family: int;
}


export const LookupAddress: {
    new(): LookupAddress;
};


export type LookupAddress = LookupAddress$instance;

export interface LookupOptions$instance {
    all: Nullable<System_Internal.Boolean>;
    family: unknown;
    hints: Nullable<System_Internal.Int32>;
    get order(): string | undefined;
    set order(value: string);
    verbatim: Nullable<System_Internal.Boolean>;
}


export const LookupOptions: {
    new(): LookupOptions;
};


export type LookupOptions = LookupOptions$instance;

export interface MarkOptions$instance {
    get detail(): unknown | undefined;
    set detail(value: unknown);
    startTime: Nullable<System_Internal.Double>;
}


export const MarkOptions: {
    new(): MarkOptions;
};


export type MarkOptions = MarkOptions$instance;

export interface MeasureOptions$instance {
    get detail(): unknown | undefined;
    set detail(value: unknown);
    end: Nullable<System_Internal.Double>;
    get endMark(): string | undefined;
    set endMark(value: string);
    start: Nullable<System_Internal.Double>;
    get startMark(): string | undefined;
    set startMark(value: string);
}


export const MeasureOptions: {
    new(): MeasureOptions;
};


export type MeasureOptions = MeasureOptions$instance;

export interface MxRecord$instance {
    exchange: string;
    priority: int;
}


export const MxRecord: {
    new(): MxRecord;
};


export type MxRecord = MxRecord$instance;

export interface NaptrRecord$instance {
    flags: string;
    order: int;
    preference: int;
    regexp: string;
    replacement: string;
    service: string;
}


export const NaptrRecord: {
    new(): NaptrRecord;
};


export type NaptrRecord = NaptrRecord$instance;

export interface ParsedPath$instance {
    base: string;
    dir: string;
    ext: string;
    name: string;
    root: string;
}


export const ParsedPath: {
    new(): ParsedPath;
};


export type ParsedPath = ParsedPath$instance;

export interface PassThrough$instance extends Transform {
}


export const PassThrough: {
    new(): PassThrough;
};


export type PassThrough = PassThrough$instance;

export interface PathModule$instance {
    readonly delimiter: string;
    readonly posix: PathModule;
    readonly sep: string;
    readonly win32: PathModule;
    basename(path: string, suffix?: string): string;
    dirname(path: string): string;
    extname(path: string): string;
    format(pathObject: ParsedPath): string;
    isAbsolute(path: string): boolean;
    join(...paths: string[]): string;
    matchesGlob(path: string, pattern: string): boolean;
    normalize(path: string): string;
    parse(path: string): ParsedPath;
    relative(from_: string, to: string): string;
    resolve(...paths: string[]): string;
    toNamespacedPath(path: string): string;
}


export const PathModule: {
    new(): PathModule;
    readonly instance: PathModule;
};


export type PathModule = PathModule$instance;

export interface PeerCertificate$instance {
    ca: boolean;
    get ext_key_usage(): string[] | undefined;
    set ext_key_usage(value: string[]);
    fingerprint: string;
    fingerprint256: string;
    fingerprint512: string;
    issuer: TLSCertificateInfo;
    raw: byte[];
    serialNumber: string;
    subject: TLSCertificateInfo;
    get subjectaltname(): string | undefined;
    set subjectaltname(value: string);
    valid_from: string;
    valid_to: string;
}


export const PeerCertificate: {
    new(): PeerCertificate;
};


export type PeerCertificate = PeerCertificate$instance;

export interface PerformanceEntry$instance {
    readonly duration: double;
    readonly entryType: string;
    readonly name: string;
    readonly startTime: double;
}


export const PerformanceEntry: {
    new(): PerformanceEntry;
};


export type PerformanceEntry = PerformanceEntry$instance;

export interface PerformanceMark$instance extends PerformanceEntry {
    readonly detail: unknown | undefined;
}


export const PerformanceMark: {
    new(name: string, startTime: double, detail: unknown): PerformanceMark;
};


export type PerformanceMark = PerformanceMark$instance;

export interface PerformanceMeasure$instance extends PerformanceEntry {
    readonly detail: unknown | undefined;
}


export const PerformanceMeasure: {
    new(name: string, startTime: double, duration: double, detail: unknown): PerformanceMeasure;
};


export type PerformanceMeasure = PerformanceMeasure$instance;

export interface PerformanceObserver$instance {
    disconnect(): void;
    observe(options: PerformanceObserverOptions): void;
    takeRecords(): PerformanceObserverEntryList;
}


export const PerformanceObserver: {
    new(callback: Action<PerformanceObserverEntryList, PerformanceObserver>): PerformanceObserver;
    supportedEntryTypes(): string[];
};


export type PerformanceObserver = PerformanceObserver$instance;

export interface PerformanceObserverEntryList$instance {
    getEntries(): PerformanceEntry[];
    getEntriesByName(name: string, type_?: string): PerformanceEntry[];
    getEntriesByType(type_: string): PerformanceEntry[];
}


export const PerformanceObserverEntryList: {
    new(entries: PerformanceEntry[]): PerformanceObserverEntryList;
};


export type PerformanceObserverEntryList = PerformanceObserverEntryList$instance;

export interface PerformanceObserverOptions$instance {
    buffered: boolean;
    get entryTypes(): string[] | undefined;
    set entryTypes(value: string[]);
}


export const PerformanceObserverOptions: {
    new(): PerformanceObserverOptions;
};


export type PerformanceObserverOptions = PerformanceObserverOptions$instance;

export interface PrivateKeyObject$instance extends KeyObject {
    readonly asymmetricKeyType: string | undefined;
    readonly symmetricKeySize: Nullable<System_Internal.Int32>;
    readonly type_: string;
    dispose(): void;
    export_(options?: unknown): unknown;
    export_(format: string, type_?: string, cipher?: string, passphrase?: string): string;
}


export const PrivateKeyObject: {
    new(): PrivateKeyObject;
};


export type PrivateKeyObject = PrivateKeyObject$instance;

export interface ProcessEnv$instance {
    readonly count: int;
    readonly isReadOnly: boolean;
    get item(): string | undefined;
    set item(value: string);
    readonly keys: ICollection<System_Internal.String>;
    readonly values: ICollection<string | undefined>;
    add(key: string, value: string): void;
    add(item: KeyValuePair<System_Internal.String, System_Internal.String>): void;
    clear(): void;
    contains(item: KeyValuePair<System_Internal.String, System_Internal.String>): boolean;
    containsKey(key: string): boolean;
    copyTo(array: KeyValuePair<System_Internal.String, System_Internal.String>[], arrayIndex: int): void;
    getEnumerator(): IEnumerator<KeyValuePair<System_Internal.String, System_Internal.String>>;
    remove(key: string): boolean;
    remove(item: KeyValuePair<System_Internal.String, System_Internal.String>): boolean;
    tryGetValue(key: string, value: string): boolean;
}


export const ProcessEnv: {
    new(): ProcessEnv;
};


export type ProcessEnv = ProcessEnv$instance;

export interface ProcessVersions$instance {
    dotnet: string;
    node: string;
    tsonic: string;
    v8: string;
}


export const ProcessVersions: {
    new(): ProcessVersions;
};


export type ProcessVersions = ProcessVersions$instance;

export interface PublicKeyObject$instance extends KeyObject {
    readonly asymmetricKeyType: string | undefined;
    readonly symmetricKeySize: Nullable<System_Internal.Int32>;
    readonly type_: string;
    dispose(): void;
    export_(options?: unknown): unknown;
    export_(format: string, type_?: string): string;
}


export const PublicKeyObject: {
    new(): PublicKeyObject;
};


export type PublicKeyObject = PublicKeyObject$instance;

export interface Readable$instance extends Stream {
    readonly destroyed: boolean;
    readonly readable: boolean;
    readonly readableEnded: boolean;
    readonly readableFlowing: Nullable<System_Internal.Boolean>;
    readonly readableLength: int;
    destroy(error?: Exception): void;
    isPaused(): boolean;
    pause(): Readable;
    push(chunk: unknown, encoding?: string): boolean;
    read(size?: Nullable<System_Internal.Int32>): unknown | undefined;
    resume(): Readable;
    setEncoding(encoding: string): Readable;
    unpipe(destination?: Stream): Readable;
    unshift(chunk: unknown): void;
}


export const Readable: {
    new(): Readable;
};


export type Readable = Readable$instance;

export interface RecordWithTtl$instance {
    address: string;
    ttl: int;
}


export const RecordWithTtl: {
    new(): RecordWithTtl;
};


export type RecordWithTtl = RecordWithTtl$instance;

export interface RemoteInfo$instance {
    address: string;
    family: string;
    port: int;
    size: int;
}


export const RemoteInfo: {
    new(): RemoteInfo;
};


export type RemoteInfo = RemoteInfo$instance;

export interface ResolveOptions$instance {
    ttl: boolean;
}


export const ResolveOptions: {
    new(): ResolveOptions;
};


export type ResolveOptions = ResolveOptions$instance;

export interface Resolver$instance {
    cancel(): void;
    getServers(): string[];
    resolve(hostname: string, callback: Action<Exception, string[]>): void;
    resolve(hostname: string, rrtype: string, callback: Action<Exception, unknown>): void;
    resolve4(hostname: string, callback: Action<Exception, string[]>): void;
    resolve4(hostname: string, options: ResolveOptions, callback: Action<Exception, unknown>): void;
    resolve6(hostname: string, callback: Action<Exception, string[]>): void;
    resolve6(hostname: string, options: ResolveOptions, callback: Action<Exception, unknown>): void;
    resolveAny(hostname: string, callback: Action<Exception, unknown[]>): void;
    resolveCaa(hostname: string, callback: Action<Exception, CaaRecord[]>): void;
    resolveCname(hostname: string, callback: Action<Exception, string[]>): void;
    resolveMx(hostname: string, callback: Action<Exception, MxRecord[]>): void;
    resolveNaptr(hostname: string, callback: Action<Exception, NaptrRecord[]>): void;
    resolveNs(hostname: string, callback: Action<Exception, string[]>): void;
    resolvePtr(hostname: string, callback: Action<Exception, string[]>): void;
    resolveSoa(hostname: string, callback: Action<Exception, SoaRecord>): void;
    resolveSrv(hostname: string, callback: Action<Exception, SrvRecord[]>): void;
    resolveTlsa(hostname: string, callback: Action<Exception, TlsaRecord[]>): void;
    resolveTxt(hostname: string, callback: Action<Exception, string[][]>): void;
    reverse(ip: string, callback: Action<Exception, string[]>): void;
    setLocalAddress(ipv4?: string, ipv6?: string): void;
    setServers(servers: string[]): void;
}


export const Resolver: {
    new(): Resolver;
    new(options: ResolverOptions): Resolver;
};


export type Resolver = Resolver$instance;

export interface ResolverOptions$instance {
    maxTimeout: Nullable<System_Internal.Int32>;
    timeout: Nullable<System_Internal.Int32>;
    tries: Nullable<System_Internal.Int32>;
}


export const ResolverOptions: {
    new(): ResolverOptions;
};


export type ResolverOptions = ResolverOptions$instance;

export interface SecretKeyObject$instance extends KeyObject {
    readonly asymmetricKeyType: string | undefined;
    readonly symmetricKeySize: Nullable<System_Internal.Int32>;
    readonly type_: string;
    dispose(): void;
    export_(options?: unknown): unknown;
    export_(): byte[];
}


export const SecretKeyObject: {
    new(): SecretKeyObject;
};


export type SecretKeyObject = SecretKeyObject$instance;

export interface SecureContext$instance {
    readonly caCertificates: X509Certificate2Collection | undefined;
    readonly certificate: X509Certificate2 | undefined;
    get context(): unknown | undefined;
    set context(value: unknown);
    readonly protocols: SslProtocols;
    loadCACertificates(ca: unknown): void;
    loadCertificate(cert: unknown, key: unknown, passphrase: string): void;
    setProtocols(minVersion: string, maxVersion: string): void;
}


export const SecureContext: {
    new(): SecureContext;
};


export type SecureContext = SecureContext$instance;

export interface SecureContextOptions$instance {
    get ca(): unknown | undefined;
    set ca(value: unknown);
    get cert(): unknown | undefined;
    set cert(value: unknown);
    get ciphers(): string | undefined;
    set ciphers(value: string);
    get key(): unknown | undefined;
    set key(value: unknown);
    get maxVersion(): string | undefined;
    set maxVersion(value: string);
    get minVersion(): string | undefined;
    set minVersion(value: string);
    get passphrase(): string | undefined;
    set passphrase(value: string);
    get pfx(): unknown | undefined;
    set pfx(value: unknown);
}


export const SecureContextOptions: {
    new(): SecureContextOptions;
};


export type SecureContextOptions = SecureContextOptions$instance;

export interface Server$instance extends EventEmitter {
    readonly listening: boolean;
    maxConnections: int;
    address(): unknown;
    close(callback?: Action<Exception>): Server;
    getConnections(callback: Action<Exception, System_Internal.Int32>): void;
    listen(port: int, hostname: string, backlog: int, listeningListener?: Action): Server;
    listen(port: int, hostname: string, listeningListener?: Action): Server;
    listen(port: int, backlog: int, listeningListener?: Action): Server;
    listen(port: int, listeningListener?: Action): Server;
    listen(options: ListenOptions, listeningListener?: Action): Server;
    ref(): Server;
    unref(): Server;
}


export const Server: {
    new(): Server;
    new(connectionListener: Action<Socket>): Server;
    new(options: ServerOpts, connectionListener: Action<Socket>): Server;
};


export type Server = Server$instance;

export interface ServerOpts$instance {
    allowHalfOpen: Nullable<System_Internal.Boolean>;
    pauseOnConnect: Nullable<System_Internal.Boolean>;
}


export const ServerOpts: {
    new(): ServerOpts;
};


export type ServerOpts = ServerOpts$instance;

export interface Sign$instance extends Transform {
    dispose(): void;
    sign(privateKey: string, outputEncoding?: string): string;
    sign(privateKey: string): byte[];
    sign(privateKey: unknown, outputEncoding?: string): string;
    sign(privateKey: unknown): byte[];
    update(data: string, inputEncoding?: string): Sign;
    update(data: byte[]): Sign;
}


export const Sign: {
    new(): Sign;
};


export type Sign = Sign$instance;

export interface SoaRecord$instance {
    expire: int;
    hostmaster: string;
    minttl: int;
    nsname: string;
    refresh: int;
    retry: int;
    serial: int;
}


export const SoaRecord: {
    new(): SoaRecord;
};


export type SoaRecord = SoaRecord$instance;

export interface Socket$instance extends Stream {
    readonly bytesRead: long;
    readonly bytesWritten: long;
    readonly connecting: boolean;
    readonly destroyed: boolean;
    readonly localAddress: string | undefined;
    readonly localFamily: string | undefined;
    readonly localPort: Nullable<System_Internal.Int32>;
    readonly readyState: string;
    readonly remoteAddress: string | undefined;
    readonly remoteFamily: string | undefined;
    readonly remotePort: Nullable<System_Internal.Int32>;
    address(): unknown;
    connect(port: int, host?: string, connectionListener?: Action): Socket;
    connect(options: TcpSocketConnectOpts, connectionListener?: Action): Socket;
    connect(path: string, connectionListener?: Action): Socket;
    destroy(error?: Exception): Socket;
    destroy(error?: Exception): void;
    destroySoon(): void;
    end(callback?: Action): Socket;
    end(data: byte[], callback?: Action): Socket;
    end(data: string, encoding?: string, callback?: Action): Socket;
    pause(): Socket;
    ref(): Socket;
    resetAndDestroy(): Socket;
    resume(): Socket;
    setEncoding(encoding?: string): Socket;
    setKeepAlive(enable?: boolean, initialDelay?: int): Socket;
    setNoDelay(noDelay?: boolean): Socket;
    setTimeout(timeout: int, callback?: Action): Socket;
    unref(): Socket;
    write(data: byte[], callback?: Action<Exception>): boolean;
    write(data: string, encoding?: string, callback?: Action<Exception>): boolean;
}


export const Socket: {
    new(): Socket;
    new(options: SocketConstructorOpts): Socket;
};


export type Socket = Socket$instance;

export interface SocketAddress$instance {
    readonly address: string;
    readonly family: string;
    readonly flowlabel: Nullable<System_Internal.Int32>;
    readonly port: int;
}


export const SocketAddress: {
    new(options: SocketAddressInitOptions): SocketAddress;
};


export type SocketAddress = SocketAddress$instance;

export interface SocketAddressInitOptions$instance {
    address: string;
    family: string;
    flowlabel: Nullable<System_Internal.Int32>;
    port: Nullable<System_Internal.Int32>;
}


export const SocketAddressInitOptions: {
    new(): SocketAddressInitOptions;
};


export type SocketAddressInitOptions = SocketAddressInitOptions$instance;

export interface SocketConstructorOpts$instance {
    allowHalfOpen: Nullable<System_Internal.Boolean>;
    fd: Nullable<System_Internal.Int32>;
    readable: Nullable<System_Internal.Boolean>;
    writable: Nullable<System_Internal.Boolean>;
}


export const SocketConstructorOpts: {
    new(): SocketConstructorOpts;
};


export type SocketConstructorOpts = SocketConstructorOpts$instance;

export interface SocketOptions$instance {
    ipv6Only: boolean;
    recvBufferSize: Nullable<System_Internal.Int32>;
    reuseAddr: boolean;
    reusePort: boolean;
    sendBufferSize: Nullable<System_Internal.Int32>;
    type_: string;
}


export const SocketOptions: {
    new(): SocketOptions;
};


export type SocketOptions = SocketOptions$instance;

export interface SpawnSyncReturns_1$instance<T> {
    get error(): Exception | undefined;
    set error(value: Exception);
    output: (T | undefined)[];
    pid: int;
    get signal(): string | undefined;
    set signal(value: string);
    status: Nullable<System_Internal.Int32>;
    stderr: T;
    stdout: T;
}


export const SpawnSyncReturns_1: {
    new<T>(): SpawnSyncReturns_1<T>;
};


export type SpawnSyncReturns_1<T> = SpawnSyncReturns_1$instance<T>;

export interface SrvRecord$instance {
    name: string;
    port: int;
    priority: int;
    weight: int;
}


export const SrvRecord: {
    new(): SrvRecord;
};


export type SrvRecord = SrvRecord$instance;

export interface Stats$instance {
    atime: DateTime;
    birthtime: DateTime;
    ctime: DateTime;
    isDirectory2: boolean;
    isFile2: boolean;
    mode: int;
    mtime: DateTime;
    size: long;
    isBlockDevice(): boolean;
    isCharacterDevice(): boolean;
    isDirectory(): boolean;
    isFIFO(): boolean;
    isFile(): boolean;
    isSocket(): boolean;
    isSymbolicLink(): boolean;
}


export const Stats: {
    new(): Stats;
};


export type Stats = Stats$instance;

export interface Stream$instance extends EventEmitter {
    destroy(error?: Exception): void;
    pipe(destination: Stream, end?: boolean): Stream;
}


export const Stream: {
    new(): Stream;
};


export type Stream = Stream$instance;

export interface StringDecoder$instance {
    end(buffer?: byte[]): string;
    write(buffer: byte[]): string;
}


export const StringDecoder: {
    new(encoding: string): StringDecoder;
};


export type StringDecoder = StringDecoder$instance;

export interface TcpSocketConnectOpts$instance {
    family: Nullable<System_Internal.Int32>;
    hints: Nullable<System_Internal.Int32>;
    host: string;
    keepAlive: Nullable<System_Internal.Boolean>;
    keepAliveInitialDelay: Nullable<System_Internal.Int32>;
    get localAddress(): string | undefined;
    set localAddress(value: string);
    localPort: Nullable<System_Internal.Int32>;
    noDelay: Nullable<System_Internal.Boolean>;
    port: int;
}


export const TcpSocketConnectOpts: {
    new(): TcpSocketConnectOpts;
};


export type TcpSocketConnectOpts = TcpSocketConnectOpts$instance;

export interface Timeout$instance {
    close(): void;
    dispose(): void;
    hasRef(): boolean;
    ref(): Timeout;
    refresh(): Timeout;
    unref(): Timeout;
}


export const Timeout: {
    new(): Timeout;
};


export type Timeout = Timeout$instance;

export interface TlsaRecord$instance {
    certUsage: int;
    data: byte[];
    match: int;
    selector: int;
}


export const TlsaRecord: {
    new(): TlsaRecord;
};


export type TlsaRecord = TlsaRecord$instance;

export interface TLSCertificateInfo$instance {
    C: string;
    CN: string;
    L: string;
    O: string;
    OU: string;
    ST: string;
}


export const TLSCertificateInfo: {
    new(): TLSCertificateInfo;
};


export type TLSCertificateInfo = TLSCertificateInfo$instance;

export interface TlsOptions$instance extends CommonConnectionOptions {
    allowHalfOpen: Nullable<System_Internal.Boolean>;
    get ca(): unknown | undefined;
    set ca(value: unknown);
    get cert(): unknown | undefined;
    set cert(value: unknown);
    handshakeTimeout: Nullable<System_Internal.Int32>;
    get key(): unknown | undefined;
    set key(value: unknown);
    get passphrase(): string | undefined;
    set passphrase(value: string);
    pauseOnConnect: Nullable<System_Internal.Boolean>;
    sessionTimeout: Nullable<System_Internal.Int32>;
}


export const TlsOptions: {
    new(): TlsOptions;
};


export type TlsOptions = TlsOptions$instance;

export interface TLSServer$instance extends Server {
    addContext(hostname: string, context: unknown): void;
    getTicketKeys(): byte[];
    setSecureContext(options: SecureContextOptions): void;
    setTicketKeys(keys: byte[]): void;
}


export const TLSServer: {
    new(): TLSServer;
    new(secureConnectionListener: Action<TLSSocket>): TLSServer;
    new(options: TlsOptions, secureConnectionListener: Action<TLSSocket>): TLSServer;
};


export type TLSServer = TLSServer$instance;

export interface TLSSocket$instance extends Socket {
    readonly alpnProtocol: string | undefined;
    readonly authorizationError: Exception | undefined;
    readonly authorized: boolean;
    readonly encrypted: boolean;
    disableRenegotiation(): void;
    enableTrace(): void;
    exportKeyingMaterial(length: int, label: string, context: byte[]): byte[];
    getCertificate(): PeerCertificate | undefined;
    getCipher(): CipherNameAndProtocol;
    getEphemeralKeyInfo(): EphemeralKeyInfo | undefined;
    getFinished(): byte[] | undefined;
    getPeerCertificate(detailed?: boolean): PeerCertificate | undefined;
    getPeerFinished(): byte[] | undefined;
    getPeerX509Certificate(): unknown | undefined;
    getProtocol(): string | undefined;
    getSession(): byte[] | undefined;
    getSharedSigalgs(): string[];
    getTLSTicket(): byte[] | undefined;
    getX509Certificate(): unknown | undefined;
    isSessionReused(): boolean;
    renegotiate(options: unknown, callback: Action<Exception>): boolean;
    setKeyCert(context: unknown): void;
    setMaxSendFragment(size: int): boolean;
    write(data: byte[], callback?: Action<Exception>): boolean;
    write(data: string, encoding?: string, callback?: Action<Exception>): boolean;
    write(data: byte[], callback?: Action<Exception>): boolean;
    write(data: string, encoding?: string, callback?: Action<Exception>): boolean;
}


export const TLSSocket: {
    new(socket: Socket, options: TLSSocketOptions): TLSSocket;
};


export type TLSSocket = TLSSocket$instance;

export interface TLSSocketOptions$instance extends CommonConnectionOptions {
    get ca(): unknown | undefined;
    set ca(value: unknown);
    get cert(): unknown | undefined;
    set cert(value: unknown);
    isServer: Nullable<System_Internal.Boolean>;
    get key(): unknown | undefined;
    set key(value: unknown);
    get passphrase(): string | undefined;
    set passphrase(value: string);
    get server(): Server | undefined;
    set server(value: Server);
    get servername(): string | undefined;
    set servername(value: string);
}


export const TLSSocketOptions: {
    new(): TLSSocketOptions;
};


export type TLSSocketOptions = TLSSocketOptions$instance;

export interface Transform$instance extends Duplex {
}


export const Transform: {
    new(): Transform;
};


export type Transform = Transform$instance;

export interface URL$instance {
    hash: string;
    host: string;
    hostname: string;
    href: string;
    readonly origin: string;
    password: string;
    pathname: string;
    port: string;
    protocol: string;
    search: string;
    readonly searchParams: URLSearchParams;
    username: string;
    toJSON(): string;
    toString(): string;
}


export const URL: {
    new(input: string, base: string): URL;
    canParse(input: string, base?: string): boolean;
    parse(input: string, base?: string): URL | undefined;
};


export type URL = URL$instance;

export interface URLSearchParams$instance {
    readonly size: int;
    append(name: string, value: string): void;
    delete_(name: string, value?: string): void;
    entries(): IEnumerable__System_Collections_Generic<KeyValuePair<System_Internal.String, System_Internal.String>>;
    forEach(callback: Action<System_Internal.String, System_Internal.String>): void;
    get_(name: string): string | undefined;
    getAll(name: string): string[];
    has(name: string, value?: string): boolean;
    keys(): IEnumerable__System_Collections_Generic<System_Internal.String>;
    set_(name: string, value: string): void;
    sort(): void;
    toString(): string;
    values(): IEnumerable__System_Collections_Generic<System_Internal.String>;
}


export const URLSearchParams: {
    new(init: string): URLSearchParams;
};


export type URLSearchParams = URLSearchParams$instance;

export interface UserInfo$instance {
    gid: int;
    homedir: string;
    get shell(): string | undefined;
    set shell(value: string);
    uid: int;
    username: string;
}


export const UserInfo: {
    new(): UserInfo;
};


export type UserInfo = UserInfo$instance;

export interface Verify$instance extends Transform {
    dispose(): void;
    update(data: string, inputEncoding?: string): Verify;
    update(data: byte[]): Verify;
    verify(publicKey: string, signature: string, signatureEncoding?: string): boolean;
    verify(publicKey: string, signature: byte[]): boolean;
    verify(publicKey: unknown, signature: string, signatureEncoding?: string): boolean;
    verify(publicKey: unknown, signature: byte[]): boolean;
}


export const Verify: {
    new(): Verify;
};


export type Verify = Verify$instance;

export interface Writable$instance extends Stream {
    readonly destroyed: boolean;
    readonly writable: boolean;
    readonly writableCorked: boolean;
    readonly writableEnded: boolean;
    readonly writableLength: int;
    cork(): void;
    destroy(error?: Exception): void;
    end(chunk?: unknown, encoding?: string, callback?: Action): void;
    uncork(): void;
    write(chunk: unknown, encoding?: string, callback?: Action): boolean;
}


export const Writable: {
    new(): Writable;
};


export type Writable = Writable$instance;

export interface X509CertificateInfo$instance {
    readonly fingerprint: string;
    readonly fingerprint256: string;
    readonly fingerprint512: string;
    readonly issuer: string;
    readonly publicKey: byte[];
    readonly raw: byte[];
    readonly serialNumber: string;
    readonly subject: string;
    readonly validFrom: DateTime;
    readonly validTo: DateTime;
    checkEmail(email: string): string | undefined;
    checkHost(hostname: string): string | undefined;
    checkIP(ip: string): string | undefined;
    checkIssued(otherCert: X509CertificateInfo): string | undefined;
    toPEM(): string;
    toString(): string;
    verify(issuerCert: X509CertificateInfo): boolean;
}


export const X509CertificateInfo: {
    new(): X509CertificateInfo;
};


export type X509CertificateInfo = X509CertificateInfo$instance;

export interface ZlibOptions$instance {
    chunkSize: Nullable<System_Internal.Int32>;
    level: Nullable<System_Internal.Int32>;
    maxOutputLength: Nullable<System_Internal.Int32>;
    memLevel: Nullable<System_Internal.Int32>;
    strategy: Nullable<System_Internal.Int32>;
    windowBits: Nullable<System_Internal.Int32>;
}


export const ZlibOptions: {
    new(): ZlibOptions;
};


export type ZlibOptions = ZlibOptions$instance;

export abstract class assert$instance {
    static deepEqual(actual: unknown, expected: unknown, message?: string): void;
    static deepStrictEqual(actual: unknown, expected: unknown, message?: string): void;
    static doesNotMatch(string_: string, regexp: Regex, message?: string): void;
    static doesNotThrow(fn: Action, message?: string): void;
    static equal(actual: unknown, expected: unknown, message?: string): void;
    static fail(message?: string): void;
    static ifError(value: unknown): void;
    static match(string_: string, regexp: Regex, message?: string): void;
    static notDeepEqual(actual: unknown, expected: unknown, message?: string): void;
    static notDeepStrictEqual(actual: unknown, expected: unknown, message?: string): void;
    static notEqual(actual: unknown, expected: unknown, message?: string): void;
    static notStrictEqual(actual: unknown, expected: unknown, message?: string): void;
    static ok(value: boolean, message?: string): void;
    static strictEqual(actual: unknown, expected: unknown, message?: string): void;
    static throws(fn: Action, message?: string): void;
}


export type assert = assert$instance;

export abstract class Certificate$instance {
    static exportChallenge(spkac: byte[]): byte[];
    static exportChallenge(spkac: string): byte[];
    static exportPublicKey(spkac: byte[]): byte[];
    static exportPublicKey(spkac: string): byte[];
    static verifySpkac(spkac: byte[]): boolean;
    static verifySpkac(spkac: string): boolean;
}


export type Certificate = Certificate$instance;

export abstract class child_process$instance {
    static exec(command: string, options: ExecOptions, callback: Action<Exception, System_Internal.String, System_Internal.String>): void;
    static exec(command: string, callback: Action<Exception, System_Internal.String, System_Internal.String>): void;
    static execFile(file: string, args: string[], options: ExecOptions, callback: Action<Exception, System_Internal.String, System_Internal.String>): void;
    static execFileSync(file: string, args?: string[], options?: ExecOptions): unknown;
    static execSync(command: string, options: ExecOptions): unknown;
    static execSync(command: string): byte[];
    static fork(modulePath: string, args?: string[], options?: ExecOptions): ChildProcess;
    static spawn(command: string, args?: string[], options?: ExecOptions): ChildProcess;
    static spawnSync(command: string, args?: string[], options?: ExecOptions): SpawnSyncReturns_1<byte[]>;
    static spawnSyncString(command: string, args?: string[], options?: ExecOptions): SpawnSyncReturns_1<System_Internal.String>;
}


export type child_process = child_process$instance;

export abstract class console$instance {
    static assert(value: boolean, message?: string, ...optionalParams: unknown[]): void;
    static clear(): void;
    static count(label?: string): void;
    static countReset(label?: string): void;
    static debug(message?: unknown, ...optionalParams: unknown[]): void;
    static dir(obj: unknown, ...options: unknown[]): void;
    static dirxml(...data: unknown[]): void;
    static error(message?: unknown, ...optionalParams: unknown[]): void;
    static group(...label: unknown[]): void;
    static groupCollapsed(...label: unknown[]): void;
    static groupEnd(): void;
    static info(message?: unknown, ...optionalParams: unknown[]): void;
    static log(message?: unknown, ...optionalParams: unknown[]): void;
    static profile(label?: string): void;
    static profileEnd(label?: string): void;
    static table(tabularData: unknown, properties?: string[]): void;
    static time(label?: string): void;
    static timeEnd(label?: string): void;
    static timeLog(label?: string, ...data: unknown[]): void;
    static timeStamp(label?: string): void;
    static trace(message?: unknown, ...optionalParams: unknown[]): void;
    static warn(message?: unknown, ...optionalParams: unknown[]): void;
}


export type console = console$instance;

export abstract class crypto$instance {
    static createCipheriv(algorithm: string, key: byte[], iv: byte[]): Cipher;
    static createCipheriv(algorithm: string, key: string, iv: string): Cipher;
    static createDecipheriv(algorithm: string, key: byte[], iv: byte[]): Decipher;
    static createDecipheriv(algorithm: string, key: string, iv: string): Decipher;
    static createDiffieHellman(prime: byte[], generator: byte[]): DiffieHellman;
    static createDiffieHellman(prime: byte[], generator?: int): DiffieHellman;
    static createDiffieHellman(primeLength: int, generator?: int): DiffieHellman;
    static createDiffieHellman(prime: string, primeEncoding: string, generator?: int): DiffieHellman;
    static createDiffieHellman(prime: string, primeEncoding: string, generator: string, generatorEncoding: string): DiffieHellman;
    static createECDH(curveName: string): ECDH;
    static createHash(algorithm: string): Hash;
    static createHmac(algorithm: string, key: byte[]): Hmac;
    static createHmac(algorithm: string, key: string): Hmac;
    static createPrivateKey(key: byte[]): KeyObject;
    static createPrivateKey(key: string): KeyObject;
    static createPublicKey(key: KeyObject): KeyObject;
    static createPublicKey(key: byte[]): KeyObject;
    static createPublicKey(key: string): KeyObject;
    static createSecretKey(key: byte[]): KeyObject;
    static createSecretKey(key: string, encoding?: string): KeyObject;
    static createSign(algorithm: string): Sign;
    static createVerify(algorithm: string): Verify;
    static generateKey(type_: string, options: unknown, callback: Action<Exception, KeyObject>): void;
    static generateKey(type_: string, options: unknown): KeyObject;
    static generateKeyPair(type_: string, options: unknown, callback: Action<Exception, unknown, unknown>): void;
    static generateKeyPairSync(type_: string, options?: unknown): ValueTuple<KeyObject, KeyObject>;
    static getCiphers(): string[];
    static getCurves(): string[];
    static getDefaultCipherList(): string;
    static getDiffieHellman(groupName: string): DiffieHellman;
    static getFips(): boolean;
    static getHashes(): string[];
    static hash(algorithm: string, data: byte[], outputEncoding?: string): byte[];
    static hkdf(digest: string, ikm: byte[], salt: byte[], info: byte[], keylen: int, callback: Action<Exception, byte[]>): void;
    static hkdfSync(digest: string, ikm: byte[], salt: byte[], info: byte[], keylen: int): byte[];
    static pbkdf2(password: string, salt: string, iterations: int, keylen: int, digest: string, callback: Action<Exception, byte[]>): void;
    static pbkdf2Sync(password: byte[], salt: byte[], iterations: int, keylen: int, digest: string): byte[];
    static pbkdf2Sync(password: string, salt: string, iterations: int, keylen: int, digest: string): byte[];
    static privateDecrypt(key: unknown, buffer: byte[]): byte[];
    static privateDecrypt(key: string, buffer: byte[]): byte[];
    static privateEncrypt(key: unknown, buffer: byte[]): byte[];
    static privateEncrypt(key: string, buffer: byte[]): byte[];
    static publicDecrypt(key: unknown, buffer: byte[]): byte[];
    static publicDecrypt(key: string, buffer: byte[]): byte[];
    static publicEncrypt(key: unknown, buffer: byte[]): byte[];
    static publicEncrypt(key: string, buffer: byte[]): byte[];
    static randomBytes(size: int, callback: Action<Exception, byte[]>): void;
    static randomBytes(size: int): byte[];
    static randomFill(buffer: byte[], offset: int, size: int, callback: Action<Exception, byte[]>): void;
    static randomFillSync(buffer: byte[], offset?: int, size?: Nullable<System_Internal.Int32>): byte[];
    static randomInt(min: int, max: int): int;
    static randomInt(max: int): int;
    static randomUUID(): string;
    static scrypt(password: string, salt: string, keylen: int, options: unknown, callback: Action<Exception, byte[]>): void;
    static scryptSync(password: byte[], salt: byte[], keylen: int, options?: unknown): byte[];
    static scryptSync(password: string, salt: string, keylen: int, options?: unknown): byte[];
    static setDefaultEncoding(encoding: string): void;
    static setFips(enabled: boolean): void;
    static sign(algorithm: string, data: byte[], privateKey: KeyObject): byte[];
    static sign(algorithm: string, data: byte[], privateKey: string): byte[];
    static timingSafeEqual(a: byte[], b: byte[]): boolean;
    static verify(algorithm: string, data: byte[], publicKey: KeyObject, signature: byte[]): boolean;
    static verify(algorithm: string, data: byte[], publicKey: string, signature: byte[]): boolean;
}


export type crypto = crypto$instance;

export abstract class dgram$instance {
    static createSocket(options: SocketOptions, callback?: Action<byte[], RemoteInfo>): DgramSocket;
    static createSocket(type_: string, callback?: Action<byte[], RemoteInfo>): DgramSocket;
}


export type dgram = dgram$instance;

export abstract class dns$instance {
    static readonly ADDRCONFIG: int;
    static readonly V4MAPPED: int;
    static readonly ALL: int;
    static readonly NODATA: string;
    static readonly FORMERR: string;
    static readonly SERVFAIL: string;
    static readonly NOTFOUND: string;
    static readonly NOTIMP: string;
    static readonly REFUSED: string;
    static readonly BADQUERY: string;
    static readonly BADNAME: string;
    static readonly BADFAMILY: string;
    static readonly BADRESP: string;
    static readonly CONNREFUSED: string;
    static readonly TIMEOUT: string;
    static readonly EOF: string;
    static readonly FILE: string;
    static readonly NOMEM: string;
    static readonly DESTRUCTION: string;
    static readonly BADSTR: string;
    static readonly BADFLAGS: string;
    static readonly NONAME: string;
    static readonly BADHINTS: string;
    static readonly NOTINITIALIZED: string;
    static readonly LOADIPHLPAPI: string;
    static readonly ADDRGETNETWORKPARAMS: string;
    static readonly CANCELLED: string;
    static getDefaultResultOrder(): string;
    static getServers(): string[];
    static lookup(hostname: string, options: LookupOptions, callback: Action<Exception, LookupAddress[]>): void;
    static lookup(hostname: string, options: LookupOptions, callback: Action<Exception, System_Internal.String, System_Internal.Int32>): void;
    static lookup(hostname: string, callback: Action<Exception, System_Internal.String, System_Internal.Int32>): void;
    static lookup(hostname: string, family: int, callback: Action<Exception, System_Internal.String, System_Internal.Int32>): void;
    static lookupService(address: string, port: int, callback: Action<Exception, System_Internal.String, System_Internal.String>): void;
    static resolve(hostname: string, callback: Action<Exception, string[]>): void;
    static resolve(hostname: string, rrtype: string, callback: Action<Exception, unknown>): void;
    static resolve4(hostname: string, options: ResolveOptions, callback: Action<Exception, unknown>): void;
    static resolve4(hostname: string, callback: Action<Exception, string[]>): void;
    static resolve6(hostname: string, options: ResolveOptions, callback: Action<Exception, unknown>): void;
    static resolve6(hostname: string, callback: Action<Exception, string[]>): void;
    static resolveAny(hostname: string, callback: Action<Exception, unknown[]>): void;
    static resolveCaa(hostname: string, callback: Action<Exception, CaaRecord[]>): void;
    static resolveCname(hostname: string, callback: Action<Exception, string[]>): void;
    static resolveMx(hostname: string, callback: Action<Exception, MxRecord[]>): void;
    static resolveNaptr(hostname: string, callback: Action<Exception, NaptrRecord[]>): void;
    static resolveNs(hostname: string, callback: Action<Exception, string[]>): void;
    static resolvePtr(hostname: string, callback: Action<Exception, string[]>): void;
    static resolveSoa(hostname: string, callback: Action<Exception, SoaRecord>): void;
    static resolveSrv(hostname: string, callback: Action<Exception, SrvRecord[]>): void;
    static resolveTlsa(hostname: string, callback: Action<Exception, TlsaRecord[]>): void;
    static resolveTxt(hostname: string, callback: Action<Exception, string[][]>): void;
    static reverse(ip: string, callback: Action<Exception, string[]>): void;
    static setDefaultResultOrder(order: string): void;
    static setServers(servers: string[]): void;
}


export type dns = dns$instance;

export abstract class fs$instance {
    static access(path: string, mode?: int): Task;
    static accessSync(path: string, mode?: int): void;
    static appendFile(path: string, data: string, encoding?: string): Task;
    static appendFileSync(path: string, data: string, encoding?: string): void;
    static chmod(path: string, mode: int): Task;
    static chmodSync(path: string, mode: int): void;
    static close(fd: int): Task;
    static closeSync(fd: int): void;
    static copyFile(src: string, dest: string, mode?: int): Task;
    static copyFileSync(src: string, dest: string, mode?: int): void;
    static cp(src: string, dest: string, recursive?: boolean): Task;
    static cpSync(src: string, dest: string, recursive?: boolean): void;
    static existsSync(path: string): boolean;
    static fstat(fd: int): Task<Stats>;
    static fstatSync(fd: int): Stats;
    static mkdir(path: string, recursive?: boolean): Task;
    static mkdirSync(path: string, recursive?: boolean): void;
    static open(path: string, flags: string, mode?: Nullable<System_Internal.Int32>): Task<System_Internal.Int32>;
    static openSync(path: string, flags: string, mode?: Nullable<System_Internal.Int32>): int;
    static read(fd: int, buffer: byte[], offset: int, length: int, position: Nullable<System_Internal.Int32>): Task<System_Internal.Int32>;
    static readdir(path: string, withFileTypes?: boolean): Task<string[]>;
    static readdirSync(path: string, withFileTypes?: boolean): string[];
    static readFile(path: string, encoding?: string): Task<System_Internal.String>;
    static readFileBytes(path: string): Task<byte[]>;
    static readFileSync(path: string, encoding?: string): string;
    static readFileSyncBytes(path: string): byte[];
    static readlink(path: string): Task<System_Internal.String>;
    static readlinkSync(path: string): string;
    static readSync(fd: int, buffer: byte[], offset: int, length: int, position: Nullable<System_Internal.Int32>): int;
    static realpath(path: string): Task<System_Internal.String>;
    static realpathSync(path: string): string;
    static rename(oldPath: string, newPath: string): Task;
    static renameSync(oldPath: string, newPath: string): void;
    static rm(path: string, recursive?: boolean): Task;
    static rmdir(path: string, recursive?: boolean): Task;
    static rmdirSync(path: string, recursive?: boolean): void;
    static rmSync(path: string, recursive?: boolean): void;
    static stat(path: string): Task<Stats>;
    static statSync(path: string): Stats;
    static symlink(target: string, path: string, type_?: string): Task;
    static symlinkSync(target: string, path: string, type_?: string): void;
    static truncate(path: string, len?: long): Task;
    static truncateSync(path: string, len?: long): void;
    static unlink(path: string): Task;
    static unlinkSync(path: string): void;
    static write(fd: int, buffer: byte[], offset: int, length: int, position: Nullable<System_Internal.Int32>): Task<System_Internal.Int32>;
    static write(fd: int, data: string, position?: Nullable<System_Internal.Int32>, encoding?: string): Task<System_Internal.Int32>;
    static writeFile(path: string, data: string, encoding?: string): Task;
    static writeFileBytes(path: string, data: byte[]): Task;
    static writeFileSync(path: string, data: string, encoding?: string): void;
    static writeFileSyncBytes(path: string, data: byte[]): void;
    static writeSync(fd: int, buffer: byte[], offset: int, length: int, position: Nullable<System_Internal.Int32>): int;
    static writeSync(fd: int, data: string, position?: Nullable<System_Internal.Int32>, encoding?: string): int;
}


export type fs = fs$instance;

export abstract class net$instance {
    static connect(options: TcpSocketConnectOpts, connectionListener?: Action): Socket;
    static connect(port: int, host?: string, connectionListener?: Action): Socket;
    static connect(path: string, connectionListener?: Action): Socket;
    static createConnection(options: TcpSocketConnectOpts, connectionListener?: Action): Socket;
    static createConnection(port: int, host?: string, connectionListener?: Action): Socket;
    static createConnection(path: string, connectionListener?: Action): Socket;
    static createServer(options: ServerOpts, connectionListener?: Action<Socket>): Server;
    static createServer(connectionListener?: Action<Socket>): Server;
    static getDefaultAutoSelectFamily(): boolean;
    static getDefaultAutoSelectFamilyAttemptTimeout(): int;
    static isIP(input: string): int;
    static isIPv4(input: string): boolean;
    static isIPv6(input: string): boolean;
    static setDefaultAutoSelectFamily(value: boolean): void;
    static setDefaultAutoSelectFamilyAttemptTimeout(value: int): void;
}


export type net = net$instance;

export abstract class os$instance {
    static readonly devNull: string;
    static readonly EOL: string;
    static arch(): string;
    static availableParallelism(): int;
    static cpus(): CpuInfo[];
    static endianness(): string;
    static freemem(): long;
    static homedir(): string;
    static hostname(): string;
    static loadavg(): double[];
    static platform(): string;
    static release(): string;
    static tmpdir(): string;
    static totalmem(): long;
    static type_(): string;
    static uptime(): long;
    static userInfo(): UserInfo;
}


export type os = os$instance;

export abstract class path$instance {
    static readonly sep: string;
    static readonly delimiter: string;
    static readonly posix: PathModule;
    static readonly win32: PathModule;
    static basename(path: string, suffix?: string): string;
    static dirname(path: string): string;
    static extname(path: string): string;
    static format(pathObject: ParsedPath): string;
    static isAbsolute(path: string): boolean;
    static join(...paths: string[]): string;
    static matchesGlob(path: string, pattern: string): boolean;
    static normalize(path: string): string;
    static parse(path: string): ParsedPath;
    static relative(from_: string, to: string): string;
    static resolve(...paths: string[]): string;
    static toNamespacedPath(path: string): string;
}


export type path = path$instance;

export abstract class performance$instance {
    static clearMarks(name?: string): void;
    static clearMeasures(name?: string): void;
    static getEntries(): PerformanceEntry[];
    static getEntriesByName(name: string, type_?: string): PerformanceEntry[];
    static getEntriesByType(type_: string): PerformanceEntry[];
    static mark(name: string, options?: MarkOptions): PerformanceMark;
    static measure(name: string, startOrOptions?: unknown, endMark?: string): PerformanceMeasure;
    static now(): double;
}


export type performance = performance$instance;

export abstract class process$instance {
    static readonly arch: string;
    static argv: string[];
    static argv0: string;
    static readonly env: ProcessEnv;
    static readonly execPath: string;
    static exitCode: Nullable<System_Internal.Int32>;
    static readonly pid: int;
    static readonly ppid: int;
    static readonly platform: string;
    static readonly version: string;
    static readonly versions: ProcessVersions;
    static chdir(directory: string): void;
    static cwd(): string;
    static exit(code?: Nullable<System_Internal.Int32>): void;
    static kill(pid: int, signal?: unknown): boolean;
}


export type process = process$instance;

export abstract class querystring$instance {
    static decode(str: string, sep?: string, eq?: string, maxKeys?: int): Dictionary<System_Internal.String, unknown>;
    static encode(obj: Dictionary<System_Internal.String, unknown>, sep?: string, eq?: string): string;
    static escape(str: string): string;
    static parse(str: string, sep?: string, eq?: string, maxKeys?: int): Dictionary<System_Internal.String, unknown>;
    static stringify(obj: Dictionary<System_Internal.String, unknown>, sep?: string, eq?: string): string;
    static unescape(str: string): string;
}


export type querystring = querystring$instance;

export abstract class readline$instance {
    static clearLine(stream: Writable, dir: int, callback?: Action): boolean;
    static clearScreenDown(stream: Writable, callback?: Action): boolean;
    static createAsyncIterator(input: Readable, options?: InterfaceOptions): IAsyncEnumerable<System_Internal.String>;
    static createInterface(options: InterfaceOptions): Interface;
    static createInterface(input: Readable, output?: Writable): Interface;
    static cursorTo(stream: Writable, x: int, y?: Nullable<System_Internal.Int32>, callback?: Action): boolean;
    static moveCursor(stream: Writable, dx: int, dy: int, callback?: Action): boolean;
}


export type readline = readline$instance;

export abstract class stream$instance {
    static finished(stream: Stream, callback: Action<Exception>): void;
    static finished(stream: Stream): Task;
    static pipeline(...streams: unknown[]): void;
}


export type stream = stream$instance;

export abstract class timers$instance {
    static clearImmediate(immediate: Immediate): void;
    static clearInterval(timeout: Timeout): void;
    static clearTimeout(timeout: Timeout): void;
    static queueMicrotask(callback: Action): void;
    static setImmediate(callback: Action): Immediate;
    static setInterval(callback: Action, delay?: int): Timeout;
    static setTimeout(callback: Action, delay?: int): Timeout;
}


export type timers = timers$instance;

export abstract class tls$instance {
    static readonly CLIENT_RENEG_LIMIT: int;
    static readonly CLIENT_RENEG_WINDOW: int;
    static DEFAULT_ECDH_CURVE: string;
    static DEFAULT_MAX_VERSION: string;
    static DEFAULT_MIN_VERSION: string;
    static DEFAULT_CIPHERS: string;
    static readonly rootCertificates: string[];
    static checkServerIdentity(hostname: string, cert: PeerCertificate): Exception | undefined;
    static connect(options: ConnectionOptions, secureConnectListener?: Action): TLSSocket;
    static connect(port: int, options?: ConnectionOptions, secureConnectListener?: Action): TLSSocket;
    static connect(port: int, host?: string, options?: ConnectionOptions, secureConnectListener?: Action): TLSSocket;
    static createSecureContext(options?: SecureContextOptions): SecureContext;
    static createServer(options: TlsOptions, secureConnectionListener?: Action<TLSSocket>): TLSServer;
    static createServer(secureConnectionListener?: Action<TLSSocket>): TLSServer;
    static getCACertificates(type_?: string): string[];
    static getCiphers(): string[];
    static setDefaultCACertificates(certs: string[]): void;
}


export type tls = tls$instance;

export abstract class util$instance {
    static debuglog(section: string): DebugLogFunction;
    static deprecate<TResult>(fn: Func<TResult>, msg: string, code?: string): Func<TResult>;
    static deprecate(action: Action, msg: string, code?: string): Action;
    static format(format: unknown, ...args: unknown[]): string;
    static inherits(constructor_: unknown, superConstructor: unknown): void;
    static inspect(obj: unknown): string;
    static isArray(obj: unknown): boolean;
    static isDeepStrictEqual(val1: unknown, val2: unknown): boolean;
}


export type util = util$instance;

export abstract class X509CertificateExtensions$instance {
    static parseCertificate(certificate: byte[]): X509CertificateInfo;
    static parseCertificate(certificate: string): X509CertificateInfo;
}


export type X509CertificateExtensions = X509CertificateExtensions$instance;

export abstract class zlib$instance {
    static brotliCompressSync(buffer: byte[], options?: BrotliOptions): byte[];
    static brotliDecompressSync(buffer: byte[], options?: BrotliOptions): byte[];
    static crc32(data: byte[], value?: uint): uint;
    static crc32(data: string, value?: uint): uint;
    static deflateRawSync(buffer: byte[], options?: ZlibOptions): byte[];
    static deflateSync(buffer: byte[], options?: ZlibOptions): byte[];
    static gunzipSync(buffer: byte[], options?: ZlibOptions): byte[];
    static gzipSync(buffer: byte[], options?: ZlibOptions): byte[];
    static inflateRawSync(buffer: byte[], options?: ZlibOptions): byte[];
    static inflateSync(buffer: byte[], options?: ZlibOptions): byte[];
    static unzipSync(buffer: byte[], options?: ZlibOptions): byte[];
}


export type zlib = zlib$instance;

