// Generated by tsbindgen - Architecture
// Namespace: System.Reflection.PortableExecutable
// Assembly: System.Reflection.Metadata

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { IEnumerable_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ImmutableArray_1 } from "../../System.Collections.Immutable/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { MetadataRootBuilder } from "../../System.Reflection.Metadata.Ecma335/internal/index.js";
import type { Blob, BlobBuilder, BlobContentId, BlobReader, MetadataReaderProvider, MethodDefinitionHandle } from "../../System.Reflection.Metadata/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_2, Boolean as ClrBoolean, Byte, Enum, Func_2, Guid, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int16, Int32, ISpanFormattable, Object as ClrObject, String as ClrString, Type, TypeCode, UInt16, UInt32, UInt64, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum Characteristics {
    relocsStripped = 1,
    executableImage = 2,
    lineNumsStripped = 4,
    localSymsStripped = 8,
    aggressiveWSTrim = 16,
    largeAddressAware = 32,
    bytesReversedLo = 128,
    bit32Machine = 256,
    debugStripped = 512,
    removableRunFromSwap = 1024,
    netRunFromSwap = 2048,
    system = 4096,
    dll = 8192,
    upSystemOnly = 16384,
    bytesReversedHi = 32768
}


export enum CorFlags {
    ilOnly = 1,
    requires32Bit = 2,
    ilLibrary = 4,
    strongNameSigned = 8,
    nativeEntryPoint = 16,
    trackDebugData = 65536,
    prefers32Bit = 131072
}


export enum DebugDirectoryEntryType {
    unknown_ = 0,
    coff = 1,
    codeView = 2,
    reproducible = 16,
    embeddedPortablePdb = 17,
    pdbChecksum = 19
}


export enum DllCharacteristics {
    processInit = 1,
    processTerm = 2,
    threadInit = 4,
    threadTerm = 8,
    highEntropyVirtualAddressSpace = 32,
    dynamicBase = 64,
    forceIntegrity = 128,
    nxCompatible = 256,
    noIsolation = 512,
    noSeh = 1024,
    noBind = 2048,
    appContainer = 4096,
    wdmDriver = 8192,
    controlFlowGuard = 16384,
    terminalServerAware = 32768
}


export enum Machine {
    unknown_ = 0,
    I386 = 332,
    wceMipsV2 = 361,
    alpha = 388,
    SH3 = 418,
    sH3Dsp = 419,
    SH3E = 420,
    SH4 = 422,
    SH5 = 424,
    arm = 448,
    thumb = 450,
    armThumb2 = 452,
    AM33 = 467,
    powerPC = 496,
    powerPCFP = 497,
    IA64 = 512,
    MIPS16 = 614,
    alpha64 = 644,
    mipsFpu = 870,
    mipsFpu16 = 1126,
    tricore = 1312,
    ebc = 3772,
    amd64 = 34404,
    M32R = 36929,
    arm64 = 43620,
    loongArch32 = 25138,
    loongArch64 = 25188,
    riscV32 = 20530,
    riscV64 = 20580,
    riscV128 = 20776
}


export enum PEMagic {
    PE32 = 267,
    pE32Plus = 523
}


export enum PEStreamOptions {
    default_ = 0,
    leaveOpen = 1,
    prefetchMetadata = 2,
    prefetchEntireImage = 4,
    isLoadedImage = 8
}


export enum SectionCharacteristics {
    typeReg = 0,
    typeDSect = 1,
    typeNoLoad = 2,
    typeGroup = 4,
    typeNoPad = 8,
    typeCopy = 16,
    containsCode = 32,
    containsInitializedData = 64,
    containsUninitializedData = 128,
    linkerOther = 256,
    linkerInfo = 512,
    typeOver = 1024,
    linkerRemove = 2048,
    linkerComdat = 4096,
    memProtected = 16384,
    noDeferSpecExc = 16384,
    gpRel = 32768,
    memFardata = 32768,
    memSysheap = 65536,
    memPurgeable = 131072,
    mem16Bit = 131072,
    memLocked = 262144,
    memPreload = 524288,
    align1Bytes = 1048576,
    align2Bytes = 2097152,
    align4Bytes = 3145728,
    align8Bytes = 4194304,
    align16Bytes = 5242880,
    align32Bytes = 6291456,
    align64Bytes = 7340032,
    align128Bytes = 8388608,
    align256Bytes = 9437184,
    align512Bytes = 10485760,
    align1024Bytes = 11534336,
    align2048Bytes = 12582912,
    align4096Bytes = 13631488,
    align8192Bytes = 14680064,
    alignMask = 15728640,
    linkerNRelocOvfl = 16777216,
    memDiscardable = 33554432,
    memNotCached = 67108864,
    memNotPaged = 134217728,
    memShared = 268435456,
    memExecute = 536870912,
    memRead = 1073741824,
    memWrite = 2147483648
}


export enum Subsystem {
    unknown_ = 0,
    native = 1,
    windowsGui = 2,
    windowsCui = 3,
    oS2Cui = 5,
    posixCui = 7,
    nativeWindows = 8,
    windowsCEGui = 9,
    efiApplication = 10,
    efiBootServiceDriver = 11,
    efiRuntimeDriver = 12,
    efiRom = 13,
    xbox = 14,
    windowsBootApplication = 16
}


export interface CodeViewDebugDirectoryData$instance {
    readonly age: int;
    readonly guid: Guid;
    readonly path: string;
}


export const CodeViewDebugDirectoryData: {
    new(): CodeViewDebugDirectoryData$instance;
};


export type CodeViewDebugDirectoryData = CodeViewDebugDirectoryData$instance;

export interface DebugDirectoryEntry$instance {
    readonly dataPointer: int;
    readonly dataRelativeVirtualAddress: int;
    readonly dataSize: int;
    readonly isPortableCodeView: boolean;
    readonly majorVersion: ushort;
    readonly minorVersion: ushort;
    readonly stamp: uint;
    readonly type_: DebugDirectoryEntryType;
}


export const DebugDirectoryEntry: {
    new(stamp: uint, majorVersion: ushort, minorVersion: ushort, type_: DebugDirectoryEntryType, dataSize: int, dataRelativeVirtualAddress: int, dataPointer: int): DebugDirectoryEntry$instance;
};


export type DebugDirectoryEntry = DebugDirectoryEntry$instance;

export interface DirectoryEntry$instance {
    readonly relativeVirtualAddress: int;
    readonly size: int;
}


export const DirectoryEntry: {
    new(relativeVirtualAddress: int, size: int): DirectoryEntry$instance;
};


export type DirectoryEntry = DirectoryEntry$instance;

export interface PdbChecksumDebugDirectoryData$instance {
    readonly algorithmName: string;
    readonly checksum: ImmutableArray_1<CLROf<byte>>;
}


export const PdbChecksumDebugDirectoryData: {
    new(): PdbChecksumDebugDirectoryData$instance;
};


export type PdbChecksumDebugDirectoryData = PdbChecksumDebugDirectoryData$instance;

export interface PEMemoryBlock$instance {
    readonly length: int;
    readonly pointer: ptr<byte>;
    getContent(): ImmutableArray_1<CLROf<byte>>;
    getContent(start: int, length: int): ImmutableArray_1<CLROf<byte>>;
    getReader(): BlobReader;
    getReader(start: int, length: int): BlobReader;
}


export const PEMemoryBlock: {
    new(): PEMemoryBlock$instance;
};


export type PEMemoryBlock = PEMemoryBlock$instance;

export interface SectionHeader$instance {
    readonly name: string;
    readonly numberOfLineNumbers: ushort;
    readonly numberOfRelocations: ushort;
    readonly pointerToLineNumbers: int;
    readonly pointerToRawData: int;
    readonly pointerToRelocations: int;
    readonly sectionCharacteristics: SectionCharacteristics;
    readonly sizeOfRawData: int;
    readonly virtualAddress: int;
    readonly virtualSize: int;
}


export const SectionHeader: {
    new(): SectionHeader$instance;
};


export type SectionHeader = SectionHeader$instance;

export interface SectionLocation$instance {
    readonly pointerToRawData: int;
    readonly relativeVirtualAddress: int;
}


export const SectionLocation: {
    new(relativeVirtualAddress: int, pointerToRawData: int): SectionLocation$instance;
};


export type SectionLocation = SectionLocation$instance;

export interface CoffHeader$instance {
    readonly characteristics: Characteristics;
    readonly machine: Machine;
    readonly numberOfSections: short;
    readonly numberOfSymbols: int;
    readonly pointerToSymbolTable: int;
    readonly sizeOfOptionalHeader: short;
    readonly timeDateStamp: int;
}


export const CoffHeader: {
    new(): CoffHeader$instance;
};


export type CoffHeader = CoffHeader$instance;

export interface CorHeader$instance {
    readonly codeManagerTableDirectory: DirectoryEntry;
    readonly entryPointTokenOrRelativeVirtualAddress: int;
    readonly exportAddressTableJumpsDirectory: DirectoryEntry;
    readonly flags: CorFlags;
    readonly majorRuntimeVersion: ushort;
    readonly managedNativeHeaderDirectory: DirectoryEntry;
    readonly metadataDirectory: DirectoryEntry;
    readonly minorRuntimeVersion: ushort;
    readonly resourcesDirectory: DirectoryEntry;
    readonly strongNameSignatureDirectory: DirectoryEntry;
    readonly vtableFixupsDirectory: DirectoryEntry;
}


export const CorHeader: {
    new(): CorHeader$instance;
};


export type CorHeader = CorHeader$instance;

export interface DebugDirectoryBuilder$instance {
    addCodeViewEntry(pdbPath: string, pdbContentId: BlobContentId, portablePdbVersion: ushort): void;
    addCodeViewEntry(pdbPath: string, pdbContentId: BlobContentId, portablePdbVersion: ushort, age: int): void;
    addEmbeddedPortablePdbEntry(debugMetadata: BlobBuilder, portablePdbVersion: ushort): void;
    addEntry(type_: DebugDirectoryEntryType, version: uint, stamp: uint): void;
    addEntry<TData>(type_: DebugDirectoryEntryType, version: uint, stamp: uint, data: TData, dataSerializer: Action_2<BlobBuilder, TData>): void;
    addPdbChecksumEntry(algorithmName: string, checksum: ImmutableArray_1<CLROf<byte>>): void;
    addReproducibleEntry(): void;
}


export const DebugDirectoryBuilder: {
    new(): DebugDirectoryBuilder$instance;
};


export type DebugDirectoryBuilder = DebugDirectoryBuilder$instance;

export interface ManagedPEBuilder$instance extends PEBuilder {
    sign(peImage: BlobBuilder, signatureProvider: Func_2<IEnumerable_1<Blob>, byte[]>): void;
}


export const ManagedPEBuilder: {
    new(header: PEHeaderBuilder, metadataRootBuilder: MetadataRootBuilder, ilStream: BlobBuilder, mappedFieldData: BlobBuilder, managedResources: BlobBuilder, nativeResources: ResourceSectionBuilder, debugDirectoryBuilder: DebugDirectoryBuilder, strongNameSignatureSize: int, entryPoint: MethodDefinitionHandle, flags: CorFlags, deterministicIdProvider: Func_2<IEnumerable_1<Blob>, BlobContentId>): ManagedPEBuilder$instance;
    readonly managedResourcesDataAlignment: int;
    readonly mappedFieldDataAlignment: int;
};


export type ManagedPEBuilder = ManagedPEBuilder$instance;

export interface PEBuilder$instance {
    readonly header: PEHeaderBuilder;
    readonly idProvider: Func_2<IEnumerable_1<Blob>, BlobContentId>;
    readonly isDeterministic: boolean;
    serialize(builder: BlobBuilder): BlobContentId;
}


export const PEBuilder: {
};


export type PEBuilder = PEBuilder$instance;

export interface PEDirectoriesBuilder$instance {
    addressOfEntryPoint: int;
    baseRelocationTable: DirectoryEntry;
    boundImportTable: DirectoryEntry;
    copyrightTable: DirectoryEntry;
    corHeaderTable: DirectoryEntry;
    debugTable: DirectoryEntry;
    delayImportTable: DirectoryEntry;
    exceptionTable: DirectoryEntry;
    exportTable: DirectoryEntry;
    globalPointerTable: DirectoryEntry;
    importAddressTable: DirectoryEntry;
    importTable: DirectoryEntry;
    loadConfigTable: DirectoryEntry;
    resourceTable: DirectoryEntry;
    threadLocalStorageTable: DirectoryEntry;
}


export const PEDirectoriesBuilder: {
    new(): PEDirectoriesBuilder$instance;
};


export type PEDirectoriesBuilder = PEDirectoriesBuilder$instance;

export interface PEHeader$instance {
    readonly addressOfEntryPoint: int;
    readonly baseOfCode: int;
    readonly baseOfData: int;
    readonly baseRelocationTableDirectory: DirectoryEntry;
    readonly boundImportTableDirectory: DirectoryEntry;
    readonly certificateTableDirectory: DirectoryEntry;
    readonly checkSum: uint;
    readonly copyrightTableDirectory: DirectoryEntry;
    readonly corHeaderTableDirectory: DirectoryEntry;
    readonly debugTableDirectory: DirectoryEntry;
    readonly delayImportTableDirectory: DirectoryEntry;
    readonly dllCharacteristics: DllCharacteristics;
    readonly exceptionTableDirectory: DirectoryEntry;
    readonly exportTableDirectory: DirectoryEntry;
    readonly fileAlignment: int;
    readonly globalPointerTableDirectory: DirectoryEntry;
    readonly imageBase: ulong;
    readonly importAddressTableDirectory: DirectoryEntry;
    readonly importTableDirectory: DirectoryEntry;
    readonly loadConfigTableDirectory: DirectoryEntry;
    readonly magic: PEMagic;
    readonly majorImageVersion: ushort;
    readonly majorLinkerVersion: byte;
    readonly majorOperatingSystemVersion: ushort;
    readonly majorSubsystemVersion: ushort;
    readonly minorImageVersion: ushort;
    readonly minorLinkerVersion: byte;
    readonly minorOperatingSystemVersion: ushort;
    readonly minorSubsystemVersion: ushort;
    readonly numberOfRvaAndSizes: int;
    readonly resourceTableDirectory: DirectoryEntry;
    readonly sectionAlignment: int;
    readonly sizeOfCode: int;
    readonly sizeOfHeaders: int;
    readonly sizeOfHeapCommit: ulong;
    readonly sizeOfHeapReserve: ulong;
    readonly sizeOfImage: int;
    readonly sizeOfInitializedData: int;
    readonly sizeOfStackCommit: ulong;
    readonly sizeOfStackReserve: ulong;
    readonly sizeOfUninitializedData: int;
    readonly subsystem: Subsystem;
    readonly threadLocalStorageTableDirectory: DirectoryEntry;
}


export const PEHeader: {
    new(): PEHeader$instance;
};


export type PEHeader = PEHeader$instance;

export interface PEHeaderBuilder$instance {
    readonly dllCharacteristics: DllCharacteristics;
    readonly fileAlignment: int;
    readonly imageBase: ulong;
    readonly imageCharacteristics: Characteristics;
    readonly machine: Machine;
    readonly majorImageVersion: ushort;
    readonly majorLinkerVersion: byte;
    readonly majorOperatingSystemVersion: ushort;
    readonly majorSubsystemVersion: ushort;
    readonly minorImageVersion: ushort;
    readonly minorLinkerVersion: byte;
    readonly minorOperatingSystemVersion: ushort;
    readonly minorSubsystemVersion: ushort;
    readonly sectionAlignment: int;
    readonly sizeOfHeapCommit: ulong;
    readonly sizeOfHeapReserve: ulong;
    readonly sizeOfStackCommit: ulong;
    readonly sizeOfStackReserve: ulong;
    readonly subsystem: Subsystem;
}


export const PEHeaderBuilder: {
    new(machine: Machine, sectionAlignment: int, fileAlignment: int, imageBase: ulong, majorLinkerVersion: byte, minorLinkerVersion: byte, majorOperatingSystemVersion: ushort, minorOperatingSystemVersion: ushort, majorImageVersion: ushort, minorImageVersion: ushort, majorSubsystemVersion: ushort, minorSubsystemVersion: ushort, subsystem: Subsystem, dllCharacteristics: DllCharacteristics, imageCharacteristics: Characteristics, sizeOfStackReserve: ulong, sizeOfStackCommit: ulong, sizeOfHeapReserve: ulong, sizeOfHeapCommit: ulong): PEHeaderBuilder$instance;
    createExecutableHeader(): PEHeaderBuilder;
    createLibraryHeader(): PEHeaderBuilder;
};


export type PEHeaderBuilder = PEHeaderBuilder$instance;

export interface PEHeaders$instance {
    readonly coffHeader: CoffHeader;
    readonly coffHeaderStartOffset: int;
    readonly corHeader: CorHeader;
    readonly corHeaderStartOffset: int;
    readonly isCoffOnly: boolean;
    readonly isConsoleApplication: boolean;
    readonly isDll: boolean;
    readonly isExe: boolean;
    readonly metadataSize: int;
    readonly metadataStartOffset: int;
    readonly peHeader: PEHeader;
    readonly peHeaderStartOffset: int;
    readonly sectionHeaders: ImmutableArray_1<SectionHeader>;
    getContainingSectionIndex(relativeVirtualAddress: int): int;
    tryGetDirectoryOffset(directory: DirectoryEntry, offset: { value: ref<int> }): boolean;
}


export const PEHeaders: {
    new(peStream: Stream): PEHeaders$instance;
    new(peStream: Stream, size: int): PEHeaders$instance;
    new(peStream: Stream, size: int, isLoadedImage: boolean): PEHeaders$instance;
};


export type PEHeaders = PEHeaders$instance;

export interface PEReader$instance {
    readonly hasMetadata: boolean;
    readonly isEntireImageAvailable: boolean;
    readonly isLoadedImage: boolean;
    readonly peHeaders: PEHeaders;
    dispose(): void;
    getEntireImage(): PEMemoryBlock;
    getMetadata(): PEMemoryBlock;
    getSectionData(relativeVirtualAddress: int): PEMemoryBlock;
    getSectionData(sectionName: string): PEMemoryBlock;
    readCodeViewDebugDirectoryData(entry: DebugDirectoryEntry): CodeViewDebugDirectoryData;
    readDebugDirectory(): ImmutableArray_1<DebugDirectoryEntry>;
    readEmbeddedPortablePdbDebugDirectoryData(entry: DebugDirectoryEntry): MetadataReaderProvider;
    readPdbChecksumDebugDirectoryData(entry: DebugDirectoryEntry): PdbChecksumDebugDirectoryData;
    tryOpenAssociatedPortablePdb(peImagePath: string, pdbFileStreamProvider: Func_2<CLROf<string>, Stream>, pdbReaderProvider: { value: ref<MetadataReaderProvider> }, pdbPath: { value: ref<string> }): boolean;
}


export const PEReader: {
    new(peImage: ptr<byte>, size: int): PEReader$instance;
    new(peImage: ptr<byte>, size: int, isLoadedImage: boolean): PEReader$instance;
    new(peStream: Stream): PEReader$instance;
    new(peStream: Stream, options: PEStreamOptions): PEReader$instance;
    new(peStream: Stream, options: PEStreamOptions, size: int): PEReader$instance;
    new(peImage: ImmutableArray_1<CLROf<byte>>): PEReader$instance;
};


export interface __PEReader$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface PEReader$instance extends System_Internal.IDisposable$instance {}

export type PEReader = PEReader$instance & __PEReader$views;


export interface ResourceSectionBuilder$instance {
}


export const ResourceSectionBuilder: {
};


export type ResourceSectionBuilder = ResourceSectionBuilder$instance;

