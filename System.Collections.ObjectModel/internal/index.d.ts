// Generated by tsbindgen - Architecture
// Namespace: System.Collections.ObjectModel
// Assembly: System.ObjectModel, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IDictionary_2, IEnumerable_1, IEnumerator_1, IEqualityComparer_1, IList_1, IReadOnlyCollection_1, IReadOnlyDictionary_2, IReadOnlyList_1, IReadOnlySet_1, ISet_1, KeyValuePair_2, List_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Specialized_Internal from "../../System.Collections.Specialized/internal/index.js";
import type { INotifyCollectionChanged, NotifyCollectionChangedEventHandler } from "../../System.Collections.Specialized/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { INotifyPropertyChanged } from "../../System.ComponentModel/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Boolean as ClrBoolean, Int32, Object as ClrObject, ReadOnlySpan_1, String as ClrString, Type, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface Collection_1$instance<T> {
    readonly count: int;
    item: T;
    add(item: T): void;
    clear(): void;
    contains(item: T): boolean;
    copyTo(array: T[], index: int): void;
    getEnumerator(): IEnumerator_1<T>;
    indexOf(item: T): int;
    insert(index: int, item: T): void;
    remove(item: T): boolean;
    removeAt(index: int): void;
}


export const Collection_1: {
    new<T>(): Collection_1$instance<T>;
    new<T>(list: IList_1<T>): Collection_1$instance<T>;
};


export interface __Collection_1$views<T> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type Collection_1<T> = Collection_1$instance<T> & __Collection_1$views<T>;


export interface KeyedCollection_2$instance<TKey, TItem> extends Collection_1$instance<TItem> {
    readonly comparer: IEqualityComparer_1<TKey>;
    add(item: TItem): void;
    add(value: unknown): int;
    clear(): void;
    contains(item: TItem): boolean;
    contains(value: unknown): boolean;
    copyTo(array: TItem[], index: int): void;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator_1<TItem>;
    getEnumerator(): IEnumerator;
    indexOf(item: TItem): int;
    insert(index: int, item: TItem): void;
    insert(index: int, value: unknown): void;
    remove(item: TItem): boolean;
    remove(value: unknown): void;
    removeAt(index: int): void;
    tryGetValue(key: TKey, item: { value: ref<TItem> }): boolean;
}


export const KeyedCollection_2: {
};


export interface __KeyedCollection_2$views<TKey, TItem> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<TItem>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<TItem>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<TItem>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<TItem>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type KeyedCollection_2<TKey, TItem> = KeyedCollection_2$instance<TKey, TItem> & __KeyedCollection_2$views<TKey, TItem>;


export interface ObservableCollection_1$instance<T> extends Collection_1$instance<T>, INotifyCollectionChanged, INotifyPropertyChanged {
    add(item: T): void;
    add(value: unknown): int;
    clear(): void;
    contains(item: T): boolean;
    contains(value: unknown): boolean;
    copyTo(array: T[], index: int): void;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator_1<T>;
    getEnumerator(): IEnumerator;
    indexOf(item: T): int;
    insert(index: int, item: T): void;
    insert(index: int, value: unknown): void;
    move(oldIndex: int, newIndex: int): void;
    remove(item: T): boolean;
    remove(value: unknown): void;
    removeAt(index: int): void;
}


export const ObservableCollection_1: {
    new<T>(): ObservableCollection_1$instance<T>;
    new<T>(collection: IEnumerable_1<T>): ObservableCollection_1$instance<T>;
    new<T>(list: List_1<T>): ObservableCollection_1$instance<T>;
};


export interface __ObservableCollection_1$views<T> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export interface ObservableCollection_1$instance<T> extends System_Collections_Specialized_Internal.INotifyCollectionChanged$instance, System_ComponentModel_Internal.INotifyPropertyChanged$instance {}

export type ObservableCollection_1<T> = ObservableCollection_1$instance<T> & __ObservableCollection_1$views<T>;


export interface ReadOnlyCollection_1$instance<T> {
    readonly count: int;
    readonly item: T;
    contains(value: T): boolean;
    copyTo(array: T[], index: int): void;
    getEnumerator(): IEnumerator_1<T>;
    indexOf(value: T): int;
}


export const ReadOnlyCollection_1: {
    new<T>(list: IList_1<T>): ReadOnlyCollection_1$instance<T>;
    readonly empty: unknown;
};


export interface __ReadOnlyCollection_1$views<T> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type ReadOnlyCollection_1<T> = ReadOnlyCollection_1$instance<T> & __ReadOnlyCollection_1$views<T>;


export interface ReadOnlyDictionary_2$instance<TKey, TValue> {
    readonly count: int;
    readonly item: TValue;
    readonly keys: ReadOnlyDictionary_2_KeyCollection<TKey, TValue>;
    readonly values: ReadOnlyDictionary_2_ValueCollection<TKey, TValue>;
    containsKey(key: TKey): boolean;
    getEnumerator(): IEnumerator_1<KeyValuePair_2<TKey, TValue>>;
    tryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
}


export const ReadOnlyDictionary_2: {
    new<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>): ReadOnlyDictionary_2$instance<TKey, TValue>;
    readonly empty: unknown;
};


export interface __ReadOnlyDictionary_2$views<TKey, TValue> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionary_2(): System_Collections_Generic_Internal.IDictionary_2$instance<TKey, TValue>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyDictionary_2(): System_Collections_Generic_Internal.IReadOnlyDictionary_2$instance<TKey, TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ReadOnlyDictionary_2<TKey, TValue> = ReadOnlyDictionary_2$instance<TKey, TValue> & __ReadOnlyDictionary_2$views<TKey, TValue>;


export interface ReadOnlyDictionary_2_KeyCollection$instance<TKey, TValue> {
    readonly count: int;
    contains(item: TKey): boolean;
    copyTo(array: TKey[], arrayIndex: int): void;
    getEnumerator(): IEnumerator_1<TKey>;
}


export const ReadOnlyDictionary_2_KeyCollection: {
    new<TKey, TValue>(): ReadOnlyDictionary_2_KeyCollection$instance<TKey, TValue>;
};


export interface __ReadOnlyDictionary_2_KeyCollection$views<TKey, TValue> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<TKey>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<TKey>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<TKey>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ReadOnlyDictionary_2_KeyCollection<TKey, TValue> = ReadOnlyDictionary_2_KeyCollection$instance<TKey, TValue> & __ReadOnlyDictionary_2_KeyCollection$views<TKey, TValue>;


export interface ReadOnlyDictionary_2_ValueCollection$instance<TKey, TValue> {
    readonly count: int;
    copyTo(array: TValue[], arrayIndex: int): void;
    getEnumerator(): IEnumerator_1<TValue>;
}


export const ReadOnlyDictionary_2_ValueCollection: {
    new<TKey, TValue>(): ReadOnlyDictionary_2_ValueCollection$instance<TKey, TValue>;
};


export interface __ReadOnlyDictionary_2_ValueCollection$views<TKey, TValue> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<TValue>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<TValue>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ReadOnlyDictionary_2_ValueCollection<TKey, TValue> = ReadOnlyDictionary_2_ValueCollection$instance<TKey, TValue> & __ReadOnlyDictionary_2_ValueCollection$views<TKey, TValue>;


export interface ReadOnlyObservableCollection_1$instance<T> extends ReadOnlyCollection_1$instance<T>, INotifyCollectionChanged, INotifyPropertyChanged {
    add(item: T): void;
    add(value: unknown): int;
    clear(): void;
    contains(value: T): boolean;
    contains(value: unknown): boolean;
    copyTo(array: T[], index: int): void;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator_1<T>;
    getEnumerator(): IEnumerator;
    indexOf(value: T): int;
    insert(index: int, item: T): void;
    insert(index: int, value: unknown): void;
    remove(item: T): boolean;
    remove(value: unknown): void;
    removeAt(index: int): void;
}


export const ReadOnlyObservableCollection_1: {
    new<T>(list: ObservableCollection_1<T>): ReadOnlyObservableCollection_1$instance<T>;
};


export interface __ReadOnlyObservableCollection_1$views<T> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export interface ReadOnlyObservableCollection_1$instance<T> extends System_Collections_Specialized_Internal.INotifyCollectionChanged$instance, System_ComponentModel_Internal.INotifyPropertyChanged$instance {}

export type ReadOnlyObservableCollection_1<T> = ReadOnlyObservableCollection_1$instance<T> & __ReadOnlyObservableCollection_1$views<T>;


export interface ReadOnlySet_1$instance<T> {
    readonly count: int;
    contains(item: T): boolean;
    getEnumerator(): IEnumerator_1<T>;
    isProperSubsetOf(other: IEnumerable_1<T>): boolean;
    isProperSupersetOf(other: IEnumerable_1<T>): boolean;
    isSubsetOf(other: IEnumerable_1<T>): boolean;
    isSupersetOf(other: IEnumerable_1<T>): boolean;
    overlaps(other: IEnumerable_1<T>): boolean;
    setEquals(other: IEnumerable_1<T>): boolean;
}


export const ReadOnlySet_1: {
    new<T>(set_: ISet_1<T>): ReadOnlySet_1$instance<T>;
    readonly empty: unknown;
};


export interface __ReadOnlySet_1$views<T> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_IReadOnlySet_1(): System_Collections_Generic_Internal.IReadOnlySet_1$instance<T>;
    As_ISet_1(): System_Collections_Generic_Internal.ISet_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ReadOnlySet_1<T> = ReadOnlySet_1$instance<T> & __ReadOnlySet_1$views<T>;


export abstract class ReadOnlyCollection$instance {
    static createCollection<T>(values: ReadOnlySpan_1<T>): ReadOnlyCollection_1<T>;
    static createSet<T>(values: ReadOnlySpan_1<T>): ReadOnlySet_1<T>;
}


export type ReadOnlyCollection = ReadOnlyCollection$instance;

