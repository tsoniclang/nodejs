// Generated by tsbindgen - Architecture
// Namespace: System.Text.Json.Nodes
// Assembly: System.Text.Json

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IDictionary_2, IEnumerable_1, IEnumerator_1, IList_1, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { JsonTypeInfo_1 } from "../../System.Text.Json.Serialization.Metadata/internal/index.js";
import type { JsonDocumentOptions, JsonElement, JsonSerializerOptions, JsonValueKind, Utf8JsonReader, Utf8JsonWriter } from "../../System.Text.Json/internal/index.js";
import type { Task_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Byte, Char, DateTime, DateTimeOffset, Decimal, Double, Func_2, Guid, Int16, Int32, Int64, Nullable_1, Object as ClrObject, ReadOnlySpan_1, SByte, Single, String as ClrString, Type, UInt16, UInt32, UInt64, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface JsonNodeOptions$instance {
    propertyNameCaseInsensitive: boolean;
}


export const JsonNodeOptions: {
    new(): JsonNodeOptions$instance;
};


export type JsonNodeOptions = JsonNodeOptions$instance;

export interface JsonArray$instance extends JsonNode {
    readonly count: int;
    add<T>(value: T): void;
    add(item: JsonNode): void;
    clear(): void;
    contains(item: JsonNode): boolean;
    getEnumerator(): IEnumerator_1<JsonNode>;
    getValues<T>(): IEnumerable_1<T>;
    indexOf(item: JsonNode): int;
    insert(index: int, item: JsonNode): void;
    remove(item: JsonNode): boolean;
    removeAll(match: Func_2<JsonNode, CLROf<boolean>>): int;
    removeAt(index: int): void;
    removeRange(index: int, count: int): void;
    writeTo(writer: Utf8JsonWriter, options?: JsonSerializerOptions): void;
}


export const JsonArray: {
    new(options: Nullable_1<JsonNodeOptions>): JsonArray$instance;
    new(options: JsonNodeOptions, items: JsonNode[]): JsonArray$instance;
    new(options: JsonNodeOptions, items: ReadOnlySpan_1<JsonNode>): JsonArray$instance;
    new(items: JsonNode[]): JsonArray$instance;
    new(items: ReadOnlySpan_1<JsonNode>): JsonArray$instance;
    create(element: JsonElement, options?: Nullable_1<JsonNodeOptions>): JsonArray;
};


export interface __JsonArray$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<JsonNode>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<JsonNode>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<JsonNode>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type JsonArray = JsonArray$instance & __JsonArray$views;


export interface JsonNode$instance {
    readonly options: Nullable_1<JsonNodeOptions>;
    readonly parent: JsonNode;
    readonly root: JsonNode;
    asArray(): JsonArray;
    asObject(): JsonObject;
    asValue(): JsonValue;
    deepClone(): JsonNode;
    get_Item(index: int): JsonNode;
    get_Item(propertyName: string): JsonNode;
    getElementIndex(): int;
    getPath(): string;
    getPropertyName(): string;
    getValue<T>(): T;
    getValueKind(): JsonValueKind;
    replaceWith<T>(value: T): void;
    set_Item(index: int, value: JsonNode): void;
    set_Item(propertyName: string, value: JsonNode): void;
    toJsonString(options?: JsonSerializerOptions): string;
    toString(): string;
    writeTo(writer: Utf8JsonWriter, options?: JsonSerializerOptions): void;
}


export const JsonNode: {
    deepEquals(node1: JsonNode, node2: JsonNode): boolean;
    parse(utf8Json: Stream, nodeOptions?: Nullable_1<JsonNodeOptions>, documentOptions?: JsonDocumentOptions): JsonNode;
    parse(utf8Json: ReadOnlySpan_1<CLROf<byte>>, nodeOptions?: Nullable_1<JsonNodeOptions>, documentOptions?: JsonDocumentOptions): JsonNode;
    parse(json: string, nodeOptions?: Nullable_1<JsonNodeOptions>, documentOptions?: JsonDocumentOptions): JsonNode;
    parse(reader: { value: ref<Utf8JsonReader> }, nodeOptions?: Nullable_1<JsonNodeOptions>): JsonNode;
    parseAsync(utf8Json: Stream, nodeOptions?: Nullable_1<JsonNodeOptions>, documentOptions?: JsonDocumentOptions, cancellationToken?: CancellationToken): Task_1<JsonNode>;
};


export type JsonNode = JsonNode$instance;

export interface JsonObject$instance extends JsonNode {
    readonly count: int;
    add(propertyName: string, value: JsonNode): void;
    add(property: KeyValuePair_2<CLROf<string>, JsonNode>): void;
    clear(): void;
    containsKey(propertyName: string): boolean;
    getAt(index: int): KeyValuePair_2<CLROf<string>, JsonNode>;
    getEnumerator(): IEnumerator_1<KeyValuePair_2<CLROf<string>, JsonNode>>;
    indexOf(propertyName: string): int;
    insert(index: int, propertyName: string, value: JsonNode): void;
    remove(propertyName: string): boolean;
    removeAt(index: int): void;
    setAt(index: int, propertyName: string, value: JsonNode): void;
    setAt(index: int, value: JsonNode): void;
    tryAdd(propertyName: string, value: JsonNode): boolean;
    tryAdd(propertyName: string, value: JsonNode, index: { value: ref<int> }): boolean;
    tryGetPropertyValue(propertyName: string, jsonNode: { value: ref<JsonNode> }): boolean;
    tryGetPropertyValue(propertyName: string, jsonNode: { value: ref<JsonNode> }, index: { value: ref<int> }): boolean;
    writeTo(writer: Utf8JsonWriter, options?: JsonSerializerOptions): void;
}


export const JsonObject: {
    new(options: Nullable_1<JsonNodeOptions>): JsonObject$instance;
    new(properties: IEnumerable_1<KeyValuePair_2<CLROf<string>, JsonNode>>, options: Nullable_1<JsonNodeOptions>): JsonObject$instance;
    create(element: JsonElement, options?: Nullable_1<JsonNodeOptions>): JsonObject;
};


export interface __JsonObject$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<CLROf<string>, JsonNode>>;
    As_IDictionary_2(): System_Collections_Generic_Internal.IDictionary_2$instance<CLROf<string>, JsonNode>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<CLROf<string>, JsonNode>>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<KeyValuePair_2<CLROf<string>, JsonNode>>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type JsonObject = JsonObject$instance & __JsonObject$views;


export interface JsonValue$instance extends JsonNode {
    tryGetValue<T>(value: { value: ref<T> }): boolean;
}


export const JsonValue: {
    create(value: boolean, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: byte, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: char, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: DateTime, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: DateTimeOffset, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: decimal, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: double, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: Guid, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: short, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: int, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: long, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: Nullable_1<CLROf<boolean>>, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: Nullable_1<CLROf<byte>>, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: Nullable_1<CLROf<char>>, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: Nullable_1<DateTime>, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: Nullable_1<DateTimeOffset>, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: Nullable_1<CLROf<decimal>>, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: Nullable_1<CLROf<double>>, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: Nullable_1<Guid>, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: Nullable_1<CLROf<short>>, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: Nullable_1<CLROf<int>>, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: Nullable_1<CLROf<long>>, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: Nullable_1<CLROf<sbyte>>, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: Nullable_1<CLROf<float>>, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: Nullable_1<JsonElement>, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: Nullable_1<CLROf<ushort>>, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: Nullable_1<CLROf<uint>>, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: Nullable_1<CLROf<ulong>>, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: sbyte, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: float, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: string, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: JsonElement, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: ushort, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: uint, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create(value: ulong, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create<T>(value: T, jsonTypeInfo: JsonTypeInfo_1<T>, options?: Nullable_1<JsonNodeOptions>): JsonValue;
    create<T>(value: T, options?: Nullable_1<JsonNodeOptions>): JsonValue;
};


export type JsonValue = JsonValue$instance;

