// Generated by tsbindgen - Architecture
// Namespace: nodejs
// Assembly: nodejs

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "@tsonic/dotnet/System.Collections.Generic/internal/index.js";
import type { Dictionary_2, IAsyncEnumerable_1, ICollection_1, IDictionary_2, IEnumerable_1, IEnumerator_1, KeyValuePair_2 } from "@tsonic/dotnet/System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "@tsonic/dotnet/System.Collections/internal/index.js";
import type { IEnumerable } from "@tsonic/dotnet/System.Collections/internal/index.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization/internal/index.js";
import type { ISerializable } from "@tsonic/dotnet/System.Runtime.Serialization/internal/index.js";
import type { SslProtocols } from "@tsonic/dotnet/System.Security.Authentication/internal/index.js";
import type { X509Certificate2, X509Certificate2Collection } from "@tsonic/dotnet/System.Security.Cryptography.X509Certificates/internal/index.js";
import type { Regex } from "@tsonic/dotnet/System.Text.RegularExpressions/internal/index.js";
import type { Task, Task_1 } from "@tsonic/dotnet/System.Threading.Tasks/internal/index.js";
import * as System_Internal from "@tsonic/dotnet/System/internal/index.js";
import type { Action, Action_1, Action_2, Action_3, AsyncCallback, Boolean as ClrBoolean, Byte, DateTime, Delegate, Double, Exception, Func_1, IAsyncResult, ICloneable, IDisposable, Int16, Int32, Int64, IntPtr, MulticastDelegate, Nullable_1, Object as ClrObject, SByte, Single, String as ClrString, UInt16, UInt32, UInt64, ValueTuple_2, Void } from "@tsonic/dotnet/System/internal/index.js";

export type DebugLogFunction = (message: string, ...args: unknown[]) => void;


export interface AddressInfo$instance {
    readonly __tsonic_type_nodejs_AddressInfo: never;

    address: string;
    family: string;
    port: int;
}


export const AddressInfo: {
    new(): AddressInfo;
};


export type AddressInfo = AddressInfo$instance;

export interface AnyAaaaRecord$instance extends RecordWithTtl {
    readonly __tsonic_type_nodejs_AnyAaaaRecord: never;

    readonly type: string;
}


export const AnyAaaaRecord: {
    new(): AnyAaaaRecord;
};


export type AnyAaaaRecord = AnyAaaaRecord$instance;

export interface AnyARecord$instance extends RecordWithTtl {
    readonly __tsonic_type_nodejs_AnyARecord: never;

    readonly type: string;
}


export const AnyARecord: {
    new(): AnyARecord;
};


export type AnyARecord = AnyARecord$instance;

export interface AnyCaaRecord$instance extends CaaRecord {
    readonly __tsonic_type_nodejs_AnyCaaRecord: never;

    readonly type: string;
}


export const AnyCaaRecord: {
    new(): AnyCaaRecord;
};


export type AnyCaaRecord = AnyCaaRecord$instance;

export interface AnyCnameRecord$instance {
    readonly __tsonic_type_nodejs_AnyCnameRecord: never;

    readonly type: string;
    value: string;
}


export const AnyCnameRecord: {
    new(): AnyCnameRecord;
};


export type AnyCnameRecord = AnyCnameRecord$instance;

export interface AnyMxRecord$instance extends MxRecord {
    readonly __tsonic_type_nodejs_AnyMxRecord: never;

    readonly type: string;
}


export const AnyMxRecord: {
    new(): AnyMxRecord;
};


export type AnyMxRecord = AnyMxRecord$instance;

export interface AnyNaptrRecord$instance extends NaptrRecord {
    readonly __tsonic_type_nodejs_AnyNaptrRecord: never;

    readonly type: string;
}


export const AnyNaptrRecord: {
    new(): AnyNaptrRecord;
};


export type AnyNaptrRecord = AnyNaptrRecord$instance;

export interface AnyNsRecord$instance {
    readonly __tsonic_type_nodejs_AnyNsRecord: never;

    readonly type: string;
    value: string;
}


export const AnyNsRecord: {
    new(): AnyNsRecord;
};


export type AnyNsRecord = AnyNsRecord$instance;

export interface AnyPtrRecord$instance {
    readonly __tsonic_type_nodejs_AnyPtrRecord: never;

    readonly type: string;
    value: string;
}


export const AnyPtrRecord: {
    new(): AnyPtrRecord;
};


export type AnyPtrRecord = AnyPtrRecord$instance;

export interface AnyRecord$instance {
    readonly __tsonic_type_nodejs_AnyRecord: never;

    type: string;
}


export const AnyRecord: (abstract new() => AnyRecord) & {
};


export type AnyRecord = AnyRecord$instance;

export interface AnySoaRecord$instance extends SoaRecord {
    readonly __tsonic_type_nodejs_AnySoaRecord: never;

    readonly type: string;
}


export const AnySoaRecord: {
    new(): AnySoaRecord;
};


export type AnySoaRecord = AnySoaRecord$instance;

export interface AnySrvRecord$instance extends SrvRecord {
    readonly __tsonic_type_nodejs_AnySrvRecord: never;

    readonly type: string;
}


export const AnySrvRecord: {
    new(): AnySrvRecord;
};


export type AnySrvRecord = AnySrvRecord$instance;

export interface AnyTlsaRecord$instance extends TlsaRecord {
    readonly __tsonic_type_nodejs_AnyTlsaRecord: never;

    readonly type: string;
}


export const AnyTlsaRecord: {
    new(): AnyTlsaRecord;
};


export type AnyTlsaRecord = AnyTlsaRecord$instance;

export interface AnyTxtRecord$instance {
    readonly __tsonic_type_nodejs_AnyTxtRecord: never;

    entries: string[];
    readonly type: string;
}


export const AnyTxtRecord: {
    new(): AnyTxtRecord;
};


export type AnyTxtRecord = AnyTxtRecord$instance;

export interface AssertionError$instance extends Exception {
    readonly __tsonic_type_nodejs_AssertionError: never;

    readonly __tsonic_iface_System_Runtime_Serialization_ISerializable: never;

    get actual(): unknown | undefined;
    set actual(value: unknown | undefined);
    readonly code: string;
    get expected(): unknown | undefined;
    set expected(value: unknown | undefined);
    generatedMessage: boolean;
    operator: string;
}


export const AssertionError: {
    new(message: string, actual: unknown, expected: unknown, operator: string): AssertionError;
};


export type AssertionError = AssertionError$instance;

export interface BindOptions$instance {
    readonly __tsonic_type_nodejs_BindOptions: never;

    get address(): string | undefined;
    set address(value: string | undefined);
    exclusive: boolean;
    get fd(): Nullable_1<System_Internal.Int32>;
    set fd(value: Nullable_1<System_Internal.Int32> | int);
    get port(): Nullable_1<System_Internal.Int32>;
    set port(value: Nullable_1<System_Internal.Int32> | int);
}


export const BindOptions: {
    new(): BindOptions;
};


export type BindOptions = BindOptions$instance;

export interface BlockList$instance {
    readonly __tsonic_type_nodejs_BlockList: never;

    addAddress(address: string, type?: string): void;
    addRange(start: string, end: string, type?: string): void;
    addSubnet(network: string, prefix: int, type?: string): void;
    check(address: string, type?: string): boolean;
    getRules(): string[];
}


export const BlockList: {
    new(): BlockList;
};


export type BlockList = BlockList$instance;

export interface BrotliOptions$instance {
    readonly __tsonic_type_nodejs_BrotliOptions: never;

    get chunkSize(): Nullable_1<System_Internal.Int32>;
    set chunkSize(value: Nullable_1<System_Internal.Int32> | int);
    get maxOutputLength(): Nullable_1<System_Internal.Int32>;
    set maxOutputLength(value: Nullable_1<System_Internal.Int32> | int);
    get quality(): Nullable_1<System_Internal.Int32>;
    set quality(value: Nullable_1<System_Internal.Int32> | int);
}


export const BrotliOptions: {
    new(): BrotliOptions;
};


export type BrotliOptions = BrotliOptions$instance;

export interface Buffer$instance {
    readonly __tsonic_type_nodejs_Buffer: never;

    readonly length: int;
    compare(target: Buffer, targetStart?: Nullable_1<System_Internal.Int32>, targetEnd?: Nullable_1<System_Internal.Int32>, sourceStart?: Nullable_1<System_Internal.Int32>, sourceEnd?: Nullable_1<System_Internal.Int32>): int;
    copy(target: Buffer, targetStart?: int, sourceStart?: Nullable_1<System_Internal.Int32>, sourceEnd?: Nullable_1<System_Internal.Int32>): int;
    equals(otherBuffer: Buffer): boolean;
    fill(value: unknown, offset?: int, end?: Nullable_1<System_Internal.Int32>, encoding?: string): Buffer;
    includes(value: unknown, byteOffset?: int, encoding?: string): boolean;
    indexOf(value: unknown, byteOffset?: int, encoding?: string): int;
    lastIndexOf(value: unknown, byteOffset?: Nullable_1<System_Internal.Int32>, encoding?: string): int;
    readBigInt64BE(offset?: int): long;
    readBigInt64LE(offset?: int): long;
    readBigUint64BE(offset?: int): ulong;
    readBigUInt64BE(offset?: int): ulong;
    readBigUint64LE(offset?: int): ulong;
    readBigUInt64LE(offset?: int): ulong;
    readDoubleBE(offset?: int): double;
    readDoubleLE(offset?: int): double;
    readFloatBE(offset?: int): float;
    readFloatLE(offset?: int): float;
    readInt16BE(offset?: int): short;
    readInt16LE(offset?: int): short;
    readInt32BE(offset?: int): int;
    readInt32LE(offset?: int): int;
    readInt8(offset?: int): sbyte;
    readIntBE(offset: int, byteLength: int): long;
    readIntLE(offset: int, byteLength: int): long;
    readUint16BE(offset?: int): ushort;
    readUInt16BE(offset?: int): ushort;
    readUint16LE(offset?: int): ushort;
    readUInt16LE(offset?: int): ushort;
    readUint32BE(offset?: int): uint;
    readUInt32BE(offset?: int): uint;
    readUint32LE(offset?: int): uint;
    readUInt32LE(offset?: int): uint;
    readUint8(offset?: int): byte;
    readUInt8(offset?: int): byte;
    readUintBE(offset: int, byteLength: int): ulong;
    readUIntBE(offset: int, byteLength: int): ulong;
    readUintLE(offset: int, byteLength: int): ulong;
    readUIntLE(offset: int, byteLength: int): ulong;
    reverse(): Buffer;
    slice(start?: Nullable_1<System_Internal.Int32>, end?: Nullable_1<System_Internal.Int32>): Buffer;
    subarray(start?: Nullable_1<System_Internal.Int32>, end?: Nullable_1<System_Internal.Int32>): Buffer;
    swap16(): Buffer;
    swap32(): Buffer;
    swap64(): Buffer;
    toJSON(): unknown;
    toString(encoding?: string, start?: int, end?: Nullable_1<System_Internal.Int32>): string;
    write(str: string, offset?: int, length?: Nullable_1<System_Internal.Int32>, encoding?: string): int;
    writeBigInt64BE(value: long, offset?: int): int;
    writeBigInt64LE(value: long, offset?: int): int;
    writeBigUint64BE(value: ulong, offset?: int): int;
    writeBigUInt64BE(value: ulong, offset?: int): int;
    writeBigUint64LE(value: ulong, offset?: int): int;
    writeBigUInt64LE(value: ulong, offset?: int): int;
    writeDoubleBE(value: double, offset?: int): int;
    writeDoubleLE(value: double, offset?: int): int;
    writeFloatBE(value: float, offset?: int): int;
    writeFloatLE(value: float, offset?: int): int;
    writeInt16BE(value: short, offset?: int): int;
    writeInt16LE(value: short, offset?: int): int;
    writeInt32BE(value: int, offset?: int): int;
    writeInt32LE(value: int, offset?: int): int;
    writeInt8(value: sbyte, offset?: int): int;
    writeIntBE(value: long, offset: int, byteLength: int): int;
    writeIntLE(value: long, offset: int, byteLength: int): int;
    writeUint16BE(value: ushort, offset?: int): int;
    writeUInt16BE(value: ushort, offset?: int): int;
    writeUint16LE(value: ushort, offset?: int): int;
    writeUInt16LE(value: ushort, offset?: int): int;
    writeUint32BE(value: uint, offset?: int): int;
    writeUInt32BE(value: uint, offset?: int): int;
    writeUint32LE(value: uint, offset?: int): int;
    writeUInt32LE(value: uint, offset?: int): int;
    writeUint8(value: byte, offset?: int): int;
    writeUInt8(value: byte, offset?: int): int;
    writeUintBE(value: ulong, offset: int, byteLength: int): int;
    writeUIntBE(value: ulong, offset: int, byteLength: int): int;
    writeUintLE(value: ulong, offset: int, byteLength: int): int;
    writeUIntLE(value: ulong, offset: int, byteLength: int): int;
}


export const Buffer: {
    poolSize: int;
    alloc(size: int, fill?: unknown, encoding?: string): Buffer;
    allocUnsafe(size: int): Buffer;
    allocUnsafeSlow(size: int): Buffer;
    byteLength(str: string, encoding?: string): int;
    compare(buf1: Buffer, buf2: Buffer): int;
    concat(list: Buffer[], totalLength?: Nullable_1<System_Internal.Int32>): Buffer;
    from(buffer: Buffer): Buffer;
    from(array: byte[]): Buffer;
    from(array: int[]): Buffer;
    from(str: string, encoding?: string): Buffer;
    isBuffer(obj: unknown): boolean;
    isEncoding(encoding: string): boolean;
    of(...items: int[]): Buffer;
};


export type Buffer = Buffer$instance & { [index: number]: byte; };

export interface BufferConstants$instance {
    readonly __tsonic_type_nodejs_BufferConstants: never;

    readonly MAX_LENGTH: int;
    readonly MAX_STRING_LENGTH: int;
}


export const BufferConstants: {
    new(): BufferConstants;
};


export type BufferConstants = BufferConstants$instance;

export interface CaaRecord$instance {
    readonly __tsonic_type_nodejs_CaaRecord: never;

    get contactemail(): string | undefined;
    set contactemail(value: string | undefined);
    get contactphone(): string | undefined;
    set contactphone(value: string | undefined);
    critical: int;
    get iodef(): string | undefined;
    set iodef(value: string | undefined);
    get issue(): string | undefined;
    set issue(value: string | undefined);
    get issuewild(): string | undefined;
    set issuewild(value: string | undefined);
}


export const CaaRecord: {
    new(): CaaRecord;
};


export type CaaRecord = CaaRecord$instance;

export interface ChildProcess$instance extends EventEmitter {
    readonly __tsonic_type_nodejs_ChildProcess: never;

    connected: boolean;
    get exitCode(): Nullable_1<System_Internal.Int32>;
    set exitCode(value: Nullable_1<System_Internal.Int32> | int);
    readonly killed: boolean;
    readonly pid: int;
    referenced: boolean;
    get signalCode(): string | undefined;
    set signalCode(value: string | undefined);
    spawnargs: string[];
    spawnfile: string;
    get stderr(): Readable | undefined;
    set stderr(value: Readable | undefined);
    get stdin(): Writable | undefined;
    set stdin(value: Writable | undefined);
    get stdout(): Readable | undefined;
    set stdout(value: Readable | undefined);
    disconnect(): void;
    kill(signal?: string): boolean;
    ref(): void;
    send(message: unknown, sendHandle?: unknown, options?: unknown, callback?: Action_1<Exception>): boolean;
    unref(): void;
}


export const ChildProcess: {
};


export type ChildProcess = ChildProcess$instance;

export interface Cipher$instance extends Transform {
    readonly __tsonic_type_nodejs_Cipher: never;

    Dispose(): void;
    final(outputEncoding?: string): string;
    final(): byte[];
    Finalize(): void;
    getAuthTag(): byte[];
    setAAD(buffer: byte[]): void;
    setAuthTag(tagLength: int): void;
    update(data: string, inputEncoding?: string, outputEncoding?: string): string;
    update(data: byte[], outputEncoding?: string): string;
}


export const Cipher: {
};


export type Cipher = Cipher$instance;

export interface CipherNameAndProtocol$instance {
    readonly __tsonic_type_nodejs_CipherNameAndProtocol: never;

    name: string;
    standardName: string;
    version: string;
}


export const CipherNameAndProtocol: {
    new(): CipherNameAndProtocol;
};


export type CipherNameAndProtocol = CipherNameAndProtocol$instance;

export interface CommonConnectionOptions$instance {
    readonly __tsonic_type_nodejs_CommonConnectionOptions: never;

    get ALPNProtocols(): string[] | undefined;
    set ALPNProtocols(value: string[] | undefined);
    get enableTrace(): Nullable_1<System_Internal.Boolean>;
    set enableTrace(value: Nullable_1<System_Internal.Boolean> | boolean);
    get rejectUnauthorized(): Nullable_1<System_Internal.Boolean>;
    set rejectUnauthorized(value: Nullable_1<System_Internal.Boolean> | boolean);
    get requestCert(): Nullable_1<System_Internal.Boolean>;
    set requestCert(value: Nullable_1<System_Internal.Boolean> | boolean);
    get secureContext(): SecureContext | undefined;
    set secureContext(value: SecureContext | undefined);
}


export const CommonConnectionOptions: {
    new(): CommonConnectionOptions;
};


export type CommonConnectionOptions = CommonConnectionOptions$instance;

export interface ConnectionOptions$instance extends CommonConnectionOptions {
    readonly __tsonic_type_nodejs_ConnectionOptions: never;

    get ca(): unknown | undefined;
    set ca(value: unknown | undefined);
    get cert(): unknown | undefined;
    set cert(value: unknown | undefined);
    get host(): string | undefined;
    set host(value: string | undefined);
    get key(): unknown | undefined;
    set key(value: unknown | undefined);
    get passphrase(): string | undefined;
    set passphrase(value: string | undefined);
    get port(): Nullable_1<System_Internal.Int32>;
    set port(value: Nullable_1<System_Internal.Int32> | int);
    get servername(): string | undefined;
    set servername(value: string | undefined);
    get timeout(): Nullable_1<System_Internal.Int32>;
    set timeout(value: Nullable_1<System_Internal.Int32> | int);
}


export const ConnectionOptions: {
    new(): ConnectionOptions;
};


export type ConnectionOptions = ConnectionOptions$instance;

export interface ConsoleConstructor$instance {
    readonly __tsonic_type_nodejs_ConsoleConstructor: never;

    assert(value: boolean, message?: string, ...optionalParams: unknown[]): void;
    clear(): void;
    count(label?: string): void;
    countReset(label?: string): void;
    debug(message?: unknown, ...optionalParams: unknown[]): void;
    dir(obj: unknown, ...options: unknown[]): void;
    dirxml(...data: unknown[]): void;
    error(message?: unknown, ...optionalParams: unknown[]): void;
    group(...label: unknown[]): void;
    groupCollapsed(...label: unknown[]): void;
    groupEnd(): void;
    info(message?: unknown, ...optionalParams: unknown[]): void;
    log(message?: unknown, ...optionalParams: unknown[]): void;
    profile(label?: string): void;
    profileEnd(label?: string): void;
    table(tabularData: unknown, properties?: string[]): void;
    time(label?: string): void;
    timeEnd(label?: string): void;
    timeLog(label?: string, ...data: unknown[]): void;
    timeStamp(label?: string): void;
    trace(message?: unknown, ...optionalParams: unknown[]): void;
    warn(message?: unknown, ...optionalParams: unknown[]): void;
}


export const ConsoleConstructor: {
    new(stdout: unknown, stderr: unknown, ignoreErrors: boolean, colorMode: unknown, inspectOptions: Nullable_1<System_Internal.Int32>, groupIndentation: boolean): ConsoleConstructor;
};


export type ConsoleConstructor = ConsoleConstructor$instance;

export interface CpuInfo$instance {
    readonly __tsonic_type_nodejs_CpuInfo: never;

    model: string;
    speed: int;
    times: CpuTimes;
}


export const CpuInfo: {
    new(): CpuInfo;
};


export type CpuInfo = CpuInfo$instance;

export interface CpuTimes$instance {
    readonly __tsonic_type_nodejs_CpuTimes: never;

    idle: long;
    irq: long;
    nice: long;
    sys: long;
    user: long;
}


export const CpuTimes: {
    new(): CpuTimes;
};


export type CpuTimes = CpuTimes$instance;

export interface CursorPosition$instance {
    readonly __tsonic_type_nodejs_CursorPosition: never;

    cols: int;
    rows: int;
}


export const CursorPosition: {
    new(): CursorPosition;
};


export type CursorPosition = CursorPosition$instance;

export interface Decipher$instance extends Transform {
    readonly __tsonic_type_nodejs_Decipher: never;

    Dispose(): void;
    final(outputEncoding?: string): string;
    final(): byte[];
    Finalize(): void;
    setAAD(buffer: byte[]): void;
    setAuthTag(buffer: byte[]): void;
    update(data: string, inputEncoding?: string, outputEncoding?: string): string;
    update(data: byte[], outputEncoding?: string): string;
}


export const Decipher: {
};


export type Decipher = Decipher$instance;

export interface DetailedPeerCertificate$instance extends PeerCertificate {
    readonly __tsonic_type_nodejs_DetailedPeerCertificate: never;

    get issuerCertificate(): DetailedPeerCertificate | undefined;
    set issuerCertificate(value: DetailedPeerCertificate | undefined);
}


export const DetailedPeerCertificate: {
    new(): DetailedPeerCertificate;
};


export type DetailedPeerCertificate = DetailedPeerCertificate$instance;

export interface DgramSocket$instance extends EventEmitter {
    readonly __tsonic_type_nodejs_DgramSocket: never;

    addMembership(multicastAddress: string, multicastInterface?: string): void;
    address(): AddressInfo;
    addSourceSpecificMembership(sourceAddress: string, groupAddress: string, multicastInterface?: string): void;
    bind(port?: int, address?: string, callback?: Action): DgramSocket;
    bind(port: int, callback: Action): DgramSocket;
    bind(callback: Action): DgramSocket;
    bind(options: BindOptions, callback?: Action): DgramSocket;
    close(callback?: Action): DgramSocket;
    connect(port: int, address?: string, callback?: Action): void;
    connect(port: int, callback: Action): void;
    disconnect(): void;
    dropMembership(multicastAddress: string): void;
    dropSourceSpecificMembership(sourceAddress: string, groupAddress: string, multicastInterface?: string): void;
    getRecvBufferSize(): int;
    getSendBufferSize(): int;
    getSendQueueCount(): int;
    getSendQueueSize(): int;
    ref(): DgramSocket;
    remoteAddress(): AddressInfo;
    send(msg: byte[], port?: Nullable_1<System_Internal.Int32>, address?: string, callback?: Action_2<Exception, System_Internal.Int32>): void;
    send(msg: string, port?: Nullable_1<System_Internal.Int32>, address?: string, callback?: Action_2<Exception, System_Internal.Int32>): void;
    send(msg: byte[], port: int, callback: Action_2<Exception, System_Internal.Int32>): void;
    send(msg: string, port: int, callback: Action_2<Exception, System_Internal.Int32>): void;
    send(msg: byte[], callback: Action_2<Exception, System_Internal.Int32>): void;
    send(msg: string, callback: Action_2<Exception, System_Internal.Int32>): void;
    send(msg: byte[], offset: int, length: int, port?: Nullable_1<System_Internal.Int32>, address?: string, callback?: Action_2<Exception, System_Internal.Int32>): void;
    send(msg: byte[], offset: int, length: int, port: int, callback: Action_2<Exception, System_Internal.Int32>): void;
    send(msg: byte[], offset: int, length: int, callback: Action_2<Exception, System_Internal.Int32>): void;
    setBroadcast(flag: boolean): void;
    setMulticastInterface(multicastInterface: string): void;
    setMulticastLoopback(flag: boolean): boolean;
    setMulticastTTL(ttl: int): int;
    setRecvBufferSize(size: int): void;
    setSendBufferSize(size: int): void;
    setTTL(ttl: int): int;
    unref(): DgramSocket;
}


export const DgramSocket: {
};


export type DgramSocket = DgramSocket$instance;

export interface DiffieHellman$instance {
    readonly __tsonic_type_nodejs_DiffieHellman: never;

    readonly __tsonic_iface_System_IDisposable: never;

    computeSecret(otherPublicKey: string, inputEncoding?: string, outputEncoding?: string): string;
    computeSecret(otherPublicKey: byte[], outputEncoding?: string): string;
    computeSecret(otherPublicKey: byte[]): byte[];
    Dispose(): void;
    Dispose(disposing: boolean): void;
    generateKeys(encoding?: string): string;
    generateKeys(): byte[];
    getGenerator(encoding?: string): string;
    getGenerator(): byte[];
    getPrime(encoding?: string): string;
    getPrime(): byte[];
    getPrivateKey(encoding?: string): string;
    getPrivateKey(): byte[];
    getPublicKey(encoding?: string): string;
    getPublicKey(): byte[];
    getVerifyError(): int;
    setPrivateKey(privateKey: string, encoding?: string): void;
    setPrivateKey(privateKey: byte[]): void;
    setPublicKey(publicKey: string, encoding?: string): void;
    setPublicKey(publicKey: byte[]): void;
}


export const DiffieHellman: {
};


export type DiffieHellman = DiffieHellman$instance;

export interface DnsPromises$instance {
    readonly __tsonic_type_nodejs_DnsPromises: never;

    getDefaultResultOrder(): string;
    getServers(): string[];
    lookup(hostname: string, options?: LookupOptions): Task_1<LookupAddress>;
    lookupAll(hostname: string, options?: LookupOptions): Task_1<LookupAddress[]>;
    lookupService(address: string, port: int): Task_1<LookupServiceResult>;
    resolve(hostname: string): Task_1<string[]>;
    resolve(hostname: string, rrtype: string): Task_1<unknown>;
    resolve4(hostname: string): Task_1<string[]>;
    resolve4(hostname: string, options: ResolveOptions): Task_1<unknown>;
    resolve6(hostname: string): Task_1<string[]>;
    resolve6(hostname: string, options: ResolveOptions): Task_1<unknown>;
    resolveAny(hostname: string): Task_1<unknown[]>;
    resolveCaa(hostname: string): Task_1<CaaRecord[]>;
    resolveCname(hostname: string): Task_1<string[]>;
    resolveMx(hostname: string): Task_1<MxRecord[]>;
    resolveNaptr(hostname: string): Task_1<NaptrRecord[]>;
    resolveNs(hostname: string): Task_1<string[]>;
    resolvePtr(hostname: string): Task_1<string[]>;
    resolveSoa(hostname: string): Task_1<SoaRecord>;
    resolveSrv(hostname: string): Task_1<SrvRecord[]>;
    resolveTlsa(hostname: string): Task_1<TlsaRecord[]>;
    resolveTxt(hostname: string): Task_1<string[][]>;
    reverse(ip: string): Task_1<string[]>;
    setDefaultResultOrder(order: string): void;
    setServers(servers: string[]): void;
}


export const DnsPromises: {
    new(): DnsPromises;
};


export type DnsPromises = DnsPromises$instance;

export interface DSAPrivateKeyObject$instance extends KeyObject {
    readonly __tsonic_type_nodejs_DSAPrivateKeyObject: never;

    readonly __tsonic_iface_System_IDisposable: never;

    readonly asymmetricKeyType: string | undefined;
    readonly symmetricKeySize: Nullable_1<System_Internal.Int32>;
    readonly type: string;
    Dispose(): void;
    export(options?: unknown): unknown;
}


export const DSAPrivateKeyObject: {
};


export type DSAPrivateKeyObject = DSAPrivateKeyObject$instance;

export interface DSAPublicKeyObject$instance extends KeyObject {
    readonly __tsonic_type_nodejs_DSAPublicKeyObject: never;

    readonly __tsonic_iface_System_IDisposable: never;

    readonly asymmetricKeyType: string | undefined;
    readonly symmetricKeySize: Nullable_1<System_Internal.Int32>;
    readonly type: string;
    Dispose(): void;
    export(options?: unknown): unknown;
}


export const DSAPublicKeyObject: {
};


export type DSAPublicKeyObject = DSAPublicKeyObject$instance;

export interface Duplex$instance extends Readable {
    readonly __tsonic_type_nodejs_Duplex: never;

    readonly writable: boolean;
    readonly writableCorked: boolean;
    readonly writableEnded: boolean;
    readonly writableLength: int;
    _write(chunk: unknown, encoding: string, callback: Action): void;
    cork(): void;
    destroy(error?: Exception): void;
    end(chunk?: unknown, encoding?: string, callback?: Action): void;
    uncork(): void;
    write(chunk: unknown, encoding?: string, callback?: Action): boolean;
}


export const Duplex: {
    new(): Duplex;
};


export type Duplex = Duplex$instance;

export interface ECDH$instance {
    readonly __tsonic_type_nodejs_ECDH: never;

    readonly __tsonic_iface_System_IDisposable: never;

    computeSecret(otherPublicKey: string, inputEncoding?: string, outputEncoding?: string): string;
    computeSecret(otherPublicKey: byte[], outputEncoding?: string): string;
    computeSecret(otherPublicKey: byte[]): byte[];
    Dispose(): void;
    Dispose(disposing: boolean): void;
    generateKeys(encoding?: string, format?: string): string;
    generateKeys(): byte[];
    getPrivateKey(encoding?: string): string;
    getPrivateKey(): byte[];
    getPublicKey(encoding?: string, format?: string): string;
    getPublicKey(): byte[];
    setPrivateKey(privateKey: string, encoding?: string): void;
    setPrivateKey(privateKey: byte[]): void;
    setPublicKey(publicKey: string, encoding?: string): void;
    setPublicKey(publicKey: byte[]): void;
}


export const ECDH: {
};


export type ECDH = ECDH$instance;

export interface EdDSAPrivateKeyObject$instance extends KeyObject {
    readonly __tsonic_type_nodejs_EdDSAPrivateKeyObject: never;

    readonly __tsonic_iface_System_IDisposable: never;

    readonly asymmetricKeyType: string | undefined;
    readonly symmetricKeySize: Nullable_1<System_Internal.Int32>;
    readonly type: string;
    Dispose(): void;
    export(options?: unknown): unknown;
}


export const EdDSAPrivateKeyObject: {
};


export type EdDSAPrivateKeyObject = EdDSAPrivateKeyObject$instance;

export interface EdDSAPublicKeyObject$instance extends KeyObject {
    readonly __tsonic_type_nodejs_EdDSAPublicKeyObject: never;

    readonly __tsonic_iface_System_IDisposable: never;

    readonly asymmetricKeyType: string | undefined;
    readonly symmetricKeySize: Nullable_1<System_Internal.Int32>;
    readonly type: string;
    Dispose(): void;
    export(options?: unknown): unknown;
}


export const EdDSAPublicKeyObject: {
};


export type EdDSAPublicKeyObject = EdDSAPublicKeyObject$instance;

export interface EphemeralKeyInfo$instance {
    readonly __tsonic_type_nodejs_EphemeralKeyInfo: never;

    get name(): string | undefined;
    set name(value: string | undefined);
    size: int;
    type: string;
}


export const EphemeralKeyInfo: {
    new(): EphemeralKeyInfo;
};


export type EphemeralKeyInfo = EphemeralKeyInfo$instance;

export interface EventEmitter$instance {
    readonly __tsonic_type_nodejs_EventEmitter: never;

    addListener(eventName: string, listener: Function): EventEmitter;
    emit(eventName: string, ...args: unknown[]): boolean;
    eventNames(): string[];
    getMaxListeners(): int;
    listenerCount(eventName: string): int;
    listeners(eventName: string): Function[];
    off(eventName: string, listener: Function): EventEmitter;
    on(eventName: string, listener: Function): EventEmitter;
    once(eventName: string, listener: Function): EventEmitter;
    prependListener(eventName: string, listener: Function): EventEmitter;
    prependOnceListener(eventName: string, listener: Function): EventEmitter;
    rawListeners(eventName: string): Function[];
    removeAllListeners(eventName?: string): EventEmitter;
    removeListener(eventName: string, listener: Function): EventEmitter;
    setMaxListeners(n: int): EventEmitter;
}


export const EventEmitter: {
    new(): EventEmitter;
    defaultMaxListeners: int;
    once(emitter: EventEmitter, eventName: string): Task_1<(unknown | undefined)[]>;
};


export type EventEmitter = EventEmitter$instance;

export interface ExecOptions$instance {
    readonly __tsonic_type_nodejs_ExecOptions: never;

    get argv0(): string | undefined;
    set argv0(value: string | undefined);
    get cwd(): string | undefined;
    set cwd(value: string | undefined);
    detached: boolean;
    get encoding(): string | undefined;
    set encoding(value: string | undefined);
    get env(): unknown | undefined;
    set env(value: unknown | undefined);
    get gid(): Nullable_1<System_Internal.Int32>;
    set gid(value: Nullable_1<System_Internal.Int32> | int);
    get input(): string | undefined;
    set input(value: string | undefined);
    get killSignal(): string | undefined;
    set killSignal(value: string | undefined);
    maxBuffer: int;
    get shell(): string | undefined;
    set shell(value: string | undefined);
    get stdio(): string | undefined;
    set stdio(value: string | undefined);
    timeout: int;
    get uid(): Nullable_1<System_Internal.Int32>;
    set uid(value: Nullable_1<System_Internal.Int32> | int);
    windowsHide: boolean;
    windowsVerbatimArguments: boolean;
}


export const ExecOptions: {
    new(): ExecOptions;
};


export type ExecOptions = ExecOptions$instance;

export interface FsPromises$instance {
    readonly __tsonic_type_nodejs_FsPromises: never;

    access(path: string, mode?: int): Task;
    appendFile(path: string, data: string, encoding?: string): Task;
    chmod(path: string, mode: int): Task;
    close(fd: int): Task;
    copyFile(src: string, dest: string, mode?: int): Task;
    cp(src: string, dest: string, recursive?: boolean): Task;
    fstat(fd: int): Task_1<Stats>;
    mkdir(path: string, recursive?: boolean): Task;
    open(path: string, flags: string, mode?: Nullable_1<System_Internal.Int32>): Task_1<System_Internal.Int32>;
    read(fd: int, buffer: byte[], offset: int, length: int, position: Nullable_1<System_Internal.Int32>): Task_1<System_Internal.Int32>;
    readdir(path: string, withFileTypes?: boolean): Task_1<string[]>;
    readFile(path: string, encoding?: string): Task_1<System_Internal.String>;
    readFileBytes(path: string): Task_1<byte[]>;
    readlink(path: string): Task_1<System_Internal.String>;
    realpath(path: string): Task_1<System_Internal.String>;
    rename(oldPath: string, newPath: string): Task;
    rm(path: string, recursive?: boolean): Task;
    rmdir(path: string, recursive?: boolean): Task;
    stat(path: string): Task_1<Stats>;
    symlink(target: string, path: string, type?: string): Task;
    truncate(path: string, len?: long): Task;
    unlink(path: string): Task;
    write(fd: int, buffer: byte[], offset: int, length: int, position: Nullable_1<System_Internal.Int32>): Task_1<System_Internal.Int32>;
    write(fd: int, data: string, position?: Nullable_1<System_Internal.Int32>, encoding?: string): Task_1<System_Internal.Int32>;
    writeFile(path: string, data: string, encoding?: string): Task;
    writeFileBytes(path: string, data: byte[]): Task;
}


export const FsPromises: {
    new(): FsPromises;
};


export type FsPromises = FsPromises$instance;

export interface Hash$instance extends Transform {
    readonly __tsonic_type_nodejs_Hash: never;

    copy(): Hash;
    digest(encoding: string): string;
    digest(): byte[];
    digest(outputLength: int): byte[];
    Dispose(): void;
    Finalize(): void;
    update(data: string, inputEncoding?: string): Hash;
    update(data: byte[]): Hash;
}


export const Hash: {
};


export type Hash = Hash$instance;

export interface Hmac$instance extends Transform {
    readonly __tsonic_type_nodejs_Hmac: never;

    digest(encoding?: string): string;
    digest(): byte[];
    Dispose(): void;
    Finalize(): void;
    update(data: string, inputEncoding?: string): Hmac;
    update(data: byte[]): Hmac;
}


export const Hmac: {
};


export type Hmac = Hmac$instance;

export interface Immediate$instance {
    readonly __tsonic_type_nodejs_Immediate: never;

    readonly __tsonic_iface_System_IDisposable: never;

    Dispose(): void;
    hasRef(): boolean;
    ref(): Immediate;
    unref(): Immediate;
}


export const Immediate: {
};


export type Immediate = Immediate$instance;

export interface Interface$instance extends EventEmitter {
    readonly __tsonic_type_nodejs_Interface: never;

    readonly cursor: int;
    readonly line: string;
    close(): void;
    getCursorPos(): CursorPosition;
    getPrompt(): string;
    pause(): Interface;
    prompt(preserveCursor?: boolean): void;
    question(query: string, callback: Action_1<System_Internal.String>): void;
    questionAsync(query: string): Task_1<System_Internal.String>;
    resume(): Interface;
    setPrompt(prompt: string): void;
    write(data: unknown, key?: unknown): void;
}


export const Interface: {
};


export type Interface = Interface$instance;

export interface InterfaceOptions$instance {
    readonly __tsonic_type_nodejs_InterfaceOptions: never;

    get escapeCodeTimeout(): Nullable_1<System_Internal.Int32>;
    set escapeCodeTimeout(value: Nullable_1<System_Internal.Int32> | int);
    get history(): string[] | undefined;
    set history(value: string[] | undefined);
    get historySize(): Nullable_1<System_Internal.Int32>;
    set historySize(value: Nullable_1<System_Internal.Int32> | int);
    get input(): Readable | undefined;
    set input(value: Readable | undefined);
    get output(): Writable | undefined;
    set output(value: Writable | undefined);
    get prompt(): string | undefined;
    set prompt(value: string | undefined);
    get removeHistoryDuplicates(): Nullable_1<System_Internal.Boolean>;
    set removeHistoryDuplicates(value: Nullable_1<System_Internal.Boolean> | boolean);
    get tabSize(): Nullable_1<System_Internal.Int32>;
    set tabSize(value: Nullable_1<System_Internal.Int32> | int);
    get terminal(): Nullable_1<System_Internal.Boolean>;
    set terminal(value: Nullable_1<System_Internal.Boolean> | boolean);
}


export const InterfaceOptions: {
    new(): InterfaceOptions;
};


export type InterfaceOptions = InterfaceOptions$instance;

export interface IpcSocketConnectOpts$instance {
    readonly __tsonic_type_nodejs_IpcSocketConnectOpts: never;

    path: string;
}


export const IpcSocketConnectOpts: {
    new(): IpcSocketConnectOpts;
};


export type IpcSocketConnectOpts = IpcSocketConnectOpts$instance;

export interface KeyObject$instance {
    readonly __tsonic_type_nodejs_KeyObject: never;

    readonly __tsonic_iface_System_IDisposable: never;

    readonly asymmetricKeyType: string | undefined;
    readonly symmetricKeySize: Nullable_1<System_Internal.Int32>;
    readonly type: string;
    Dispose(): void;
    export(options?: unknown): unknown;
}


export const KeyObject: (abstract new() => KeyObject) & {
};


export type KeyObject = KeyObject$instance;

export interface ListenOptions$instance {
    readonly __tsonic_type_nodejs_ListenOptions: never;

    get backlog(): Nullable_1<System_Internal.Int32>;
    set backlog(value: Nullable_1<System_Internal.Int32> | int);
    get host(): string | undefined;
    set host(value: string | undefined);
    get ipv6Only(): Nullable_1<System_Internal.Boolean>;
    set ipv6Only(value: Nullable_1<System_Internal.Boolean> | boolean);
    get path(): string | undefined;
    set path(value: string | undefined);
    get port(): Nullable_1<System_Internal.Int32>;
    set port(value: Nullable_1<System_Internal.Int32> | int);
}


export const ListenOptions: {
    new(): ListenOptions;
};


export type ListenOptions = ListenOptions$instance;

export interface LookupAddress$instance {
    readonly __tsonic_type_nodejs_LookupAddress: never;

    address: string;
    family: int;
}


export const LookupAddress: {
    new(): LookupAddress;
};


export type LookupAddress = LookupAddress$instance;

export interface LookupOptions$instance {
    readonly __tsonic_type_nodejs_LookupOptions: never;

    get all(): Nullable_1<System_Internal.Boolean>;
    set all(value: Nullable_1<System_Internal.Boolean> | boolean);
    get family(): unknown | undefined;
    set family(value: unknown | undefined);
    get hints(): Nullable_1<System_Internal.Int32>;
    set hints(value: Nullable_1<System_Internal.Int32> | int);
    get order(): string | undefined;
    set order(value: string | undefined);
    get verbatim(): Nullable_1<System_Internal.Boolean>;
    set verbatim(value: Nullable_1<System_Internal.Boolean> | boolean);
}


export const LookupOptions: {
    new(): LookupOptions;
};


export type LookupOptions = LookupOptions$instance;

export interface LookupServiceResult$instance {
    readonly __tsonic_type_nodejs_LookupServiceResult: never;

    hostname: string;
    service: string;
}


export const LookupServiceResult: {
    new(): LookupServiceResult;
};


export type LookupServiceResult = LookupServiceResult$instance;

export interface MarkOptions$instance {
    readonly __tsonic_type_nodejs_MarkOptions: never;

    get detail(): unknown | undefined;
    set detail(value: unknown | undefined);
    get startTime(): Nullable_1<System_Internal.Double>;
    set startTime(value: Nullable_1<System_Internal.Double> | double);
}


export const MarkOptions: {
    new(): MarkOptions;
};


export type MarkOptions = MarkOptions$instance;

export interface MeasureOptions$instance {
    readonly __tsonic_type_nodejs_MeasureOptions: never;

    get detail(): unknown | undefined;
    set detail(value: unknown | undefined);
    get end(): Nullable_1<System_Internal.Double>;
    set end(value: Nullable_1<System_Internal.Double> | double);
    get endMark(): string | undefined;
    set endMark(value: string | undefined);
    get start(): Nullable_1<System_Internal.Double>;
    set start(value: Nullable_1<System_Internal.Double> | double);
    get startMark(): string | undefined;
    set startMark(value: string | undefined);
}


export const MeasureOptions: {
    new(): MeasureOptions;
};


export type MeasureOptions = MeasureOptions$instance;

export interface MxRecord$instance {
    readonly __tsonic_type_nodejs_MxRecord: never;

    exchange: string;
    priority: int;
}


export const MxRecord: {
    new(): MxRecord;
};


export type MxRecord = MxRecord$instance;

export interface NaptrRecord$instance {
    readonly __tsonic_type_nodejs_NaptrRecord: never;

    flags: string;
    order: int;
    preference: int;
    regexp: string;
    replacement: string;
    service: string;
}


export const NaptrRecord: {
    new(): NaptrRecord;
};


export type NaptrRecord = NaptrRecord$instance;

export interface ParsedPath$instance {
    readonly __tsonic_type_nodejs_ParsedPath: never;

    base: string;
    dir: string;
    ext: string;
    name: string;
    root: string;
}


export const ParsedPath: {
    new(): ParsedPath;
};


export type ParsedPath = ParsedPath$instance;

export interface PassThrough$instance extends Transform {
    readonly __tsonic_type_nodejs_PassThrough: never;

    _transform(chunk: unknown, encoding: string, callback: Action_2<Exception, unknown>): void;
}


export const PassThrough: {
    new(): PassThrough;
};


export type PassThrough = PassThrough$instance;

export interface PathModule$instance {
    readonly __tsonic_type_nodejs_PathModule: never;

    readonly delimiter: string;
    readonly posix: PathModule;
    readonly sep: string;
    readonly win32: PathModule;
    basename(path: string, suffix?: string): string;
    dirname(path: string): string;
    extname(path: string): string;
    format(pathObject: ParsedPath): string;
    isAbsolute(path: string): boolean;
    join(...paths: string[]): string;
    matchesGlob(path: string, pattern: string): boolean;
    normalize(path: string): string;
    parse(path: string): ParsedPath;
    relative(from: string, to: string): string;
    resolve(...paths: string[]): string;
    toNamespacedPath(path: string): string;
}


export const PathModule: {
    readonly Instance: PathModule;
};


export type PathModule = PathModule$instance;

export interface PeerCertificate$instance {
    readonly __tsonic_type_nodejs_PeerCertificate: never;

    ca: boolean;
    get ext_key_usage(): string[] | undefined;
    set ext_key_usage(value: string[] | undefined);
    fingerprint: string;
    fingerprint256: string;
    fingerprint512: string;
    issuer: TLSCertificateInfo;
    get raw(): byte[] | undefined;
    set raw(value: byte[] | undefined);
    serialNumber: string;
    subject: TLSCertificateInfo;
    get subjectaltname(): string | undefined;
    set subjectaltname(value: string | undefined);
    valid_from: string;
    valid_to: string;
}


export const PeerCertificate: {
    new(): PeerCertificate;
};


export type PeerCertificate = PeerCertificate$instance;

export interface PerformanceEntry$instance {
    readonly __tsonic_type_nodejs_PerformanceEntry: never;

    readonly duration: double;
    readonly entryType: string;
    readonly name: string;
    readonly startTime: double;
}


export const PerformanceEntry: {
};


export type PerformanceEntry = PerformanceEntry$instance;

export interface PerformanceMark$instance extends PerformanceEntry {
    readonly __tsonic_type_nodejs_PerformanceMark: never;

    readonly detail: unknown | undefined;
}


export const PerformanceMark: {
    new(name: string, startTime: double, detail: unknown): PerformanceMark;
};


export type PerformanceMark = PerformanceMark$instance;

export interface PerformanceMeasure$instance extends PerformanceEntry {
    readonly __tsonic_type_nodejs_PerformanceMeasure: never;

    readonly detail: unknown | undefined;
}


export const PerformanceMeasure: {
    new(name: string, startTime: double, duration: double, detail: unknown): PerformanceMeasure;
};


export type PerformanceMeasure = PerformanceMeasure$instance;

export interface PerformanceObserver$instance {
    readonly __tsonic_type_nodejs_PerformanceObserver: never;

    disconnect(): void;
    observe(options: PerformanceObserverOptions): void;
    takeRecords(): PerformanceObserverEntryList;
}


export const PerformanceObserver: {
    new(callback: Action_2<PerformanceObserverEntryList, PerformanceObserver>): PerformanceObserver;
    supportedEntryTypes(): string[];
};


export type PerformanceObserver = PerformanceObserver$instance;

export interface PerformanceObserverEntryList$instance {
    readonly __tsonic_type_nodejs_PerformanceObserverEntryList: never;

    getEntries(): PerformanceEntry[];
    getEntriesByName(name: string, type?: string): PerformanceEntry[];
    getEntriesByType(type: string): PerformanceEntry[];
}


export const PerformanceObserverEntryList: {
    new(entries: PerformanceEntry[]): PerformanceObserverEntryList;
};


export type PerformanceObserverEntryList = PerformanceObserverEntryList$instance;

export interface PerformanceObserverOptions$instance {
    readonly __tsonic_type_nodejs_PerformanceObserverOptions: never;

    buffered: boolean;
    get entryTypes(): string[] | undefined;
    set entryTypes(value: string[] | undefined);
}


export const PerformanceObserverOptions: {
    new(): PerformanceObserverOptions;
};


export type PerformanceObserverOptions = PerformanceObserverOptions$instance;

export interface PrivateKeyObject$instance extends KeyObject {
    readonly __tsonic_type_nodejs_PrivateKeyObject: never;

    readonly __tsonic_iface_System_IDisposable: never;

    readonly asymmetricKeyType: string | undefined;
    readonly symmetricKeySize: Nullable_1<System_Internal.Int32>;
    readonly type: string;
    Dispose(): void;
    export(options?: unknown): unknown;
    export(format: string, type?: string, cipher?: string, passphrase?: string): string;
}


export const PrivateKeyObject: {
};


export type PrivateKeyObject = PrivateKeyObject$instance;

export interface ProcessEnv$instance {
    readonly __tsonic_type_nodejs_ProcessEnv: never;

    readonly __tsonic_iface_System_Collections_Generic_ICollection_1: never;
    readonly __tsonic_iface_System_Collections_Generic_IDictionary_2: never;
    readonly __tsonic_iface_System_Collections_Generic_IEnumerable_1: never;
    readonly __tsonic_iface_System_Collections_IEnumerable: never;

    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly Keys: ICollection_1<System_Internal.String>;
    readonly Values: ICollection_1<string | undefined>;
    Add(key: string, value: string): void;
    Add(item: KeyValuePair_2<System_Internal.String, System_Internal.String>): void;
    Clear(): void;
    Contains(item: KeyValuePair_2<System_Internal.String, System_Internal.String>): boolean;
    ContainsKey(key: string): boolean;
    CopyTo(array: KeyValuePair_2<System_Internal.String, System_Internal.String>[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator_1<KeyValuePair_2<System_Internal.String, System_Internal.String>>;
    Remove(key: string): boolean;
    Remove(item: KeyValuePair_2<System_Internal.String, System_Internal.String>): boolean;
    TryGetValue(key: string, value: string): boolean;
}


export const ProcessEnv: {
    new(): ProcessEnv;
};


export type ProcessEnv = ProcessEnv$instance & { [key: string]: string | undefined; };

export interface ProcessVersions$instance {
    readonly __tsonic_type_nodejs_ProcessVersions: never;

    dotnet: string;
    node: string;
    tsonic: string;
    v8: string;
}


export const ProcessVersions: {
    new(): ProcessVersions;
};


export type ProcessVersions = ProcessVersions$instance;

export interface PublicKeyObject$instance extends KeyObject {
    readonly __tsonic_type_nodejs_PublicKeyObject: never;

    readonly __tsonic_iface_System_IDisposable: never;

    readonly asymmetricKeyType: string | undefined;
    readonly symmetricKeySize: Nullable_1<System_Internal.Int32>;
    readonly type: string;
    Dispose(): void;
    export(options?: unknown): unknown;
    export(format: string, type?: string): string;
}


export const PublicKeyObject: {
};


export type PublicKeyObject = PublicKeyObject$instance;

export interface Readable$instance extends Stream {
    readonly __tsonic_type_nodejs_Readable: never;

    destroyed: boolean;
    readonly readable: boolean;
    readonly readableEnded: boolean;
    readonly readableFlowing: Nullable_1<System_Internal.Boolean>;
    readonly readableLength: int;
    _read(size: int): void;
    destroy(error?: Exception): void;
    isPaused(): boolean;
    pause(): Readable;
    push(chunk: unknown, encoding?: string): boolean;
    read(size?: Nullable_1<System_Internal.Int32>): unknown | undefined;
    resume(): Readable;
    setEncoding(encoding: string): Readable;
    unpipe(destination?: Stream): Readable;
    unshift(chunk: unknown): void;
}


export const Readable: {
    new(): Readable;
};


export type Readable = Readable$instance;

export interface ReadlinePromises$instance {
    readonly __tsonic_type_nodejs_ReadlinePromises: never;

    createInterface(options: InterfaceOptions): Interface;
    createInterface(input: Readable, output?: Writable): Interface;
    question(rl: Interface, query: string): Task_1<System_Internal.String>;
}


export const ReadlinePromises: {
    new(): ReadlinePromises;
};


export type ReadlinePromises = ReadlinePromises$instance;

export interface RecordWithTtl$instance {
    readonly __tsonic_type_nodejs_RecordWithTtl: never;

    address: string;
    ttl: int;
}


export const RecordWithTtl: {
    new(): RecordWithTtl;
};


export type RecordWithTtl = RecordWithTtl$instance;

export interface RemoteInfo$instance {
    readonly __tsonic_type_nodejs_RemoteInfo: never;

    address: string;
    family: string;
    port: int;
    size: int;
}


export const RemoteInfo: {
    new(): RemoteInfo;
};


export type RemoteInfo = RemoteInfo$instance;

export interface ResolveOptions$instance {
    readonly __tsonic_type_nodejs_ResolveOptions: never;

    ttl: boolean;
}


export const ResolveOptions: {
    new(): ResolveOptions;
};


export type ResolveOptions = ResolveOptions$instance;

export interface Resolver$instance {
    readonly __tsonic_type_nodejs_Resolver: never;

    cancel(): void;
    getServers(): string[];
    resolve(hostname: string, callback: Action_2<Exception, string[]>): void;
    resolve(hostname: string, rrtype: string, callback: Action_2<Exception, unknown>): void;
    resolve4(hostname: string, callback: Action_2<Exception, string[]>): void;
    resolve4(hostname: string, options: ResolveOptions, callback: Action_2<Exception, unknown>): void;
    resolve6(hostname: string, callback: Action_2<Exception, string[]>): void;
    resolve6(hostname: string, options: ResolveOptions, callback: Action_2<Exception, unknown>): void;
    resolveAny(hostname: string, callback: Action_2<Exception, unknown[]>): void;
    resolveCaa(hostname: string, callback: Action_2<Exception, CaaRecord[]>): void;
    resolveCname(hostname: string, callback: Action_2<Exception, string[]>): void;
    resolveMx(hostname: string, callback: Action_2<Exception, MxRecord[]>): void;
    resolveNaptr(hostname: string, callback: Action_2<Exception, NaptrRecord[]>): void;
    resolveNs(hostname: string, callback: Action_2<Exception, string[]>): void;
    resolvePtr(hostname: string, callback: Action_2<Exception, string[]>): void;
    resolveSoa(hostname: string, callback: Action_2<Exception, SoaRecord>): void;
    resolveSrv(hostname: string, callback: Action_2<Exception, SrvRecord[]>): void;
    resolveTlsa(hostname: string, callback: Action_2<Exception, TlsaRecord[]>): void;
    resolveTxt(hostname: string, callback: Action_2<Exception, string[][]>): void;
    reverse(ip: string, callback: Action_2<Exception, string[]>): void;
    setLocalAddress(ipv4?: string, ipv6?: string): void;
    setServers(servers: string[]): void;
}


export const Resolver: {
    new(): Resolver;
    new(options: ResolverOptions): Resolver;
};


export type Resolver = Resolver$instance;

export interface ResolverOptions$instance {
    readonly __tsonic_type_nodejs_ResolverOptions: never;

    get maxTimeout(): Nullable_1<System_Internal.Int32>;
    set maxTimeout(value: Nullable_1<System_Internal.Int32> | int);
    get timeout(): Nullable_1<System_Internal.Int32>;
    set timeout(value: Nullable_1<System_Internal.Int32> | int);
    get tries(): Nullable_1<System_Internal.Int32>;
    set tries(value: Nullable_1<System_Internal.Int32> | int);
}


export const ResolverOptions: {
    new(): ResolverOptions;
};


export type ResolverOptions = ResolverOptions$instance;

export interface SecretKeyObject$instance extends KeyObject {
    readonly __tsonic_type_nodejs_SecretKeyObject: never;

    readonly __tsonic_iface_System_IDisposable: never;

    readonly asymmetricKeyType: string | undefined;
    readonly symmetricKeySize: Nullable_1<System_Internal.Int32>;
    readonly type: string;
    Dispose(): void;
    export(options?: unknown): unknown;
    export(): byte[];
}


export const SecretKeyObject: {
};


export type SecretKeyObject = SecretKeyObject$instance;

export interface SecureContext$instance {
    readonly __tsonic_type_nodejs_SecureContext: never;

    readonly CACertificates: X509Certificate2Collection | undefined;
    readonly Certificate: X509Certificate2 | undefined;
    get context(): unknown | undefined;
    set context(value: unknown | undefined);
    readonly Protocols: SslProtocols;
    LoadCACertificates(ca: unknown): void;
    LoadCertificate(cert: unknown, key: unknown, passphrase: string): void;
    SetProtocols(minVersion: string, maxVersion: string): void;
}


export const SecureContext: {
    new(): SecureContext;
};


export type SecureContext = SecureContext$instance;

export interface SecureContextOptions$instance {
    readonly __tsonic_type_nodejs_SecureContextOptions: never;

    get ca(): unknown | undefined;
    set ca(value: unknown | undefined);
    get cert(): unknown | undefined;
    set cert(value: unknown | undefined);
    get ciphers(): string | undefined;
    set ciphers(value: string | undefined);
    get key(): unknown | undefined;
    set key(value: unknown | undefined);
    get maxVersion(): string | undefined;
    set maxVersion(value: string | undefined);
    get minVersion(): string | undefined;
    set minVersion(value: string | undefined);
    get passphrase(): string | undefined;
    set passphrase(value: string | undefined);
    get pfx(): unknown | undefined;
    set pfx(value: unknown | undefined);
}


export const SecureContextOptions: {
    new(): SecureContextOptions;
};


export type SecureContextOptions = SecureContextOptions$instance;

export interface Server$instance extends EventEmitter {
    readonly __tsonic_type_nodejs_Server: never;

    readonly listening: boolean;
    maxConnections: int;
    address(): unknown | undefined;
    close(callback?: Action_1<Exception>): Server;
    getConnections(callback: Action_2<Exception, System_Internal.Int32>): void;
    listen(port: int, hostname: string, backlog: int, listeningListener?: Action): Server;
    listen(port: int, hostname: string, listeningListener?: Action): Server;
    listen(port: int, backlog: int, listeningListener?: Action): Server;
    listen(port: int, listeningListener?: Action): Server;
    listen(options: ListenOptions, listeningListener?: Action): Server;
    ref(): Server;
    unref(): Server;
}


export const Server: {
    new(): Server;
    new(connectionListener: Action_1<Socket>): Server;
    new(options: ServerOpts, connectionListener: Action_1<Socket>): Server;
};


export type Server = Server$instance;

export interface ServerOpts$instance {
    readonly __tsonic_type_nodejs_ServerOpts: never;

    get allowHalfOpen(): Nullable_1<System_Internal.Boolean>;
    set allowHalfOpen(value: Nullable_1<System_Internal.Boolean> | boolean);
    get pauseOnConnect(): Nullable_1<System_Internal.Boolean>;
    set pauseOnConnect(value: Nullable_1<System_Internal.Boolean> | boolean);
}


export const ServerOpts: {
    new(): ServerOpts;
};


export type ServerOpts = ServerOpts$instance;

export interface Sign$instance extends Transform {
    readonly __tsonic_type_nodejs_Sign: never;

    Dispose(): void;
    Finalize(): void;
    sign(privateKey: string, outputEncoding?: string): string;
    sign(privateKey: string): byte[];
    sign(privateKey: unknown, outputEncoding?: string): string;
    sign(privateKey: unknown): byte[];
    update(data: string, inputEncoding?: string): Sign;
    update(data: byte[]): Sign;
}


export const Sign: {
};


export type Sign = Sign$instance;

export interface SoaRecord$instance {
    readonly __tsonic_type_nodejs_SoaRecord: never;

    expire: int;
    hostmaster: string;
    minttl: int;
    nsname: string;
    refresh: int;
    retry: int;
    serial: int;
}


export const SoaRecord: {
    new(): SoaRecord;
};


export type SoaRecord = SoaRecord$instance;

export interface Socket$instance extends Stream {
    readonly __tsonic_type_nodejs_Socket: never;

    bytesRead: long;
    bytesWritten: long;
    readonly connecting: boolean;
    readonly destroyed: boolean;
    get localAddress(): string | undefined;
    set localAddress(value: string | undefined);
    get localFamily(): string | undefined;
    set localFamily(value: string | undefined);
    get localPort(): Nullable_1<System_Internal.Int32>;
    set localPort(value: Nullable_1<System_Internal.Int32> | int);
    readonly readyState: string;
    get remoteAddress(): string | undefined;
    set remoteAddress(value: string | undefined);
    get remoteFamily(): string | undefined;
    set remoteFamily(value: string | undefined);
    get remotePort(): Nullable_1<System_Internal.Int32>;
    set remotePort(value: Nullable_1<System_Internal.Int32> | int);
    address(): unknown;
    connect(port: int, host?: string, connectionListener?: Action): Socket;
    connect(options: TcpSocketConnectOpts, connectionListener?: Action): Socket;
    connect(path: string, connectionListener?: Action): Socket;
    destroy(error?: Exception): Socket;
    destroy(error?: Exception): void;
    destroySoon(): void;
    end(callback?: Action): Socket;
    end(data: byte[], callback?: Action): Socket;
    end(data: string, encoding?: string, callback?: Action): Socket;
    pause(): Socket;
    ref(): Socket;
    resetAndDestroy(): Socket;
    resume(): Socket;
    setEncoding(encoding?: string): Socket;
    setKeepAlive(enable?: boolean, initialDelay?: int): Socket;
    setNoDelay(noDelay?: boolean): Socket;
    setTimeout(timeout: int, callback?: Action): Socket;
    unref(): Socket;
    write(data: byte[], callback?: Action_1<Exception>): boolean;
    write(data: string, encoding?: string, callback?: Action_1<Exception>): boolean;
}


export const Socket: {
    new(): Socket;
    new(options: SocketConstructorOpts): Socket;
};


export type Socket = Socket$instance;

export interface SocketAddress$instance {
    readonly __tsonic_type_nodejs_SocketAddress: never;

    address: string;
    family: string;
    get flowlabel(): Nullable_1<System_Internal.Int32>;
    set flowlabel(value: Nullable_1<System_Internal.Int32> | int);
    port: int;
}


export const SocketAddress: {
    new(options: SocketAddressInitOptions): SocketAddress;
};


export type SocketAddress = SocketAddress$instance;

export interface SocketAddressInitOptions$instance {
    readonly __tsonic_type_nodejs_SocketAddressInitOptions: never;

    get address(): string | undefined;
    set address(value: string | undefined);
    get family(): string | undefined;
    set family(value: string | undefined);
    get flowlabel(): Nullable_1<System_Internal.Int32>;
    set flowlabel(value: Nullable_1<System_Internal.Int32> | int);
    get port(): Nullable_1<System_Internal.Int32>;
    set port(value: Nullable_1<System_Internal.Int32> | int);
}


export const SocketAddressInitOptions: {
    new(): SocketAddressInitOptions;
};


export type SocketAddressInitOptions = SocketAddressInitOptions$instance;

export interface SocketConstructorOpts$instance {
    readonly __tsonic_type_nodejs_SocketConstructorOpts: never;

    get allowHalfOpen(): Nullable_1<System_Internal.Boolean>;
    set allowHalfOpen(value: Nullable_1<System_Internal.Boolean> | boolean);
    get fd(): Nullable_1<System_Internal.Int32>;
    set fd(value: Nullable_1<System_Internal.Int32> | int);
    get readable(): Nullable_1<System_Internal.Boolean>;
    set readable(value: Nullable_1<System_Internal.Boolean> | boolean);
    get writable(): Nullable_1<System_Internal.Boolean>;
    set writable(value: Nullable_1<System_Internal.Boolean> | boolean);
}


export const SocketConstructorOpts: {
    new(): SocketConstructorOpts;
};


export type SocketConstructorOpts = SocketConstructorOpts$instance;

export interface SocketOptions$instance {
    readonly __tsonic_type_nodejs_SocketOptions: never;

    ipv6Only: boolean;
    get recvBufferSize(): Nullable_1<System_Internal.Int32>;
    set recvBufferSize(value: Nullable_1<System_Internal.Int32> | int);
    reuseAddr: boolean;
    reusePort: boolean;
    get sendBufferSize(): Nullable_1<System_Internal.Int32>;
    set sendBufferSize(value: Nullable_1<System_Internal.Int32> | int);
    type: string;
}


export const SocketOptions: {
    new(): SocketOptions;
};


export type SocketOptions = SocketOptions$instance;

export interface SpawnSyncReturns_1$instance<T> {
    readonly __tsonic_type_nodejs_SpawnSyncReturns_1: never;

    get error(): Exception | undefined;
    set error(value: Exception | undefined);
    output: (T | undefined)[];
    pid: int;
    get signal(): string | undefined;
    set signal(value: string | undefined);
    get status(): Nullable_1<System_Internal.Int32>;
    set status(value: Nullable_1<System_Internal.Int32> | int);
    stderr: T;
    stdout: T;
}


export const SpawnSyncReturns_1: {
    new<T>(): SpawnSyncReturns_1<T>;
};


export type SpawnSyncReturns_1<T> = SpawnSyncReturns_1$instance<T>;

export interface SrvRecord$instance {
    readonly __tsonic_type_nodejs_SrvRecord: never;

    name: string;
    port: int;
    priority: int;
    weight: int;
}


export const SrvRecord: {
    new(): SrvRecord;
};


export type SrvRecord = SrvRecord$instance;

export interface Stats$instance {
    readonly __tsonic_type_nodejs_Stats: never;

    atime: DateTime;
    birthtime: DateTime;
    ctime: DateTime;
    isDirectory: boolean;
    isFile: boolean;
    mode: int;
    mtime: DateTime;
    size: long;
    IsBlockDevice(): boolean;
    IsCharacterDevice(): boolean;
    IsDirectory(): boolean;
    IsFIFO(): boolean;
    IsFile(): boolean;
    IsSocket(): boolean;
    IsSymbolicLink(): boolean;
}


export const Stats: {
    new(): Stats;
};


export type Stats = Stats$instance;

export interface Stream$instance extends EventEmitter {
    readonly __tsonic_type_nodejs_Stream: never;

    destroy(error?: Exception): void;
    pipe(destination: Stream, end?: boolean): Stream;
}


export const Stream: {
    new(): Stream;
};


export type Stream = Stream$instance;

export interface StreamPromises$instance {
    readonly __tsonic_type_nodejs_StreamPromises: never;

    finished(streamValue: Stream): Task;
    pipeline(...streams: Stream[]): Task;
}


export const StreamPromises: {
    new(): StreamPromises;
};


export type StreamPromises = StreamPromises$instance;

export interface StringDecoder$instance {
    readonly __tsonic_type_nodejs_StringDecoder: never;

    end(buffer?: byte[]): string;
    write(buffer: byte[]): string;
}


export const StringDecoder: {
    new(encoding: string): StringDecoder;
};


export type StringDecoder = StringDecoder$instance;

export interface TcpSocketConnectOpts$instance {
    readonly __tsonic_type_nodejs_TcpSocketConnectOpts: never;

    get family(): Nullable_1<System_Internal.Int32>;
    set family(value: Nullable_1<System_Internal.Int32> | int);
    get hints(): Nullable_1<System_Internal.Int32>;
    set hints(value: Nullable_1<System_Internal.Int32> | int);
    get host(): string | undefined;
    set host(value: string | undefined);
    get keepAlive(): Nullable_1<System_Internal.Boolean>;
    set keepAlive(value: Nullable_1<System_Internal.Boolean> | boolean);
    get keepAliveInitialDelay(): Nullable_1<System_Internal.Int32>;
    set keepAliveInitialDelay(value: Nullable_1<System_Internal.Int32> | int);
    get localAddress(): string | undefined;
    set localAddress(value: string | undefined);
    get localPort(): Nullable_1<System_Internal.Int32>;
    set localPort(value: Nullable_1<System_Internal.Int32> | int);
    get noDelay(): Nullable_1<System_Internal.Boolean>;
    set noDelay(value: Nullable_1<System_Internal.Boolean> | boolean);
    port: int;
}


export const TcpSocketConnectOpts: {
    new(): TcpSocketConnectOpts;
};


export type TcpSocketConnectOpts = TcpSocketConnectOpts$instance;

export interface Timeout$instance {
    readonly __tsonic_type_nodejs_Timeout: never;

    readonly __tsonic_iface_System_IDisposable: never;

    close(): void;
    Dispose(): void;
    hasRef(): boolean;
    ref(): Timeout;
    refresh(): Timeout;
    unref(): Timeout;
}


export const Timeout: {
};


export type Timeout = Timeout$instance;

export interface TimersPromises$instance {
    readonly __tsonic_type_nodejs_TimersPromises: never;

    readonly scheduler: TimersScheduler;
    setImmediate(value?: unknown): Task_1<unknown | undefined>;
    setInterval(delay?: int, value?: unknown): IAsyncEnumerable_1<unknown | undefined>;
    setTimeout(delay?: int, value?: unknown): Task_1<unknown | undefined>;
}


export const TimersPromises: {
    new(): TimersPromises;
};


export type TimersPromises = TimersPromises$instance;

export interface TimersScheduler$instance {
    readonly __tsonic_type_nodejs_TimersScheduler: never;

    wait(delay?: int): Task;
    yield(): Task;
}


export const TimersScheduler: {
    new(): TimersScheduler;
};


export type TimersScheduler = TimersScheduler$instance;

export interface TlsaRecord$instance {
    readonly __tsonic_type_nodejs_TlsaRecord: never;

    certUsage: int;
    data: byte[];
    match: int;
    selector: int;
}


export const TlsaRecord: {
    new(): TlsaRecord;
};


export type TlsaRecord = TlsaRecord$instance;

export interface TLSCertificateInfo$instance {
    readonly __tsonic_type_nodejs_TLSCertificateInfo: never;

    C: string;
    CN: string;
    L: string;
    O: string;
    OU: string;
    ST: string;
}


export const TLSCertificateInfo: {
    new(): TLSCertificateInfo;
};


export type TLSCertificateInfo = TLSCertificateInfo$instance;

export interface TlsOptions$instance extends CommonConnectionOptions {
    readonly __tsonic_type_nodejs_TlsOptions: never;

    get allowHalfOpen(): Nullable_1<System_Internal.Boolean>;
    set allowHalfOpen(value: Nullable_1<System_Internal.Boolean> | boolean);
    get ca(): unknown | undefined;
    set ca(value: unknown | undefined);
    get cert(): unknown | undefined;
    set cert(value: unknown | undefined);
    get handshakeTimeout(): Nullable_1<System_Internal.Int32>;
    set handshakeTimeout(value: Nullable_1<System_Internal.Int32> | int);
    get key(): unknown | undefined;
    set key(value: unknown | undefined);
    get passphrase(): string | undefined;
    set passphrase(value: string | undefined);
    get pauseOnConnect(): Nullable_1<System_Internal.Boolean>;
    set pauseOnConnect(value: Nullable_1<System_Internal.Boolean> | boolean);
    get sessionTimeout(): Nullable_1<System_Internal.Int32>;
    set sessionTimeout(value: Nullable_1<System_Internal.Int32> | int);
}


export const TlsOptions: {
    new(): TlsOptions;
};


export type TlsOptions = TlsOptions$instance;

export interface TLSServer$instance extends Server {
    readonly __tsonic_type_nodejs_TLSServer: never;

    addContext(hostname: string, context: unknown): void;
    getTicketKeys(): byte[];
    setSecureContext(options: SecureContextOptions): void;
    setTicketKeys(keys: byte[]): void;
}


export const TLSServer: {
    new(): TLSServer;
    new(secureConnectionListener: Action_1<TLSSocket>): TLSServer;
    new(options: TlsOptions, secureConnectionListener: Action_1<TLSSocket>): TLSServer;
};


export type TLSServer = TLSServer$instance;

export interface TLSSocket$instance extends Socket {
    readonly __tsonic_type_nodejs_TLSSocket: never;

    readonly alpnProtocol: string | undefined;
    readonly authorizationError: Exception | undefined;
    readonly authorized: boolean;
    readonly encrypted: boolean;
    disableRenegotiation(): void;
    enableTrace(): void;
    exportKeyingMaterial(length: int, label: string, context: byte[]): byte[];
    getCertificate(): PeerCertificate | undefined;
    getCipher(): CipherNameAndProtocol;
    getEphemeralKeyInfo(): EphemeralKeyInfo | undefined;
    getFinished(): byte[] | undefined;
    getPeerCertificate(detailed?: boolean): PeerCertificate | undefined;
    getPeerFinished(): byte[] | undefined;
    getPeerX509Certificate(): unknown | undefined;
    getProtocol(): string | undefined;
    getSession(): byte[] | undefined;
    getSharedSigalgs(): string[];
    getTLSTicket(): byte[] | undefined;
    getX509Certificate(): unknown | undefined;
    isSessionReused(): boolean;
    renegotiate(options: unknown, callback: Action_1<Exception>): boolean;
    setKeyCert(context: unknown): void;
    setMaxSendFragment(size: int): boolean;
    write(data: byte[], callback?: Action_1<Exception>): boolean;
    write(data: string, encoding?: string, callback?: Action_1<Exception>): boolean;
}


export const TLSSocket: {
    new(socket: Socket, options: TLSSocketOptions): TLSSocket;
};


export type TLSSocket = TLSSocket$instance;

export interface TLSSocketOptions$instance extends CommonConnectionOptions {
    readonly __tsonic_type_nodejs_TLSSocketOptions: never;

    get ca(): unknown | undefined;
    set ca(value: unknown | undefined);
    get cert(): unknown | undefined;
    set cert(value: unknown | undefined);
    get isServer(): Nullable_1<System_Internal.Boolean>;
    set isServer(value: Nullable_1<System_Internal.Boolean> | boolean);
    get key(): unknown | undefined;
    set key(value: unknown | undefined);
    get passphrase(): string | undefined;
    set passphrase(value: string | undefined);
    get server(): Server | undefined;
    set server(value: Server | undefined);
    get servername(): string | undefined;
    set servername(value: string | undefined);
}


export const TLSSocketOptions: {
    new(): TLSSocketOptions;
};


export type TLSSocketOptions = TLSSocketOptions$instance;

export interface Transform$instance extends Duplex {
    readonly __tsonic_type_nodejs_Transform: never;

    _flush(callback: Action_1<Exception>): void;
    _transform(chunk: unknown, encoding: string, callback: Action_2<Exception, unknown>): void;
    _write(chunk: unknown, encoding: string, callback: Action): void;
}


export const Transform: {
    new(): Transform;
};


export type Transform = Transform$instance;

export interface URL$instance {
    readonly __tsonic_type_nodejs_URL: never;

    hash: string;
    host: string;
    hostname: string;
    href: string;
    readonly origin: string;
    password: string;
    pathname: string;
    port: string;
    protocol: string;
    search: string;
    readonly searchParams: URLSearchParams;
    username: string;
    toJSON(): string;
    ToString(): string;
}


export const URL: {
    new(input: string, base: string): URL;
    canParse(input: string, base?: string): boolean;
    parse(input: string, base?: string): URL | undefined;
};


export type URL = URL$instance;

export interface URLPattern$instance {
    readonly __tsonic_type_nodejs_URLPattern: never;

    exec(input: string): Dictionary_2<System_Internal.String, System_Internal.String> | undefined;
    test(input: string): boolean;
}


export const URLPattern: {
    new(pattern: string): URLPattern;
};


export type URLPattern = URLPattern$instance;

export interface URLSearchParams$instance {
    readonly __tsonic_type_nodejs_URLSearchParams: never;

    readonly size: int;
    append(name: string, value: string): void;
    delete(name: string, value?: string): void;
    entries(): IEnumerable_1<KeyValuePair_2<System_Internal.String, System_Internal.String>>;
    forEach(callback: Action_2<System_Internal.String, System_Internal.String>): void;
    get(name: string): string | undefined;
    getAll(name: string): string[];
    has(name: string, value?: string): boolean;
    keys(): IEnumerable_1<System_Internal.String>;
    set(name: string, value: string): void;
    sort(): void;
    ToString(): string;
    values(): IEnumerable_1<System_Internal.String>;
}


export const URLSearchParams: {
    new(init: string): URLSearchParams;
};


export type URLSearchParams = URLSearchParams$instance;

export interface UserInfo$instance {
    readonly __tsonic_type_nodejs_UserInfo: never;

    gid: int;
    homedir: string;
    get shell(): string | undefined;
    set shell(value: string | undefined);
    uid: int;
    username: string;
}


export const UserInfo: {
    new(): UserInfo;
};


export type UserInfo = UserInfo$instance;

export interface Verify$instance extends Transform {
    readonly __tsonic_type_nodejs_Verify: never;

    Dispose(): void;
    Finalize(): void;
    update(data: string, inputEncoding?: string): Verify;
    update(data: byte[]): Verify;
    verify(publicKey: string, signature: string, signatureEncoding?: string): boolean;
    verify(publicKey: string, signature: byte[]): boolean;
    verify(publicKey: unknown, signature: string, signatureEncoding?: string): boolean;
    verify(publicKey: unknown, signature: byte[]): boolean;
}


export const Verify: {
};


export type Verify = Verify$instance;

export interface Writable$instance extends Stream {
    readonly __tsonic_type_nodejs_Writable: never;

    destroyed: boolean;
    readonly writable: boolean;
    readonly writableCorked: boolean;
    readonly writableEnded: boolean;
    readonly writableLength: int;
    _final(callback: Action): void;
    _write(chunk: unknown, encoding: string, callback: Action): void;
    cork(): void;
    destroy(error?: Exception): void;
    end(chunk?: unknown, encoding?: string, callback?: Action): void;
    uncork(): void;
    write(chunk: unknown, encoding?: string, callback?: Action): boolean;
}


export const Writable: {
    new(): Writable;
};


export type Writable = Writable$instance;

export interface X509CertificateInfo$instance {
    readonly __tsonic_type_nodejs_X509CertificateInfo: never;

    readonly fingerprint: string;
    readonly fingerprint256: string;
    readonly fingerprint512: string;
    readonly issuer: string;
    readonly publicKey: byte[];
    readonly raw: byte[];
    readonly serialNumber: string;
    readonly subject: string;
    readonly validFrom: DateTime;
    readonly validTo: DateTime;
    checkEmail(email: string): string | undefined;
    checkHost(hostname: string): string | undefined;
    checkIP(ip: string): string | undefined;
    checkIssued(otherCert: X509CertificateInfo): string | undefined;
    toPEM(): string;
    ToString(): string;
    verify(issuerCert: X509CertificateInfo): boolean;
}


export const X509CertificateInfo: {
};


export type X509CertificateInfo = X509CertificateInfo$instance;

export interface ZlibOptions$instance {
    readonly __tsonic_type_nodejs_ZlibOptions: never;

    get chunkSize(): Nullable_1<System_Internal.Int32>;
    set chunkSize(value: Nullable_1<System_Internal.Int32> | int);
    get level(): Nullable_1<System_Internal.Int32>;
    set level(value: Nullable_1<System_Internal.Int32> | int);
    get maxOutputLength(): Nullable_1<System_Internal.Int32>;
    set maxOutputLength(value: Nullable_1<System_Internal.Int32> | int);
    get memLevel(): Nullable_1<System_Internal.Int32>;
    set memLevel(value: Nullable_1<System_Internal.Int32> | int);
    get strategy(): Nullable_1<System_Internal.Int32>;
    set strategy(value: Nullable_1<System_Internal.Int32> | int);
    get windowBits(): Nullable_1<System_Internal.Int32>;
    set windowBits(value: Nullable_1<System_Internal.Int32> | int);
}


export const ZlibOptions: {
    new(): ZlibOptions;
};


export type ZlibOptions = ZlibOptions$instance;

export abstract class assert$instance {
    static deepEqual(actual: unknown, expected: unknown, message?: string): void;
    static deepStrictEqual(actual: unknown, expected: unknown, message?: string): void;
    static doesNotMatch(string: string, regexp: Regex, message?: string): void;
    static doesNotReject(fn: Func_1<Task>, message?: string): Task;
    static doesNotThrow(fn: Action, message?: string): void;
    static equal(actual: unknown, expected: unknown, message?: string): void;
    static fail(message?: string): void;
    static ifError(value: unknown): void;
    static match(string: string, regexp: Regex, message?: string): void;
    static notDeepEqual(actual: unknown, expected: unknown, message?: string): void;
    static notDeepStrictEqual(actual: unknown, expected: unknown, message?: string): void;
    static notEqual(actual: unknown, expected: unknown, message?: string): void;
    static notStrictEqual(actual: unknown, expected: unknown, message?: string): void;
    static ok(value: boolean, message?: string): void;
    static rejects(fn: Func_1<Task>, message?: string): Task;
    static strict(actual: unknown, expected: unknown, message?: string): void;
    static strictEqual(actual: unknown, expected: unknown, message?: string): void;
    static throws(fn: Action, message?: string): void;
}


export type assert = assert$instance;

export abstract class buffer$instance {
    static INSPECT_MAX_BYTES: int;
    static readonly constants: BufferConstants;
    static readonly kMaxLength: int;
    static readonly kStringMaxLength: int;
    static atob(data: string): string;
    static btoa(data: string): string;
    static isAscii(value: Buffer): boolean;
    static isAscii(value: byte[]): boolean;
    static isUtf8(value: Buffer): boolean;
    static isUtf8(value: byte[]): boolean;
    static resolveObjectURL(id: string): unknown | undefined;
    static SlowBuffer(size: int): Buffer;
    static transcode(source: Buffer, fromEncoding: string, toEncoding: string): Buffer;
}


export type buffer = buffer$instance;

export abstract class Certificate$instance {
    static exportChallenge(spkac: byte[]): byte[];
    static exportChallenge(spkac: string): byte[];
    static exportPublicKey(spkac: byte[]): byte[];
    static exportPublicKey(spkac: string): byte[];
    static verifySpkac(spkac: byte[]): boolean;
    static verifySpkac(spkac: string): boolean;
}


export type Certificate = Certificate$instance;

export abstract class child_process$instance {
    static exec(command: string, options: ExecOptions, callback: Action_3<Exception, System_Internal.String, System_Internal.String>): void;
    static exec(command: string, callback: Action_3<Exception, System_Internal.String, System_Internal.String>): void;
    static execFile(file: string, args: string[], options: ExecOptions, callback: Action_3<Exception, System_Internal.String, System_Internal.String>): void;
    static execFileSync(file: string, args?: string[], options?: ExecOptions): unknown;
    static execSync(command: string, options: ExecOptions): unknown;
    static execSync(command: string): byte[];
    static fork(modulePath: string, args?: string[], options?: ExecOptions): ChildProcess;
    static spawn(command: string, args?: string[], options?: ExecOptions): ChildProcess;
    static spawnSync(command: string, args?: string[], options?: ExecOptions): SpawnSyncReturns_1<byte[]>;
    static spawnSyncString(command: string, args?: string[], options?: ExecOptions): SpawnSyncReturns_1<System_Internal.String>;
}


export type child_process = child_process$instance;

export abstract class console$instance {
    static readonly Console: ConsoleConstructor;
    static assert(value: boolean, message?: string, ...optionalParams: unknown[]): void;
    static clear(): void;
    static count(label?: string): void;
    static countReset(label?: string): void;
    static debug(message?: unknown, ...optionalParams: unknown[]): void;
    static dir(obj: unknown, ...options: unknown[]): void;
    static dirxml(...data: unknown[]): void;
    static error(message?: unknown, ...optionalParams: unknown[]): void;
    static group(...label: unknown[]): void;
    static groupCollapsed(...label: unknown[]): void;
    static groupEnd(): void;
    static info(message?: unknown, ...optionalParams: unknown[]): void;
    static log(message?: unknown, ...optionalParams: unknown[]): void;
    static profile(label?: string): void;
    static profileEnd(label?: string): void;
    static table(tabularData: unknown, properties?: string[]): void;
    static time(label?: string): void;
    static timeEnd(label?: string): void;
    static timeLog(label?: string, ...data: unknown[]): void;
    static timeStamp(label?: string): void;
    static trace(message?: unknown, ...optionalParams: unknown[]): void;
    static warn(message?: unknown, ...optionalParams: unknown[]): void;
}


export type console = console$instance;

export abstract class crypto$instance {
    static createCipheriv(algorithm: string, key: byte[], iv: byte[]): Cipher;
    static createCipheriv(algorithm: string, key: string, iv: string): Cipher;
    static createDecipheriv(algorithm: string, key: byte[], iv: byte[]): Decipher;
    static createDecipheriv(algorithm: string, key: string, iv: string): Decipher;
    static createDiffieHellman(prime: byte[], generator: byte[]): DiffieHellman;
    static createDiffieHellman(prime: byte[], generator?: int): DiffieHellman;
    static createDiffieHellman(primeLength: int, generator?: int): DiffieHellman;
    static createDiffieHellman(prime: string, primeEncoding: string, generator?: int): DiffieHellman;
    static createDiffieHellman(prime: string, primeEncoding: string, generator: string, generatorEncoding: string): DiffieHellman;
    static createECDH(curveName: string): ECDH;
    static createHash(algorithm: string): Hash;
    static createHmac(algorithm: string, key: byte[]): Hmac;
    static createHmac(algorithm: string, key: string): Hmac;
    static createPrivateKey(key: byte[]): KeyObject;
    static createPrivateKey(key: string): KeyObject;
    static createPublicKey(key: KeyObject): KeyObject;
    static createPublicKey(key: byte[]): KeyObject;
    static createPublicKey(key: string): KeyObject;
    static createSecretKey(key: byte[]): KeyObject;
    static createSecretKey(key: string, encoding?: string): KeyObject;
    static createSign(algorithm: string): Sign;
    static createVerify(algorithm: string): Verify;
    static generateKey(type: string, options: unknown, callback: Action_2<Exception, KeyObject>): void;
    static generateKey(type: string, options: unknown): KeyObject;
    static generateKeyPair(type: string, options: unknown, callback: Action_3<Exception, unknown, unknown>): void;
    static generateKeyPairSync(type: string, options?: unknown): ValueTuple_2<KeyObject, KeyObject>;
    static getCiphers(): string[];
    static getCurves(): string[];
    static getDefaultCipherList(): string;
    static getDiffieHellman(groupName: string): DiffieHellman;
    static getFips(): boolean;
    static getHashes(): string[];
    static hash(algorithm: string, data: byte[], outputEncoding?: string): byte[];
    static hkdf(digest: string, ikm: byte[], salt: byte[], info: byte[], keylen: int, callback: Action_2<Exception, byte[]>): void;
    static hkdfSync(digest: string, ikm: byte[], salt: byte[], info: byte[], keylen: int): byte[];
    static pbkdf2(password: string, salt: string, iterations: int, keylen: int, digest: string, callback: Action_2<Exception, byte[]>): void;
    static pbkdf2Sync(password: byte[], salt: byte[], iterations: int, keylen: int, digest: string): byte[];
    static pbkdf2Sync(password: string, salt: string, iterations: int, keylen: int, digest: string): byte[];
    static privateDecrypt(key: unknown, buffer: byte[]): byte[];
    static privateDecrypt(key: string, buffer: byte[]): byte[];
    static privateEncrypt(key: unknown, buffer: byte[]): byte[];
    static privateEncrypt(key: string, buffer: byte[]): byte[];
    static publicDecrypt(key: unknown, buffer: byte[]): byte[];
    static publicDecrypt(key: string, buffer: byte[]): byte[];
    static publicEncrypt(key: unknown, buffer: byte[]): byte[];
    static publicEncrypt(key: string, buffer: byte[]): byte[];
    static randomBytes(size: int, callback: Action_2<Exception, byte[]>): void;
    static randomBytes(size: int): byte[];
    static randomFill(buffer: byte[], offset: int, size: int, callback: Action_2<Exception, byte[]>): void;
    static randomFillSync(buffer: byte[], offset?: int, size?: Nullable_1<System_Internal.Int32>): byte[];
    static randomInt(min: int, max: int): int;
    static randomInt(max: int): int;
    static randomUUID(): string;
    static scrypt(password: string, salt: string, keylen: int, options: unknown, callback: Action_2<Exception, byte[]>): void;
    static scryptSync(password: byte[], salt: byte[], keylen: int, options?: unknown): byte[];
    static scryptSync(password: string, salt: string, keylen: int, options?: unknown): byte[];
    static setDefaultEncoding(encoding: string): void;
    static setFips(enabled: boolean): void;
    static sign(algorithm: string, data: byte[], privateKey: KeyObject): byte[];
    static sign(algorithm: string, data: byte[], privateKey: string): byte[];
    static timingSafeEqual(a: byte[], b: byte[]): boolean;
    static verify(algorithm: string, data: byte[], publicKey: KeyObject, signature: byte[]): boolean;
    static verify(algorithm: string, data: byte[], publicKey: string, signature: byte[]): boolean;
}


export type crypto = crypto$instance;

export abstract class dgram$instance {
    static createSocket(options: SocketOptions, callback?: Action_2<byte[], RemoteInfo>): DgramSocket;
    static createSocket(type: string, callback?: Action_2<byte[], RemoteInfo>): DgramSocket;
}


export type dgram = dgram$instance;

export abstract class dns$instance {
    static readonly ADDRCONFIG: int;
    static readonly V4MAPPED: int;
    static readonly ALL: int;
    static readonly NODATA: string;
    static readonly FORMERR: string;
    static readonly SERVFAIL: string;
    static readonly NOTFOUND: string;
    static readonly NOTIMP: string;
    static readonly REFUSED: string;
    static readonly BADQUERY: string;
    static readonly BADNAME: string;
    static readonly BADFAMILY: string;
    static readonly BADRESP: string;
    static readonly CONNREFUSED: string;
    static readonly TIMEOUT: string;
    static readonly EOF: string;
    static readonly FILE: string;
    static readonly NOMEM: string;
    static readonly DESTRUCTION: string;
    static readonly BADSTR: string;
    static readonly BADFLAGS: string;
    static readonly NONAME: string;
    static readonly BADHINTS: string;
    static readonly NOTINITIALIZED: string;
    static readonly LOADIPHLPAPI: string;
    static readonly ADDRGETNETWORKPARAMS: string;
    static readonly CANCELLED: string;
    static readonly promises: DnsPromises;
    static getDefaultResultOrder(): string;
    static getServers(): string[];
    static lookup(hostname: string, options: LookupOptions, callback: Action_2<Exception, LookupAddress[]>): void;
    static lookup(hostname: string, options: LookupOptions, callback: Action_3<Exception, System_Internal.String, System_Internal.Int32>): void;
    static lookup(hostname: string, callback: Action_3<Exception, System_Internal.String, System_Internal.Int32>): void;
    static lookup(hostname: string, family: int, callback: Action_3<Exception, System_Internal.String, System_Internal.Int32>): void;
    static lookupService(address: string, port: int, callback: Action_3<Exception, System_Internal.String, System_Internal.String>): void;
    static resolve(hostname: string, callback: Action_2<Exception, string[]>): void;
    static resolve(hostname: string, rrtype: string, callback: Action_2<Exception, unknown>): void;
    static resolve4(hostname: string, options: ResolveOptions, callback: Action_2<Exception, unknown>): void;
    static resolve4(hostname: string, callback: Action_2<Exception, string[]>): void;
    static resolve6(hostname: string, options: ResolveOptions, callback: Action_2<Exception, unknown>): void;
    static resolve6(hostname: string, callback: Action_2<Exception, string[]>): void;
    static resolveAny(hostname: string, callback: Action_2<Exception, unknown[]>): void;
    static resolveCaa(hostname: string, callback: Action_2<Exception, CaaRecord[]>): void;
    static resolveCname(hostname: string, callback: Action_2<Exception, string[]>): void;
    static resolveMx(hostname: string, callback: Action_2<Exception, MxRecord[]>): void;
    static resolveNaptr(hostname: string, callback: Action_2<Exception, NaptrRecord[]>): void;
    static resolveNs(hostname: string, callback: Action_2<Exception, string[]>): void;
    static resolvePtr(hostname: string, callback: Action_2<Exception, string[]>): void;
    static resolveSoa(hostname: string, callback: Action_2<Exception, SoaRecord>): void;
    static resolveSrv(hostname: string, callback: Action_2<Exception, SrvRecord[]>): void;
    static resolveTlsa(hostname: string, callback: Action_2<Exception, TlsaRecord[]>): void;
    static resolveTxt(hostname: string, callback: Action_2<Exception, string[][]>): void;
    static reverse(ip: string, callback: Action_2<Exception, string[]>): void;
    static setDefaultResultOrder(order: string): void;
    static setServers(servers: string[]): void;
}


export type dns = dns$instance;

export abstract class events$instance {
    static readonly captureRejectionSymbol: string;
    static captureRejections: boolean;
    static defaultMaxListeners: int;
    static readonly errorMonitor: string;
    static addAbortListener(signal: unknown, listener: Action): Action;
    static getEventListeners(emitter: EventEmitter, eventName: string): Function[];
    static getMaxListeners(emitter: EventEmitter): int;
    static listenerCount(emitter: EventEmitter, eventName: string): int;
    static on(emitter: EventEmitter, eventName: string): IAsyncEnumerable_1<(unknown | undefined)[]>;
    static once(emitter: EventEmitter, eventName: string): Task_1<(unknown | undefined)[]>;
    static setMaxListeners(n: int, ...emitters: EventEmitter[]): void;
}


export type events = events$instance;

export abstract class fs$instance {
    static readonly promises: FsPromises;
    static access(path: string, mode?: int): Task;
    static accessSync(path: string, mode?: int): void;
    static appendFile(path: string, data: string, encoding?: string): Task;
    static appendFileSync(path: string, data: string, encoding?: string): void;
    static chmod(path: string, mode: int): Task;
    static chmodSync(path: string, mode: int): void;
    static close(fd: int): Task;
    static closeSync(fd: int): void;
    static copyFile(src: string, dest: string, mode?: int): Task;
    static copyFileSync(src: string, dest: string, mode?: int): void;
    static cp(src: string, dest: string, recursive?: boolean): Task;
    static cpSync(src: string, dest: string, recursive?: boolean): void;
    static existsSync(path: string): boolean;
    static fstat(fd: int): Task_1<Stats>;
    static fstatSync(fd: int): Stats;
    static mkdir(path: string, recursive?: boolean): Task;
    static mkdirSync(path: string, recursive?: boolean): void;
    static open(path: string, flags: string, mode?: Nullable_1<System_Internal.Int32>): Task_1<System_Internal.Int32>;
    static openSync(path: string, flags: string, mode?: Nullable_1<System_Internal.Int32>): int;
    static read(fd: int, buffer: byte[], offset: int, length: int, position: Nullable_1<System_Internal.Int32>): Task_1<System_Internal.Int32>;
    static readdir(path: string, withFileTypes?: boolean): Task_1<string[]>;
    static readdirSync(path: string, withFileTypes?: boolean): string[];
    static readFile(path: string, encoding?: string): Task_1<System_Internal.String>;
    static readFileBytes(path: string): Task_1<byte[]>;
    static readFileSync(path: string, encoding?: string): string;
    static readFileSyncBytes(path: string): byte[];
    static readlink(path: string): Task_1<System_Internal.String>;
    static readlinkSync(path: string): string;
    static readSync(fd: int, buffer: byte[], offset: int, length: int, position: Nullable_1<System_Internal.Int32>): int;
    static realpath(path: string): Task_1<System_Internal.String>;
    static realpathSync(path: string): string;
    static rename(oldPath: string, newPath: string): Task;
    static renameSync(oldPath: string, newPath: string): void;
    static rm(path: string, recursive?: boolean): Task;
    static rmdir(path: string, recursive?: boolean): Task;
    static rmdirSync(path: string, recursive?: boolean): void;
    static rmSync(path: string, recursive?: boolean): void;
    static stat(path: string): Task_1<Stats>;
    static statSync(path: string): Stats;
    static symlink(target: string, path: string, type?: string): Task;
    static symlinkSync(target: string, path: string, type?: string): void;
    static truncate(path: string, len?: long): Task;
    static truncateSync(path: string, len?: long): void;
    static unlink(path: string): Task;
    static unlinkSync(path: string): void;
    static write(fd: int, buffer: byte[], offset: int, length: int, position: Nullable_1<System_Internal.Int32>): Task_1<System_Internal.Int32>;
    static write(fd: int, data: string, position?: Nullable_1<System_Internal.Int32>, encoding?: string): Task_1<System_Internal.Int32>;
    static writeFile(path: string, data: string, encoding?: string): Task;
    static writeFileBytes(path: string, data: byte[]): Task;
    static writeFileSync(path: string, data: string, encoding?: string): void;
    static writeFileSyncBytes(path: string, data: byte[]): void;
    static writeSync(fd: int, buffer: byte[], offset: int, length: int, position: Nullable_1<System_Internal.Int32>): int;
    static writeSync(fd: int, data: string, position?: Nullable_1<System_Internal.Int32>, encoding?: string): int;
}


export type fs = fs$instance;

export abstract class net$instance {
    static connect(options: TcpSocketConnectOpts, connectionListener?: Action): Socket;
    static connect(port: int, host?: string, connectionListener?: Action): Socket;
    static connect(path: string, connectionListener?: Action): Socket;
    static createConnection(options: TcpSocketConnectOpts, connectionListener?: Action): Socket;
    static createConnection(port: int, host?: string, connectionListener?: Action): Socket;
    static createConnection(path: string, connectionListener?: Action): Socket;
    static createServer(options: ServerOpts, connectionListener?: Action_1<Socket>): Server;
    static createServer(connectionListener?: Action_1<Socket>): Server;
    static getDefaultAutoSelectFamily(): boolean;
    static getDefaultAutoSelectFamilyAttemptTimeout(): int;
    static isIP(input: string): int;
    static isIPv4(input: string): boolean;
    static isIPv6(input: string): boolean;
    static setDefaultAutoSelectFamily(value: boolean): void;
    static setDefaultAutoSelectFamilyAttemptTimeout(value: int): void;
}


export type net = net$instance;

export abstract class os$instance {
    static readonly devNull: string;
    static readonly EOL: string;
    static arch(): string;
    static availableParallelism(): int;
    static cpus(): CpuInfo[];
    static endianness(): string;
    static freemem(): long;
    static homedir(): string;
    static hostname(): string;
    static loadavg(): double[];
    static machine(): string;
    static platform(): string;
    static release(): string;
    static tmpdir(): string;
    static totalmem(): long;
    static type(): string;
    static uptime(): long;
    static userInfo(): UserInfo;
    static version(): string;
}


export type os = os$instance;

export abstract class path$instance {
    static readonly sep: string;
    static readonly delimiter: string;
    static readonly posix: PathModule;
    static readonly win32: PathModule;
    static basename(path: string, suffix?: string): string;
    static dirname(path: string): string;
    static extname(path: string): string;
    static format(pathObject: ParsedPath): string;
    static isAbsolute(path: string): boolean;
    static join(...paths: string[]): string;
    static matchesGlob(path: string, pattern: string): boolean;
    static normalize(path: string): string;
    static parse(path: string): ParsedPath;
    static relative(from: string, to: string): string;
    static resolve(...paths: string[]): string;
    static toNamespacedPath(path: string): string;
}


export type path = path$instance;

export abstract class performance$instance {
    static clearMarks(name?: string): void;
    static clearMeasures(name?: string): void;
    static getEntries(): PerformanceEntry[];
    static getEntriesByName(name: string, type?: string): PerformanceEntry[];
    static getEntriesByType(type: string): PerformanceEntry[];
    static mark(name: string, options?: MarkOptions): PerformanceMark;
    static measure(name: string, startOrOptions?: unknown, endMark?: string): PerformanceMeasure;
    static now(): double;
}


export type performance = performance$instance;

export abstract class process$instance {
    static readonly arch: string;
    static argv: string[];
    static argv0: string;
    static readonly env: ProcessEnv;
    static readonly execPath: string;
    static get exitCode(): Nullable_1<System_Internal.Int32>;
    static set exitCode(value: Nullable_1<System_Internal.Int32> | int);
    static readonly pid: int;
    static readonly ppid: int;
    static readonly platform: string;
    static readonly version: string;
    static readonly versions: ProcessVersions;
    static chdir(directory: string): void;
    static cwd(): string;
    static exit(code?: Nullable_1<System_Internal.Int32>): void;
    static kill(pid: int, signal?: unknown): boolean;
}


export type process = process$instance;

export abstract class querystring$instance {
    static decode(str: string, sep?: string, eq?: string, maxKeys?: int): Dictionary_2<System_Internal.String, unknown>;
    static encode(obj: Dictionary_2<System_Internal.String, unknown>, sep?: string, eq?: string): string;
    static escape(str: string): string;
    static parse(str: string, sep?: string, eq?: string, maxKeys?: int): Dictionary_2<System_Internal.String, unknown>;
    static stringify(obj: Dictionary_2<System_Internal.String, unknown>, sep?: string, eq?: string): string;
    static unescape(str: string): string;
}


export type querystring = querystring$instance;

export abstract class readline$instance {
    static readonly promises: ReadlinePromises;
    static clearLine(stream: Writable, dir: int, callback?: Action): boolean;
    static clearScreenDown(stream: Writable, callback?: Action): boolean;
    static createAsyncIterator(input: Readable, options?: InterfaceOptions): IAsyncEnumerable_1<System_Internal.String>;
    static createInterface(options: InterfaceOptions): Interface;
    static createInterface(input: Readable, output?: Writable): Interface;
    static cursorTo(stream: Writable, x: int, y?: Nullable_1<System_Internal.Int32>, callback?: Action): boolean;
    static emitKeypressEvents(stream: Readable, rl?: Interface): void;
    static moveCursor(stream: Writable, dx: int, dy: int, callback?: Action): boolean;
}


export type readline = readline$instance;

export abstract class stream$instance {
    static readonly promises: StreamPromises;
    static finished(stream: Stream, callback: Action_1<Exception>): void;
    static finished(stream: Stream): Task;
    static pipeline(...streams: unknown[]): void;
}


export type stream = stream$instance;

export abstract class timers$instance {
    static readonly promises: TimersPromises;
    static clearImmediate(immediate: Immediate): void;
    static clearInterval(timeout: Timeout): void;
    static clearTimeout(timeout: Timeout): void;
    static queueMicrotask(callback: Action): void;
    static setImmediate(callback: Action): Immediate;
    static setInterval(callback: Action, delay?: int): Timeout;
    static setTimeout(callback: Action, delay?: int): Timeout;
}


export type timers = timers$instance;

export abstract class tls$instance {
    static readonly CLIENT_RENEG_LIMIT: int;
    static readonly CLIENT_RENEG_WINDOW: int;
    static DEFAULT_ECDH_CURVE: string;
    static DEFAULT_MAX_VERSION: string;
    static DEFAULT_MIN_VERSION: string;
    static DEFAULT_CIPHERS: string;
    static readonly rootCertificates: string[];
    static checkServerIdentity(hostname: string, cert: PeerCertificate): Exception | undefined;
    static connect(options: ConnectionOptions, secureConnectListener?: Action): TLSSocket;
    static connect(port: int, options?: ConnectionOptions, secureConnectListener?: Action): TLSSocket;
    static connect(port: int, host?: string, options?: ConnectionOptions, secureConnectListener?: Action): TLSSocket;
    static createSecureContext(options?: SecureContextOptions): SecureContext;
    static createServer(options: TlsOptions, secureConnectionListener?: Action_1<TLSSocket>): TLSServer;
    static createServer(secureConnectionListener?: Action_1<TLSSocket>): TLSServer;
    static getCACertificates(type?: string): string[];
    static getCiphers(): string[];
    static setDefaultCACertificates(certs: string[]): void;
}


export type tls = tls$instance;

export abstract class url$instance {
    static domainToASCII(domain: string): string;
    static domainToUnicode(domain: string): string;
    static fileURLToPath(fileUrl: URL): string;
    static fileURLToPath(fileUrl: string): string;
    static fileURLToPathBuffer(fileUrl: URL): Buffer;
    static fileURLToPathBuffer(fileUrl: string): Buffer;
    static format(input: unknown): string;
    static parse(input: string): URL | undefined;
    static pathToFileURL(filePath: string): URL;
    static resolve(from: string, to: string): string;
    static urlToHttpOptions(input: URL): Dictionary_2<System_Internal.String, unknown | undefined>;
}


export type url = url$instance;

export abstract class util$instance {
    static debuglog(section: string): DebugLogFunction;
    static deprecate<TResult>(fn: Func_1<TResult>, msg: string, code?: string): Func_1<TResult>;
    static deprecate(action: Action, msg: string, code?: string): Action;
    static format(format: unknown, ...args: unknown[]): string;
    static formatWithOptions(inspectOptions: unknown, formatValue: unknown, ...args: unknown[]): string;
    static inherits(constructor: unknown, superConstructor: unknown): void;
    static inspect(obj: unknown): string;
    static isArray(obj: unknown): boolean;
    static isDeepStrictEqual(val1: unknown, val2: unknown): boolean;
    static stripVTControlCharacters(input: string): string;
    static toUSVString(input: string): string;
}


export type util = util$instance;

export abstract class X509CertificateExtensions$instance {
    static ParseCertificate(certificate: byte[]): X509CertificateInfo;
    static ParseCertificate(certificate: string): X509CertificateInfo;
}


export type X509CertificateExtensions = X509CertificateExtensions$instance;

export abstract class zlib$instance {
    static brotliCompressSync(buffer: byte[], options?: BrotliOptions): byte[];
    static brotliDecompressSync(buffer: byte[], options?: BrotliOptions): byte[];
    static crc32(data: byte[], value?: uint): uint;
    static crc32(data: string, value?: uint): uint;
    static deflateRawSync(buffer: byte[], options?: ZlibOptions): byte[];
    static deflateSync(buffer: byte[], options?: ZlibOptions): byte[];
    static gunzipSync(buffer: byte[], options?: ZlibOptions): byte[];
    static gzipSync(buffer: byte[], options?: ZlibOptions): byte[];
    static inflateRawSync(buffer: byte[], options?: ZlibOptions): byte[];
    static inflateSync(buffer: byte[], options?: ZlibOptions): byte[];
    static unzipSync(buffer: byte[], options?: ZlibOptions): byte[];
}


export type zlib = zlib$instance;

