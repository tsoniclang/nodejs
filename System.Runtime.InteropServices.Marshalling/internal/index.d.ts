// Generated by tsbindgen - Architecture
// Namespace: System.Runtime.InteropServices.Marshalling
// Assembly: System.Private.CoreLib, System.Runtime.InteropServices

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { IFloatingPointIeee754_1, INumber_1 } from "../../System.Numerics/internal/index.js";
import * as System_Runtime_InteropServices_Internal from "../../System.Runtime.InteropServices/internal/index.js";
import type { ComWrappers, ComWrappers_ComInterfaceEntry, CreateComInterfaceFlags, CreateObjectFlags, IDynamicInterfaceCastable, SafeHandle, StringMarshalling, VarEnum } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Attribute, Boolean as ClrBoolean, Byte, Char, Enum, Exception, Guid, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, Object as ClrObject, ReadOnlySpan_1, RuntimeTypeHandle, Span_1, String as ClrString, Type, TypeCode, UInt16, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum ComInterfaceOptions {
    none = 0,
    managedObjectWrapper = 1,
    comObjectWrapper = 2
}


export enum MarshalMode {
    default_ = 0,
    managedToUnmanagedIn = 1,
    managedToUnmanagedRef = 2,
    managedToUnmanagedOut = 3,
    unmanagedToManagedIn = 4,
    unmanagedToManagedRef = 5,
    unmanagedToManagedOut = 6,
    elementIn = 7,
    elementRef = 8,
    elementOut = 9
}


export interface IComExposedClass$instance {
}


export type IComExposedClass = IComExposedClass$instance;

export interface IComExposedDetails$instance {
    getComInterfaceEntries(count: { value: ref<int> }): ptr<ComWrappers_ComInterfaceEntry>;
}


export type IComExposedDetails = IComExposedDetails$instance;

export interface IIUnknownCacheStrategy$instance {
    clear(unknownStrategy: IIUnknownStrategy): void;
    constructTableInfo(handle: RuntimeTypeHandle, interfaceDetails: IIUnknownDerivedDetails, ptr: ptr<void>): IIUnknownCacheStrategy_TableInfo;
    tryGetTableInfo(handle: RuntimeTypeHandle, info: { value: ref<IIUnknownCacheStrategy_TableInfo> }): boolean;
    trySetTableInfo(handle: RuntimeTypeHandle, info: IIUnknownCacheStrategy_TableInfo): boolean;
}


export type IIUnknownCacheStrategy = IIUnknownCacheStrategy$instance;

export interface IIUnknownDerivedDetails$instance {
    readonly iid: Guid;
    readonly implementation: Type;
    readonly managedVirtualMethodTable: ptr<void>;
}


export type IIUnknownDerivedDetails = IIUnknownDerivedDetails$instance;

export interface IIUnknownInterfaceDetailsStrategy$instance {
    getComExposedTypeDetails(type_: RuntimeTypeHandle): IComExposedDetails;
    getIUnknownDerivedDetails(type_: RuntimeTypeHandle): IIUnknownDerivedDetails;
}


export type IIUnknownInterfaceDetailsStrategy = IIUnknownInterfaceDetailsStrategy$instance;

export interface IIUnknownInterfaceType$instance {
}


export type IIUnknownInterfaceType = IIUnknownInterfaceType$instance;

export interface IIUnknownStrategy$instance {
    createInstancePointer(unknown_: ptr<void>): ptr<void>;
    queryInterface(instancePtr: ptr<void>, iid: { value: ref<Guid> }, ppObj: { value: ref<ptr<void>> }): int;
    release(instancePtr: ptr<void>): int;
}


export type IIUnknownStrategy = IIUnknownStrategy$instance;

export interface IUnmanagedVirtualMethodTableProvider$instance {
    getVirtualMethodTableInfoForKey(type_: Type): VirtualMethodTableInfo;
}


export type IUnmanagedVirtualMethodTableProvider = IUnmanagedVirtualMethodTableProvider$instance;

export interface AnsiStringMarshaller_ManagedToUnmanagedIn$instance {
    free(): void;
    fromManaged(managed: string, buffer: Span_1<CLROf<byte>>): void;
    toUnmanaged(): ptr<byte>;
}


export const AnsiStringMarshaller_ManagedToUnmanagedIn: {
    new(): AnsiStringMarshaller_ManagedToUnmanagedIn$instance;
    readonly bufferSize: int;
};


export type AnsiStringMarshaller_ManagedToUnmanagedIn = AnsiStringMarshaller_ManagedToUnmanagedIn$instance;

export interface ArrayMarshaller_2_ManagedToUnmanagedIn$instance<T, TUnmanagedElement extends unknown> {
    free(): void;
    fromManaged(array: T[], buffer: Span_1<TUnmanagedElement>): void;
    getManagedValuesSource(): ReadOnlySpan_1<T>;
    getPinnableReference(): ref<TUnmanagedElement>;
    getUnmanagedValuesDestination(): Span_1<TUnmanagedElement>;
    toUnmanaged(): ptr<TUnmanagedElement>;
}


export const ArrayMarshaller_2_ManagedToUnmanagedIn: {
    new<T, TUnmanagedElement extends unknown>(): ArrayMarshaller_2_ManagedToUnmanagedIn$instance<T, TUnmanagedElement>;
    readonly bufferSize: int;
    getPinnableReference<T, TUnmanagedElement extends unknown>(array: T[]): ref<T>;
};


export type ArrayMarshaller_2_ManagedToUnmanagedIn<T, TUnmanagedElement> = ArrayMarshaller_2_ManagedToUnmanagedIn$instance<T, TUnmanagedElement>;

export interface BStrStringMarshaller_ManagedToUnmanagedIn$instance {
    free(): void;
    fromManaged(managed: string, buffer: Span_1<CLROf<byte>>): void;
    toUnmanaged(): ptr<ushort>;
}


export const BStrStringMarshaller_ManagedToUnmanagedIn: {
    new(): BStrStringMarshaller_ManagedToUnmanagedIn$instance;
    readonly bufferSize: int;
};


export type BStrStringMarshaller_ManagedToUnmanagedIn = BStrStringMarshaller_ManagedToUnmanagedIn$instance;

export interface ComVariant$instance {
    readonly varType: VarEnum;
    as_<T>(): T;
    dispose(): void;
    getRawDataRef<T extends unknown>(): ref<T>;
}


export const ComVariant: {
    new(): ComVariant$instance;
    readonly null_: ComVariant;
    create<T>(value: T): ComVariant;
    createRaw<T extends unknown>(vt: VarEnum, rawValue: T): ComVariant;
};


export interface __ComVariant$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ComVariant$instance extends System_Internal.IDisposable$instance {}

export type ComVariant = ComVariant$instance & __ComVariant$views;


export interface ComVariantMarshaller_RefPropagate$instance {
    free(): void;
    fromManaged(managed: unknown): void;
    fromUnmanaged(unmanaged: ComVariant): void;
    toManaged(): unknown;
    toUnmanaged(): ComVariant;
}


export const ComVariantMarshaller_RefPropagate: {
    new(): ComVariantMarshaller_RefPropagate$instance;
};


export type ComVariantMarshaller_RefPropagate = ComVariantMarshaller_RefPropagate$instance;

export interface CustomMarshallerAttribute_GenericPlaceholder$instance {
}


export const CustomMarshallerAttribute_GenericPlaceholder: {
    new(): CustomMarshallerAttribute_GenericPlaceholder$instance;
};


export type CustomMarshallerAttribute_GenericPlaceholder = CustomMarshallerAttribute_GenericPlaceholder$instance;

export interface IIUnknownCacheStrategy_TableInfo$instance {
    managedType: RuntimeTypeHandle;
    table: ptr<void>;
    thisPtr: ptr<void>;
}


export const IIUnknownCacheStrategy_TableInfo: {
    new(): IIUnknownCacheStrategy_TableInfo$instance;
};


export type IIUnknownCacheStrategy_TableInfo = IIUnknownCacheStrategy_TableInfo$instance;

export interface PointerArrayMarshaller_2_ManagedToUnmanagedIn$instance<T extends unknown, TUnmanagedElement extends unknown> {
    free(): void;
    fromManaged(array: ptr<T>[], buffer: Span_1<TUnmanagedElement>): void;
    getManagedValuesSource(): ReadOnlySpan_1<CLROf<nint>>;
    getPinnableReference(): ref<TUnmanagedElement>;
    getUnmanagedValuesDestination(): Span_1<TUnmanagedElement>;
    toUnmanaged(): ptr<TUnmanagedElement>;
}


export const PointerArrayMarshaller_2_ManagedToUnmanagedIn: {
    new<T extends unknown, TUnmanagedElement extends unknown>(): PointerArrayMarshaller_2_ManagedToUnmanagedIn$instance<T, TUnmanagedElement>;
    readonly bufferSize: int;
    getPinnableReference<T extends unknown, TUnmanagedElement extends unknown>(array: ptr<T>[]): ref<byte>;
};


export type PointerArrayMarshaller_2_ManagedToUnmanagedIn<T, TUnmanagedElement> = PointerArrayMarshaller_2_ManagedToUnmanagedIn$instance<T, TUnmanagedElement>;

export interface ReadOnlySpanMarshaller_2_ManagedToUnmanagedIn$instance<T, TUnmanagedElement extends unknown> {
    free(): void;
    fromManaged(managed: ReadOnlySpan_1<T>, buffer: Span_1<TUnmanagedElement>): void;
    getManagedValuesSource(): ReadOnlySpan_1<T>;
    getPinnableReference(): ref<TUnmanagedElement>;
    getUnmanagedValuesDestination(): Span_1<TUnmanagedElement>;
    toUnmanaged(): ptr<TUnmanagedElement>;
}


export const ReadOnlySpanMarshaller_2_ManagedToUnmanagedIn: {
    new<T, TUnmanagedElement extends unknown>(): ReadOnlySpanMarshaller_2_ManagedToUnmanagedIn$instance<T, TUnmanagedElement>;
    readonly bufferSize: int;
    getPinnableReference<T, TUnmanagedElement extends unknown>(managed: ReadOnlySpan_1<T>): ref<T>;
};


export type ReadOnlySpanMarshaller_2_ManagedToUnmanagedIn<T, TUnmanagedElement> = ReadOnlySpanMarshaller_2_ManagedToUnmanagedIn$instance<T, TUnmanagedElement>;

export interface ReadOnlySpanMarshaller_2_ManagedToUnmanagedOut$instance<T, TUnmanagedElement extends unknown> {
    free(): void;
    fromUnmanaged(unmanaged: ptr<TUnmanagedElement>): void;
    getManagedValuesDestination(numElements: int): Span_1<T>;
    getUnmanagedValuesSource(numElements: int): ReadOnlySpan_1<TUnmanagedElement>;
    toManaged(): ReadOnlySpan_1<T>;
}


export const ReadOnlySpanMarshaller_2_ManagedToUnmanagedOut: {
    new<T, TUnmanagedElement extends unknown>(): ReadOnlySpanMarshaller_2_ManagedToUnmanagedOut$instance<T, TUnmanagedElement>;
};


export type ReadOnlySpanMarshaller_2_ManagedToUnmanagedOut<T, TUnmanagedElement> = ReadOnlySpanMarshaller_2_ManagedToUnmanagedOut$instance<T, TUnmanagedElement>;

export interface SafeHandleMarshaller_1_ManagedToUnmanagedIn$instance<T extends SafeHandle> {
    free(): void;
    fromManaged(handle: T): void;
    toUnmanaged(): nint;
}


export const SafeHandleMarshaller_1_ManagedToUnmanagedIn: {
    new<T extends SafeHandle>(): SafeHandleMarshaller_1_ManagedToUnmanagedIn$instance<T>;
};


export type SafeHandleMarshaller_1_ManagedToUnmanagedIn<T extends SafeHandle> = SafeHandleMarshaller_1_ManagedToUnmanagedIn$instance<T>;

export interface SafeHandleMarshaller_1_ManagedToUnmanagedOut$instance<T extends SafeHandle> {
    free(): void;
    fromUnmanaged(value: nint): void;
    toManaged(): T;
}


export const SafeHandleMarshaller_1_ManagedToUnmanagedOut: {
    new<T extends SafeHandle>(): SafeHandleMarshaller_1_ManagedToUnmanagedOut$instance<T>;
};


export type SafeHandleMarshaller_1_ManagedToUnmanagedOut<T extends SafeHandle> = SafeHandleMarshaller_1_ManagedToUnmanagedOut$instance<T>;

export interface SafeHandleMarshaller_1_ManagedToUnmanagedRef$instance<T extends SafeHandle> {
    free(): void;
    fromManaged(handle: T): void;
    fromUnmanaged(value: nint): void;
    onInvoked(): void;
    toManagedFinally(): T;
    toUnmanaged(): nint;
}


export const SafeHandleMarshaller_1_ManagedToUnmanagedRef: {
    new<T extends SafeHandle>(): SafeHandleMarshaller_1_ManagedToUnmanagedRef$instance<T>;
};


export type SafeHandleMarshaller_1_ManagedToUnmanagedRef<T extends SafeHandle> = SafeHandleMarshaller_1_ManagedToUnmanagedRef$instance<T>;

export interface SpanMarshaller_2_ManagedToUnmanagedIn$instance<T, TUnmanagedElement extends unknown> {
    free(): void;
    fromManaged(managed: Span_1<T>, buffer: Span_1<TUnmanagedElement>): void;
    getManagedValuesSource(): ReadOnlySpan_1<T>;
    getPinnableReference(): ref<TUnmanagedElement>;
    getUnmanagedValuesDestination(): Span_1<TUnmanagedElement>;
    toUnmanaged(): ptr<TUnmanagedElement>;
}


export const SpanMarshaller_2_ManagedToUnmanagedIn: {
    new<T, TUnmanagedElement extends unknown>(): SpanMarshaller_2_ManagedToUnmanagedIn$instance<T, TUnmanagedElement>;
    readonly bufferSize: int;
    getPinnableReference<T, TUnmanagedElement extends unknown>(managed: Span_1<T>): ref<T>;
};


export type SpanMarshaller_2_ManagedToUnmanagedIn<T, TUnmanagedElement> = SpanMarshaller_2_ManagedToUnmanagedIn$instance<T, TUnmanagedElement>;

export interface Utf8StringMarshaller_ManagedToUnmanagedIn$instance {
    free(): void;
    fromManaged(managed: string, buffer: Span_1<CLROf<byte>>): void;
    toUnmanaged(): ptr<byte>;
}


export const Utf8StringMarshaller_ManagedToUnmanagedIn: {
    new(): Utf8StringMarshaller_ManagedToUnmanagedIn$instance;
    readonly bufferSize: int;
};


export type Utf8StringMarshaller_ManagedToUnmanagedIn = Utf8StringMarshaller_ManagedToUnmanagedIn$instance;

export interface VirtualMethodTableInfo$instance {
    readonly thisPointer: ptr<void>;
    readonly virtualMethodTable: ptr<void>;
    deconstruct(thisPointer: { value: ref<ptr<void>> }, virtualMethodTable: { value: ref<ptr<void>> }): void;
}


export const VirtualMethodTableInfo: {
    new(thisPointer: ptr<void>, virtualMethodTable: ptr<void>): VirtualMethodTableInfo$instance;
};


export type VirtualMethodTableInfo = VirtualMethodTableInfo$instance;

export interface ComExposedClassAttribute_1$instance<T extends IComExposedClass> extends Attribute {
    getComInterfaceEntries(count: { value: ref<int> }): ptr<ComWrappers_ComInterfaceEntry>;
}


export const ComExposedClassAttribute_1: {
    new<T extends IComExposedClass>(): ComExposedClassAttribute_1$instance<T>;
};


export interface __ComExposedClassAttribute_1$views<T extends IComExposedClass> {
    As_IComExposedDetails(): IComExposedDetails$instance;
}

export interface ComExposedClassAttribute_1$instance<T extends IComExposedClass> extends IComExposedDetails$instance {}

export type ComExposedClassAttribute_1<T extends IComExposedClass> = ComExposedClassAttribute_1$instance<T> & __ComExposedClassAttribute_1$views<T>;


export interface ComObject$instance {
    finalRelease(): void;
}


export const ComObject: {
    new(): ComObject$instance;
};


export interface __ComObject$views {
    As_IDynamicInterfaceCastable(): System_Runtime_InteropServices_Internal.IDynamicInterfaceCastable$instance;
    As_IUnmanagedVirtualMethodTableProvider(): IUnmanagedVirtualMethodTableProvider$instance;
}

export interface ComObject$instance extends System_Runtime_InteropServices_Internal.IDynamicInterfaceCastable$instance, IUnmanagedVirtualMethodTableProvider$instance {}

export type ComObject = ComObject$instance & __ComObject$views;


export interface ContiguousCollectionMarshallerAttribute$instance extends Attribute {
}


export const ContiguousCollectionMarshallerAttribute: {
    new(): ContiguousCollectionMarshallerAttribute$instance;
};


export type ContiguousCollectionMarshallerAttribute = ContiguousCollectionMarshallerAttribute$instance;

export interface CustomMarshallerAttribute$instance extends Attribute {
    readonly managedType: Type;
    readonly marshallerType: Type;
    readonly marshalMode: MarshalMode;
}


export const CustomMarshallerAttribute: {
    new(managedType: Type, marshalMode: MarshalMode, marshallerType: Type): CustomMarshallerAttribute$instance;
};


export type CustomMarshallerAttribute = CustomMarshallerAttribute$instance;

export interface GeneratedComClassAttribute$instance extends Attribute {
}


export const GeneratedComClassAttribute: {
    new(): GeneratedComClassAttribute$instance;
};


export type GeneratedComClassAttribute = GeneratedComClassAttribute$instance;

export interface GeneratedComInterfaceAttribute$instance extends Attribute {
    exceptionToUnmanagedMarshaller: Type;
    options: ComInterfaceOptions;
    stringMarshalling: StringMarshalling;
    stringMarshallingCustomType: Type;
}


export const GeneratedComInterfaceAttribute: {
    new(): GeneratedComInterfaceAttribute$instance;
};


export type GeneratedComInterfaceAttribute = GeneratedComInterfaceAttribute$instance;

export interface IUnknownDerivedAttribute_2$instance<T extends IIUnknownInterfaceType, TImpl> extends Attribute {
    readonly iid: Guid;
    readonly implementation: Type;
    readonly managedVirtualMethodTable: ptr<void>;
}


export const IUnknownDerivedAttribute_2: {
    new<T extends IIUnknownInterfaceType, TImpl>(): IUnknownDerivedAttribute_2$instance<T, TImpl>;
};


export interface __IUnknownDerivedAttribute_2$views<T extends IIUnknownInterfaceType, TImpl> {
    As_IIUnknownDerivedDetails(): IIUnknownDerivedDetails$instance;
}

export interface IUnknownDerivedAttribute_2$instance<T extends IIUnknownInterfaceType, TImpl> extends IIUnknownDerivedDetails$instance {}

export type IUnknownDerivedAttribute_2<T extends IIUnknownInterfaceType, TImpl> = IUnknownDerivedAttribute_2$instance<T, TImpl> & __IUnknownDerivedAttribute_2$views<T, TImpl>;


export interface MarshalUsingAttribute$instance extends Attribute {
    constantElementCount: int;
    countElementName: string;
    elementIndirectionDepth: int;
    readonly nativeType: Type;
}


export const MarshalUsingAttribute: {
    new(): MarshalUsingAttribute$instance;
    new(nativeType: Type): MarshalUsingAttribute$instance;
    readonly returnsCountValue: string;
};


export type MarshalUsingAttribute = MarshalUsingAttribute$instance;

export interface NativeMarshallingAttribute$instance extends Attribute {
    readonly nativeType: Type;
}


export const NativeMarshallingAttribute: {
    new(nativeType: Type): NativeMarshallingAttribute$instance;
};


export type NativeMarshallingAttribute = NativeMarshallingAttribute$instance;

export interface StrategyBasedComWrappers$instance extends ComWrappers {
}


export const StrategyBasedComWrappers: {
    new(): StrategyBasedComWrappers$instance;
    readonly defaultIUnknownInterfaceDetailsStrategy: IIUnknownInterfaceDetailsStrategy;
    readonly defaultIUnknownStrategy: IIUnknownStrategy;
};


export type StrategyBasedComWrappers = StrategyBasedComWrappers$instance;

export abstract class AnsiStringMarshaller$instance {
    static convertToManaged(unmanaged: ptr<byte>): string;
    static convertToUnmanaged(managed: string): ptr<byte>;
    static free(unmanaged: ptr<byte>): void;
}


export type AnsiStringMarshaller = AnsiStringMarshaller$instance;

export abstract class ArrayMarshaller_2$instance {
    static allocateContainerForManagedElements<T, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>, numElements: int): T[];
    static allocateContainerForUnmanagedElements<T, TUnmanagedElement extends unknown>(managed: T[], numElements: { value: ref<int> }): ptr<TUnmanagedElement>;
    static free<T, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>): void;
    static getManagedValuesDestination<T, TUnmanagedElement extends unknown>(managed: T[]): Span_1<T>;
    static getManagedValuesSource<T, TUnmanagedElement extends unknown>(managed: T[]): ReadOnlySpan_1<T>;
    static getUnmanagedValuesDestination<T, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>, numElements: int): Span_1<TUnmanagedElement>;
    static getUnmanagedValuesSource<T, TUnmanagedElement extends unknown>(unmanagedValue: ptr<TUnmanagedElement>, numElements: int): ReadOnlySpan_1<TUnmanagedElement>;
}


export abstract class BStrStringMarshaller$instance {
    static convertToManaged(unmanaged: ptr<ushort>): string;
    static convertToUnmanaged(managed: string): ptr<ushort>;
    static free(unmanaged: ptr<ushort>): void;
}


export type BStrStringMarshaller = BStrStringMarshaller$instance;

export abstract class ComInterfaceMarshaller_1$instance {
    static convertToManaged<T>(unmanaged: ptr<void>): T;
    static convertToUnmanaged<T>(managed: T): ptr<void>;
    static free<T>(unmanaged: ptr<void>): void;
}


export abstract class ComVariantMarshaller$instance {
    static convertToManaged(unmanaged: ComVariant): unknown;
    static convertToUnmanaged(managed: unknown): ComVariant;
    static free(unmanaged: ComVariant): void;
}


export type ComVariantMarshaller = ComVariantMarshaller$instance;

export abstract class ExceptionAsDefaultMarshaller_1$instance {
    static convertToUnmanaged<T extends unknown>(e: Exception): T;
}


export abstract class ExceptionAsHResultMarshaller_1$instance {
    static convertToUnmanaged<T extends INumber_1<T>>(e: Exception): T;
}


export abstract class ExceptionAsNaNMarshaller_1$instance {
    static convertToUnmanaged<T extends IFloatingPointIeee754_1<T>>(e: Exception): T;
}


export abstract class ExceptionAsVoidMarshaller$instance {
    static convertToUnmanaged(e: Exception): void;
}


export type ExceptionAsVoidMarshaller = ExceptionAsVoidMarshaller$instance;

export abstract class PointerArrayMarshaller_2$instance {
    static allocateContainerForManagedElements<T extends unknown, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>, numElements: int): ptr<T>[];
    static allocateContainerForUnmanagedElements<T extends unknown, TUnmanagedElement extends unknown>(managed: ptr<T>[], numElements: { value: ref<int> }): ptr<TUnmanagedElement>;
    static free<T extends unknown, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>): void;
    static getManagedValuesDestination<T extends unknown, TUnmanagedElement extends unknown>(managed: ptr<T>[]): Span_1<CLROf<nint>>;
    static getManagedValuesSource<T extends unknown, TUnmanagedElement extends unknown>(managed: ptr<T>[]): ReadOnlySpan_1<CLROf<nint>>;
    static getUnmanagedValuesDestination<T extends unknown, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>, numElements: int): Span_1<TUnmanagedElement>;
    static getUnmanagedValuesSource<T extends unknown, TUnmanagedElement extends unknown>(unmanagedValue: ptr<TUnmanagedElement>, numElements: int): ReadOnlySpan_1<TUnmanagedElement>;
}


export abstract class ReadOnlySpanMarshaller_2$instance {
}


export abstract class ReadOnlySpanMarshaller_2_UnmanagedToManagedOut$instance {
    static allocateContainerForUnmanagedElements<T, TUnmanagedElement extends unknown>(managed: ReadOnlySpan_1<T>, numElements: { value: ref<int> }): ptr<TUnmanagedElement>;
    static getManagedValuesSource<T, TUnmanagedElement extends unknown>(managed: ReadOnlySpan_1<T>): ReadOnlySpan_1<T>;
    static getUnmanagedValuesDestination<T, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>, numElements: int): Span_1<TUnmanagedElement>;
}


export abstract class SafeHandleMarshaller_1$instance {
}


export abstract class SpanMarshaller_2$instance {
    static allocateContainerForManagedElements<T, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>, numElements: int): Span_1<T>;
    static allocateContainerForUnmanagedElements<T, TUnmanagedElement extends unknown>(managed: Span_1<T>, numElements: { value: ref<int> }): ptr<TUnmanagedElement>;
    static free<T, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>): void;
    static getManagedValuesDestination<T, TUnmanagedElement extends unknown>(managed: Span_1<T>): Span_1<T>;
    static getManagedValuesSource<T, TUnmanagedElement extends unknown>(managed: Span_1<T>): ReadOnlySpan_1<T>;
    static getUnmanagedValuesDestination<T, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>, numElements: int): Span_1<TUnmanagedElement>;
    static getUnmanagedValuesSource<T, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>, numElements: int): ReadOnlySpan_1<TUnmanagedElement>;
}


export abstract class UniqueComInterfaceMarshaller_1$instance {
    static convertToManaged<T>(unmanaged: ptr<void>): T;
    static convertToUnmanaged<T>(managed: T): ptr<void>;
    static free<T>(unmanaged: ptr<void>): void;
}


export abstract class Utf16StringMarshaller$instance {
    static convertToManaged(unmanaged: ptr<ushort>): string;
    static convertToUnmanaged(managed: string): ptr<ushort>;
    static free(unmanaged: ptr<ushort>): void;
    static getPinnableReference(str: string): ref<char>;
}


export type Utf16StringMarshaller = Utf16StringMarshaller$instance;

export abstract class Utf8StringMarshaller$instance {
    static convertToManaged(unmanaged: ptr<byte>): string;
    static convertToUnmanaged(managed: string): ptr<byte>;
    static free(unmanaged: ptr<byte>): void;
}


export type Utf8StringMarshaller = Utf8StringMarshaller$instance;

