// Generated by tsbindgen - Architecture
// Namespace: System.Net
// Assembly: System.Net.HttpListener, System.Net.NameResolution, System.Net.Primitives, System.Net.Requests, System.Net.WebClient, System.Net.WebHeaderCollection, System.Net.WebProxy, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IReadOnlyCollection_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Specialized_Internal from "../../System.Collections.Specialized/internal/index.js";
import type { NameObjectCollectionBase_KeysCollection, NameValueCollection, StringDictionary } from "../../System.Collections.Specialized/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ArrayList, ICollection, IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { AsyncCompletedEventArgs, AsyncCompletedEventHandler, Component, IComponent, IContainer, ISite, ProgressChangedEventArgs, Win32Exception } from "../../System.ComponentModel/internal/index.js";
import type { BinaryWriter, Stream, TextWriter } from "../../System.IO/internal/index.js";
import type { RequestCachePolicy } from "../../System.Net.Cache/internal/index.js";
import type { AuthenticationLevel, EncryptionPolicy, RemoteCertificateValidationCallback } from "../../System.Net.Security/internal/index.js";
import type { AddressFamily } from "../../System.Net.Sockets/internal/index.js";
import type { HttpListenerWebSocketContext } from "../../System.Net.WebSockets/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { ChannelBinding, ChannelBindingKind, ExtendedProtectionPolicy, ServiceNameCollection } from "../../System.Security.Authentication.ExtendedProtection/internal/index.js";
import type { Claim, ClaimsIdentity } from "../../System.Security.Claims/internal/index.js";
import type { X509Certificate, X509Certificate2, X509CertificateCollection } from "../../System.Security.Cryptography.X509Certificates/internal/index.js";
import * as System_Security_Principal_Internal from "../../System.Security.Principal/internal/index.js";
import type { GenericIdentity, IIdentity, IPrincipal, TokenImpersonationLevel } from "../../System.Security.Principal/internal/index.js";
import type { SecureString } from "../../System.Security/internal/index.js";
import type { Encoding } from "../../System.Text/internal/index.js";
import type { Task, Task_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, ArraySegment_1, AsyncCallback, Boolean as ClrBoolean, Byte, Char, DateTime, Delegate, Enum, EventArgs, Exception, FormatException, Guid, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, InvalidOperationException, IParsable_1, ISpanFormattable, ISpanParsable_1, IUtf8SpanFormattable, IUtf8SpanParsable_1, MarshalByRefObject, Memory_1, MulticastDelegate, Object as ClrObject, Predicate_1, ReadOnlySpan_1, Span_1, String as ClrString, TimeSpan, Type, TypeCode, Uri, ValueType, Version, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum AuthenticationSchemes {
    none = 0,
    digest = 1,
    negotiate = 2,
    ntlm = 4,
    basic = 8,
    anonymous = 32768,
    integratedWindowsAuthentication = 6
}


export enum CookieVariant {
    unknown_ = 0,
    plain = 1,
    rfc2109 = 2,
    rfc2965 = 3,
    default_ = 2
}


export enum DecompressionMethods {
    none = 0,
    gZip = 1,
    deflate = 2,
    brotli = 4,
    all = -1
}


export enum FtpStatusCode {
    undefined = 0,
    restartMarker = 110,
    serviceTemporarilyNotAvailable = 120,
    dataAlreadyOpen = 125,
    openingData = 150,
    commandOK = 200,
    commandExtraneous = 202,
    directoryStatus = 212,
    fileStatus = 213,
    systemType = 215,
    sendUserCommand = 220,
    closingControl = 221,
    closingData = 226,
    enteringPassive = 227,
    loggedInProceed = 230,
    serverWantsSecureSession = 234,
    fileActionOK = 250,
    pathnameCreated = 257,
    sendPasswordCommand = 331,
    needLoginAccount = 332,
    fileCommandPending = 350,
    serviceNotAvailable = 421,
    cantOpenData = 425,
    connectionClosed = 426,
    actionNotTakenFileUnavailableOrBusy = 450,
    actionAbortedLocalProcessingError = 451,
    actionNotTakenInsufficientSpace = 452,
    commandSyntaxError = 500,
    argumentSyntaxError = 501,
    commandNotImplemented = 502,
    badCommandSequence = 503,
    notLoggedIn = 530,
    accountNeeded = 532,
    actionNotTakenFileUnavailable = 550,
    actionAbortedUnknownPageType = 551,
    fileActionAborted = 552,
    actionNotTakenFilenameNotAllowed = 553
}


export enum HttpRequestHeader {
    cacheControl = 0,
    connection = 1,
    date = 2,
    keepAlive = 3,
    pragma = 4,
    trailer = 5,
    transferEncoding = 6,
    upgrade = 7,
    via = 8,
    warning = 9,
    allow = 10,
    contentLength = 11,
    contentType = 12,
    contentEncoding = 13,
    contentLanguage = 14,
    contentLocation = 15,
    contentMd5 = 16,
    contentRange = 17,
    expires = 18,
    lastModified = 19,
    accept = 20,
    acceptCharset = 21,
    acceptEncoding = 22,
    acceptLanguage = 23,
    authorization = 24,
    cookie = 25,
    expect = 26,
    from_ = 27,
    host = 28,
    ifMatch = 29,
    ifModifiedSince = 30,
    ifNoneMatch = 31,
    ifRange = 32,
    ifUnmodifiedSince = 33,
    maxForwards = 34,
    proxyAuthorization = 35,
    referer = 36,
    range = 37,
    te = 38,
    translate = 39,
    userAgent = 40
}


export enum HttpResponseHeader {
    cacheControl = 0,
    connection = 1,
    date = 2,
    keepAlive = 3,
    pragma = 4,
    trailer = 5,
    transferEncoding = 6,
    upgrade = 7,
    via = 8,
    warning = 9,
    allow = 10,
    contentLength = 11,
    contentType = 12,
    contentEncoding = 13,
    contentLanguage = 14,
    contentLocation = 15,
    contentMd5 = 16,
    contentRange = 17,
    expires = 18,
    lastModified = 19,
    acceptRanges = 20,
    age = 21,
    eTag = 22,
    location = 23,
    proxyAuthenticate = 24,
    retryAfter = 25,
    server = 26,
    setCookie = 27,
    vary = 28,
    wwwAuthenticate = 29
}


export enum HttpStatusCode {
    continue_ = 100,
    switchingProtocols = 101,
    processing = 102,
    earlyHints = 103,
    OK = 200,
    created = 201,
    accepted = 202,
    nonAuthoritativeInformation = 203,
    noContent = 204,
    resetContent = 205,
    partialContent = 206,
    multiStatus = 207,
    alreadyReported = 208,
    imUsed = 226,
    multipleChoices = 300,
    ambiguous = 300,
    movedPermanently = 301,
    moved = 301,
    found = 302,
    redirect = 302,
    seeOther = 303,
    redirectMethod = 303,
    notModified = 304,
    useProxy = 305,
    unused = 306,
    temporaryRedirect = 307,
    redirectKeepVerb = 307,
    permanentRedirect = 308,
    badRequest = 400,
    unauthorized = 401,
    paymentRequired = 402,
    forbidden = 403,
    notFound = 404,
    methodNotAllowed = 405,
    notAcceptable = 406,
    proxyAuthenticationRequired = 407,
    requestTimeout = 408,
    conflict = 409,
    gone = 410,
    lengthRequired = 411,
    preconditionFailed = 412,
    requestEntityTooLarge = 413,
    requestUriTooLong = 414,
    unsupportedMediaType = 415,
    requestedRangeNotSatisfiable = 416,
    expectationFailed = 417,
    misdirectedRequest = 421,
    unprocessableEntity = 422,
    unprocessableContent = 422,
    locked = 423,
    failedDependency = 424,
    upgradeRequired = 426,
    preconditionRequired = 428,
    tooManyRequests = 429,
    requestHeaderFieldsTooLarge = 431,
    unavailableForLegalReasons = 451,
    internalServerError = 500,
    notImplemented = 501,
    badGateway = 502,
    serviceUnavailable = 503,
    gatewayTimeout = 504,
    httpVersionNotSupported = 505,
    variantAlsoNegotiates = 506,
    insufficientStorage = 507,
    loopDetected = 508,
    notExtended = 510,
    networkAuthenticationRequired = 511
}


export enum SecurityProtocolType {
    systemDefault = 0,
    ssl3 = 48,
    tls = 192,
    tls11 = 768,
    tls12 = 3072,
    tls13 = 12288
}


export enum WebExceptionStatus {
    success = 0,
    nameResolutionFailure = 1,
    connectFailure = 2,
    receiveFailure = 3,
    sendFailure = 4,
    pipelineFailure = 5,
    requestCanceled = 6,
    protocolError = 7,
    connectionClosed = 8,
    trustFailure = 9,
    secureChannelFailure = 10,
    serverProtocolViolation = 11,
    keepAliveFailure = 12,
    pending = 13,
    timeout = 14,
    proxyNameResolutionFailure = 15,
    unknownError = 16,
    messageLengthLimitExceeded = 17,
    cacheEntryNotFound = 18,
    requestProhibitedByCachePolicy = 19,
    requestProhibitedByProxy = 20
}


export type AuthenticationSchemeSelector = (httpRequest: HttpListenerRequest) => AuthenticationSchemes;


export type BindIPEndPoint = (servicePoint: ServicePoint, remoteEndPoint: IPEndPoint, retryCount: int) => IPEndPoint;


export type DownloadDataCompletedEventHandler = (sender: unknown, e: DownloadDataCompletedEventArgs) => void;


export type DownloadProgressChangedEventHandler = (sender: unknown, e: DownloadProgressChangedEventArgs) => void;


export type DownloadStringCompletedEventHandler = (sender: unknown, e: DownloadStringCompletedEventArgs) => void;


export type HttpContinueDelegate = (StatusCode: int, httpHeaders: WebHeaderCollection) => void;


export type HttpListener_ExtendedProtectionSelector = (request: HttpListenerRequest) => ExtendedProtectionPolicy;


export type OpenReadCompletedEventHandler = (sender: unknown, e: OpenReadCompletedEventArgs) => void;


export type OpenWriteCompletedEventHandler = (sender: unknown, e: OpenWriteCompletedEventArgs) => void;


export type UploadDataCompletedEventHandler = (sender: unknown, e: UploadDataCompletedEventArgs) => void;


export type UploadFileCompletedEventHandler = (sender: unknown, e: UploadFileCompletedEventArgs) => void;


export type UploadProgressChangedEventHandler = (sender: unknown, e: UploadProgressChangedEventArgs) => void;


export type UploadStringCompletedEventHandler = (sender: unknown, e: UploadStringCompletedEventArgs) => void;


export type UploadValuesCompletedEventHandler = (sender: unknown, e: UploadValuesCompletedEventArgs) => void;


export type WriteStreamClosedEventHandler = (sender: unknown, e: WriteStreamClosedEventArgs) => void;


export interface IAuthenticationModule$instance {
    readonly canPreAuthenticate: boolean;
    readonly authenticationType: string;
    authenticate(challenge: string, request: WebRequest, credentials: ICredentials): Authorization;
    preAuthenticate(request: WebRequest, credentials: ICredentials): Authorization;
}


export type IAuthenticationModule = IAuthenticationModule$instance;

export interface ICredentialPolicy$instance {
    shouldSendCredential(challengeUri: Uri, request: WebRequest, credential: NetworkCredential, authenticationModule: IAuthenticationModule): boolean;
}


export type ICredentialPolicy = ICredentialPolicy$instance;

export interface ICredentials$instance {
    getCredential(uri: Uri, authType: string): NetworkCredential;
}


export type ICredentials = ICredentials$instance;

export interface ICredentialsByHost$instance {
    getCredential(host: string, port: int, authenticationType: string): NetworkCredential;
}


export type ICredentialsByHost = ICredentialsByHost$instance;

export interface IWebProxy$instance {
    credentials: ICredentials;
    getProxy(destination: Uri): Uri;
    isBypassed(host: Uri): boolean;
}


export type IWebProxy = IWebProxy$instance;

export interface IWebProxyScript$instance {
    close(): void;
    load(scriptLocation: Uri, script: string, helperType: Type): boolean;
    run(url: string, host: string): string;
}


export type IWebProxyScript = IWebProxyScript$instance;

export interface IWebRequestCreate$instance {
    create(uri: Uri): WebRequest;
}


export type IWebRequestCreate = IWebRequestCreate$instance;

export interface IPNetwork$instance {
    readonly baseAddress: IPAddress;
    readonly prefixLength: int;
    contains(address: IPAddress): boolean;
    equals(other: IPNetwork): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export const IPNetwork: {
    new(baseAddress: IPAddress, prefixLength: int): IPNetwork$instance;
    parse(utf8Text: ReadOnlySpan_1<CLROf<byte>>): IPNetwork;
    parse(s: ReadOnlySpan_1<CLROf<char>>): IPNetwork;
    parse(s: string): IPNetwork;
    tryParse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<IPNetwork> }): boolean;
    tryParse(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<IPNetwork> }): boolean;
    tryParse(s: string, result: { value: ref<IPNetwork> }): boolean;
};


export interface __IPNetwork$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<IPNetwork>;
    As_IFormattable(): System_Internal.IFormattable$instance;
    As_IParsable_1(): System_Internal.IParsable_1$instance<IPNetwork>;
    As_ISpanFormattable(): System_Internal.ISpanFormattable$instance;
    As_ISpanParsable_1(): System_Internal.ISpanParsable_1$instance<IPNetwork>;
    As_IUtf8SpanFormattable(): System_Internal.IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): System_Internal.IUtf8SpanParsable_1$instance<IPNetwork>;

    // Structural method bridges for numeric interface constraints
    Equals(other: IPNetwork): boolean;
}

export interface IPNetwork$instance extends System_Internal.ISpanParsable_1$instance<IPNetwork> {}

export type IPNetwork = IPNetwork$instance & __IPNetwork$views;


export interface AuthenticationManager$instance {
}


export const AuthenticationManager: {
    new(): AuthenticationManager$instance;
    credentialPolicy: ICredentialPolicy;
    readonly customTargetNameDictionary: StringDictionary;
    readonly registeredModules: IEnumerator;
    authenticate(challenge: string, request: WebRequest, credentials: ICredentials): Authorization;
    preAuthenticate(request: WebRequest, credentials: ICredentials): Authorization;
    register(authenticationModule: IAuthenticationModule): void;
    unregister(authenticationModule: IAuthenticationModule): void;
    unregister(authenticationScheme: string): void;
};


export type AuthenticationManager = AuthenticationManager$instance;

export interface Authorization$instance {
    readonly complete: boolean;
    readonly connectionGroupId: string;
    readonly message: string;
    mutuallyAuthenticated: boolean;
    protectionRealm: string[];
}


export const Authorization: {
    new(token: string): Authorization$instance;
    new(token: string, finished: boolean): Authorization$instance;
    new(token: string, finished: boolean, connectionGroupId: string): Authorization$instance;
};


export type Authorization = Authorization$instance;

export interface Cookie$instance {
    comment: string;
    commentUri: Uri;
    discard: boolean;
    domain: string;
    expired: boolean;
    expires: DateTime;
    httpOnly: boolean;
    name: string;
    path: string;
    port: string;
    secure: boolean;
    readonly timeStamp: DateTime;
    value: string;
    version: int;
    equals(comparand: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const Cookie: {
    new(): Cookie$instance;
    new(name: string, value: string): Cookie$instance;
    new(name: string, value: string, path: string): Cookie$instance;
    new(name: string, value: string, path: string, domain: string): Cookie$instance;
};


export type Cookie = Cookie$instance;

export interface CookieCollection$instance {
    readonly count: int;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    readonly syncRoot: unknown;
    add(cookie: Cookie): void;
    add(cookies: CookieCollection): void;
    clear(): void;
    contains(cookie: Cookie): boolean;
    copyTo(array: ClrArray, index: int): void;
    copyTo(array: Cookie[], index: int): void;
    get_Item(index: int): Cookie;
    get_Item(name: string): Cookie;
    getEnumerator(): IEnumerator;
    remove(cookie: Cookie): boolean;
}


export const CookieCollection: {
    new(): CookieCollection$instance;
};


export interface __CookieCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<Cookie>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<Cookie>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<Cookie>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type CookieCollection = CookieCollection$instance & __CookieCollection$views;


export interface CookieContainer$instance {
    capacity: int;
    readonly count: int;
    maxCookieSize: int;
    perDomainCapacity: int;
    add(cookie: Cookie): void;
    add(cookies: CookieCollection): void;
    add(uri: Uri, cookie: Cookie): void;
    add(uri: Uri, cookies: CookieCollection): void;
    getAllCookies(): CookieCollection;
    getCookieHeader(uri: Uri): string;
    getCookies(uri: Uri): CookieCollection;
    setCookies(uri: Uri, cookieHeader: string): void;
}


export const CookieContainer: {
    new(): CookieContainer$instance;
    new(capacity: int): CookieContainer$instance;
    new(capacity: int, perDomainCapacity: int, maxCookieSize: int): CookieContainer$instance;
    readonly defaultCookieLimit: int;
    readonly defaultPerDomainCookieLimit: int;
    readonly defaultCookieLengthLimit: int;
};


export type CookieContainer = CookieContainer$instance;

export interface CookieException$instance extends FormatException {
    getObjectData(serializationInfo: SerializationInfo, streamingContext: StreamingContext): void;
}


export const CookieException: {
    new(): CookieException$instance;
    new(message: string): CookieException$instance;
    new(message: string, innerException: Exception): CookieException$instance;
};


export interface __CookieException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type CookieException = CookieException$instance & __CookieException$views;


export interface CredentialCache$instance {
    add(uriPrefix: Uri, authType: string, cred: NetworkCredential): void;
    add(host: string, port: int, authenticationType: string, credential: NetworkCredential): void;
    getCredential(uriPrefix: Uri, authType: string): NetworkCredential;
    getCredential(host: string, port: int, authenticationType: string): NetworkCredential;
    getEnumerator(): IEnumerator;
    remove(uriPrefix: Uri, authType: string): void;
    remove(host: string, port: int, authenticationType: string): void;
}


export const CredentialCache: {
    new(): CredentialCache$instance;
    readonly defaultCredentials: ICredentials;
    readonly defaultNetworkCredentials: NetworkCredential;
};


export interface __CredentialCache$views {
    As_ICredentials(): ICredentials$instance;
    As_ICredentialsByHost(): ICredentialsByHost$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export interface CredentialCache$instance extends System_Collections_Internal.IEnumerable$instance {}

export type CredentialCache = CredentialCache$instance & __CredentialCache$views;


export interface DnsEndPoint$instance extends EndPoint {
    readonly addressFamily: AddressFamily;
    readonly host: string;
    readonly port: int;
    equals(comparand: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const DnsEndPoint: {
    new(host: string, port: int): DnsEndPoint$instance;
    new(host: string, port: int, addressFamily: AddressFamily): DnsEndPoint$instance;
};


export type DnsEndPoint = DnsEndPoint$instance;

export interface DownloadDataCompletedEventArgs$instance extends AsyncCompletedEventArgs {
    readonly result: byte[];
}


export const DownloadDataCompletedEventArgs: {
    new(): DownloadDataCompletedEventArgs$instance;
};


export type DownloadDataCompletedEventArgs = DownloadDataCompletedEventArgs$instance;

export interface DownloadProgressChangedEventArgs$instance extends ProgressChangedEventArgs {
    readonly bytesReceived: long;
    readonly totalBytesToReceive: long;
}


export const DownloadProgressChangedEventArgs: {
    new(): DownloadProgressChangedEventArgs$instance;
};


export type DownloadProgressChangedEventArgs = DownloadProgressChangedEventArgs$instance;

export interface DownloadStringCompletedEventArgs$instance extends AsyncCompletedEventArgs {
    readonly result: string;
}


export const DownloadStringCompletedEventArgs: {
    new(): DownloadStringCompletedEventArgs$instance;
};


export type DownloadStringCompletedEventArgs = DownloadStringCompletedEventArgs$instance;

export interface EndPoint$instance {
    readonly addressFamily: AddressFamily;
    create(socketAddress: SocketAddress): EndPoint;
    serialize(): SocketAddress;
}


export const EndPoint: {
};


export type EndPoint = EndPoint$instance;

export interface FileWebRequest$instance extends WebRequest$instance {
    connectionGroupName: string;
    contentLength: long;
    contentType: string;
    credentials: ICredentials;
    readonly headers: WebHeaderCollection;
    method: string;
    preAuthenticate: boolean;
    proxy: IWebProxy;
    readonly requestUri: Uri;
    timeout: int;
    useDefaultCredentials: boolean;
    abort(): void;
    beginGetRequestStream(callback: AsyncCallback, state: unknown): IAsyncResult;
    beginGetResponse(callback: AsyncCallback, state: unknown): IAsyncResult;
    endGetRequestStream(asyncResult: IAsyncResult): Stream;
    endGetResponse(asyncResult: IAsyncResult): WebResponse;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getRequestStream(): Stream;
    getRequestStreamAsync(): Task_1<Stream>;
    getRequestStreamAsync(): Task_1<Stream>;
    getResponse(): WebResponse;
    getResponseAsync(): Task_1<WebResponse>;
    getResponseAsync(): Task_1<WebResponse>;
}


export const FileWebRequest: {
    new(): FileWebRequest$instance;
};


export interface __FileWebRequest$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface FileWebRequest$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type FileWebRequest = FileWebRequest$instance & __FileWebRequest$views;


export interface FileWebResponse$instance extends WebResponse$instance {
    readonly contentLength: long;
    readonly contentType: string;
    readonly headers: WebHeaderCollection;
    readonly responseUri: Uri;
    readonly supportsHeaders: boolean;
    close(): void;
    dispose(): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getResponseStream(): Stream;
}


export const FileWebResponse: {
    new(): FileWebResponse$instance;
};


export interface __FileWebResponse$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface FileWebResponse$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type FileWebResponse = FileWebResponse$instance & __FileWebResponse$views;


export interface FtpWebRequest$instance extends WebRequest$instance {
    cachePolicy: RequestCachePolicy;
    clientCertificates: X509CertificateCollection;
    connectionGroupName: string;
    contentLength: long;
    contentOffset: long;
    contentType: string;
    credentials: ICredentials;
    enableSsl: boolean;
    headers: WebHeaderCollection;
    keepAlive: boolean;
    method: string;
    preAuthenticate: boolean;
    proxy: IWebProxy;
    readWriteTimeout: int;
    renameTo: string;
    readonly requestUri: Uri;
    readonly servicePoint: ServicePoint;
    timeout: int;
    useBinary: boolean;
    useDefaultCredentials: boolean;
    usePassive: boolean;
    abort(): void;
    beginGetRequestStream(callback: AsyncCallback, state: unknown): IAsyncResult;
    beginGetResponse(callback: AsyncCallback, state: unknown): IAsyncResult;
    endGetRequestStream(asyncResult: IAsyncResult): Stream;
    endGetResponse(asyncResult: IAsyncResult): WebResponse;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getRequestStream(): Stream;
    getResponse(): WebResponse;
}


export const FtpWebRequest: {
    new(): FtpWebRequest$instance;
    defaultCachePolicy: RequestCachePolicy;
};


export interface __FtpWebRequest$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface FtpWebRequest$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type FtpWebRequest = FtpWebRequest$instance & __FtpWebRequest$views;


export interface FtpWebResponse$instance extends WebResponse$instance {
    readonly bannerMessage: string;
    readonly contentLength: long;
    readonly exitMessage: string;
    readonly headers: WebHeaderCollection;
    readonly lastModified: DateTime;
    readonly responseUri: Uri;
    readonly statusCode: FtpStatusCode;
    readonly statusDescription: string;
    readonly supportsHeaders: boolean;
    readonly welcomeMessage: string;
    close(): void;
    dispose(): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getResponseStream(): Stream;
}


export const FtpWebResponse: {
    new(): FtpWebResponse$instance;
};


export interface __FtpWebResponse$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface FtpWebResponse$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type FtpWebResponse = FtpWebResponse$instance & __FtpWebResponse$views;


export interface GlobalProxySelection$instance {
}


export const GlobalProxySelection: {
    new(): GlobalProxySelection$instance;
    select: IWebProxy;
    getEmptyWebProxy(): IWebProxy;
};


export type GlobalProxySelection = GlobalProxySelection$instance;

export interface HttpListener$instance {
    authenticationSchemes: AuthenticationSchemes;
    authenticationSchemeSelectorDelegate: AuthenticationSchemeSelector;
    readonly defaultServiceNames: ServiceNameCollection;
    extendedProtectionPolicy: ExtendedProtectionPolicy;
    extendedProtectionSelectorDelegate: HttpListener_ExtendedProtectionSelector;
    ignoreWriteExceptions: boolean;
    readonly isListening: boolean;
    readonly prefixes: HttpListenerPrefixCollection;
    realm: string;
    readonly timeoutManager: HttpListenerTimeoutManager;
    unsafeConnectionNtlmAuthentication: boolean;
    abort(): void;
    beginGetContext(callback: AsyncCallback, state: unknown): IAsyncResult;
    close(): void;
    endGetContext(asyncResult: IAsyncResult): HttpListenerContext;
    getContext(): HttpListenerContext;
    getContextAsync(): Task_1<HttpListenerContext>;
    start(): void;
    stop(): void;
}


export const HttpListener: {
    new(): HttpListener$instance;
    readonly isSupported: boolean;
};


export interface __HttpListener$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface HttpListener$instance extends System_Internal.IDisposable$instance {}

export type HttpListener = HttpListener$instance & __HttpListener$views;


export interface HttpListenerBasicIdentity$instance extends GenericIdentity {
    readonly password: string;
}


export const HttpListenerBasicIdentity: {
    new(username: string, password: string): HttpListenerBasicIdentity$instance;
};


export interface __HttpListenerBasicIdentity$views {
    As_IIdentity(): System_Security_Principal_Internal.IIdentity$instance;
}

export interface HttpListenerBasicIdentity$instance extends System_Security_Principal_Internal.IIdentity$instance {}

export type HttpListenerBasicIdentity = HttpListenerBasicIdentity$instance & __HttpListenerBasicIdentity$views;


export interface HttpListenerContext$instance {
    readonly request: HttpListenerRequest;
    readonly response: HttpListenerResponse;
    readonly user: IPrincipal;
    acceptWebSocketAsync(subProtocol: string): Task_1<HttpListenerWebSocketContext>;
    acceptWebSocketAsync(subProtocol: string, keepAliveInterval: TimeSpan): Task_1<HttpListenerWebSocketContext>;
    acceptWebSocketAsync(subProtocol: string, receiveBufferSize: int, keepAliveInterval: TimeSpan): Task_1<HttpListenerWebSocketContext>;
    acceptWebSocketAsync(subProtocol: string, receiveBufferSize: int, keepAliveInterval: TimeSpan, internalBuffer: ArraySegment_1<CLROf<byte>>): Task_1<HttpListenerWebSocketContext>;
}


export const HttpListenerContext: {
    new(): HttpListenerContext$instance;
};


export type HttpListenerContext = HttpListenerContext$instance;

export interface HttpListenerException$instance extends Win32Exception {
    readonly errorCode: int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const HttpListenerException: {
    new(): HttpListenerException$instance;
    new(errorCode: int): HttpListenerException$instance;
    new(errorCode: int, message: string): HttpListenerException$instance;
};


export interface __HttpListenerException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type HttpListenerException = HttpListenerException$instance & __HttpListenerException$views;


export interface HttpListenerPrefixCollection$instance {
    readonly count: int;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    add(uriPrefix: string): void;
    clear(): void;
    contains(uriPrefix: string): boolean;
    copyTo(array: ClrArray, offset: int): void;
    copyTo(array: string[], offset: int): void;
    getEnumerator(): IEnumerator_1<CLROf<string>>;
    remove(uriPrefix: string): boolean;
}


export const HttpListenerPrefixCollection: {
    new(): HttpListenerPrefixCollection$instance;
};


export interface __HttpListenerPrefixCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<CLROf<string>>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<CLROf<string>>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type HttpListenerPrefixCollection = HttpListenerPrefixCollection$instance & __HttpListenerPrefixCollection$views;


export interface HttpListenerRequest$instance {
    readonly acceptTypes: string[];
    readonly clientCertificateError: int;
    readonly contentEncoding: Encoding;
    readonly contentLength64: long;
    readonly contentType: string;
    readonly cookies: CookieCollection;
    readonly hasEntityBody: boolean;
    readonly headers: NameValueCollection;
    readonly httpMethod: string;
    readonly inputStream: Stream;
    readonly isAuthenticated: boolean;
    readonly isLocal: boolean;
    readonly isSecureConnection: boolean;
    readonly isWebSocketRequest: boolean;
    readonly keepAlive: boolean;
    readonly localEndPoint: IPEndPoint;
    readonly protocolVersion: Version;
    readonly queryString: NameValueCollection;
    readonly rawUrl: string;
    readonly remoteEndPoint: IPEndPoint;
    readonly requestTraceIdentifier: Guid;
    readonly serviceName: string;
    readonly transportContext: TransportContext;
    readonly url: Uri;
    readonly urlReferrer: Uri;
    readonly userAgent: string;
    readonly userHostAddress: string;
    readonly userHostName: string;
    readonly userLanguages: string[];
    beginGetClientCertificate(requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    endGetClientCertificate(asyncResult: IAsyncResult): X509Certificate2;
    getClientCertificate(): X509Certificate2;
    getClientCertificateAsync(): Task_1<X509Certificate2>;
}


export const HttpListenerRequest: {
    new(): HttpListenerRequest$instance;
};


export type HttpListenerRequest = HttpListenerRequest$instance;

export interface HttpListenerResponse$instance {
    contentEncoding: Encoding;
    contentLength64: long;
    contentType: string;
    cookies: CookieCollection;
    headers: WebHeaderCollection;
    keepAlive: boolean;
    readonly outputStream: Stream;
    protocolVersion: Version;
    redirectLocation: string;
    sendChunked: boolean;
    statusCode: int;
    statusDescription: string;
    abort(): void;
    addHeader(name: string, value: string): void;
    appendCookie(cookie: Cookie): void;
    appendHeader(name: string, value: string): void;
    close(): void;
    close(responseEntity: byte[], willBlock: boolean): void;
    copyFrom(templateResponse: HttpListenerResponse): void;
    redirect(url: string): void;
    setCookie(cookie: Cookie): void;
}


export const HttpListenerResponse: {
    new(): HttpListenerResponse$instance;
};


export interface __HttpListenerResponse$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface HttpListenerResponse$instance extends System_Internal.IDisposable$instance {}

export type HttpListenerResponse = HttpListenerResponse$instance & __HttpListenerResponse$views;


export interface HttpListenerTimeoutManager$instance {
    drainEntityBody: TimeSpan;
    entityBody: TimeSpan;
    headerWait: TimeSpan;
    idleConnection: TimeSpan;
    minSendBytesPerSecond: long;
    requestQueue: TimeSpan;
}


export const HttpListenerTimeoutManager: {
    new(): HttpListenerTimeoutManager$instance;
};


export type HttpListenerTimeoutManager = HttpListenerTimeoutManager$instance;

export interface HttpWebRequest$instance extends WebRequest$instance {
    accept: string;
    readonly address: Uri;
    allowAutoRedirect: boolean;
    allowReadStreamBuffering: boolean;
    allowWriteStreamBuffering: boolean;
    automaticDecompression: DecompressionMethods;
    clientCertificates: X509CertificateCollection;
    connection: string;
    connectionGroupName: string;
    contentLength: long;
    contentType: string;
    continueDelegate: HttpContinueDelegate;
    continueTimeout: int;
    cookieContainer: CookieContainer;
    credentials: ICredentials;
    date: DateTime;
    expect: string;
    readonly haveResponse: boolean;
    headers: WebHeaderCollection;
    host: string;
    ifModifiedSince: DateTime;
    keepAlive: boolean;
    maximumAutomaticRedirections: int;
    maximumResponseHeadersLength: int;
    mediaType: string;
    method: string;
    pipelined: boolean;
    preAuthenticate: boolean;
    protocolVersion: Version;
    proxy: IWebProxy;
    readWriteTimeout: int;
    referer: string;
    readonly requestUri: Uri;
    sendChunked: boolean;
    serverCertificateValidationCallback: RemoteCertificateValidationCallback;
    readonly servicePoint: ServicePoint;
    readonly supportsCookieContainer: boolean;
    timeout: int;
    transferEncoding: string;
    unsafeAuthenticatedConnectionSharing: boolean;
    useDefaultCredentials: boolean;
    userAgent: string;
    abort(): void;
    addRange(from_: int, to: int): void;
    addRange(from_: long, to: long): void;
    addRange(range: int): void;
    addRange(range: long): void;
    addRange(rangeSpecifier: string, from_: int, to: int): void;
    addRange(rangeSpecifier: string, from_: long, to: long): void;
    addRange(rangeSpecifier: string, range: int): void;
    addRange(rangeSpecifier: string, range: long): void;
    beginGetRequestStream(callback: AsyncCallback, state: unknown): IAsyncResult;
    beginGetResponse(callback: AsyncCallback, state: unknown): IAsyncResult;
    endGetRequestStream(asyncResult: IAsyncResult): Stream;
    endGetResponse(asyncResult: IAsyncResult): WebResponse;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getRequestStream(): Stream;
    getResponse(): WebResponse;
}


export const HttpWebRequest: {
    new(): HttpWebRequest$instance;
    defaultMaximumResponseHeadersLength: int;
    defaultMaximumErrorResponseLength: int;
    defaultCachePolicy: RequestCachePolicy;
};


export interface __HttpWebRequest$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface HttpWebRequest$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type HttpWebRequest = HttpWebRequest$instance & __HttpWebRequest$views;


export interface HttpWebResponse$instance extends WebResponse$instance {
    readonly characterSet: string;
    readonly contentEncoding: string;
    readonly contentLength: long;
    readonly contentType: string;
    cookies: CookieCollection;
    readonly headers: WebHeaderCollection;
    readonly isMutuallyAuthenticated: boolean;
    readonly lastModified: DateTime;
    readonly method: string;
    readonly protocolVersion: Version;
    readonly responseUri: Uri;
    readonly server: string;
    readonly statusCode: HttpStatusCode;
    readonly statusDescription: string;
    readonly supportsHeaders: boolean;
    close(): void;
    dispose(): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getResponseHeader(headerName: string): string;
    getResponseStream(): Stream;
}


export const HttpWebResponse: {
    new(): HttpWebResponse$instance;
};


export interface __HttpWebResponse$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface HttpWebResponse$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type HttpWebResponse = HttpWebResponse$instance & __HttpWebResponse$views;


export interface IPAddress$instance {
    address: long;
    readonly addressFamily: AddressFamily;
    readonly isIPv4MappedToIPv6: boolean;
    readonly isIPv6LinkLocal: boolean;
    readonly isIPv6Multicast: boolean;
    readonly isIPv6SiteLocal: boolean;
    readonly isIPv6Teredo: boolean;
    readonly isIPv6UniqueLocal: boolean;
    scopeId: long;
    equals(comparand: unknown): boolean;
    getAddressBytes(): byte[];
    getHashCode(): int;
    mapToIPv4(): IPAddress;
    mapToIPv6(): IPAddress;
    toString(): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryWriteBytes(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export const IPAddress: {
    new(newAddress: long): IPAddress$instance;
    new(address: byte[], scopeid: long): IPAddress$instance;
    new(address: ReadOnlySpan_1<CLROf<byte>>, scopeid: long): IPAddress$instance;
    new(address: byte[]): IPAddress$instance;
    new(address: ReadOnlySpan_1<CLROf<byte>>): IPAddress$instance;
    readonly any_: IPAddress;
    readonly loopback: IPAddress;
    readonly broadcast: IPAddress;
    readonly none: IPAddress;
    readonly iPv6Any: IPAddress;
    readonly iPv6Loopback: IPAddress;
    readonly iPv6None: IPAddress;
    hostToNetworkOrder(host: short): short;
    hostToNetworkOrder(host: int): int;
    hostToNetworkOrder(host: long): long;
    isLoopback(address: IPAddress): boolean;
    isValid(ipSpan: ReadOnlySpan_1<CLROf<char>>): boolean;
    isValidUtf8(utf8Text: ReadOnlySpan_1<CLROf<byte>>): boolean;
    networkToHostOrder(network: short): short;
    networkToHostOrder(network: int): int;
    networkToHostOrder(network: long): long;
    parse(utf8Text: ReadOnlySpan_1<CLROf<byte>>): IPAddress;
    parse(ipSpan: ReadOnlySpan_1<CLROf<char>>): IPAddress;
    parse(ipString: string): IPAddress;
    tryParse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<IPAddress> }): boolean;
    tryParse(ipSpan: ReadOnlySpan_1<CLROf<char>>, address: { value: ref<IPAddress> }): boolean;
    tryParse(ipString: string, address: { value: ref<IPAddress> }): boolean;
};


export interface __IPAddress$views {
    As_IFormattable(): System_Internal.IFormattable$instance;
    As_IParsable_1(): System_Internal.IParsable_1$instance<IPAddress>;
    As_ISpanFormattable(): System_Internal.ISpanFormattable$instance;
    As_ISpanParsable_1(): System_Internal.ISpanParsable_1$instance<IPAddress>;
    As_IUtf8SpanFormattable(): System_Internal.IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): System_Internal.IUtf8SpanParsable_1$instance<IPAddress>;
}

export interface IPAddress$instance extends System_Internal.ISpanParsable_1$instance<IPAddress> {}

export type IPAddress = IPAddress$instance & __IPAddress$views;


export interface IPEndPoint$instance extends EndPoint {
    address: IPAddress;
    readonly addressFamily: AddressFamily;
    port: int;
    create(socketAddress: SocketAddress): EndPoint;
    equals(comparand: unknown): boolean;
    getHashCode(): int;
    serialize(): SocketAddress;
    toString(): string;
}


export const IPEndPoint: {
    new(address: long, port: int): IPEndPoint$instance;
    new(address: IPAddress, port: int): IPEndPoint$instance;
    readonly minPort: int;
    readonly maxPort: int;
    parse(s: ReadOnlySpan_1<CLROf<char>>): IPEndPoint;
    parse(s: string): IPEndPoint;
    tryParse(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<IPEndPoint> }): boolean;
    tryParse(s: string, result: { value: ref<IPEndPoint> }): boolean;
};


export type IPEndPoint = IPEndPoint$instance;

export interface IPHostEntry$instance {
    addressList: IPAddress[];
    aliases: string[];
    hostName: string;
}


export const IPHostEntry: {
    new(): IPHostEntry$instance;
};


export type IPHostEntry = IPHostEntry$instance;

export interface NetworkCredential$instance {
    domain: string;
    password: string;
    securePassword: SecureString;
    userName: string;
    getCredential(uri: Uri, authenticationType: string): NetworkCredential;
    getCredential(host: string, port: int, authenticationType: string): NetworkCredential;
}


export const NetworkCredential: {
    new(): NetworkCredential$instance;
    new(userName: string, password: string): NetworkCredential$instance;
    new(userName: string, password: string, domain: string): NetworkCredential$instance;
    new(userName: string, password: SecureString): NetworkCredential$instance;
    new(userName: string, password: SecureString, domain: string): NetworkCredential$instance;
};


export interface __NetworkCredential$views {
    As_ICredentials(): ICredentials$instance;
    As_ICredentialsByHost(): ICredentialsByHost$instance;
}

export type NetworkCredential = NetworkCredential$instance & __NetworkCredential$views;


export interface OpenReadCompletedEventArgs$instance extends AsyncCompletedEventArgs {
    readonly result: Stream;
}


export const OpenReadCompletedEventArgs: {
    new(): OpenReadCompletedEventArgs$instance;
};


export type OpenReadCompletedEventArgs = OpenReadCompletedEventArgs$instance;

export interface OpenWriteCompletedEventArgs$instance extends AsyncCompletedEventArgs {
    readonly result: Stream;
}


export const OpenWriteCompletedEventArgs: {
    new(): OpenWriteCompletedEventArgs$instance;
};


export type OpenWriteCompletedEventArgs = OpenWriteCompletedEventArgs$instance;

export interface PathList$instance {
}


export const PathList: {
    new(): PathList$instance;
};


export type PathList = PathList$instance;

export interface ProtocolViolationException$instance extends InvalidOperationException {
    getObjectData(serializationInfo: SerializationInfo, streamingContext: StreamingContext): void;
}


export const ProtocolViolationException: {
    new(): ProtocolViolationException$instance;
    new(message: string): ProtocolViolationException$instance;
};


export interface __ProtocolViolationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ProtocolViolationException = ProtocolViolationException$instance & __ProtocolViolationException$views;


export interface ServicePoint$instance {
    readonly address: Uri;
    bindIPEndPointDelegate: BindIPEndPoint;
    readonly certificate: X509Certificate;
    readonly clientCertificate: X509Certificate;
    connectionLeaseTimeout: int;
    connectionLimit: int;
    readonly connectionName: string;
    readonly currentConnections: int;
    expect100Continue: boolean;
    readonly idleSince: DateTime;
    maxIdleTime: int;
    readonly protocolVersion: Version;
    receiveBufferSize: int;
    readonly supportsPipelining: boolean;
    useNagleAlgorithm: boolean;
    closeConnectionGroup(connectionGroupName: string): boolean;
    setTcpKeepAlive(enabled: boolean, keepAliveTime: int, keepAliveInterval: int): void;
}


export const ServicePoint: {
    new(): ServicePoint$instance;
};


export type ServicePoint = ServicePoint$instance;

export interface ServicePointManager$instance {
}


export const ServicePointManager: {
    new(): ServicePointManager$instance;
    readonly defaultNonPersistentConnectionLimit: int;
    readonly defaultPersistentConnectionLimit: int;
    securityProtocol: SecurityProtocolType;
    maxServicePoints: int;
    defaultConnectionLimit: int;
    maxServicePointIdleTime: int;
    useNagleAlgorithm: boolean;
    expect100Continue: boolean;
    enableDnsRoundRobin: boolean;
    dnsRefreshTimeout: int;
    serverCertificateValidationCallback: RemoteCertificateValidationCallback;
    reusePort: boolean;
    checkCertificateRevocationList: boolean;
    readonly encryptionPolicy: EncryptionPolicy;
    findServicePoint(uriString: string, proxy: IWebProxy): ServicePoint;
    findServicePoint(address: Uri, proxy: IWebProxy): ServicePoint;
    findServicePoint(address: Uri): ServicePoint;
    setTcpKeepAlive(enabled: boolean, keepAliveTime: int, keepAliveInterval: int): void;
};


export type ServicePointManager = ServicePointManager$instance;

export interface SocketAddress$instance {
    readonly buffer: Memory_1<CLROf<byte>>;
    readonly family: AddressFamily;
    item: byte;
    size: int;
    equals(comparand: unknown): boolean;
    equals(comparand: SocketAddress): boolean;
    getHashCode(): int;
    toString(): string;
}


export const SocketAddress: {
    new(family: AddressFamily): SocketAddress$instance;
    new(family: AddressFamily, size: int): SocketAddress$instance;
    getMaximumAddressSize(addressFamily: AddressFamily): int;
};


export interface __SocketAddress$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SocketAddress>;

    // Structural method bridges for numeric interface constraints
    Equals(other: SocketAddress): boolean;
}

export type SocketAddress = SocketAddress$instance & __SocketAddress$views;


export interface TransportContext$instance {
    getChannelBinding(kind: ChannelBindingKind): ChannelBinding;
}


export const TransportContext: {
};


export type TransportContext = TransportContext$instance;

export interface UploadDataCompletedEventArgs$instance extends AsyncCompletedEventArgs {
    readonly result: byte[];
}


export const UploadDataCompletedEventArgs: {
    new(): UploadDataCompletedEventArgs$instance;
};


export type UploadDataCompletedEventArgs = UploadDataCompletedEventArgs$instance;

export interface UploadFileCompletedEventArgs$instance extends AsyncCompletedEventArgs {
    readonly result: byte[];
}


export const UploadFileCompletedEventArgs: {
    new(): UploadFileCompletedEventArgs$instance;
};


export type UploadFileCompletedEventArgs = UploadFileCompletedEventArgs$instance;

export interface UploadProgressChangedEventArgs$instance extends ProgressChangedEventArgs {
    readonly bytesReceived: long;
    readonly bytesSent: long;
    readonly totalBytesToReceive: long;
    readonly totalBytesToSend: long;
}


export const UploadProgressChangedEventArgs: {
    new(): UploadProgressChangedEventArgs$instance;
};


export type UploadProgressChangedEventArgs = UploadProgressChangedEventArgs$instance;

export interface UploadStringCompletedEventArgs$instance extends AsyncCompletedEventArgs {
    readonly result: string;
}


export const UploadStringCompletedEventArgs: {
    new(): UploadStringCompletedEventArgs$instance;
};


export type UploadStringCompletedEventArgs = UploadStringCompletedEventArgs$instance;

export interface UploadValuesCompletedEventArgs$instance extends AsyncCompletedEventArgs {
    readonly result: byte[];
}


export const UploadValuesCompletedEventArgs: {
    new(): UploadValuesCompletedEventArgs$instance;
};


export type UploadValuesCompletedEventArgs = UploadValuesCompletedEventArgs$instance;

export interface WebClient$instance extends Component {
    allowReadStreamBuffering: boolean;
    allowWriteStreamBuffering: boolean;
    baseAddress: string;
    cachePolicy: RequestCachePolicy;
    credentials: ICredentials;
    encoding: Encoding;
    headers: WebHeaderCollection;
    readonly isBusy: boolean;
    proxy: IWebProxy;
    queryString: NameValueCollection;
    readonly responseHeaders: WebHeaderCollection;
    useDefaultCredentials: boolean;
    cancelAsync(): void;
    dispose(): void;
    downloadData(address: string): byte[];
    downloadData(address: Uri): byte[];
    downloadDataAsync(address: Uri): void;
    downloadDataAsync(address: Uri, userToken: unknown): void;
    downloadDataTaskAsync(address: string): Task_1<byte[]>;
    downloadDataTaskAsync(address: Uri): Task_1<byte[]>;
    downloadFile(address: string, fileName: string): void;
    downloadFile(address: Uri, fileName: string): void;
    downloadFileAsync(address: Uri, fileName: string): void;
    downloadFileAsync(address: Uri, fileName: string, userToken: unknown): void;
    downloadFileTaskAsync(address: string, fileName: string): Task;
    downloadFileTaskAsync(address: Uri, fileName: string): Task;
    downloadString(address: string): string;
    downloadString(address: Uri): string;
    downloadStringAsync(address: Uri): void;
    downloadStringAsync(address: Uri, userToken: unknown): void;
    downloadStringTaskAsync(address: string): Task_1<CLROf<string>>;
    downloadStringTaskAsync(address: Uri): Task_1<CLROf<string>>;
    openRead(address: string): Stream;
    openRead(address: Uri): Stream;
    openReadAsync(address: Uri): void;
    openReadAsync(address: Uri, userToken: unknown): void;
    openReadTaskAsync(address: string): Task_1<Stream>;
    openReadTaskAsync(address: Uri): Task_1<Stream>;
    openWrite(address: string): Stream;
    openWrite(address: Uri): Stream;
    openWrite(address: string, method: string): Stream;
    openWrite(address: Uri, method: string): Stream;
    openWriteAsync(address: Uri): void;
    openWriteAsync(address: Uri, method: string): void;
    openWriteAsync(address: Uri, method: string, userToken: unknown): void;
    openWriteTaskAsync(address: string): Task_1<Stream>;
    openWriteTaskAsync(address: Uri): Task_1<Stream>;
    openWriteTaskAsync(address: string, method: string): Task_1<Stream>;
    openWriteTaskAsync(address: Uri, method: string): Task_1<Stream>;
    uploadData(address: string, data: byte[]): byte[];
    uploadData(address: Uri, data: byte[]): byte[];
    uploadData(address: string, method: string, data: byte[]): byte[];
    uploadData(address: Uri, method: string, data: byte[]): byte[];
    uploadDataAsync(address: Uri, data: byte[]): void;
    uploadDataAsync(address: Uri, method: string, data: byte[]): void;
    uploadDataAsync(address: Uri, method: string, data: byte[], userToken: unknown): void;
    uploadDataTaskAsync(address: string, data: byte[]): Task_1<byte[]>;
    uploadDataTaskAsync(address: Uri, data: byte[]): Task_1<byte[]>;
    uploadDataTaskAsync(address: string, method: string, data: byte[]): Task_1<byte[]>;
    uploadDataTaskAsync(address: Uri, method: string, data: byte[]): Task_1<byte[]>;
    uploadFile(address: string, fileName: string): byte[];
    uploadFile(address: Uri, fileName: string): byte[];
    uploadFile(address: string, method: string, fileName: string): byte[];
    uploadFile(address: Uri, method: string, fileName: string): byte[];
    uploadFileAsync(address: Uri, fileName: string): void;
    uploadFileAsync(address: Uri, method: string, fileName: string): void;
    uploadFileAsync(address: Uri, method: string, fileName: string, userToken: unknown): void;
    uploadFileTaskAsync(address: string, fileName: string): Task_1<byte[]>;
    uploadFileTaskAsync(address: Uri, fileName: string): Task_1<byte[]>;
    uploadFileTaskAsync(address: string, method: string, fileName: string): Task_1<byte[]>;
    uploadFileTaskAsync(address: Uri, method: string, fileName: string): Task_1<byte[]>;
    uploadString(address: string, data: string): string;
    uploadString(address: Uri, data: string): string;
    uploadString(address: string, method: string, data: string): string;
    uploadString(address: Uri, method: string, data: string): string;
    uploadStringAsync(address: Uri, data: string): void;
    uploadStringAsync(address: Uri, method: string, data: string): void;
    uploadStringAsync(address: Uri, method: string, data: string, userToken: unknown): void;
    uploadStringTaskAsync(address: string, data: string): Task_1<CLROf<string>>;
    uploadStringTaskAsync(address: Uri, data: string): Task_1<CLROf<string>>;
    uploadStringTaskAsync(address: string, method: string, data: string): Task_1<CLROf<string>>;
    uploadStringTaskAsync(address: Uri, method: string, data: string): Task_1<CLROf<string>>;
    uploadValues(address: string, data: NameValueCollection): byte[];
    uploadValues(address: Uri, data: NameValueCollection): byte[];
    uploadValues(address: string, method: string, data: NameValueCollection): byte[];
    uploadValues(address: Uri, method: string, data: NameValueCollection): byte[];
    uploadValuesAsync(address: Uri, data: NameValueCollection): void;
    uploadValuesAsync(address: Uri, method: string, data: NameValueCollection): void;
    uploadValuesAsync(address: Uri, method: string, data: NameValueCollection, userToken: unknown): void;
    uploadValuesTaskAsync(address: string, data: NameValueCollection): Task_1<byte[]>;
    uploadValuesTaskAsync(address: string, method: string, data: NameValueCollection): Task_1<byte[]>;
    uploadValuesTaskAsync(address: Uri, data: NameValueCollection): Task_1<byte[]>;
    uploadValuesTaskAsync(address: Uri, method: string, data: NameValueCollection): Task_1<byte[]>;
}


export const WebClient: {
    new(): WebClient$instance;
};


export interface __WebClient$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface WebClient$instance extends System_ComponentModel_Internal.IComponent$instance {}

export type WebClient = WebClient$instance & __WebClient$views;


export interface WebException$instance extends InvalidOperationException {
    readonly response: WebResponse;
    readonly status: WebExceptionStatus;
    getObjectData(serializationInfo: SerializationInfo, streamingContext: StreamingContext): void;
}


export const WebException: {
    new(): WebException$instance;
    new(message: string): WebException$instance;
    new(message: string, innerException: Exception): WebException$instance;
    new(message: string, status: WebExceptionStatus): WebException$instance;
    new(message: string, innerException: Exception, status: WebExceptionStatus, response: WebResponse): WebException$instance;
};


export interface __WebException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type WebException = WebException$instance & __WebException$views;


export interface WebHeaderCollection$instance extends NameValueCollection {
    readonly allKeys: string[];
    readonly count: int;
    readonly keys: NameObjectCollectionBase_KeysCollection;
    add(header: HttpResponseHeader, value: string): void;
    add(name: string, value: string): void;
    add(c: NameValueCollection): void;
    clear(): void;
    copyTo(dest: ClrArray, index: int): void;
    get_(index: int): string;
    get_(name: string): string;
    getEnumerator(): IEnumerator;
    getKey(index: int): string;
    getObjectData(serializationInfo: SerializationInfo, streamingContext: StreamingContext): void;
    getValues(index: int): string[];
    getValues(header: string): string[];
    onDeserialization(sender: unknown): void;
    remove(header: HttpResponseHeader): void;
    remove(name: string): void;
    set_(name: string, value: string): void;
    set_(header: HttpResponseHeader, value: string): void;
    toByteArray(): byte[];
    toString(): string;
}


export const WebHeaderCollection: {
    new(): WebHeaderCollection$instance;
    isRestricted(headerName: string, response: boolean): boolean;
    isRestricted(headerName: string): boolean;
};


export interface __WebHeaderCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type WebHeaderCollection = WebHeaderCollection$instance & __WebHeaderCollection$views;


export interface WebProxy$instance {
    address: Uri;
    readonly bypassArrayList: ArrayList;
    bypassList: string[];
    bypassProxyOnLocal: boolean;
    credentials: ICredentials;
    useDefaultCredentials: boolean;
    getProxy(destination: Uri): Uri;
    isBypassed(host: Uri): boolean;
}


export const WebProxy: {
    new(): WebProxy$instance;
    new(Address: Uri): WebProxy$instance;
    new(Address: Uri, BypassOnLocal: boolean): WebProxy$instance;
    new(Address: Uri, BypassOnLocal: boolean, BypassList: string[]): WebProxy$instance;
    new(Address: Uri, BypassOnLocal: boolean, BypassList: string[], Credentials: ICredentials): WebProxy$instance;
    new(Host: string, Port: int): WebProxy$instance;
    new(Address: string): WebProxy$instance;
    new(Address: string, BypassOnLocal: boolean): WebProxy$instance;
    new(Address: string, BypassOnLocal: boolean, BypassList: string[]): WebProxy$instance;
    new(Address: string, BypassOnLocal: boolean, BypassList: string[], Credentials: ICredentials): WebProxy$instance;
    getDefaultProxy(): WebProxy;
};


export interface __WebProxy$views {
    As_IWebProxy(): IWebProxy$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface WebProxy$instance extends IWebProxy$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type WebProxy = WebProxy$instance & __WebProxy$views;


export interface WebRequest$instance extends MarshalByRefObject {
    authenticationLevel: AuthenticationLevel;
    cachePolicy: RequestCachePolicy;
    connectionGroupName: string;
    contentLength: long;
    contentType: string;
    credentials: ICredentials;
    headers: WebHeaderCollection;
    impersonationLevel: TokenImpersonationLevel;
    method: string;
    preAuthenticate: boolean;
    proxy: IWebProxy;
    readonly requestUri: Uri;
    timeout: int;
    useDefaultCredentials: boolean;
    abort(): void;
    beginGetRequestStream(callback: AsyncCallback, state: unknown): IAsyncResult;
    beginGetResponse(callback: AsyncCallback, state: unknown): IAsyncResult;
    endGetRequestStream(asyncResult: IAsyncResult): Stream;
    endGetResponse(asyncResult: IAsyncResult): WebResponse;
    getRequestStream(): Stream;
    getRequestStreamAsync(): Task_1<Stream>;
    getResponse(): WebResponse;
    getResponseAsync(): Task_1<WebResponse>;
}


export const WebRequest: {
    defaultCachePolicy: RequestCachePolicy;
    defaultWebProxy: IWebProxy;
    create(requestUriString: string): WebRequest;
    create(requestUri: Uri): WebRequest;
    createDefault(requestUri: Uri): WebRequest;
    createHttp(requestUriString: string): HttpWebRequest;
    createHttp(requestUri: Uri): HttpWebRequest;
    getSystemWebProxy(): IWebProxy;
    registerPrefix(prefix: string, creator: IWebRequestCreate): boolean;
};


export interface __WebRequest$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface WebRequest$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type WebRequest = WebRequest$instance & __WebRequest$views;


export interface WebResponse$instance extends MarshalByRefObject {
    contentLength: long;
    contentType: string;
    readonly headers: WebHeaderCollection;
    readonly isFromCache: boolean;
    readonly isMutuallyAuthenticated: boolean;
    readonly responseUri: Uri;
    readonly supportsHeaders: boolean;
    close(): void;
    dispose(): void;
    getResponseStream(): Stream;
}


export const WebResponse: {
};


export interface __WebResponse$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface WebResponse$instance extends System_Internal.IDisposable$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type WebResponse = WebResponse$instance & __WebResponse$views;


export interface WriteStreamClosedEventArgs$instance extends EventArgs {
    readonly error: Exception;
}


export const WriteStreamClosedEventArgs: {
    new(): WriteStreamClosedEventArgs$instance;
};


export type WriteStreamClosedEventArgs = WriteStreamClosedEventArgs$instance;

export abstract class Dns$instance {
    static beginGetHostAddresses(hostNameOrAddress: string, requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    static beginGetHostByName(hostName: string, requestCallback: AsyncCallback, stateObject: unknown): IAsyncResult;
    static beginGetHostEntry(address: IPAddress, requestCallback: AsyncCallback, stateObject: unknown): IAsyncResult;
    static beginGetHostEntry(hostNameOrAddress: string, requestCallback: AsyncCallback, stateObject: unknown): IAsyncResult;
    static beginResolve(hostName: string, requestCallback: AsyncCallback, stateObject: unknown): IAsyncResult;
    static endGetHostAddresses(asyncResult: IAsyncResult): IPAddress[];
    static endGetHostByName(asyncResult: IAsyncResult): IPHostEntry;
    static endGetHostEntry(asyncResult: IAsyncResult): IPHostEntry;
    static endResolve(asyncResult: IAsyncResult): IPHostEntry;
    static getHostAddresses(hostNameOrAddress: string, family: AddressFamily): IPAddress[];
    static getHostAddresses(hostNameOrAddress: string): IPAddress[];
    static getHostAddressesAsync(hostNameOrAddress: string, family: AddressFamily, cancellationToken?: CancellationToken): Task_1<IPAddress[]>;
    static getHostAddressesAsync(hostNameOrAddress: string, cancellationToken: CancellationToken): Task_1<IPAddress[]>;
    static getHostAddressesAsync(hostNameOrAddress: string): Task_1<IPAddress[]>;
    static getHostByAddress(address: IPAddress): IPHostEntry;
    static getHostByAddress(address: string): IPHostEntry;
    static getHostByName(hostName: string): IPHostEntry;
    static getHostEntry(address: IPAddress): IPHostEntry;
    static getHostEntry(hostNameOrAddress: string, family: AddressFamily): IPHostEntry;
    static getHostEntry(hostNameOrAddress: string): IPHostEntry;
    static getHostEntryAsync(address: IPAddress): Task_1<IPHostEntry>;
    static getHostEntryAsync(hostNameOrAddress: string, family: AddressFamily, cancellationToken?: CancellationToken): Task_1<IPHostEntry>;
    static getHostEntryAsync(hostNameOrAddress: string, cancellationToken: CancellationToken): Task_1<IPHostEntry>;
    static getHostEntryAsync(hostNameOrAddress: string): Task_1<IPHostEntry>;
    static getHostName(): string;
    static resolve(hostName: string): IPHostEntry;
}


export type Dns = Dns$instance;

export abstract class HttpVersion$instance {
    static readonly unknown_: Version;
    static readonly version10: Version;
    static readonly version11: Version;
    static readonly version20: Version;
    static readonly version30: Version;
}


export type HttpVersion = HttpVersion$instance;

export abstract class WebRequestMethods$instance {
}


export type WebRequestMethods = WebRequestMethods$instance;

export abstract class WebRequestMethods_File$instance {
    static readonly downloadFile: string;
    static readonly uploadFile: string;
}


export type WebRequestMethods_File = WebRequestMethods_File$instance;

export abstract class WebRequestMethods_Ftp$instance {
    static readonly downloadFile: string;
    static readonly listDirectory: string;
    static readonly uploadFile: string;
    static readonly deleteFile: string;
    static readonly appendFile: string;
    static readonly getFileSize: string;
    static readonly uploadFileWithUniqueName: string;
    static readonly makeDirectory: string;
    static readonly removeDirectory: string;
    static readonly listDirectoryDetails: string;
    static readonly getDateTimestamp: string;
    static readonly printWorkingDirectory: string;
    static readonly rename: string;
}


export type WebRequestMethods_Ftp = WebRequestMethods_Ftp$instance;

export abstract class WebRequestMethods_Http$instance {
    static readonly get_: string;
    static readonly connect: string;
    static readonly head: string;
    static readonly put: string;
    static readonly post: string;
    static readonly mkCol: string;
}


export type WebRequestMethods_Http = WebRequestMethods_Http$instance;

export abstract class WebUtility$instance {
    static htmlDecode(value: string, output: TextWriter): void;
    static htmlDecode(value: string): string;
    static htmlEncode(value: string, output: TextWriter): void;
    static htmlEncode(value: string): string;
    static urlDecode(encodedValue: string): string;
    static urlDecodeToBytes(encodedValue: byte[], offset: int, count: int): byte[];
    static urlEncode(value: string): string;
    static urlEncodeToBytes(value: byte[], offset: int, count: int): byte[];
}


export type WebUtility = WebUtility$instance;

