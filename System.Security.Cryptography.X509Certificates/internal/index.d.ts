// Generated by tsbindgen - Architecture
// Namespace: System.Security.Cryptography.X509Certificates
// Assembly: System.Security.Cryptography

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { SafeX509ChainHandle } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { IEnumerable_1, IEnumerator_1 } from "../../System.Collections.Generic/internal/index.js";
import type { Collection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { CollectionBase, ICollection, IDictionary, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import type { UniversalTagNumber } from "../../System.Formats.Asn1/internal/index.js";
import type { IPAddress } from "../../System.Net/internal/index.js";
import type { BigInteger } from "../../System.Numerics/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Security_Cryptography_Internal from "../../System.Security.Cryptography/internal/index.js";
import type { AsnEncodedData, AsymmetricAlgorithm, CompositeMLDsa, CryptographicException, DSA, ECDiffieHellman, ECDsa, HashAlgorithmName, MLDsa, MLKem, Oid, OidCollection, PbeParameters, RSA, RSASignaturePadding, SlhDsa } from "../../System.Security.Cryptography/internal/index.js";
import type { SecureString } from "../../System.Security/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Boolean as ClrBoolean, Byte, Char, DateTime, DateTimeOffset, Enum, Exception, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, Span_1, String as ClrString, TimeSpan, Type, TypeCode, Uri, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum CertificateRequestLoadOptions {
    default_ = 0,
    skipSignatureValidation = 1,
    unsafeLoadCertificateExtensions = 2
}


export enum OpenFlags {
    readOnly = 0,
    readWrite = 1,
    maxAllowed = 2,
    openExistingOnly = 4,
    includeArchived = 8
}


export enum Pkcs12ExportPbeParameters {
    default_ = 0,
    pkcs12TripleDesSha1 = 1,
    pbes2Aes256Sha256 = 2
}


export enum StoreLocation {
    currentUser = 1,
    localMachine = 2
}


export enum StoreName {
    addressBook = 1,
    authRoot = 2,
    certificateAuthority = 3,
    disallowed = 4,
    my = 5,
    root = 6,
    trustedPeople = 7,
    trustedPublisher = 8
}


export enum X500DistinguishedNameFlags {
    none = 0,
    reversed = 1,
    useSemicolons = 16,
    doNotUsePlusSign = 32,
    doNotUseQuotes = 64,
    useCommas = 128,
    useNewLines = 256,
    useUTF8Encoding = 4096,
    useT61Encoding = 8192,
    forceUTF8Encoding = 16384
}


export enum X509ChainStatusFlags {
    noError = 0,
    notTimeValid = 1,
    notTimeNested = 2,
    revoked = 4,
    notSignatureValid = 8,
    notValidForUsage = 16,
    untrustedRoot = 32,
    revocationStatusUnknown = 64,
    cyclic = 128,
    invalidExtension = 256,
    invalidPolicyConstraints = 512,
    invalidBasicConstraints = 1024,
    invalidNameConstraints = 2048,
    hasNotSupportedNameConstraint = 4096,
    hasNotDefinedNameConstraint = 8192,
    hasNotPermittedNameConstraint = 16384,
    hasExcludedNameConstraint = 32768,
    partialChain = 65536,
    ctlNotTimeValid = 131072,
    ctlNotSignatureValid = 262144,
    ctlNotValidForUsage = 524288,
    offlineRevocation = 16777216,
    noIssuanceChainPolicy = 33554432,
    explicitDistrust = 67108864,
    hasNotSupportedCriticalExtension = 134217728,
    hasWeakSignature = 1048576
}


export enum X509ChainTrustMode {
    system = 0,
    customRootTrust = 1
}


export enum X509ContentType {
    unknown_ = 0,
    cert = 1,
    serializedCert = 2,
    pfx = 3,
    pkcs12 = 3,
    serializedStore = 4,
    pkcs7 = 5,
    authenticode = 6
}


export enum X509FindType {
    findByThumbprint = 0,
    findBySubjectName = 1,
    findBySubjectDistinguishedName = 2,
    findByIssuerName = 3,
    findByIssuerDistinguishedName = 4,
    findBySerialNumber = 5,
    findByTimeValid = 6,
    findByTimeNotYetValid = 7,
    findByTimeExpired = 8,
    findByTemplateName = 9,
    findByApplicationPolicy = 10,
    findByCertificatePolicy = 11,
    findByExtension = 12,
    findByKeyUsage = 13,
    findBySubjectKeyIdentifier = 14
}


export enum X509IncludeOption {
    none = 0,
    excludeRoot = 1,
    endCertOnly = 2,
    wholeChain = 3
}


export enum X509KeyStorageFlags {
    defaultKeySet = 0,
    userKeySet = 1,
    machineKeySet = 2,
    exportable = 4,
    userProtected = 8,
    persistKeySet = 16,
    ephemeralKeySet = 32
}


export enum X509KeyUsageFlags {
    none = 0,
    encipherOnly = 1,
    crlSign = 2,
    keyCertSign = 4,
    keyAgreement = 8,
    dataEncipherment = 16,
    keyEncipherment = 32,
    nonRepudiation = 64,
    digitalSignature = 128,
    decipherOnly = 32768
}


export enum X509NameType {
    simpleName = 0,
    emailName = 1,
    upnName = 2,
    dnsName = 3,
    dnsFromAlternativeName = 4,
    urlName = 5
}


export enum X509RevocationFlag {
    endCertificateOnly = 0,
    entireChain = 1,
    excludeRoot = 2
}


export enum X509RevocationMode {
    noCheck = 0,
    online = 1,
    offline = 2
}


export enum X509RevocationReason {
    unspecified = 0,
    keyCompromise = 1,
    caCompromise = 2,
    affiliationChanged = 3,
    superseded = 4,
    cessationOfOperation = 5,
    certificateHold = 6,
    removeFromCrl = 8,
    privilegeWithdrawn = 9,
    aaCompromise = 10,
    weakAlgorithmOrKey = 11
}


export enum X509SubjectKeyIdentifierHashAlgorithm {
    sha1 = 0,
    shortSha1 = 1,
    capiSha1 = 2,
    sha256 = 3,
    sha384 = 4,
    sha512 = 5,
    shortSha256 = 6,
    shortSha384 = 7,
    shortSha512 = 8
}


export enum X509VerificationFlags {
    noFlag = 0,
    ignoreNotTimeValid = 1,
    ignoreCtlNotTimeValid = 2,
    ignoreNotTimeNested = 4,
    ignoreInvalidBasicConstraints = 8,
    allowUnknownCertificateAuthority = 16,
    ignoreWrongUsage = 32,
    ignoreInvalidName = 64,
    ignoreInvalidPolicy = 128,
    ignoreEndRevocationUnknown = 256,
    ignoreCtlSignerRevocationUnknown = 512,
    ignoreCertificateAuthorityRevocationUnknown = 1024,
    ignoreRootRevocationUnknown = 2048,
    allFlags = 4095
}


export interface X509ChainStatus$instance {
    status: X509ChainStatusFlags;
    statusInformation: string;
}


export const X509ChainStatus: {
    new(): X509ChainStatus$instance;
};


export type X509ChainStatus = X509ChainStatus$instance;

export interface CertificateRequest$instance {
    readonly certificateExtensions: Collection_1<X509Extension>;
    readonly hashAlgorithm: HashAlgorithmName;
    readonly otherRequestAttributes: Collection_1<AsnEncodedData>;
    readonly publicKey: PublicKey;
    readonly subjectName: X500DistinguishedName;
    create(issuerCertificate: X509Certificate2, notBefore: DateTimeOffset, notAfter: DateTimeOffset, serialNumber: byte[]): X509Certificate2;
    create(issuerCertificate: X509Certificate2, notBefore: DateTimeOffset, notAfter: DateTimeOffset, serialNumber: ReadOnlySpan_1<CLROf<byte>>): X509Certificate2;
    create(issuerName: X500DistinguishedName, generator: X509SignatureGenerator, notBefore: DateTimeOffset, notAfter: DateTimeOffset, serialNumber: byte[]): X509Certificate2;
    create(issuerName: X500DistinguishedName, generator: X509SignatureGenerator, notBefore: DateTimeOffset, notAfter: DateTimeOffset, serialNumber: ReadOnlySpan_1<CLROf<byte>>): X509Certificate2;
    createSelfSigned(notBefore: DateTimeOffset, notAfter: DateTimeOffset): X509Certificate2;
    createSigningRequest(): byte[];
    createSigningRequest(signatureGenerator: X509SignatureGenerator): byte[];
    createSigningRequestPem(): string;
    createSigningRequestPem(signatureGenerator: X509SignatureGenerator): string;
}


export const CertificateRequest: {
    new(subjectName: string, key: ECDsa, hashAlgorithm: HashAlgorithmName): CertificateRequest$instance;
    new(subjectName: X500DistinguishedName, key: ECDsa, hashAlgorithm: HashAlgorithmName): CertificateRequest$instance;
    new(subjectName: string, key: RSA, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): CertificateRequest$instance;
    new(subjectName: X500DistinguishedName, key: RSA, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): CertificateRequest$instance;
    new(subjectName: string, key: MLDsa): CertificateRequest$instance;
    new(subjectName: X500DistinguishedName, key: MLDsa): CertificateRequest$instance;
    new(subjectName: string, key: SlhDsa): CertificateRequest$instance;
    new(subjectName: X500DistinguishedName, key: SlhDsa): CertificateRequest$instance;
    new(subjectName: string, key: CompositeMLDsa): CertificateRequest$instance;
    new(subjectName: X500DistinguishedName, key: CompositeMLDsa): CertificateRequest$instance;
    new(subjectName: X500DistinguishedName, publicKey: PublicKey, hashAlgorithm: HashAlgorithmName): CertificateRequest$instance;
    new(subjectName: X500DistinguishedName, publicKey: PublicKey, hashAlgorithm: HashAlgorithmName, rsaSignaturePadding: RSASignaturePadding): CertificateRequest$instance;
    loadSigningRequest(pkcs10: byte[], signerHashAlgorithm: HashAlgorithmName, options?: CertificateRequestLoadOptions, signerSignaturePadding?: RSASignaturePadding): CertificateRequest;
    loadSigningRequest(pkcs10: ReadOnlySpan_1<CLROf<byte>>, signerHashAlgorithm: HashAlgorithmName, bytesConsumed: { value: ref<int> }, options?: CertificateRequestLoadOptions, signerSignaturePadding?: RSASignaturePadding): CertificateRequest;
    loadSigningRequestPem(pkcs10Pem: ReadOnlySpan_1<CLROf<char>>, signerHashAlgorithm: HashAlgorithmName, options?: CertificateRequestLoadOptions, signerSignaturePadding?: RSASignaturePadding): CertificateRequest;
    loadSigningRequestPem(pkcs10Pem: string, signerHashAlgorithm: HashAlgorithmName, options?: CertificateRequestLoadOptions, signerSignaturePadding?: RSASignaturePadding): CertificateRequest;
};


export type CertificateRequest = CertificateRequest$instance;

export interface CertificateRevocationListBuilder$instance {
    addEntry(certificate: X509Certificate2, revocationTime?: Nullable_1<DateTimeOffset>, reason?: Nullable_1<X509RevocationReason>): void;
    addEntry(serialNumber: byte[], revocationTime?: Nullable_1<DateTimeOffset>, reason?: Nullable_1<X509RevocationReason>): void;
    addEntry(serialNumber: ReadOnlySpan_1<CLROf<byte>>, revocationTime?: Nullable_1<DateTimeOffset>, reason?: Nullable_1<X509RevocationReason>): void;
    build(issuerCertificate: X509Certificate2, crlNumber: BigInteger, nextUpdate: DateTimeOffset, hashAlgorithm: HashAlgorithmName, rsaSignaturePadding?: RSASignaturePadding, thisUpdate?: Nullable_1<DateTimeOffset>): byte[];
    build(issuerName: X500DistinguishedName, generator: X509SignatureGenerator, crlNumber: BigInteger, nextUpdate: DateTimeOffset, hashAlgorithm: HashAlgorithmName, authorityKeyIdentifier: X509AuthorityKeyIdentifierExtension, thisUpdate?: Nullable_1<DateTimeOffset>): byte[];
    removeEntry(serialNumber: byte[]): boolean;
    removeEntry(serialNumber: ReadOnlySpan_1<CLROf<byte>>): boolean;
}


export const CertificateRevocationListBuilder: {
    new(): CertificateRevocationListBuilder$instance;
    buildCrlDistributionPointExtension(uris: IEnumerable_1<CLROf<string>>, critical?: boolean): X509Extension;
    load(currentCrl: byte[], currentCrlNumber: { value: ref<BigInteger> }): CertificateRevocationListBuilder;
    load(currentCrl: ReadOnlySpan_1<CLROf<byte>>, currentCrlNumber: { value: ref<BigInteger> }, bytesConsumed: { value: ref<int> }): CertificateRevocationListBuilder;
    loadPem(currentCrl: ReadOnlySpan_1<CLROf<char>>, currentCrlNumber: { value: ref<BigInteger> }): CertificateRevocationListBuilder;
    loadPem(currentCrl: string, currentCrlNumber: { value: ref<BigInteger> }): CertificateRevocationListBuilder;
};


export type CertificateRevocationListBuilder = CertificateRevocationListBuilder$instance;

export interface Pkcs12LoaderLimits$instance {
    allowDuplicateAttributes: boolean;
    ignoreEncryptedAuthSafes: boolean;
    ignorePrivateKeys: boolean;
    individualKdfIterationLimit: Nullable_1<CLROf<int>>;
    readonly isReadOnly: boolean;
    macIterationLimit: Nullable_1<CLROf<int>>;
    maxCertificates: Nullable_1<CLROf<int>>;
    maxKeys: Nullable_1<CLROf<int>>;
    preserveCertificateAlias: boolean;
    preserveKeyName: boolean;
    preserveStorageProvider: boolean;
    preserveUnknownAttributes: boolean;
    totalKdfIterationLimit: Nullable_1<CLROf<int>>;
    makeReadOnly(): void;
}


export const Pkcs12LoaderLimits: {
    new(): Pkcs12LoaderLimits$instance;
    new(copyFrom: Pkcs12LoaderLimits): Pkcs12LoaderLimits$instance;
    readonly defaults: Pkcs12LoaderLimits;
    readonly dangerousNoLimits: Pkcs12LoaderLimits;
};


export type Pkcs12LoaderLimits = Pkcs12LoaderLimits$instance;

export interface Pkcs12LoadLimitExceededException$instance extends CryptographicException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const Pkcs12LoadLimitExceededException: {
    new(propertyName: string): Pkcs12LoadLimitExceededException$instance;
};


export interface __Pkcs12LoadLimitExceededException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Pkcs12LoadLimitExceededException = Pkcs12LoadLimitExceededException$instance & __Pkcs12LoadLimitExceededException$views;


export interface PublicKey$instance {
    readonly encodedKeyValue: AsnEncodedData;
    readonly encodedParameters: AsnEncodedData;
    readonly key: AsymmetricAlgorithm;
    readonly oid: Oid;
    exportSubjectPublicKeyInfo(): byte[];
    getCompositeMLDsaPublicKey(): CompositeMLDsa;
    getDSAPublicKey(): DSA;
    getECDiffieHellmanPublicKey(): ECDiffieHellman;
    getECDsaPublicKey(): ECDsa;
    getMLDsaPublicKey(): MLDsa;
    getMLKemPublicKey(): MLKem;
    getRSAPublicKey(): RSA;
    getSlhDsaPublicKey(): SlhDsa;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export const PublicKey: {
    new(oid: Oid, parameters: AsnEncodedData, keyValue: AsnEncodedData): PublicKey$instance;
    new(key: AsymmetricAlgorithm): PublicKey$instance;
    new(key: MLKem): PublicKey$instance;
    new(key: MLDsa): PublicKey$instance;
    new(key: SlhDsa): PublicKey$instance;
    new(key: CompositeMLDsa): PublicKey$instance;
    createFromSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): PublicKey;
};


export type PublicKey = PublicKey$instance;

export interface SubjectAlternativeNameBuilder$instance {
    addDnsName(dnsName: string): void;
    addEmailAddress(emailAddress: string): void;
    addIpAddress(ipAddress: IPAddress): void;
    addUri(uri: Uri): void;
    addUserPrincipalName(upn: string): void;
    build(critical?: boolean): X509Extension;
}


export const SubjectAlternativeNameBuilder: {
    new(): SubjectAlternativeNameBuilder$instance;
};


export type SubjectAlternativeNameBuilder = SubjectAlternativeNameBuilder$instance;

export interface X500DistinguishedName$instance extends AsnEncodedData {
    readonly name: string;
    decode(flag: X500DistinguishedNameFlags): string;
    enumerateRelativeDistinguishedNames(reversed?: boolean): IEnumerable_1<X500RelativeDistinguishedName>;
    format(multiLine: boolean): string;
}


export const X500DistinguishedName: {
    new(encodedDistinguishedName: byte[]): X500DistinguishedName$instance;
    new(encodedDistinguishedName: ReadOnlySpan_1<CLROf<byte>>): X500DistinguishedName$instance;
    new(encodedDistinguishedName: AsnEncodedData): X500DistinguishedName$instance;
    new(distinguishedName: X500DistinguishedName): X500DistinguishedName$instance;
    new(distinguishedName: string): X500DistinguishedName$instance;
    new(distinguishedName: string, flag: X500DistinguishedNameFlags): X500DistinguishedName$instance;
};


export type X500DistinguishedName = X500DistinguishedName$instance;

export interface X500DistinguishedNameBuilder$instance {
    add(oidValue: string, value: string, stringEncodingType?: Nullable_1<UniversalTagNumber>): void;
    add(oid: Oid, value: string, stringEncodingType?: Nullable_1<UniversalTagNumber>): void;
    addCommonName(commonName: string): void;
    addCountryOrRegion(twoLetterCode: string): void;
    addDomainComponent(domainComponent: string): void;
    addEmailAddress(emailAddress: string): void;
    addLocalityName(localityName: string): void;
    addOrganizationalUnitName(organizationalUnitName: string): void;
    addOrganizationName(organizationName: string): void;
    addStateOrProvinceName(stateOrProvinceName: string): void;
    build(): X500DistinguishedName;
}


export const X500DistinguishedNameBuilder: {
    new(): X500DistinguishedNameBuilder$instance;
};


export type X500DistinguishedNameBuilder = X500DistinguishedNameBuilder$instance;

export interface X500RelativeDistinguishedName$instance {
    readonly hasMultipleElements: boolean;
    readonly rawData: ReadOnlyMemory_1<CLROf<byte>>;
    getSingleElementType(): Oid;
    getSingleElementValue(): string;
}


export const X500RelativeDistinguishedName: {
    new(): X500RelativeDistinguishedName$instance;
};


export type X500RelativeDistinguishedName = X500RelativeDistinguishedName$instance;

export interface X509AuthorityInformationAccessExtension$instance extends X509Extension {
    copyFrom(asnEncodedData: AsnEncodedData): void;
    enumerateCAIssuersUris(): IEnumerable_1<CLROf<string>>;
    enumerateOcspUris(): IEnumerable_1<CLROf<string>>;
    enumerateUris(accessMethodOid: string): IEnumerable_1<CLROf<string>>;
    enumerateUris(accessMethodOid: Oid): IEnumerable_1<CLROf<string>>;
}


export const X509AuthorityInformationAccessExtension: {
    new(): X509AuthorityInformationAccessExtension$instance;
    new(rawData: byte[], critical: boolean): X509AuthorityInformationAccessExtension$instance;
    new(rawData: ReadOnlySpan_1<CLROf<byte>>, critical: boolean): X509AuthorityInformationAccessExtension$instance;
    new(ocspUris: IEnumerable_1<CLROf<string>>, caIssuersUris: IEnumerable_1<CLROf<string>>, critical: boolean): X509AuthorityInformationAccessExtension$instance;
};


export type X509AuthorityInformationAccessExtension = X509AuthorityInformationAccessExtension$instance;

export interface X509AuthorityKeyIdentifierExtension$instance extends X509Extension {
    readonly keyIdentifier: Nullable_1<ReadOnlyMemory_1<CLROf<byte>>>;
    readonly namedIssuer: X500DistinguishedName;
    readonly rawIssuer: Nullable_1<ReadOnlyMemory_1<CLROf<byte>>>;
    readonly serialNumber: Nullable_1<ReadOnlyMemory_1<CLROf<byte>>>;
    copyFrom(asnEncodedData: AsnEncodedData): void;
}


export const X509AuthorityKeyIdentifierExtension: {
    new(): X509AuthorityKeyIdentifierExtension$instance;
    new(rawData: byte[], critical: boolean): X509AuthorityKeyIdentifierExtension$instance;
    new(rawData: ReadOnlySpan_1<CLROf<byte>>, critical: boolean): X509AuthorityKeyIdentifierExtension$instance;
    create(keyIdentifier: byte[], issuerName: X500DistinguishedName, serialNumber: byte[]): X509AuthorityKeyIdentifierExtension;
    create(keyIdentifier: ReadOnlySpan_1<CLROf<byte>>, issuerName: X500DistinguishedName, serialNumber: ReadOnlySpan_1<CLROf<byte>>): X509AuthorityKeyIdentifierExtension;
    createFromCertificate(certificate: X509Certificate2, includeKeyIdentifier: boolean, includeIssuerAndSerial: boolean): X509AuthorityKeyIdentifierExtension;
    createFromIssuerNameAndSerialNumber(issuerName: X500DistinguishedName, serialNumber: byte[]): X509AuthorityKeyIdentifierExtension;
    createFromIssuerNameAndSerialNumber(issuerName: X500DistinguishedName, serialNumber: ReadOnlySpan_1<CLROf<byte>>): X509AuthorityKeyIdentifierExtension;
    createFromSubjectKeyIdentifier(subjectKeyIdentifier: byte[]): X509AuthorityKeyIdentifierExtension;
    createFromSubjectKeyIdentifier(subjectKeyIdentifier: ReadOnlySpan_1<CLROf<byte>>): X509AuthorityKeyIdentifierExtension;
    createFromSubjectKeyIdentifier(subjectKeyIdentifier: X509SubjectKeyIdentifierExtension): X509AuthorityKeyIdentifierExtension;
};


export type X509AuthorityKeyIdentifierExtension = X509AuthorityKeyIdentifierExtension$instance;

export interface X509BasicConstraintsExtension$instance extends X509Extension {
    readonly certificateAuthority: boolean;
    readonly hasPathLengthConstraint: boolean;
    readonly pathLengthConstraint: int;
    copyFrom(asnEncodedData: AsnEncodedData): void;
}


export const X509BasicConstraintsExtension: {
    new(): X509BasicConstraintsExtension$instance;
    new(certificateAuthority: boolean, hasPathLengthConstraint: boolean, pathLengthConstraint: int, critical: boolean): X509BasicConstraintsExtension$instance;
    new(encodedBasicConstraints: AsnEncodedData, critical: boolean): X509BasicConstraintsExtension$instance;
    createForCertificateAuthority(pathLengthConstraint?: Nullable_1<CLROf<int>>): X509BasicConstraintsExtension;
    createForEndEntity(critical?: boolean): X509BasicConstraintsExtension;
};


export type X509BasicConstraintsExtension = X509BasicConstraintsExtension$instance;

export interface X509Certificate$instance {
    readonly handle: nint;
    readonly issuer: string;
    readonly serialNumberBytes: ReadOnlyMemory_1<CLROf<byte>>;
    readonly subject: string;
    dispose(): void;
    equals(obj: unknown): boolean;
    equals(other: X509Certificate): boolean;
    export_(contentType: X509ContentType): byte[];
    export_(contentType: X509ContentType, password: string): byte[];
    export_(contentType: X509ContentType, password: SecureString): byte[];
    exportPkcs12(exportParameters: Pkcs12ExportPbeParameters, password: string): byte[];
    exportPkcs12(exportParameters: PbeParameters, password: string): byte[];
    getCertHash(): byte[];
    getCertHash(hashAlgorithm: HashAlgorithmName): byte[];
    getCertHashString(): string;
    getCertHashString(hashAlgorithm: HashAlgorithmName): string;
    getEffectiveDateString(): string;
    getExpirationDateString(): string;
    getFormat(): string;
    getHashCode(): int;
    getIssuerName(): string;
    getKeyAlgorithm(): string;
    getKeyAlgorithmParameters(): byte[];
    getKeyAlgorithmParametersString(): string;
    getName(): string;
    getPublicKey(): byte[];
    getPublicKeyString(): string;
    getRawCertData(): byte[];
    getRawCertDataString(): string;
    getSerialNumber(): byte[];
    getSerialNumberString(): string;
    import_(rawData: byte[]): void;
    import_(rawData: byte[], password: string, keyStorageFlags: X509KeyStorageFlags): void;
    import_(rawData: byte[], password: SecureString, keyStorageFlags: X509KeyStorageFlags): void;
    import_(fileName: string): void;
    import_(fileName: string, password: string, keyStorageFlags: X509KeyStorageFlags): void;
    import_(fileName: string, password: SecureString, keyStorageFlags: X509KeyStorageFlags): void;
    reset(): void;
    toString(): string;
    toString(fVerbose: boolean): string;
    tryGetCertHash(hashAlgorithm: HashAlgorithmName, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export const X509Certificate: {
    new(): X509Certificate$instance;
    new(data: byte[]): X509Certificate$instance;
    new(rawData: byte[], password: string): X509Certificate$instance;
    new(rawData: byte[], password: SecureString): X509Certificate$instance;
    new(rawData: byte[], password: string, keyStorageFlags: X509KeyStorageFlags): X509Certificate$instance;
    new(rawData: byte[], password: SecureString, keyStorageFlags: X509KeyStorageFlags): X509Certificate$instance;
    new(handle: nint): X509Certificate$instance;
    new(fileName: string): X509Certificate$instance;
    new(fileName: string, password: string): X509Certificate$instance;
    new(fileName: string, password: SecureString): X509Certificate$instance;
    new(fileName: string, password: string, keyStorageFlags: X509KeyStorageFlags): X509Certificate$instance;
    new(fileName: string, password: SecureString, keyStorageFlags: X509KeyStorageFlags): X509Certificate$instance;
    new(cert: X509Certificate): X509Certificate$instance;
    new(info: SerializationInfo, context: StreamingContext): X509Certificate$instance;
    createFromCertFile(filename: string): X509Certificate;
    createFromSignedFile(filename: string): X509Certificate;
};


export interface __X509Certificate$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface X509Certificate$instance extends System_Internal.IDisposable$instance, System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type X509Certificate = X509Certificate$instance & __X509Certificate$views;


export interface X509Certificate2$instance extends X509Certificate$instance {
    archived: boolean;
    readonly extensions: X509ExtensionCollection;
    friendlyName: string;
    readonly hasPrivateKey: boolean;
    readonly issuerName: X500DistinguishedName;
    readonly notAfter: DateTime;
    readonly notBefore: DateTime;
    privateKey: AsymmetricAlgorithm;
    readonly publicKey: PublicKey;
    readonly rawData: byte[];
    readonly rawDataMemory: ReadOnlyMemory_1<CLROf<byte>>;
    readonly serialNumber: string;
    readonly signatureAlgorithm: Oid;
    readonly subjectName: X500DistinguishedName;
    readonly thumbprint: string;
    readonly version: int;
    copyWithPrivateKey(privateKey: ECDiffieHellman): X509Certificate2;
    copyWithPrivateKey(privateKey: MLKem): X509Certificate2;
    copyWithPrivateKey(privateKey: MLDsa): X509Certificate2;
    copyWithPrivateKey(privateKey: SlhDsa): X509Certificate2;
    copyWithPrivateKey(privateKey: CompositeMLDsa): X509Certificate2;
    dispose(): void;
    exportCertificatePem(): string;
    getCompositeMLDsaPrivateKey(): CompositeMLDsa;
    getCompositeMLDsaPublicKey(): CompositeMLDsa;
    getECDiffieHellmanPrivateKey(): ECDiffieHellman;
    getECDiffieHellmanPublicKey(): ECDiffieHellman;
    getMLDsaPrivateKey(): MLDsa;
    getMLDsaPublicKey(): MLDsa;
    getMLKemPrivateKey(): MLKem;
    getMLKemPublicKey(): MLKem;
    getNameInfo(nameType: X509NameType, forIssuer: boolean): string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getSlhDsaPrivateKey(): SlhDsa;
    getSlhDsaPublicKey(): SlhDsa;
    import_(rawData: byte[]): void;
    import_(rawData: byte[], password: string, keyStorageFlags: X509KeyStorageFlags): void;
    import_(rawData: byte[], password: SecureString, keyStorageFlags: X509KeyStorageFlags): void;
    import_(fileName: string): void;
    import_(fileName: string, password: string, keyStorageFlags: X509KeyStorageFlags): void;
    import_(fileName: string, password: SecureString, keyStorageFlags: X509KeyStorageFlags): void;
    matchesHostname(hostname: string, allowWildcards?: boolean, allowCommonName?: boolean): boolean;
    onDeserialization(sender: unknown): void;
    reset(): void;
    toString(): string;
    toString(verbose: boolean): string;
    tryExportCertificatePem(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    verify(): boolean;
}


export const X509Certificate2: {
    new(): X509Certificate2$instance;
    new(rawData: byte[]): X509Certificate2$instance;
    new(rawData: byte[], password: string): X509Certificate2$instance;
    new(rawData: byte[], password: SecureString): X509Certificate2$instance;
    new(rawData: byte[], password: string, keyStorageFlags: X509KeyStorageFlags): X509Certificate2$instance;
    new(rawData: byte[], password: SecureString, keyStorageFlags: X509KeyStorageFlags): X509Certificate2$instance;
    new(rawData: ReadOnlySpan_1<CLROf<byte>>): X509Certificate2$instance;
    new(rawData: ReadOnlySpan_1<CLROf<byte>>, password: ReadOnlySpan_1<CLROf<char>>, keyStorageFlags: X509KeyStorageFlags): X509Certificate2$instance;
    new(handle: nint): X509Certificate2$instance;
    new(fileName: string): X509Certificate2$instance;
    new(fileName: string, password: string): X509Certificate2$instance;
    new(fileName: string, password: SecureString): X509Certificate2$instance;
    new(fileName: string, password: string, keyStorageFlags: X509KeyStorageFlags): X509Certificate2$instance;
    new(fileName: string, password: SecureString, keyStorageFlags: X509KeyStorageFlags): X509Certificate2$instance;
    new(fileName: string, password: ReadOnlySpan_1<CLROf<char>>, keyStorageFlags: X509KeyStorageFlags): X509Certificate2$instance;
    new(certificate: X509Certificate): X509Certificate2$instance;
    createFromEncryptedPem(certPem: ReadOnlySpan_1<CLROf<char>>, keyPem: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): X509Certificate2;
    createFromEncryptedPemFile(certPemFilePath: string, password: ReadOnlySpan_1<CLROf<char>>, keyPemFilePath?: string): X509Certificate2;
    createFromPem(certPem: ReadOnlySpan_1<CLROf<char>>, keyPem: ReadOnlySpan_1<CLROf<char>>): X509Certificate2;
    createFromPem(certPem: ReadOnlySpan_1<CLROf<char>>): X509Certificate2;
    createFromPemFile(certPemFilePath: string, keyPemFilePath?: string): X509Certificate2;
    getCertContentType(rawData: byte[]): X509ContentType;
    getCertContentType(rawData: ReadOnlySpan_1<CLROf<byte>>): X509ContentType;
    getCertContentType(fileName: string): X509ContentType;
};


export interface __X509Certificate2$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface X509Certificate2$instance extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type X509Certificate2 = X509Certificate2$instance & __X509Certificate2$views;


export interface X509Certificate2Collection$instance extends X509CertificateCollection$instance {
    add(value: X509Certificate): int;
    add(value: unknown): int;
    addRange(certificates: X509Certificate2Collection): void;
    addRange(value: X509Certificate[]): void;
    addRange(value: X509CertificateCollection): void;
    clear(): void;
    contains(value: X509Certificate): boolean;
    contains(value: unknown): boolean;
    copyTo(array: X509Certificate[], index: int): void;
    copyTo(array: ClrArray, index: int): void;
    export_(contentType: X509ContentType): byte[];
    export_(contentType: X509ContentType, password: string): byte[];
    exportCertificatePems(): string;
    exportPkcs12(exportParameters: Pkcs12ExportPbeParameters, password: string): byte[];
    exportPkcs12(exportParameters: PbeParameters, password: string): byte[];
    exportPkcs7Pem(): string;
    find(findType: X509FindType, findValue: unknown, validOnly: boolean): X509Certificate2Collection;
    findByThumbprint(hashAlgorithm: HashAlgorithmName, thumbprintHex: string): X509Certificate2Collection;
    findByThumbprint(hashAlgorithm: HashAlgorithmName, thumbprintHex: ReadOnlySpan_1<CLROf<char>>): X509Certificate2Collection;
    findByThumbprint(hashAlgorithm: HashAlgorithmName, thumbprintBytes: ReadOnlySpan_1<CLROf<byte>>): X509Certificate2Collection;
    getEnumerator(): X509CertificateCollection_X509CertificateEnumerator;
    getEnumerator(): IEnumerator;
    import_(rawData: byte[]): void;
    import_(rawData: ReadOnlySpan_1<CLROf<byte>>): void;
    import_(rawData: byte[], password: string, keyStorageFlags?: X509KeyStorageFlags): void;
    import_(rawData: ReadOnlySpan_1<CLROf<byte>>, password: string, keyStorageFlags?: X509KeyStorageFlags): void;
    import_(rawData: ReadOnlySpan_1<CLROf<byte>>, password: ReadOnlySpan_1<CLROf<char>>, keyStorageFlags?: X509KeyStorageFlags): void;
    import_(fileName: string): void;
    import_(fileName: string, password: string, keyStorageFlags?: X509KeyStorageFlags): void;
    import_(fileName: string, password: ReadOnlySpan_1<CLROf<char>>, keyStorageFlags?: X509KeyStorageFlags): void;
    importFromPem(certPem: ReadOnlySpan_1<CLROf<char>>): void;
    importFromPemFile(certPemFilePath: string): void;
    indexOf(value: X509Certificate): int;
    insert(index: int, value: X509Certificate): void;
    insert(index: int, value: unknown): void;
    remove(value: X509Certificate): void;
    remove(value: unknown): void;
    removeAt(index: int): void;
    removeRange(certificates: X509Certificate2[]): void;
    removeRange(certificates: X509Certificate2Collection): void;
    tryExportCertificatePems(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    tryExportPkcs7Pem(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
}


export const X509Certificate2Collection: {
    new(): X509Certificate2Collection$instance;
    new(certificate: X509Certificate2): X509Certificate2Collection$instance;
    new(certificates: X509Certificate2[]): X509Certificate2Collection$instance;
    new(certificates: X509Certificate2Collection): X509Certificate2Collection$instance;
};


export interface __X509Certificate2Collection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<X509Certificate2>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type X509Certificate2Collection = X509Certificate2Collection$instance & __X509Certificate2Collection$views;


export interface X509Certificate2Enumerator$instance {
    readonly current: X509Certificate2;
    moveNext(): boolean;
    reset(): void;
}


export const X509Certificate2Enumerator: {
    new(): X509Certificate2Enumerator$instance;
};


export interface __X509Certificate2Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<X509Certificate2>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type X509Certificate2Enumerator = X509Certificate2Enumerator$instance & __X509Certificate2Enumerator$views;


export interface X509CertificateCollection$instance extends CollectionBase {
    item: X509Certificate | X509Certificate2;
    add(value: unknown): int;
    addRange(value: X509Certificate[]): void;
    addRange(value: X509CertificateCollection): void;
    clear(): void;
    contains(value: unknown): boolean;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator;
    getHashCode(): int;
    indexOf(value: X509Certificate): int;
    insert(index: int, value: unknown): void;
    remove(value: unknown): void;
    removeAt(index: int): void;
}


export const X509CertificateCollection: {
    new(): X509CertificateCollection$instance;
    new(value: X509Certificate[]): X509CertificateCollection$instance;
    new(value: X509CertificateCollection): X509CertificateCollection$instance;
};


export interface __X509CertificateCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type X509CertificateCollection = X509CertificateCollection$instance & __X509CertificateCollection$views;


export interface X509CertificateCollection_X509CertificateEnumerator$instance {
    readonly current: unknown | X509Certificate;
    moveNext(): boolean;
    reset(): void;
}


export const X509CertificateCollection_X509CertificateEnumerator: {
    new(mappings: X509CertificateCollection): X509CertificateCollection_X509CertificateEnumerator$instance;
};


export interface __X509CertificateCollection_X509CertificateEnumerator$views {
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type X509CertificateCollection_X509CertificateEnumerator = X509CertificateCollection_X509CertificateEnumerator$instance & __X509CertificateCollection_X509CertificateEnumerator$views;


export interface X509Chain$instance {
    readonly chainContext: nint;
    readonly chainElements: X509ChainElementCollection;
    chainPolicy: X509ChainPolicy;
    readonly chainStatus: X509ChainStatus[];
    readonly safeHandle: SafeX509ChainHandle;
    build(certificate: X509Certificate2): boolean;
    dispose(): void;
    reset(): void;
}


export const X509Chain: {
    new(): X509Chain$instance;
    new(useMachineContext: boolean): X509Chain$instance;
    new(chainContext: nint): X509Chain$instance;
    create(): X509Chain;
};


export interface __X509Chain$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface X509Chain$instance extends System_Internal.IDisposable$instance {}

export type X509Chain = X509Chain$instance & __X509Chain$views;


export interface X509ChainElement$instance {
    readonly certificate: X509Certificate2;
    readonly chainElementStatus: X509ChainStatus[];
    readonly information: string;
}


export const X509ChainElement: {
    new(): X509ChainElement$instance;
};


export type X509ChainElement = X509ChainElement$instance;

export interface X509ChainElementCollection$instance {
    readonly count: int;
    readonly isSynchronized: boolean;
    readonly item: X509ChainElement;
    readonly syncRoot: unknown;
    copyTo(array: X509ChainElement[], index: int): void;
    getEnumerator(): X509ChainElementEnumerator;
}


export const X509ChainElementCollection: {
    new(): X509ChainElementCollection$instance;
};


export interface __X509ChainElementCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<X509ChainElement>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type X509ChainElementCollection = X509ChainElementCollection$instance & __X509ChainElementCollection$views;


export interface X509ChainElementEnumerator$instance {
    readonly current: X509ChainElement;
    moveNext(): boolean;
    reset(): void;
}


export const X509ChainElementEnumerator: {
    new(): X509ChainElementEnumerator$instance;
};


export interface __X509ChainElementEnumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<X509ChainElement>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type X509ChainElementEnumerator = X509ChainElementEnumerator$instance & __X509ChainElementEnumerator$views;


export interface X509ChainPolicy$instance {
    readonly applicationPolicy: OidCollection;
    readonly certificatePolicy: OidCollection;
    readonly customTrustStore: X509Certificate2Collection;
    disableCertificateDownloads: boolean;
    readonly extraStore: X509Certificate2Collection;
    revocationFlag: X509RevocationFlag;
    revocationMode: X509RevocationMode;
    trustMode: X509ChainTrustMode;
    urlRetrievalTimeout: TimeSpan;
    verificationFlags: X509VerificationFlags;
    verificationTime: DateTime;
    verificationTimeIgnored: boolean;
    clone(): X509ChainPolicy;
    reset(): void;
}


export const X509ChainPolicy: {
    new(): X509ChainPolicy$instance;
};


export type X509ChainPolicy = X509ChainPolicy$instance;

export interface X509EnhancedKeyUsageExtension$instance extends X509Extension {
    readonly enhancedKeyUsages: OidCollection;
    copyFrom(asnEncodedData: AsnEncodedData): void;
}


export const X509EnhancedKeyUsageExtension: {
    new(): X509EnhancedKeyUsageExtension$instance;
    new(encodedEnhancedKeyUsages: AsnEncodedData, critical: boolean): X509EnhancedKeyUsageExtension$instance;
    new(enhancedKeyUsages: OidCollection, critical: boolean): X509EnhancedKeyUsageExtension$instance;
};


export type X509EnhancedKeyUsageExtension = X509EnhancedKeyUsageExtension$instance;

export interface X509Extension$instance extends AsnEncodedData {
    critical: boolean;
    copyFrom(asnEncodedData: AsnEncodedData): void;
}


export const X509Extension: {
    new(encodedExtension: AsnEncodedData, critical: boolean): X509Extension$instance;
    new(oid: Oid, rawData: byte[], critical: boolean): X509Extension$instance;
    new(oid: Oid, rawData: ReadOnlySpan_1<CLROf<byte>>, critical: boolean): X509Extension$instance;
    new(oid: string, rawData: byte[], critical: boolean): X509Extension$instance;
    new(oid: string, rawData: ReadOnlySpan_1<CLROf<byte>>, critical: boolean): X509Extension$instance;
};


export type X509Extension = X509Extension$instance;

export interface X509ExtensionCollection$instance {
    readonly count: int;
    readonly isSynchronized: boolean;
    readonly syncRoot: unknown;
    add(extension: X509Extension): int;
    copyTo(array: X509Extension[], index: int): void;
    get_Item(index: int): X509Extension;
    get_Item(oid: string): X509Extension;
    getEnumerator(): X509ExtensionEnumerator;
}


export const X509ExtensionCollection: {
    new(): X509ExtensionCollection$instance;
};


export interface __X509ExtensionCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<X509Extension>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type X509ExtensionCollection = X509ExtensionCollection$instance & __X509ExtensionCollection$views;


export interface X509ExtensionEnumerator$instance {
    readonly current: X509Extension;
    moveNext(): boolean;
    reset(): void;
}


export const X509ExtensionEnumerator: {
    new(): X509ExtensionEnumerator$instance;
};


export interface __X509ExtensionEnumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<X509Extension>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type X509ExtensionEnumerator = X509ExtensionEnumerator$instance & __X509ExtensionEnumerator$views;


export interface X509KeyUsageExtension$instance extends X509Extension {
    readonly keyUsages: X509KeyUsageFlags;
    copyFrom(asnEncodedData: AsnEncodedData): void;
}


export const X509KeyUsageExtension: {
    new(): X509KeyUsageExtension$instance;
    new(encodedKeyUsage: AsnEncodedData, critical: boolean): X509KeyUsageExtension$instance;
    new(keyUsages: X509KeyUsageFlags, critical: boolean): X509KeyUsageExtension$instance;
};


export type X509KeyUsageExtension = X509KeyUsageExtension$instance;

export interface X509SignatureGenerator$instance {
    readonly publicKey: PublicKey;
    getSignatureAlgorithmIdentifier(hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: byte[], hashAlgorithm: HashAlgorithmName): byte[];
}


export const X509SignatureGenerator: {
    createForCompositeMLDsa(key: CompositeMLDsa): X509SignatureGenerator;
    createForECDsa(key: ECDsa): X509SignatureGenerator;
    createForMLDsa(key: MLDsa): X509SignatureGenerator;
    createForRSA(key: RSA, signaturePadding: RSASignaturePadding): X509SignatureGenerator;
    createForSlhDsa(key: SlhDsa): X509SignatureGenerator;
};


export type X509SignatureGenerator = X509SignatureGenerator$instance;

export interface X509Store$instance {
    readonly certificates: X509Certificate2Collection;
    readonly isOpen: boolean;
    readonly location: StoreLocation;
    readonly name: string;
    readonly storeHandle: nint;
    add(certificate: X509Certificate2): void;
    addRange(certificates: X509Certificate2Collection): void;
    close(): void;
    dispose(): void;
    open(flags: OpenFlags): void;
    remove(certificate: X509Certificate2): void;
    removeRange(certificates: X509Certificate2Collection): void;
}


export const X509Store: {
    new(): X509Store$instance;
    new(storeName: string): X509Store$instance;
    new(storeName: StoreName): X509Store$instance;
    new(storeLocation: StoreLocation): X509Store$instance;
    new(storeName: StoreName, storeLocation: StoreLocation): X509Store$instance;
    new(storeName: StoreName, storeLocation: StoreLocation, flags: OpenFlags): X509Store$instance;
    new(storeName: string, storeLocation: StoreLocation): X509Store$instance;
    new(storeName: string, storeLocation: StoreLocation, flags: OpenFlags): X509Store$instance;
    new(storeHandle: nint): X509Store$instance;
};


export interface __X509Store$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface X509Store$instance extends System_Internal.IDisposable$instance {}

export type X509Store = X509Store$instance & __X509Store$views;


export interface X509SubjectAlternativeNameExtension$instance extends X509Extension {
    copyFrom(asnEncodedData: AsnEncodedData): void;
    enumerateDnsNames(): IEnumerable_1<CLROf<string>>;
    enumerateIPAddresses(): IEnumerable_1<IPAddress>;
}


export const X509SubjectAlternativeNameExtension: {
    new(): X509SubjectAlternativeNameExtension$instance;
    new(rawData: byte[], critical: boolean): X509SubjectAlternativeNameExtension$instance;
    new(rawData: ReadOnlySpan_1<CLROf<byte>>, critical: boolean): X509SubjectAlternativeNameExtension$instance;
};


export type X509SubjectAlternativeNameExtension = X509SubjectAlternativeNameExtension$instance;

export interface X509SubjectKeyIdentifierExtension$instance extends X509Extension {
    readonly subjectKeyIdentifier: string;
    readonly subjectKeyIdentifierBytes: ReadOnlyMemory_1<CLROf<byte>>;
    copyFrom(asnEncodedData: AsnEncodedData): void;
}


export const X509SubjectKeyIdentifierExtension: {
    new(): X509SubjectKeyIdentifierExtension$instance;
    new(encodedSubjectKeyIdentifier: AsnEncodedData, critical: boolean): X509SubjectKeyIdentifierExtension$instance;
    new(subjectKeyIdentifier: byte[], critical: boolean): X509SubjectKeyIdentifierExtension$instance;
    new(subjectKeyIdentifier: ReadOnlySpan_1<CLROf<byte>>, critical: boolean): X509SubjectKeyIdentifierExtension$instance;
    new(key: PublicKey, critical: boolean): X509SubjectKeyIdentifierExtension$instance;
    new(key: PublicKey, algorithm: X509SubjectKeyIdentifierHashAlgorithm, critical: boolean): X509SubjectKeyIdentifierExtension$instance;
    new(subjectKeyIdentifier: string, critical: boolean): X509SubjectKeyIdentifierExtension$instance;
};


export type X509SubjectKeyIdentifierExtension = X509SubjectKeyIdentifierExtension$instance;

export abstract class DSACertificateExtensions$instance {
    static copyWithPrivateKey(certificate: X509Certificate2, privateKey: DSA): X509Certificate2;
    static getDSAPrivateKey(certificate: X509Certificate2): DSA;
    static getDSAPublicKey(certificate: X509Certificate2): DSA;
}


export type DSACertificateExtensions = DSACertificateExtensions$instance;

export abstract class ECDsaCertificateExtensions$instance {
    static copyWithPrivateKey(certificate: X509Certificate2, privateKey: ECDsa): X509Certificate2;
    static getECDsaPrivateKey(certificate: X509Certificate2): ECDsa;
    static getECDsaPublicKey(certificate: X509Certificate2): ECDsa;
}


export type ECDsaCertificateExtensions = ECDsaCertificateExtensions$instance;

export abstract class RSACertificateExtensions$instance {
    static copyWithPrivateKey(certificate: X509Certificate2, privateKey: RSA): X509Certificate2;
    static getRSAPrivateKey(certificate: X509Certificate2): RSA;
    static getRSAPublicKey(certificate: X509Certificate2): RSA;
}


export type RSACertificateExtensions = RSACertificateExtensions$instance;

export abstract class X509CertificateLoader$instance {
    static loadCertificate(data: byte[]): X509Certificate2;
    static loadCertificate(data: ReadOnlySpan_1<CLROf<byte>>): X509Certificate2;
    static loadCertificateFromFile(path: string): X509Certificate2;
    static loadPkcs12(data: byte[], password: string, keyStorageFlags?: X509KeyStorageFlags, loaderLimits?: Pkcs12LoaderLimits): X509Certificate2;
    static loadPkcs12(data: ReadOnlySpan_1<CLROf<byte>>, password: ReadOnlySpan_1<CLROf<char>>, keyStorageFlags?: X509KeyStorageFlags, loaderLimits?: Pkcs12LoaderLimits): X509Certificate2;
    static loadPkcs12Collection(data: byte[], password: string, keyStorageFlags?: X509KeyStorageFlags, loaderLimits?: Pkcs12LoaderLimits): X509Certificate2Collection;
    static loadPkcs12Collection(data: ReadOnlySpan_1<CLROf<byte>>, password: ReadOnlySpan_1<CLROf<char>>, keyStorageFlags?: X509KeyStorageFlags, loaderLimits?: Pkcs12LoaderLimits): X509Certificate2Collection;
    static loadPkcs12CollectionFromFile(path: string, password: ReadOnlySpan_1<CLROf<char>>, keyStorageFlags?: X509KeyStorageFlags, loaderLimits?: Pkcs12LoaderLimits): X509Certificate2Collection;
    static loadPkcs12CollectionFromFile(path: string, password: string, keyStorageFlags?: X509KeyStorageFlags, loaderLimits?: Pkcs12LoaderLimits): X509Certificate2Collection;
    static loadPkcs12FromFile(path: string, password: ReadOnlySpan_1<CLROf<char>>, keyStorageFlags?: X509KeyStorageFlags, loaderLimits?: Pkcs12LoaderLimits): X509Certificate2;
    static loadPkcs12FromFile(path: string, password: string, keyStorageFlags?: X509KeyStorageFlags, loaderLimits?: Pkcs12LoaderLimits): X509Certificate2;
}


export type X509CertificateLoader = X509CertificateLoader$instance;

