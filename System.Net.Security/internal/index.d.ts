// Generated by tsbindgen - Architecture
// Namespace: System.Net.Security
// Assembly: System.Net.Primitives, System.Net.Security

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { IBufferWriter_1 } from "../../System.Buffers/internal/index.js";
import type { IEnumerable_1, List_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ReadOnlyCollection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_IO_Internal from "../../System.IO/internal/index.js";
import type { SeekOrigin, Stream } from "../../System.IO/internal/index.js";
import type { NetworkCredential, TransportContext } from "../../System.Net/internal/index.js";
import type { MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { ChannelBinding, ExtendedProtectionPolicy } from "../../System.Security.Authentication.ExtendedProtection/internal/index.js";
import type { CipherAlgorithmType, ExchangeAlgorithmType, HashAlgorithmType, SslProtocols } from "../../System.Security.Authentication/internal/index.js";
import type { X509Certificate, X509Certificate2, X509Certificate2Collection, X509CertificateCollection, X509Chain, X509ChainPolicy, X509RevocationMode, X509Store } from "../../System.Security.Cryptography.X509Certificates/internal/index.js";
import type { IIdentity, TokenImpersonationLevel } from "../../System.Security.Principal/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { AsyncCallback, Boolean as ClrBoolean, Byte, Delegate, Enum, IAsyncDisposable, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int32, Int64, IntPtr, ISpanFormattable, Memory_1, MulticastDelegate, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, Span_1, String as ClrString, Type, TypeCode, UInt16, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum AuthenticationLevel {
    none = 0,
    mutualAuthRequested = 1,
    mutualAuthRequired = 2
}


export enum EncryptionPolicy {
    requireEncryption = 0,
    allowNoEncryption = 1,
    noEncryption = 2
}


export enum NegotiateAuthenticationStatusCode {
    completed = 0,
    continueNeeded = 1,
    genericFailure = 2,
    badBinding = 3,
    unsupported = 4,
    messageAltered = 5,
    contextExpired = 6,
    credentialsExpired = 7,
    invalidCredentials = 8,
    invalidToken = 9,
    unknownCredentials = 10,
    qopNotSupported = 11,
    outOfSequence = 12,
    securityQosFailed = 13,
    targetUnknown = 14,
    impersonationValidationFailed = 15
}


export enum ProtectionLevel {
    none = 0,
    sign = 1,
    encryptAndSign = 2
}


export enum SslPolicyErrors {
    none = 0,
    remoteCertificateNotAvailable = 1,
    remoteCertificateNameMismatch = 2,
    remoteCertificateChainErrors = 4
}


export enum TlsCipherSuite {
    TLS_NULL_WITH_NULL_NULL = 0,
    TLS_RSA_WITH_NULL_MD5 = 1,
    TLS_RSA_WITH_NULL_SHA = 2,
    TLS_RSA_EXPORT_WITH_RC4_40_MD5 = 3,
    TLS_RSA_WITH_RC4_128_MD5 = 4,
    TLS_RSA_WITH_RC4_128_SHA = 5,
    TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = 6,
    TLS_RSA_WITH_IDEA_CBC_SHA = 7,
    TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = 8,
    TLS_RSA_WITH_DES_CBC_SHA = 9,
    TLS_RSA_WITH_3DES_EDE_CBC_SHA = 10,
    TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = 11,
    TLS_DH_DSS_WITH_DES_CBC_SHA = 12,
    TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = 13,
    TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = 14,
    TLS_DH_RSA_WITH_DES_CBC_SHA = 15,
    TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = 16,
    TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = 17,
    TLS_DHE_DSS_WITH_DES_CBC_SHA = 18,
    TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = 19,
    TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = 20,
    TLS_DHE_RSA_WITH_DES_CBC_SHA = 21,
    TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = 22,
    TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 = 23,
    TLS_DH_anon_WITH_RC4_128_MD5 = 24,
    TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA = 25,
    TLS_DH_anon_WITH_DES_CBC_SHA = 26,
    TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = 27,
    TLS_KRB5_WITH_DES_CBC_SHA = 30,
    TLS_KRB5_WITH_3DES_EDE_CBC_SHA = 31,
    TLS_KRB5_WITH_RC4_128_SHA = 32,
    TLS_KRB5_WITH_IDEA_CBC_SHA = 33,
    TLS_KRB5_WITH_DES_CBC_MD5 = 34,
    TLS_KRB5_WITH_3DES_EDE_CBC_MD5 = 35,
    TLS_KRB5_WITH_RC4_128_MD5 = 36,
    TLS_KRB5_WITH_IDEA_CBC_MD5 = 37,
    TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA = 38,
    TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA = 39,
    TLS_KRB5_EXPORT_WITH_RC4_40_SHA = 40,
    TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 = 41,
    TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 = 42,
    TLS_KRB5_EXPORT_WITH_RC4_40_MD5 = 43,
    TLS_PSK_WITH_NULL_SHA = 44,
    TLS_DHE_PSK_WITH_NULL_SHA = 45,
    TLS_RSA_PSK_WITH_NULL_SHA = 46,
    TLS_RSA_WITH_AES_128_CBC_SHA = 47,
    TLS_DH_DSS_WITH_AES_128_CBC_SHA = 48,
    TLS_DH_RSA_WITH_AES_128_CBC_SHA = 49,
    TLS_DHE_DSS_WITH_AES_128_CBC_SHA = 50,
    TLS_DHE_RSA_WITH_AES_128_CBC_SHA = 51,
    TLS_DH_anon_WITH_AES_128_CBC_SHA = 52,
    TLS_RSA_WITH_AES_256_CBC_SHA = 53,
    TLS_DH_DSS_WITH_AES_256_CBC_SHA = 54,
    TLS_DH_RSA_WITH_AES_256_CBC_SHA = 55,
    TLS_DHE_DSS_WITH_AES_256_CBC_SHA = 56,
    TLS_DHE_RSA_WITH_AES_256_CBC_SHA = 57,
    TLS_DH_anon_WITH_AES_256_CBC_SHA = 58,
    TLS_RSA_WITH_NULL_SHA256 = 59,
    TLS_RSA_WITH_AES_128_CBC_SHA256 = 60,
    TLS_RSA_WITH_AES_256_CBC_SHA256 = 61,
    TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = 62,
    TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = 63,
    TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = 64,
    TLS_RSA_WITH_CAMELLIA_128_CBC_SHA = 65,
    TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = 66,
    TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = 67,
    TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = 68,
    TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = 69,
    TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA = 70,
    TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = 103,
    TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = 104,
    TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = 105,
    TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = 106,
    TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = 107,
    TLS_DH_anon_WITH_AES_128_CBC_SHA256 = 108,
    TLS_DH_anon_WITH_AES_256_CBC_SHA256 = 109,
    TLS_RSA_WITH_CAMELLIA_256_CBC_SHA = 132,
    TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = 133,
    TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = 134,
    TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = 135,
    TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = 136,
    TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA = 137,
    TLS_PSK_WITH_RC4_128_SHA = 138,
    TLS_PSK_WITH_3DES_EDE_CBC_SHA = 139,
    TLS_PSK_WITH_AES_128_CBC_SHA = 140,
    TLS_PSK_WITH_AES_256_CBC_SHA = 141,
    TLS_DHE_PSK_WITH_RC4_128_SHA = 142,
    TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA = 143,
    TLS_DHE_PSK_WITH_AES_128_CBC_SHA = 144,
    TLS_DHE_PSK_WITH_AES_256_CBC_SHA = 145,
    TLS_RSA_PSK_WITH_RC4_128_SHA = 146,
    TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA = 147,
    TLS_RSA_PSK_WITH_AES_128_CBC_SHA = 148,
    TLS_RSA_PSK_WITH_AES_256_CBC_SHA = 149,
    TLS_RSA_WITH_SEED_CBC_SHA = 150,
    TLS_DH_DSS_WITH_SEED_CBC_SHA = 151,
    TLS_DH_RSA_WITH_SEED_CBC_SHA = 152,
    TLS_DHE_DSS_WITH_SEED_CBC_SHA = 153,
    TLS_DHE_RSA_WITH_SEED_CBC_SHA = 154,
    TLS_DH_anon_WITH_SEED_CBC_SHA = 155,
    TLS_RSA_WITH_AES_128_GCM_SHA256 = 156,
    TLS_RSA_WITH_AES_256_GCM_SHA384 = 157,
    TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = 158,
    TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = 159,
    TLS_DH_RSA_WITH_AES_128_GCM_SHA256 = 160,
    TLS_DH_RSA_WITH_AES_256_GCM_SHA384 = 161,
    TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = 162,
    TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = 163,
    TLS_DH_DSS_WITH_AES_128_GCM_SHA256 = 164,
    TLS_DH_DSS_WITH_AES_256_GCM_SHA384 = 165,
    TLS_DH_anon_WITH_AES_128_GCM_SHA256 = 166,
    TLS_DH_anon_WITH_AES_256_GCM_SHA384 = 167,
    TLS_PSK_WITH_AES_128_GCM_SHA256 = 168,
    TLS_PSK_WITH_AES_256_GCM_SHA384 = 169,
    TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 = 170,
    TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 = 171,
    TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 = 172,
    TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 = 173,
    TLS_PSK_WITH_AES_128_CBC_SHA256 = 174,
    TLS_PSK_WITH_AES_256_CBC_SHA384 = 175,
    TLS_PSK_WITH_NULL_SHA256 = 176,
    TLS_PSK_WITH_NULL_SHA384 = 177,
    TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 = 178,
    TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 = 179,
    TLS_DHE_PSK_WITH_NULL_SHA256 = 180,
    TLS_DHE_PSK_WITH_NULL_SHA384 = 181,
    TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 = 182,
    TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 = 183,
    TLS_RSA_PSK_WITH_NULL_SHA256 = 184,
    TLS_RSA_PSK_WITH_NULL_SHA384 = 185,
    TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 186,
    TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 = 187,
    TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 188,
    TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = 189,
    TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 190,
    TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 = 191,
    TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 = 192,
    TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 = 193,
    TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 = 194,
    TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = 195,
    TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = 196,
    TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 = 197,
    TLS_AES_128_GCM_SHA256 = 4865,
    TLS_AES_256_GCM_SHA384 = 4866,
    TLS_CHACHA20_POLY1305_SHA256 = 4867,
    TLS_AES_128_CCM_SHA256 = 4868,
    TLS_AES_128_CCM_8_SHA256 = 4869,
    TLS_ECDH_ECDSA_WITH_NULL_SHA = 49153,
    TLS_ECDH_ECDSA_WITH_RC4_128_SHA = 49154,
    TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = 49155,
    TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = 49156,
    TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = 49157,
    TLS_ECDHE_ECDSA_WITH_NULL_SHA = 49158,
    TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = 49159,
    TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = 49160,
    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = 49161,
    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = 49162,
    TLS_ECDH_RSA_WITH_NULL_SHA = 49163,
    TLS_ECDH_RSA_WITH_RC4_128_SHA = 49164,
    TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = 49165,
    TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = 49166,
    TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = 49167,
    TLS_ECDHE_RSA_WITH_NULL_SHA = 49168,
    TLS_ECDHE_RSA_WITH_RC4_128_SHA = 49169,
    TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = 49170,
    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = 49171,
    TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = 49172,
    TLS_ECDH_anon_WITH_NULL_SHA = 49173,
    TLS_ECDH_anon_WITH_RC4_128_SHA = 49174,
    TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = 49175,
    TLS_ECDH_anon_WITH_AES_128_CBC_SHA = 49176,
    TLS_ECDH_anon_WITH_AES_256_CBC_SHA = 49177,
    TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA = 49178,
    TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = 49179,
    TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = 49180,
    TLS_SRP_SHA_WITH_AES_128_CBC_SHA = 49181,
    TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = 49182,
    TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = 49183,
    TLS_SRP_SHA_WITH_AES_256_CBC_SHA = 49184,
    TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = 49185,
    TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = 49186,
    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = 49187,
    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = 49188,
    TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = 49189,
    TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = 49190,
    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = 49191,
    TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = 49192,
    TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = 49193,
    TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = 49194,
    TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = 49195,
    TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = 49196,
    TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = 49197,
    TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = 49198,
    TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = 49199,
    TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = 49200,
    TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = 49201,
    TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = 49202,
    TLS_ECDHE_PSK_WITH_RC4_128_SHA = 49203,
    TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = 49204,
    TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA = 49205,
    TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA = 49206,
    TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = 49207,
    TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = 49208,
    TLS_ECDHE_PSK_WITH_NULL_SHA = 49209,
    TLS_ECDHE_PSK_WITH_NULL_SHA256 = 49210,
    TLS_ECDHE_PSK_WITH_NULL_SHA384 = 49211,
    TLS_RSA_WITH_ARIA_128_CBC_SHA256 = 49212,
    TLS_RSA_WITH_ARIA_256_CBC_SHA384 = 49213,
    TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 = 49214,
    TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 = 49215,
    TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 = 49216,
    TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 = 49217,
    TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 = 49218,
    TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 = 49219,
    TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 = 49220,
    TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 = 49221,
    TLS_DH_anon_WITH_ARIA_128_CBC_SHA256 = 49222,
    TLS_DH_anon_WITH_ARIA_256_CBC_SHA384 = 49223,
    TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 = 49224,
    TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 = 49225,
    TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 = 49226,
    TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 = 49227,
    TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 = 49228,
    TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 = 49229,
    TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 = 49230,
    TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 = 49231,
    TLS_RSA_WITH_ARIA_128_GCM_SHA256 = 49232,
    TLS_RSA_WITH_ARIA_256_GCM_SHA384 = 49233,
    TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256 = 49234,
    TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384 = 49235,
    TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 = 49236,
    TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 = 49237,
    TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256 = 49238,
    TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384 = 49239,
    TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 = 49240,
    TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 = 49241,
    TLS_DH_anon_WITH_ARIA_128_GCM_SHA256 = 49242,
    TLS_DH_anon_WITH_ARIA_256_GCM_SHA384 = 49243,
    TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 = 49244,
    TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 = 49245,
    TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 = 49246,
    TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 = 49247,
    TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 = 49248,
    TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 = 49249,
    TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 = 49250,
    TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 = 49251,
    TLS_PSK_WITH_ARIA_128_CBC_SHA256 = 49252,
    TLS_PSK_WITH_ARIA_256_CBC_SHA384 = 49253,
    TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 = 49254,
    TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 = 49255,
    TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 = 49256,
    TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 = 49257,
    TLS_PSK_WITH_ARIA_128_GCM_SHA256 = 49258,
    TLS_PSK_WITH_ARIA_256_GCM_SHA384 = 49259,
    TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256 = 49260,
    TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384 = 49261,
    TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 = 49262,
    TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 = 49263,
    TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 = 49264,
    TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 = 49265,
    TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = 49266,
    TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = 49267,
    TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = 49268,
    TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = 49269,
    TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 49270,
    TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = 49271,
    TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 49272,
    TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 = 49273,
    TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 49274,
    TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 49275,
    TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 49276,
    TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 49277,
    TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 49278,
    TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 49279,
    TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 = 49280,
    TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 = 49281,
    TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 = 49282,
    TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 = 49283,
    TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 = 49284,
    TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 = 49285,
    TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = 49286,
    TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = 49287,
    TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = 49288,
    TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = 49289,
    TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 49290,
    TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 49291,
    TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 49292,
    TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 49293,
    TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 = 49294,
    TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 = 49295,
    TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 = 49296,
    TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 = 49297,
    TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 = 49298,
    TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 = 49299,
    TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 = 49300,
    TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 = 49301,
    TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = 49302,
    TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = 49303,
    TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = 49304,
    TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = 49305,
    TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = 49306,
    TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = 49307,
    TLS_RSA_WITH_AES_128_CCM = 49308,
    TLS_RSA_WITH_AES_256_CCM = 49309,
    TLS_DHE_RSA_WITH_AES_128_CCM = 49310,
    TLS_DHE_RSA_WITH_AES_256_CCM = 49311,
    TLS_RSA_WITH_AES_128_CCM_8 = 49312,
    TLS_RSA_WITH_AES_256_CCM_8 = 49313,
    TLS_DHE_RSA_WITH_AES_128_CCM_8 = 49314,
    TLS_DHE_RSA_WITH_AES_256_CCM_8 = 49315,
    TLS_PSK_WITH_AES_128_CCM = 49316,
    TLS_PSK_WITH_AES_256_CCM = 49317,
    TLS_DHE_PSK_WITH_AES_128_CCM = 49318,
    TLS_DHE_PSK_WITH_AES_256_CCM = 49319,
    TLS_PSK_WITH_AES_128_CCM_8 = 49320,
    TLS_PSK_WITH_AES_256_CCM_8 = 49321,
    TLS_PSK_DHE_WITH_AES_128_CCM_8 = 49322,
    TLS_PSK_DHE_WITH_AES_256_CCM_8 = 49323,
    TLS_ECDHE_ECDSA_WITH_AES_128_CCM = 49324,
    TLS_ECDHE_ECDSA_WITH_AES_256_CCM = 49325,
    TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = 49326,
    TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = 49327,
    TLS_ECCPWD_WITH_AES_128_GCM_SHA256 = 49328,
    TLS_ECCPWD_WITH_AES_256_GCM_SHA384 = 49329,
    TLS_ECCPWD_WITH_AES_128_CCM_SHA256 = 49330,
    TLS_ECCPWD_WITH_AES_256_CCM_SHA384 = 49331,
    TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = 52392,
    TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = 52393,
    TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = 52394,
    TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 = 52395,
    TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = 52396,
    TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = 52397,
    TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 = 52398,
    TLS_ECDHE_PSK_WITH_AES_128_GCM_SHA256 = 53249,
    TLS_ECDHE_PSK_WITH_AES_256_GCM_SHA384 = 53250,
    TLS_ECDHE_PSK_WITH_AES_128_CCM_8_SHA256 = 53251,
    TLS_ECDHE_PSK_WITH_AES_128_CCM_SHA256 = 53253
}


export type LocalCertificateSelectionCallback = (sender: unknown, targetHost: string, localCertificates: X509CertificateCollection, remoteCertificate: X509Certificate, acceptableIssuers: string[]) => X509Certificate;


export type RemoteCertificateValidationCallback = (sender: unknown, certificate: X509Certificate, chain: X509Chain, sslPolicyErrors: SslPolicyErrors) => boolean;


export type ServerCertificateSelectionCallback = (sender: unknown, hostName: string) => X509Certificate;


export type ServerOptionsSelectionCallback = (stream: SslStream, clientHelloInfo: SslClientHelloInfo, state: unknown, cancellationToken: CancellationToken) => ValueTask_1<SslServerAuthenticationOptions>;


export interface SslApplicationProtocol$instance {
    readonly protocol: ReadOnlyMemory_1<CLROf<byte>>;
    equals(other: SslApplicationProtocol): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const SslApplicationProtocol: {
    new(protocol: byte[]): SslApplicationProtocol$instance;
    new(protocol: string): SslApplicationProtocol$instance;
    readonly http3: SslApplicationProtocol;
    readonly http2: SslApplicationProtocol;
    readonly http11: SslApplicationProtocol;
};


export interface __SslApplicationProtocol$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SslApplicationProtocol>;

    // Structural method bridges for numeric interface constraints
    Equals(other: SslApplicationProtocol): boolean;
}

export type SslApplicationProtocol = SslApplicationProtocol$instance & __SslApplicationProtocol$views;


export interface SslClientHelloInfo$instance {
    readonly serverName: string;
    readonly sslProtocols: SslProtocols;
}


export const SslClientHelloInfo: {
    new(serverName: string, sslProtocols: SslProtocols): SslClientHelloInfo$instance;
};


export type SslClientHelloInfo = SslClientHelloInfo$instance;

export interface AuthenticatedStream$instance extends Stream {
    readonly isAuthenticated: boolean;
    readonly isEncrypted: boolean;
    readonly isMutuallyAuthenticated: boolean;
    readonly isServer: boolean;
    readonly isSigned: boolean;
    readonly leaveInnerStreamOpen: boolean;
    dispose(): void;
    disposeAsync(): ValueTask;
}


export const AuthenticatedStream: {
};


export interface __AuthenticatedStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type AuthenticatedStream = AuthenticatedStream$instance & __AuthenticatedStream$views;


export interface CipherSuitesPolicy$instance {
    readonly allowedCipherSuites: IEnumerable_1<TlsCipherSuite>;
}


export const CipherSuitesPolicy: {
    new(allowedCipherSuites: IEnumerable_1<TlsCipherSuite>): CipherSuitesPolicy$instance;
};


export type CipherSuitesPolicy = CipherSuitesPolicy$instance;

export interface NegotiateAuthentication$instance {
    readonly impersonationLevel: TokenImpersonationLevel;
    readonly isAuthenticated: boolean;
    readonly isEncrypted: boolean;
    readonly isMutuallyAuthenticated: boolean;
    readonly isServer: boolean;
    readonly isSigned: boolean;
    readonly package_: string;
    readonly protectionLevel: ProtectionLevel;
    readonly remoteIdentity: IIdentity;
    readonly targetName: string;
    computeIntegrityCheck(message: ReadOnlySpan_1<CLROf<byte>>, signatureWriter: IBufferWriter_1<CLROf<byte>>): void;
    dispose(): void;
    getOutgoingBlob(incomingBlob: ReadOnlySpan_1<CLROf<byte>>, statusCode: { value: ref<NegotiateAuthenticationStatusCode> }): byte[];
    getOutgoingBlob(incomingBlob: string, statusCode: { value: ref<NegotiateAuthenticationStatusCode> }): string;
    unwrap(input: ReadOnlySpan_1<CLROf<byte>>, outputWriter: IBufferWriter_1<CLROf<byte>>, wasEncrypted: { value: ref<boolean> }): NegotiateAuthenticationStatusCode;
    unwrapInPlace(input: Span_1<CLROf<byte>>, unwrappedOffset: { value: ref<int> }, unwrappedLength: { value: ref<int> }, wasEncrypted: { value: ref<boolean> }): NegotiateAuthenticationStatusCode;
    verifyIntegrityCheck(message: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    wrap(input: ReadOnlySpan_1<CLROf<byte>>, outputWriter: IBufferWriter_1<CLROf<byte>>, requestEncryption: boolean, isEncrypted: { value: ref<boolean> }): NegotiateAuthenticationStatusCode;
}


export const NegotiateAuthentication: {
    new(clientOptions: NegotiateAuthenticationClientOptions): NegotiateAuthentication$instance;
    new(serverOptions: NegotiateAuthenticationServerOptions): NegotiateAuthentication$instance;
};


export interface __NegotiateAuthentication$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface NegotiateAuthentication$instance extends System_Internal.IDisposable$instance {}

export type NegotiateAuthentication = NegotiateAuthentication$instance & __NegotiateAuthentication$views;


export interface NegotiateAuthenticationClientOptions$instance {
    allowedImpersonationLevel: TokenImpersonationLevel;
    binding: ChannelBinding;
    credential: NetworkCredential;
    package_: string;
    requiredProtectionLevel: ProtectionLevel;
    requireMutualAuthentication: boolean;
    targetName: string;
}


export const NegotiateAuthenticationClientOptions: {
    new(): NegotiateAuthenticationClientOptions$instance;
};


export type NegotiateAuthenticationClientOptions = NegotiateAuthenticationClientOptions$instance;

export interface NegotiateAuthenticationServerOptions$instance {
    binding: ChannelBinding;
    credential: NetworkCredential;
    package_: string;
    policy: ExtendedProtectionPolicy;
    requiredImpersonationLevel: TokenImpersonationLevel;
    requiredProtectionLevel: ProtectionLevel;
}


export const NegotiateAuthenticationServerOptions: {
    new(): NegotiateAuthenticationServerOptions$instance;
};


export type NegotiateAuthenticationServerOptions = NegotiateAuthenticationServerOptions$instance;

export interface NegotiateStream$instance extends AuthenticatedStream$instance {
    readonly canRead: boolean;
    readonly canSeek: boolean;
    readonly canTimeout: boolean;
    readonly canWrite: boolean;
    readonly impersonationLevel: TokenImpersonationLevel;
    readonly isAuthenticated: boolean;
    readonly isEncrypted: boolean;
    readonly isMutuallyAuthenticated: boolean;
    readonly isServer: boolean;
    readonly isSigned: boolean;
    readonly length: long;
    position: long;
    readTimeout: int;
    readonly remoteIdentity: IIdentity;
    writeTimeout: int;
    authenticateAsClient(): void;
    authenticateAsClient(credential: NetworkCredential, targetName: string): void;
    authenticateAsClient(credential: NetworkCredential, binding: ChannelBinding, targetName: string): void;
    authenticateAsClient(credential: NetworkCredential, targetName: string, requiredProtectionLevel: ProtectionLevel, allowedImpersonationLevel: TokenImpersonationLevel): void;
    authenticateAsClient(credential: NetworkCredential, binding: ChannelBinding, targetName: string, requiredProtectionLevel: ProtectionLevel, allowedImpersonationLevel: TokenImpersonationLevel): void;
    authenticateAsClientAsync(): Task;
    authenticateAsClientAsync(credential: NetworkCredential, targetName: string): Task;
    authenticateAsClientAsync(credential: NetworkCredential, targetName: string, requiredProtectionLevel: ProtectionLevel, allowedImpersonationLevel: TokenImpersonationLevel): Task;
    authenticateAsClientAsync(credential: NetworkCredential, binding: ChannelBinding, targetName: string): Task;
    authenticateAsClientAsync(credential: NetworkCredential, binding: ChannelBinding, targetName: string, requiredProtectionLevel: ProtectionLevel, allowedImpersonationLevel: TokenImpersonationLevel): Task;
    authenticateAsServer(): void;
    authenticateAsServer(policy: ExtendedProtectionPolicy): void;
    authenticateAsServer(credential: NetworkCredential, requiredProtectionLevel: ProtectionLevel, requiredImpersonationLevel: TokenImpersonationLevel): void;
    authenticateAsServer(credential: NetworkCredential, policy: ExtendedProtectionPolicy, requiredProtectionLevel: ProtectionLevel, requiredImpersonationLevel: TokenImpersonationLevel): void;
    authenticateAsServerAsync(): Task;
    authenticateAsServerAsync(policy: ExtendedProtectionPolicy): Task;
    authenticateAsServerAsync(credential: NetworkCredential, requiredProtectionLevel: ProtectionLevel, requiredImpersonationLevel: TokenImpersonationLevel): Task;
    authenticateAsServerAsync(credential: NetworkCredential, policy: ExtendedProtectionPolicy, requiredProtectionLevel: ProtectionLevel, requiredImpersonationLevel: TokenImpersonationLevel): Task;
    beginAuthenticateAsClient(asyncCallback: AsyncCallback, asyncState: unknown): IAsyncResult;
    beginAuthenticateAsClient(credential: NetworkCredential, targetName: string, asyncCallback: AsyncCallback, asyncState: unknown): IAsyncResult;
    beginAuthenticateAsClient(credential: NetworkCredential, binding: ChannelBinding, targetName: string, asyncCallback: AsyncCallback, asyncState: unknown): IAsyncResult;
    beginAuthenticateAsClient(credential: NetworkCredential, targetName: string, requiredProtectionLevel: ProtectionLevel, allowedImpersonationLevel: TokenImpersonationLevel, asyncCallback: AsyncCallback, asyncState: unknown): IAsyncResult;
    beginAuthenticateAsClient(credential: NetworkCredential, binding: ChannelBinding, targetName: string, requiredProtectionLevel: ProtectionLevel, allowedImpersonationLevel: TokenImpersonationLevel, asyncCallback: AsyncCallback, asyncState: unknown): IAsyncResult;
    beginAuthenticateAsServer(asyncCallback: AsyncCallback, asyncState: unknown): IAsyncResult;
    beginAuthenticateAsServer(policy: ExtendedProtectionPolicy, asyncCallback: AsyncCallback, asyncState: unknown): IAsyncResult;
    beginAuthenticateAsServer(credential: NetworkCredential, requiredProtectionLevel: ProtectionLevel, requiredImpersonationLevel: TokenImpersonationLevel, asyncCallback: AsyncCallback, asyncState: unknown): IAsyncResult;
    beginAuthenticateAsServer(credential: NetworkCredential, policy: ExtendedProtectionPolicy, requiredProtectionLevel: ProtectionLevel, requiredImpersonationLevel: TokenImpersonationLevel, asyncCallback: AsyncCallback, asyncState: unknown): IAsyncResult;
    beginRead(buffer: byte[], offset: int, count: int, asyncCallback: AsyncCallback, asyncState: unknown): IAsyncResult;
    beginWrite(buffer: byte[], offset: int, count: int, asyncCallback: AsyncCallback, asyncState: unknown): IAsyncResult;
    dispose(): void;
    disposeAsync(): ValueTask;
    endAuthenticateAsClient(asyncResult: IAsyncResult): void;
    endAuthenticateAsServer(asyncResult: IAsyncResult): void;
    endRead(asyncResult: IAsyncResult): int;
    endWrite(asyncResult: IAsyncResult): void;
    flush(): void;
    flushAsync(cancellationToken: CancellationToken): Task;
    flushAsync(): Task;
    read(buffer: byte[], offset: int, count: int): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    seek(offset: long, origin: SeekOrigin): long;
    setLength(value: long): void;
    write(buffer: byte[], offset: int, count: int): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    writeAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeAsync(buffer: byte[], offset: int, count: int): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
}


export const NegotiateStream: {
    new(innerStream: Stream): NegotiateStream$instance;
    new(innerStream: Stream, leaveInnerStreamOpen: boolean): NegotiateStream$instance;
};


export interface __NegotiateStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type NegotiateStream = NegotiateStream$instance & __NegotiateStream$views;


export interface SslCertificateTrust$instance {
}


export const SslCertificateTrust: {
    new(): SslCertificateTrust$instance;
    createForX509Collection(trustList: X509Certificate2Collection, sendTrustInHandshake?: boolean): SslCertificateTrust;
    createForX509Store(store: X509Store, sendTrustInHandshake?: boolean): SslCertificateTrust;
};


export type SslCertificateTrust = SslCertificateTrust$instance;

export interface SslClientAuthenticationOptions$instance {
    allowRenegotiation: boolean;
    allowRsaPkcs1Padding: boolean;
    allowRsaPssPadding: boolean;
    allowTlsResume: boolean;
    applicationProtocols: List_1<SslApplicationProtocol>;
    certificateChainPolicy: X509ChainPolicy;
    certificateRevocationCheckMode: X509RevocationMode;
    cipherSuitesPolicy: CipherSuitesPolicy;
    clientCertificateContext: SslStreamCertificateContext;
    clientCertificates: X509CertificateCollection;
    enabledSslProtocols: SslProtocols;
    encryptionPolicy: EncryptionPolicy;
    localCertificateSelectionCallback: LocalCertificateSelectionCallback;
    remoteCertificateValidationCallback: RemoteCertificateValidationCallback;
    targetHost: string;
}


export const SslClientAuthenticationOptions: {
    new(): SslClientAuthenticationOptions$instance;
};


export type SslClientAuthenticationOptions = SslClientAuthenticationOptions$instance;

export interface SslServerAuthenticationOptions$instance {
    allowRenegotiation: boolean;
    allowRsaPkcs1Padding: boolean;
    allowRsaPssPadding: boolean;
    allowTlsResume: boolean;
    applicationProtocols: List_1<SslApplicationProtocol>;
    certificateChainPolicy: X509ChainPolicy;
    certificateRevocationCheckMode: X509RevocationMode;
    cipherSuitesPolicy: CipherSuitesPolicy;
    clientCertificateRequired: boolean;
    enabledSslProtocols: SslProtocols;
    encryptionPolicy: EncryptionPolicy;
    remoteCertificateValidationCallback: RemoteCertificateValidationCallback;
    serverCertificate: X509Certificate;
    serverCertificateContext: SslStreamCertificateContext;
    serverCertificateSelectionCallback: ServerCertificateSelectionCallback;
}


export const SslServerAuthenticationOptions: {
    new(): SslServerAuthenticationOptions$instance;
};


export type SslServerAuthenticationOptions = SslServerAuthenticationOptions$instance;

export interface SslStream$instance extends AuthenticatedStream$instance {
    readonly canRead: boolean;
    readonly canSeek: boolean;
    readonly canTimeout: boolean;
    readonly canWrite: boolean;
    readonly checkCertRevocationStatus: boolean;
    readonly cipherAlgorithm: CipherAlgorithmType;
    readonly cipherStrength: int;
    readonly hashAlgorithm: HashAlgorithmType;
    readonly hashStrength: int;
    readonly isAuthenticated: boolean;
    readonly isEncrypted: boolean;
    readonly isMutuallyAuthenticated: boolean;
    readonly isServer: boolean;
    readonly isSigned: boolean;
    readonly keyExchangeAlgorithm: ExchangeAlgorithmType;
    readonly keyExchangeStrength: int;
    readonly length: long;
    readonly localCertificate: X509Certificate;
    readonly negotiatedApplicationProtocol: SslApplicationProtocol;
    readonly negotiatedCipherSuite: TlsCipherSuite;
    position: long;
    readTimeout: int;
    readonly remoteCertificate: X509Certificate;
    readonly sslProtocol: SslProtocols;
    readonly targetHostName: string;
    readonly transportContext: TransportContext;
    writeTimeout: int;
    authenticateAsClient(targetHost: string): void;
    authenticateAsClient(targetHost: string, clientCertificates: X509CertificateCollection, checkCertificateRevocation: boolean): void;
    authenticateAsClient(targetHost: string, clientCertificates: X509CertificateCollection, enabledSslProtocols: SslProtocols, checkCertificateRevocation: boolean): void;
    authenticateAsClient(sslClientAuthenticationOptions: SslClientAuthenticationOptions): void;
    authenticateAsClientAsync(targetHost: string): Task;
    authenticateAsClientAsync(targetHost: string, clientCertificates: X509CertificateCollection, checkCertificateRevocation: boolean): Task;
    authenticateAsClientAsync(targetHost: string, clientCertificates: X509CertificateCollection, enabledSslProtocols: SslProtocols, checkCertificateRevocation: boolean): Task;
    authenticateAsClientAsync(sslClientAuthenticationOptions: SslClientAuthenticationOptions, cancellationToken?: CancellationToken): Task;
    authenticateAsServer(serverCertificate: X509Certificate): void;
    authenticateAsServer(serverCertificate: X509Certificate, clientCertificateRequired: boolean, checkCertificateRevocation: boolean): void;
    authenticateAsServer(serverCertificate: X509Certificate, clientCertificateRequired: boolean, enabledSslProtocols: SslProtocols, checkCertificateRevocation: boolean): void;
    authenticateAsServer(sslServerAuthenticationOptions: SslServerAuthenticationOptions): void;
    authenticateAsServerAsync(serverCertificate: X509Certificate): Task;
    authenticateAsServerAsync(serverCertificate: X509Certificate, clientCertificateRequired: boolean, checkCertificateRevocation: boolean): Task;
    authenticateAsServerAsync(serverCertificate: X509Certificate, clientCertificateRequired: boolean, enabledSslProtocols: SslProtocols, checkCertificateRevocation: boolean): Task;
    authenticateAsServerAsync(sslServerAuthenticationOptions: SslServerAuthenticationOptions, cancellationToken?: CancellationToken): Task;
    authenticateAsServerAsync(optionsCallback: ServerOptionsSelectionCallback, state: unknown, cancellationToken?: CancellationToken): Task;
    beginAuthenticateAsClient(targetHost: string, asyncCallback: AsyncCallback, asyncState: unknown): IAsyncResult;
    beginAuthenticateAsClient(targetHost: string, clientCertificates: X509CertificateCollection, checkCertificateRevocation: boolean, asyncCallback: AsyncCallback, asyncState: unknown): IAsyncResult;
    beginAuthenticateAsClient(targetHost: string, clientCertificates: X509CertificateCollection, enabledSslProtocols: SslProtocols, checkCertificateRevocation: boolean, asyncCallback: AsyncCallback, asyncState: unknown): IAsyncResult;
    beginAuthenticateAsServer(serverCertificate: X509Certificate, asyncCallback: AsyncCallback, asyncState: unknown): IAsyncResult;
    beginAuthenticateAsServer(serverCertificate: X509Certificate, clientCertificateRequired: boolean, checkCertificateRevocation: boolean, asyncCallback: AsyncCallback, asyncState: unknown): IAsyncResult;
    beginAuthenticateAsServer(serverCertificate: X509Certificate, clientCertificateRequired: boolean, enabledSslProtocols: SslProtocols, checkCertificateRevocation: boolean, asyncCallback: AsyncCallback, asyncState: unknown): IAsyncResult;
    beginRead(buffer: byte[], offset: int, count: int, asyncCallback: AsyncCallback, asyncState: unknown): IAsyncResult;
    beginWrite(buffer: byte[], offset: int, count: int, asyncCallback: AsyncCallback, asyncState: unknown): IAsyncResult;
    dispose(): void;
    disposeAsync(): ValueTask;
    endAuthenticateAsClient(asyncResult: IAsyncResult): void;
    endAuthenticateAsServer(asyncResult: IAsyncResult): void;
    endRead(asyncResult: IAsyncResult): int;
    endWrite(asyncResult: IAsyncResult): void;
    flush(): void;
    flushAsync(cancellationToken: CancellationToken): Task;
    flushAsync(): Task;
    negotiateClientCertificateAsync(cancellationToken?: CancellationToken): Task;
    read(buffer: Span_1<CLROf<byte>>): int;
    read(buffer: byte[], offset: int, count: int): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readByte(): int;
    seek(offset: long, origin: SeekOrigin): long;
    setLength(value: long): void;
    shutdownAsync(): Task;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    write(buffer: byte[]): void;
    write(buffer: byte[], offset: int, count: int): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    writeAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeAsync(buffer: byte[], offset: int, count: int): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeByte(value: byte): void;
}


export const SslStream: {
    new(innerStream: Stream): SslStream$instance;
    new(innerStream: Stream, leaveInnerStreamOpen: boolean): SslStream$instance;
    new(innerStream: Stream, leaveInnerStreamOpen: boolean, userCertificateValidationCallback: RemoteCertificateValidationCallback): SslStream$instance;
    new(innerStream: Stream, leaveInnerStreamOpen: boolean, userCertificateValidationCallback: RemoteCertificateValidationCallback, userCertificateSelectionCallback: LocalCertificateSelectionCallback): SslStream$instance;
    new(innerStream: Stream, leaveInnerStreamOpen: boolean, userCertificateValidationCallback: RemoteCertificateValidationCallback, userCertificateSelectionCallback: LocalCertificateSelectionCallback, encryptionPolicy: EncryptionPolicy): SslStream$instance;
};


export interface __SslStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type SslStream = SslStream$instance & __SslStream$views;


export interface SslStreamCertificateContext$instance {
    readonly intermediateCertificates: ReadOnlyCollection_1<X509Certificate2>;
    readonly targetCertificate: X509Certificate2;
}


export const SslStreamCertificateContext: {
    new(): SslStreamCertificateContext$instance;
    create(target: X509Certificate2, additionalCertificates: X509Certificate2Collection, offline?: boolean, trust?: SslCertificateTrust): SslStreamCertificateContext;
    create(target: X509Certificate2, additionalCertificates: X509Certificate2Collection, offline: boolean): SslStreamCertificateContext;
};


export type SslStreamCertificateContext = SslStreamCertificateContext$instance;

