// Generated by tsbindgen - Architecture
// Namespace: System.Security.AccessControl
// Assembly: Microsoft.Win32.Registry, System.IO.FileSystem.AccessControl, System.Security.AccessControl, System.Threading.AccessControl

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IEnumerable, IEnumerator, ReadOnlyCollectionBase } from "../../System.Collections/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { IdentityReference, SecurityIdentifier } from "../../System.Security.Principal/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Boolean as ClrBoolean, Byte, Enum, Exception, Guid, IComparable, IConvertible, IFormatProvider, IFormattable, Int32, ISpanFormattable, Object as ClrObject, String as ClrString, Type, TypeCode, UnauthorizedAccessException, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum AccessControlActions {
    none = 0,
    view = 1,
    change = 2
}


export enum AccessControlModification {
    add = 0,
    set_ = 1,
    reset = 2,
    remove = 3,
    removeAll = 4,
    removeSpecific = 5
}


export enum AccessControlSections {
    none = 0,
    audit = 1,
    access = 2,
    owner = 4,
    group = 8,
    all = 15
}


export enum AccessControlType {
    allow = 0,
    deny = 1
}


export enum AceFlags {
    none = 0,
    objectInherit = 1,
    containerInherit = 2,
    noPropagateInherit = 4,
    inheritOnly = 8,
    inheritanceFlags = 15,
    inherited = 16,
    successfulAccess = 64,
    failedAccess = 128,
    auditFlags = 192
}


export enum AceQualifier {
    accessAllowed = 0,
    accessDenied = 1,
    systemAudit = 2,
    systemAlarm = 3
}


export enum AceType {
    accessAllowed = 0,
    accessDenied = 1,
    systemAudit = 2,
    systemAlarm = 3,
    accessAllowedCompound = 4,
    accessAllowedObject = 5,
    accessDeniedObject = 6,
    systemAuditObject = 7,
    systemAlarmObject = 8,
    accessAllowedCallback = 9,
    accessDeniedCallback = 10,
    accessAllowedCallbackObject = 11,
    accessDeniedCallbackObject = 12,
    systemAuditCallback = 13,
    systemAlarmCallback = 14,
    systemAuditCallbackObject = 15,
    maxDefinedAceType = 16,
    systemAlarmCallbackObject = 16
}


export enum AuditFlags {
    none = 0,
    success = 1,
    failure = 2
}


export enum CompoundAceType {
    impersonation = 1
}


export enum ControlFlags {
    none = 0,
    ownerDefaulted = 1,
    groupDefaulted = 2,
    discretionaryAclPresent = 4,
    discretionaryAclDefaulted = 8,
    systemAclPresent = 16,
    systemAclDefaulted = 32,
    discretionaryAclUntrusted = 64,
    serverSecurity = 128,
    discretionaryAclAutoInheritRequired = 256,
    systemAclAutoInheritRequired = 512,
    discretionaryAclAutoInherited = 1024,
    systemAclAutoInherited = 2048,
    discretionaryAclProtected = 4096,
    systemAclProtected = 8192,
    rmControlValid = 16384,
    selfRelative = 32768
}


export enum EventWaitHandleRights {
    modify = 2,
    delete_ = 65536,
    readPermissions = 131072,
    changePermissions = 262144,
    takeOwnership = 524288,
    synchronize = 1048576,
    fullControl = 2031619
}


export enum FileSystemRights {
    listDirectory = 1,
    readData = 1,
    createFiles = 2,
    writeData = 2,
    appendData = 4,
    createDirectories = 4,
    readExtendedAttributes = 8,
    writeExtendedAttributes = 16,
    executeFile = 32,
    traverse = 32,
    deleteSubdirectoriesAndFiles = 64,
    readAttributes = 128,
    writeAttributes = 256,
    write = 278,
    delete_ = 65536,
    readPermissions = 131072,
    read = 131209,
    readAndExecute = 131241,
    modify = 197055,
    changePermissions = 262144,
    takeOwnership = 524288,
    synchronize = 1048576,
    fullControl = 2032127
}


export enum InheritanceFlags {
    none = 0,
    containerInherit = 1,
    objectInherit = 2
}


export enum MutexRights {
    modify = 1,
    delete_ = 65536,
    readPermissions = 131072,
    changePermissions = 262144,
    takeOwnership = 524288,
    synchronize = 1048576,
    fullControl = 2031617
}


export enum ObjectAceFlags {
    none = 0,
    objectAceTypePresent = 1,
    inheritedObjectAceTypePresent = 2
}


export enum PropagationFlags {
    none = 0,
    noPropagateInherit = 1,
    inheritOnly = 2
}


export enum RegistryRights {
    queryValues = 1,
    setValue = 2,
    createSubKey = 4,
    enumerateSubKeys = 8,
    notify = 16,
    createLink = 32,
    delete_ = 65536,
    readPermissions = 131072,
    writeKey = 131078,
    executeKey = 131097,
    readKey = 131097,
    changePermissions = 262144,
    takeOwnership = 524288,
    fullControl = 983103
}


export enum ResourceType {
    unknown_ = 0,
    fileObject = 1,
    service = 2,
    printer = 3,
    registryKey = 4,
    lmShare = 5,
    kernelObject = 6,
    windowObject = 7,
    dsObject = 8,
    dsObjectAll = 9,
    providerDefined = 10,
    wmiGuidObject = 11,
    registryWow6432Key = 12
}


export enum SecurityInfos {
    owner = 1,
    group = 2,
    discretionaryAcl = 4,
    systemAcl = 8
}


export enum SemaphoreRights {
    modify = 2,
    delete_ = 65536,
    readPermissions = 131072,
    changePermissions = 262144,
    takeOwnership = 524288,
    synchronize = 1048576,
    fullControl = 2031619
}


export interface AccessRule$instance extends AuthorizationRule {
    readonly accessControlType: AccessControlType;
}


export const AccessRule: {
};


export type AccessRule = AccessRule$instance;

export interface AccessRule_1$instance<T extends unknown> extends AccessRule {
    readonly rights: T;
}


export const AccessRule_1: {
    new<T extends unknown>(identity: IdentityReference, rights: T, type_: AccessControlType): AccessRule_1$instance<T>;
    new<T extends unknown>(identity: IdentityReference, rights: T, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, type_: AccessControlType): AccessRule_1$instance<T>;
    new<T extends unknown>(identity: string, rights: T, type_: AccessControlType): AccessRule_1$instance<T>;
    new<T extends unknown>(identity: string, rights: T, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, type_: AccessControlType): AccessRule_1$instance<T>;
};


export type AccessRule_1<T> = AccessRule_1$instance<T>;

export interface AceEnumerator$instance {
    readonly current: GenericAce | unknown;
    moveNext(): boolean;
    reset(): void;
}


export const AceEnumerator: {
    new(): AceEnumerator$instance;
};


export interface __AceEnumerator$views {
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type AceEnumerator = AceEnumerator$instance & __AceEnumerator$views;


export interface AuditRule$instance extends AuthorizationRule {
    readonly auditFlags: AuditFlags;
}


export const AuditRule: {
};


export type AuditRule = AuditRule$instance;

export interface AuditRule_1$instance<T extends unknown> extends AuditRule {
    readonly rights: T;
}


export const AuditRule_1: {
    new<T extends unknown>(identity: IdentityReference, rights: T, flags: AuditFlags): AuditRule_1$instance<T>;
    new<T extends unknown>(identity: IdentityReference, rights: T, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, flags: AuditFlags): AuditRule_1$instance<T>;
    new<T extends unknown>(identity: string, rights: T, flags: AuditFlags): AuditRule_1$instance<T>;
    new<T extends unknown>(identity: string, rights: T, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, flags: AuditFlags): AuditRule_1$instance<T>;
};


export type AuditRule_1<T> = AuditRule_1$instance<T>;

export interface AuthorizationRule$instance {
    readonly identityReference: IdentityReference;
    readonly inheritanceFlags: InheritanceFlags;
    readonly isInherited: boolean;
    readonly propagationFlags: PropagationFlags;
}


export const AuthorizationRule: {
};


export type AuthorizationRule = AuthorizationRule$instance;

export interface AuthorizationRuleCollection$instance extends ReadOnlyCollectionBase {
    readonly item: AuthorizationRule;
    addRule(rule: AuthorizationRule): void;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator;
}


export const AuthorizationRuleCollection: {
    new(): AuthorizationRuleCollection$instance;
};


export interface __AuthorizationRuleCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export interface AuthorizationRuleCollection$instance extends System_Collections_Internal.ICollection$instance {}

export type AuthorizationRuleCollection = AuthorizationRuleCollection$instance & __AuthorizationRuleCollection$views;


export interface CommonAce$instance extends QualifiedAce {
    readonly binaryLength: int;
    getBinaryForm(binaryForm: byte[], offset: int): void;
}


export const CommonAce: {
    new(flags: AceFlags, qualifier: AceQualifier, accessMask: int, sid: SecurityIdentifier, isCallback: boolean, opaque: byte[]): CommonAce$instance;
    maxOpaqueLength(isCallback: boolean): int;
};


export type CommonAce = CommonAce$instance;

export interface CommonAcl$instance extends GenericAcl$instance {
    readonly binaryLength: int;
    readonly count: int;
    readonly isCanonical: boolean;
    readonly isContainer: boolean;
    readonly isDS: boolean;
    item: GenericAce;
    readonly revision: byte;
    copyTo(array: GenericAce[], index: int): void;
    copyTo(array: ClrArray, index: int): void;
    getBinaryForm(binaryForm: byte[], offset: int): void;
    getEnumerator(): AceEnumerator;
    getEnumerator(): IEnumerator;
    purge(sid: SecurityIdentifier): void;
    removeInheritedAces(): void;
}


export const CommonAcl: {
};


export interface __CommonAcl$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type CommonAcl = CommonAcl$instance & __CommonAcl$views;


export interface CommonObjectSecurity$instance extends ObjectSecurity {
    getAccessRules(includeExplicit: boolean, includeInherited: boolean, targetType: Type): AuthorizationRuleCollection;
    getAuditRules(includeExplicit: boolean, includeInherited: boolean, targetType: Type): AuthorizationRuleCollection;
}


export const CommonObjectSecurity: {
};


export type CommonObjectSecurity = CommonObjectSecurity$instance;

export interface CommonSecurityDescriptor$instance extends GenericSecurityDescriptor {
    readonly controlFlags: ControlFlags;
    discretionaryAcl: DiscretionaryAcl;
    group: SecurityIdentifier;
    readonly isContainer: boolean;
    readonly isDiscretionaryAclCanonical: boolean;
    readonly isDS: boolean;
    readonly isSystemAclCanonical: boolean;
    owner: SecurityIdentifier;
    systemAcl: SystemAcl;
    addDiscretionaryAcl(revision: byte, trusted: int): void;
    addSystemAcl(revision: byte, trusted: int): void;
    purgeAccessControl(sid: SecurityIdentifier): void;
    purgeAudit(sid: SecurityIdentifier): void;
    setDiscretionaryAclProtection(isProtected: boolean, preserveInheritance: boolean): void;
    setSystemAclProtection(isProtected: boolean, preserveInheritance: boolean): void;
}


export const CommonSecurityDescriptor: {
    new(isContainer: boolean, isDS: boolean, binaryForm: byte[], offset: int): CommonSecurityDescriptor$instance;
    new(isContainer: boolean, isDS: boolean, flags: ControlFlags, owner: SecurityIdentifier, group: SecurityIdentifier, systemAcl: SystemAcl, discretionaryAcl: DiscretionaryAcl): CommonSecurityDescriptor$instance;
    new(isContainer: boolean, isDS: boolean, rawSecurityDescriptor: RawSecurityDescriptor): CommonSecurityDescriptor$instance;
    new(isContainer: boolean, isDS: boolean, sddlForm: string): CommonSecurityDescriptor$instance;
};


export type CommonSecurityDescriptor = CommonSecurityDescriptor$instance;

export interface CompoundAce$instance extends KnownAce {
    readonly binaryLength: int;
    compoundAceType: CompoundAceType;
    getBinaryForm(binaryForm: byte[], offset: int): void;
}


export const CompoundAce: {
    new(flags: AceFlags, accessMask: int, compoundAceType: CompoundAceType, sid: SecurityIdentifier): CompoundAce$instance;
};


export type CompoundAce = CompoundAce$instance;

export interface CustomAce$instance extends GenericAce {
    readonly binaryLength: int;
    readonly opaqueLength: int;
    getBinaryForm(binaryForm: byte[], offset: int): void;
    getOpaque(): byte[];
    setOpaque(opaque: byte[]): void;
}


export const CustomAce: {
    new(type_: AceType, flags: AceFlags, opaque: byte[]): CustomAce$instance;
    readonly maxOpaqueLength: int;
};


export type CustomAce = CustomAce$instance;

export interface DirectoryObjectSecurity$instance extends ObjectSecurity {
    accessRuleFactory(identityReference: IdentityReference, accessMask: int, isInherited: boolean, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, type_: AccessControlType, objectType: Guid, inheritedObjectType: Guid): AccessRule;
    accessRuleFactory(identityReference: IdentityReference, accessMask: int, isInherited: boolean, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, type_: AccessControlType): AccessRule;
    auditRuleFactory(identityReference: IdentityReference, accessMask: int, isInherited: boolean, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, flags: AuditFlags, objectType: Guid, inheritedObjectType: Guid): AuditRule;
    auditRuleFactory(identityReference: IdentityReference, accessMask: int, isInherited: boolean, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, flags: AuditFlags): AuditRule;
    getAccessRules(includeExplicit: boolean, includeInherited: boolean, targetType: Type): AuthorizationRuleCollection;
    getAuditRules(includeExplicit: boolean, includeInherited: boolean, targetType: Type): AuthorizationRuleCollection;
}


export const DirectoryObjectSecurity: {
};


export type DirectoryObjectSecurity = DirectoryObjectSecurity$instance;

export interface DirectorySecurity$instance extends FileSystemSecurity {
}


export const DirectorySecurity: {
    new(): DirectorySecurity$instance;
    new(name: string, includeSections: AccessControlSections): DirectorySecurity$instance;
};


export type DirectorySecurity = DirectorySecurity$instance;

export interface DiscretionaryAcl$instance extends CommonAcl$instance {
    addAccess(accessType: AccessControlType, sid: SecurityIdentifier, accessMask: int, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags): void;
    addAccess(accessType: AccessControlType, sid: SecurityIdentifier, accessMask: int, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, objectFlags: ObjectAceFlags, objectType: Guid, inheritedObjectType: Guid): void;
    addAccess(accessType: AccessControlType, sid: SecurityIdentifier, rule: ObjectAccessRule): void;
    copyTo(array: ClrArray, index: int): void;
    copyTo(array: GenericAce[], index: int): void;
    getEnumerator(): IEnumerator;
    getEnumerator(): AceEnumerator;
    removeAccess(accessType: AccessControlType, sid: SecurityIdentifier, accessMask: int, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags): boolean;
    removeAccess(accessType: AccessControlType, sid: SecurityIdentifier, accessMask: int, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, objectFlags: ObjectAceFlags, objectType: Guid, inheritedObjectType: Guid): boolean;
    removeAccess(accessType: AccessControlType, sid: SecurityIdentifier, rule: ObjectAccessRule): boolean;
    removeAccessSpecific(accessType: AccessControlType, sid: SecurityIdentifier, accessMask: int, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags): void;
    removeAccessSpecific(accessType: AccessControlType, sid: SecurityIdentifier, accessMask: int, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, objectFlags: ObjectAceFlags, objectType: Guid, inheritedObjectType: Guid): void;
    removeAccessSpecific(accessType: AccessControlType, sid: SecurityIdentifier, rule: ObjectAccessRule): void;
    setAccess(accessType: AccessControlType, sid: SecurityIdentifier, accessMask: int, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags): void;
    setAccess(accessType: AccessControlType, sid: SecurityIdentifier, accessMask: int, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, objectFlags: ObjectAceFlags, objectType: Guid, inheritedObjectType: Guid): void;
    setAccess(accessType: AccessControlType, sid: SecurityIdentifier, rule: ObjectAccessRule): void;
}


export const DiscretionaryAcl: {
    new(isContainer: boolean, isDS: boolean, revision: byte, capacity: int): DiscretionaryAcl$instance;
    new(isContainer: boolean, isDS: boolean, capacity: int): DiscretionaryAcl$instance;
    new(isContainer: boolean, isDS: boolean, rawAcl: RawAcl): DiscretionaryAcl$instance;
};


export interface __DiscretionaryAcl$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type DiscretionaryAcl = DiscretionaryAcl$instance & __DiscretionaryAcl$views;


export interface EventWaitHandleAccessRule$instance extends AccessRule {
    readonly eventWaitHandleRights: EventWaitHandleRights;
}


export const EventWaitHandleAccessRule: {
    new(identity: IdentityReference, eventRights: EventWaitHandleRights, type_: AccessControlType): EventWaitHandleAccessRule$instance;
    new(identity: string, eventRights: EventWaitHandleRights, type_: AccessControlType): EventWaitHandleAccessRule$instance;
};


export type EventWaitHandleAccessRule = EventWaitHandleAccessRule$instance;

export interface EventWaitHandleAuditRule$instance extends AuditRule {
    readonly eventWaitHandleRights: EventWaitHandleRights;
}


export const EventWaitHandleAuditRule: {
    new(identity: IdentityReference, eventRights: EventWaitHandleRights, flags: AuditFlags): EventWaitHandleAuditRule$instance;
};


export type EventWaitHandleAuditRule = EventWaitHandleAuditRule$instance;

export interface EventWaitHandleSecurity$instance extends NativeObjectSecurity {
    readonly accessRightType: Type;
    readonly accessRuleType: Type;
    readonly auditRuleType: Type;
    accessRuleFactory(identityReference: IdentityReference, accessMask: int, isInherited: boolean, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, type_: AccessControlType): AccessRule;
    addAccessRule(rule: EventWaitHandleAccessRule): void;
    addAuditRule(rule: EventWaitHandleAuditRule): void;
    auditRuleFactory(identityReference: IdentityReference, accessMask: int, isInherited: boolean, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, flags: AuditFlags): AuditRule;
    removeAccessRule(rule: EventWaitHandleAccessRule): boolean;
    removeAccessRuleAll(rule: EventWaitHandleAccessRule): void;
    removeAccessRuleSpecific(rule: EventWaitHandleAccessRule): void;
    removeAuditRule(rule: EventWaitHandleAuditRule): boolean;
    removeAuditRuleAll(rule: EventWaitHandleAuditRule): void;
    removeAuditRuleSpecific(rule: EventWaitHandleAuditRule): void;
    resetAccessRule(rule: EventWaitHandleAccessRule): void;
    setAccessRule(rule: EventWaitHandleAccessRule): void;
    setAuditRule(rule: EventWaitHandleAuditRule): void;
}


export const EventWaitHandleSecurity: {
    new(): EventWaitHandleSecurity$instance;
};


export type EventWaitHandleSecurity = EventWaitHandleSecurity$instance;

export interface FileSecurity$instance extends FileSystemSecurity {
}


export const FileSecurity: {
    new(): FileSecurity$instance;
    new(fileName: string, includeSections: AccessControlSections): FileSecurity$instance;
};


export type FileSecurity = FileSecurity$instance;

export interface FileSystemAccessRule$instance extends AccessRule {
    readonly fileSystemRights: FileSystemRights;
}


export const FileSystemAccessRule: {
    new(identity: IdentityReference, fileSystemRights: FileSystemRights, type_: AccessControlType): FileSystemAccessRule$instance;
    new(identity: IdentityReference, fileSystemRights: FileSystemRights, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, type_: AccessControlType): FileSystemAccessRule$instance;
    new(identity: string, fileSystemRights: FileSystemRights, type_: AccessControlType): FileSystemAccessRule$instance;
    new(identity: string, fileSystemRights: FileSystemRights, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, type_: AccessControlType): FileSystemAccessRule$instance;
};


export type FileSystemAccessRule = FileSystemAccessRule$instance;

export interface FileSystemAuditRule$instance extends AuditRule {
    readonly fileSystemRights: FileSystemRights;
}


export const FileSystemAuditRule: {
    new(identity: IdentityReference, fileSystemRights: FileSystemRights, flags: AuditFlags): FileSystemAuditRule$instance;
    new(identity: IdentityReference, fileSystemRights: FileSystemRights, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, flags: AuditFlags): FileSystemAuditRule$instance;
    new(identity: string, fileSystemRights: FileSystemRights, flags: AuditFlags): FileSystemAuditRule$instance;
    new(identity: string, fileSystemRights: FileSystemRights, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, flags: AuditFlags): FileSystemAuditRule$instance;
};


export type FileSystemAuditRule = FileSystemAuditRule$instance;

export interface FileSystemSecurity$instance extends NativeObjectSecurity {
    readonly accessRightType: Type;
    readonly accessRuleType: Type;
    readonly auditRuleType: Type;
    accessRuleFactory(identityReference: IdentityReference, accessMask: int, isInherited: boolean, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, type_: AccessControlType): AccessRule;
    addAccessRule(rule: FileSystemAccessRule): void;
    addAuditRule(rule: FileSystemAuditRule): void;
    auditRuleFactory(identityReference: IdentityReference, accessMask: int, isInherited: boolean, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, flags: AuditFlags): AuditRule;
    removeAccessRule(rule: FileSystemAccessRule): boolean;
    removeAccessRuleAll(rule: FileSystemAccessRule): void;
    removeAccessRuleSpecific(rule: FileSystemAccessRule): void;
    removeAuditRule(rule: FileSystemAuditRule): boolean;
    removeAuditRuleAll(rule: FileSystemAuditRule): void;
    removeAuditRuleSpecific(rule: FileSystemAuditRule): void;
    resetAccessRule(rule: FileSystemAccessRule): void;
    setAccessRule(rule: FileSystemAccessRule): void;
    setAuditRule(rule: FileSystemAuditRule): void;
}


export const FileSystemSecurity: {
};


export type FileSystemSecurity = FileSystemSecurity$instance;

export interface GenericAce$instance {
    aceFlags: AceFlags;
    readonly aceType: AceType;
    readonly auditFlags: AuditFlags;
    readonly binaryLength: int;
    readonly inheritanceFlags: InheritanceFlags;
    readonly isInherited: boolean;
    readonly propagationFlags: PropagationFlags;
    copy(): GenericAce;
    equals(o: unknown): boolean;
    getBinaryForm(binaryForm: byte[], offset: int): void;
    getHashCode(): int;
}


export const GenericAce: {
    createFromBinaryForm(binaryForm: byte[], offset: int): GenericAce;
};


export type GenericAce = GenericAce$instance;

export interface GenericAcl$instance {
    readonly binaryLength: int;
    readonly count: int;
    readonly isSynchronized: boolean;
    item: GenericAce;
    readonly revision: byte;
    readonly syncRoot: unknown;
    copyTo(array: GenericAce[], index: int): void;
    getBinaryForm(binaryForm: byte[], offset: int): void;
    getEnumerator(): AceEnumerator;
}


export const GenericAcl: {
    readonly aclRevision: byte;
    readonly aclRevisionDS: byte;
    readonly maxBinaryLength: int;
};


export interface __GenericAcl$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type GenericAcl = GenericAcl$instance & __GenericAcl$views;


export interface GenericSecurityDescriptor$instance {
    readonly binaryLength: int;
    readonly controlFlags: ControlFlags;
    group: SecurityIdentifier;
    owner: SecurityIdentifier;
    getBinaryForm(binaryForm: byte[], offset: int): void;
    getSddlForm(includeSections: AccessControlSections): string;
}


export const GenericSecurityDescriptor: {
    readonly revision: byte;
    isSddlConversionSupported(): boolean;
};


export type GenericSecurityDescriptor = GenericSecurityDescriptor$instance;

export interface KnownAce$instance extends GenericAce {
    accessMask: int;
    securityIdentifier: SecurityIdentifier;
}


export const KnownAce: {
};


export type KnownAce = KnownAce$instance;

export interface MutexAccessRule$instance extends AccessRule {
    readonly mutexRights: MutexRights;
}


export const MutexAccessRule: {
    new(identity: IdentityReference, eventRights: MutexRights, type_: AccessControlType): MutexAccessRule$instance;
    new(identity: string, eventRights: MutexRights, type_: AccessControlType): MutexAccessRule$instance;
};


export type MutexAccessRule = MutexAccessRule$instance;

export interface MutexAuditRule$instance extends AuditRule {
    readonly mutexRights: MutexRights;
}


export const MutexAuditRule: {
    new(identity: IdentityReference, eventRights: MutexRights, flags: AuditFlags): MutexAuditRule$instance;
};


export type MutexAuditRule = MutexAuditRule$instance;

export interface MutexSecurity$instance extends NativeObjectSecurity {
    readonly accessRightType: Type;
    readonly accessRuleType: Type;
    readonly auditRuleType: Type;
    accessRuleFactory(identityReference: IdentityReference, accessMask: int, isInherited: boolean, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, type_: AccessControlType): AccessRule;
    addAccessRule(rule: MutexAccessRule): void;
    addAuditRule(rule: MutexAuditRule): void;
    auditRuleFactory(identityReference: IdentityReference, accessMask: int, isInherited: boolean, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, flags: AuditFlags): AuditRule;
    removeAccessRule(rule: MutexAccessRule): boolean;
    removeAccessRuleAll(rule: MutexAccessRule): void;
    removeAccessRuleSpecific(rule: MutexAccessRule): void;
    removeAuditRule(rule: MutexAuditRule): boolean;
    removeAuditRuleAll(rule: MutexAuditRule): void;
    removeAuditRuleSpecific(rule: MutexAuditRule): void;
    resetAccessRule(rule: MutexAccessRule): void;
    setAccessRule(rule: MutexAccessRule): void;
    setAuditRule(rule: MutexAuditRule): void;
}


export const MutexSecurity: {
    new(): MutexSecurity$instance;
    new(name: string, includeSections: AccessControlSections): MutexSecurity$instance;
};


export type MutexSecurity = MutexSecurity$instance;

export interface NativeObjectSecurity$instance extends CommonObjectSecurity {
}


export const NativeObjectSecurity: {
};


export type NativeObjectSecurity = NativeObjectSecurity$instance;

export interface ObjectAccessRule$instance extends AccessRule {
    readonly inheritedObjectType: Guid;
    readonly objectFlags: ObjectAceFlags;
    readonly objectType: Guid;
}


export const ObjectAccessRule: {
};


export type ObjectAccessRule = ObjectAccessRule$instance;

export interface ObjectAce$instance extends QualifiedAce {
    readonly binaryLength: int;
    inheritedObjectAceType: Guid;
    objectAceFlags: ObjectAceFlags;
    objectAceType: Guid;
    getBinaryForm(binaryForm: byte[], offset: int): void;
}


export const ObjectAce: {
    new(aceFlags: AceFlags, qualifier: AceQualifier, accessMask: int, sid: SecurityIdentifier, flags: ObjectAceFlags, type_: Guid, inheritedType: Guid, isCallback: boolean, opaque: byte[]): ObjectAce$instance;
    maxOpaqueLength(isCallback: boolean): int;
};


export type ObjectAce = ObjectAce$instance;

export interface ObjectAuditRule$instance extends AuditRule {
    readonly inheritedObjectType: Guid;
    readonly objectFlags: ObjectAceFlags;
    readonly objectType: Guid;
}


export const ObjectAuditRule: {
};


export type ObjectAuditRule = ObjectAuditRule$instance;

export interface ObjectSecurity$instance {
    readonly accessRightType: Type;
    readonly accessRuleType: Type;
    readonly areAccessRulesCanonical: boolean;
    readonly areAccessRulesProtected: boolean;
    readonly areAuditRulesCanonical: boolean;
    readonly areAuditRulesProtected: boolean;
    readonly auditRuleType: Type;
    accessRuleFactory(identityReference: IdentityReference, accessMask: int, isInherited: boolean, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, type_: AccessControlType): AccessRule;
    auditRuleFactory(identityReference: IdentityReference, accessMask: int, isInherited: boolean, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, flags: AuditFlags): AuditRule;
    getGroup(targetType: Type): IdentityReference;
    getOwner(targetType: Type): IdentityReference;
    getSecurityDescriptorBinaryForm(): byte[];
    getSecurityDescriptorSddlForm(includeSections: AccessControlSections): string;
    modifyAccessRule(modification: AccessControlModification, rule: AccessRule, modified: { value: ref<boolean> }): boolean;
    modifyAuditRule(modification: AccessControlModification, rule: AuditRule, modified: { value: ref<boolean> }): boolean;
    purgeAccessRules(identity: IdentityReference): void;
    purgeAuditRules(identity: IdentityReference): void;
    setAccessRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
    setAuditRuleProtection(isProtected: boolean, preserveInheritance: boolean): void;
    setGroup(identity: IdentityReference): void;
    setOwner(identity: IdentityReference): void;
    setSecurityDescriptorBinaryForm(binaryForm: byte[]): void;
    setSecurityDescriptorBinaryForm(binaryForm: byte[], includeSections: AccessControlSections): void;
    setSecurityDescriptorSddlForm(sddlForm: string): void;
    setSecurityDescriptorSddlForm(sddlForm: string, includeSections: AccessControlSections): void;
}


export const ObjectSecurity: {
    isSddlConversionSupported(): boolean;
};


export type ObjectSecurity = ObjectSecurity$instance;

export interface ObjectSecurity_1$instance<T extends unknown> extends NativeObjectSecurity {
    readonly accessRightType: Type;
    readonly accessRuleType: Type;
    readonly auditRuleType: Type;
    accessRuleFactory(identityReference: IdentityReference, accessMask: int, isInherited: boolean, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, type_: AccessControlType): AccessRule;
    addAccessRule(rule: AccessRule_1<T>): void;
    addAuditRule(rule: AuditRule_1<T>): void;
    auditRuleFactory(identityReference: IdentityReference, accessMask: int, isInherited: boolean, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, flags: AuditFlags): AuditRule;
    removeAccessRule(rule: AccessRule_1<T>): boolean;
    removeAccessRuleAll(rule: AccessRule_1<T>): void;
    removeAccessRuleSpecific(rule: AccessRule_1<T>): void;
    removeAuditRule(rule: AuditRule_1<T>): boolean;
    removeAuditRuleAll(rule: AuditRule_1<T>): void;
    removeAuditRuleSpecific(rule: AuditRule_1<T>): void;
    resetAccessRule(rule: AccessRule_1<T>): void;
    setAccessRule(rule: AccessRule_1<T>): void;
    setAuditRule(rule: AuditRule_1<T>): void;
}


export const ObjectSecurity_1: {
};


export type ObjectSecurity_1<T> = ObjectSecurity_1$instance<T>;

export interface PrivilegeNotHeldException$instance extends UnauthorizedAccessException {
    readonly privilegeName: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const PrivilegeNotHeldException: {
    new(): PrivilegeNotHeldException$instance;
    new(privilege: string): PrivilegeNotHeldException$instance;
    new(privilege: string, inner: Exception): PrivilegeNotHeldException$instance;
};


export interface __PrivilegeNotHeldException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type PrivilegeNotHeldException = PrivilegeNotHeldException$instance & __PrivilegeNotHeldException$views;


export interface QualifiedAce$instance extends KnownAce {
    readonly aceQualifier: AceQualifier;
    readonly isCallback: boolean;
    readonly opaqueLength: int;
    getOpaque(): byte[];
    setOpaque(opaque: byte[]): void;
}


export const QualifiedAce: {
};


export type QualifiedAce = QualifiedAce$instance;

export interface RawAcl$instance extends GenericAcl$instance {
    readonly binaryLength: int;
    readonly count: int;
    item: GenericAce;
    readonly revision: byte;
    copyTo(array: GenericAce[], index: int): void;
    copyTo(array: ClrArray, index: int): void;
    getBinaryForm(binaryForm: byte[], offset: int): void;
    getEnumerator(): AceEnumerator;
    getEnumerator(): IEnumerator;
    insertAce(index: int, ace: GenericAce): void;
    removeAce(index: int): void;
}


export const RawAcl: {
    new(revision: byte, capacity: int): RawAcl$instance;
    new(binaryForm: byte[], offset: int): RawAcl$instance;
};


export interface __RawAcl$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type RawAcl = RawAcl$instance & __RawAcl$views;


export interface RawSecurityDescriptor$instance extends GenericSecurityDescriptor {
    readonly controlFlags: ControlFlags;
    discretionaryAcl: RawAcl;
    group: SecurityIdentifier;
    owner: SecurityIdentifier;
    resourceManagerControl: byte;
    systemAcl: RawAcl;
    setFlags(flags: ControlFlags): void;
}


export const RawSecurityDescriptor: {
    new(binaryForm: byte[], offset: int): RawSecurityDescriptor$instance;
    new(flags: ControlFlags, owner: SecurityIdentifier, group: SecurityIdentifier, systemAcl: RawAcl, discretionaryAcl: RawAcl): RawSecurityDescriptor$instance;
    new(sddlForm: string): RawSecurityDescriptor$instance;
};


export type RawSecurityDescriptor = RawSecurityDescriptor$instance;

export interface RegistryAccessRule$instance extends AccessRule {
    readonly registryRights: RegistryRights;
}


export const RegistryAccessRule: {
    new(identity: IdentityReference, registryRights: RegistryRights, type_: AccessControlType): RegistryAccessRule$instance;
    new(identity: IdentityReference, registryRights: RegistryRights, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, type_: AccessControlType): RegistryAccessRule$instance;
    new(identity: string, registryRights: RegistryRights, type_: AccessControlType): RegistryAccessRule$instance;
    new(identity: string, registryRights: RegistryRights, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, type_: AccessControlType): RegistryAccessRule$instance;
};


export type RegistryAccessRule = RegistryAccessRule$instance;

export interface RegistryAuditRule$instance extends AuditRule {
    readonly registryRights: RegistryRights;
}


export const RegistryAuditRule: {
    new(identity: IdentityReference, registryRights: RegistryRights, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, flags: AuditFlags): RegistryAuditRule$instance;
    new(identity: string, registryRights: RegistryRights, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, flags: AuditFlags): RegistryAuditRule$instance;
};


export type RegistryAuditRule = RegistryAuditRule$instance;

export interface RegistrySecurity$instance extends NativeObjectSecurity {
    readonly accessRightType: Type;
    readonly accessRuleType: Type;
    readonly auditRuleType: Type;
    accessRuleFactory(identityReference: IdentityReference, accessMask: int, isInherited: boolean, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, type_: AccessControlType): AccessRule;
    addAccessRule(rule: RegistryAccessRule): void;
    addAuditRule(rule: RegistryAuditRule): void;
    auditRuleFactory(identityReference: IdentityReference, accessMask: int, isInherited: boolean, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, flags: AuditFlags): AuditRule;
    removeAccessRule(rule: RegistryAccessRule): boolean;
    removeAccessRuleAll(rule: RegistryAccessRule): void;
    removeAccessRuleSpecific(rule: RegistryAccessRule): void;
    removeAuditRule(rule: RegistryAuditRule): boolean;
    removeAuditRuleAll(rule: RegistryAuditRule): void;
    removeAuditRuleSpecific(rule: RegistryAuditRule): void;
    resetAccessRule(rule: RegistryAccessRule): void;
    setAccessRule(rule: RegistryAccessRule): void;
    setAuditRule(rule: RegistryAuditRule): void;
}


export const RegistrySecurity: {
    new(): RegistrySecurity$instance;
};


export type RegistrySecurity = RegistrySecurity$instance;

export interface SemaphoreAccessRule$instance extends AccessRule {
    readonly semaphoreRights: SemaphoreRights;
}


export const SemaphoreAccessRule: {
    new(identity: IdentityReference, eventRights: SemaphoreRights, type_: AccessControlType): SemaphoreAccessRule$instance;
    new(identity: string, eventRights: SemaphoreRights, type_: AccessControlType): SemaphoreAccessRule$instance;
};


export type SemaphoreAccessRule = SemaphoreAccessRule$instance;

export interface SemaphoreAuditRule$instance extends AuditRule {
    readonly semaphoreRights: SemaphoreRights;
}


export const SemaphoreAuditRule: {
    new(identity: IdentityReference, eventRights: SemaphoreRights, flags: AuditFlags): SemaphoreAuditRule$instance;
};


export type SemaphoreAuditRule = SemaphoreAuditRule$instance;

export interface SemaphoreSecurity$instance extends NativeObjectSecurity {
    readonly accessRightType: Type;
    readonly accessRuleType: Type;
    readonly auditRuleType: Type;
    accessRuleFactory(identityReference: IdentityReference, accessMask: int, isInherited: boolean, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, type_: AccessControlType): AccessRule;
    addAccessRule(rule: SemaphoreAccessRule): void;
    addAuditRule(rule: SemaphoreAuditRule): void;
    auditRuleFactory(identityReference: IdentityReference, accessMask: int, isInherited: boolean, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, flags: AuditFlags): AuditRule;
    removeAccessRule(rule: SemaphoreAccessRule): boolean;
    removeAccessRuleAll(rule: SemaphoreAccessRule): void;
    removeAccessRuleSpecific(rule: SemaphoreAccessRule): void;
    removeAuditRule(rule: SemaphoreAuditRule): boolean;
    removeAuditRuleAll(rule: SemaphoreAuditRule): void;
    removeAuditRuleSpecific(rule: SemaphoreAuditRule): void;
    resetAccessRule(rule: SemaphoreAccessRule): void;
    setAccessRule(rule: SemaphoreAccessRule): void;
    setAuditRule(rule: SemaphoreAuditRule): void;
}


export const SemaphoreSecurity: {
    new(): SemaphoreSecurity$instance;
    new(name: string, includeSections: AccessControlSections): SemaphoreSecurity$instance;
};


export type SemaphoreSecurity = SemaphoreSecurity$instance;

export interface SystemAcl$instance extends CommonAcl$instance {
    addAudit(auditFlags: AuditFlags, sid: SecurityIdentifier, accessMask: int, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags): void;
    addAudit(auditFlags: AuditFlags, sid: SecurityIdentifier, accessMask: int, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, objectFlags: ObjectAceFlags, objectType: Guid, inheritedObjectType: Guid): void;
    addAudit(sid: SecurityIdentifier, rule: ObjectAuditRule): void;
    copyTo(array: ClrArray, index: int): void;
    copyTo(array: GenericAce[], index: int): void;
    getEnumerator(): IEnumerator;
    getEnumerator(): AceEnumerator;
    removeAudit(auditFlags: AuditFlags, sid: SecurityIdentifier, accessMask: int, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags): boolean;
    removeAudit(auditFlags: AuditFlags, sid: SecurityIdentifier, accessMask: int, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, objectFlags: ObjectAceFlags, objectType: Guid, inheritedObjectType: Guid): boolean;
    removeAudit(sid: SecurityIdentifier, rule: ObjectAuditRule): boolean;
    removeAuditSpecific(auditFlags: AuditFlags, sid: SecurityIdentifier, accessMask: int, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags): void;
    removeAuditSpecific(auditFlags: AuditFlags, sid: SecurityIdentifier, accessMask: int, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, objectFlags: ObjectAceFlags, objectType: Guid, inheritedObjectType: Guid): void;
    removeAuditSpecific(sid: SecurityIdentifier, rule: ObjectAuditRule): void;
    setAudit(auditFlags: AuditFlags, sid: SecurityIdentifier, accessMask: int, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags): void;
    setAudit(auditFlags: AuditFlags, sid: SecurityIdentifier, accessMask: int, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, objectFlags: ObjectAceFlags, objectType: Guid, inheritedObjectType: Guid): void;
    setAudit(sid: SecurityIdentifier, rule: ObjectAuditRule): void;
}


export const SystemAcl: {
    new(isContainer: boolean, isDS: boolean, revision: byte, capacity: int): SystemAcl$instance;
    new(isContainer: boolean, isDS: boolean, capacity: int): SystemAcl$instance;
    new(isContainer: boolean, isDS: boolean, rawAcl: RawAcl): SystemAcl$instance;
};


export interface __SystemAcl$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type SystemAcl = SystemAcl$instance & __SystemAcl$views;


