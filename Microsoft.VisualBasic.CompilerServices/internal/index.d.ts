// Generated by tsbindgen - Architecture
// Namespace: Microsoft.VisualBasic.CompilerServices
// Assembly: Microsoft.VisualBasic.Core

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { CallType, CompareMethod } from "../../Microsoft.VisualBasic/internal/index.js";
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { CultureInfo, NumberFormatInfo } from "../../System.Globalization/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Attribute, Boolean as ClrBoolean, Byte, Char, DateTime, Decimal, Double, Exception, Int16, Int32, Int64, Object as ClrObject, SByte, Single, String as ClrString, Type, UInt16, UInt32, UInt64, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface BooleanType$instance {
}


export const BooleanType: {
    new(): BooleanType$instance;
    fromObject(Value: unknown): boolean;
    fromString(Value: string): boolean;
};


export type BooleanType = BooleanType$instance;

export interface ByteType$instance {
}


export const ByteType: {
    new(): ByteType$instance;
    fromObject(Value: unknown): byte;
    fromString(Value: string): byte;
};


export type ByteType = ByteType$instance;

export interface CharArrayType$instance {
}


export const CharArrayType: {
    new(): CharArrayType$instance;
    fromObject(Value: unknown): char[];
    fromString(Value: string): char[];
};


export type CharArrayType = CharArrayType$instance;

export interface CharType$instance {
}


export const CharType: {
    new(): CharType$instance;
    fromObject(Value: unknown): char;
    fromString(Value: string): char;
};


export type CharType = CharType$instance;

export interface Conversions$instance {
}


export const Conversions: {
    new(): Conversions$instance;
    changeType(Expression: unknown, TargetType: Type): unknown;
    fallbackUserDefinedConversion(Expression: unknown, TargetType: Type): unknown;
    fromCharAndCount(Value: char, Count: int): string;
    fromCharArray(Value: char[]): string;
    fromCharArraySubset(Value: char[], StartIndex: int, Length: int): string;
    toBoolean(Value: unknown): boolean;
    toBoolean(Value: string): boolean;
    toByte(Value: unknown): byte;
    toByte(Value: string): byte;
    toChar(Value: unknown): char;
    toChar(Value: string): char;
    toCharArrayRankOne(Value: unknown): char[];
    toCharArrayRankOne(Value: string): char[];
    toDate(Value: unknown): DateTime;
    toDate(Value: string): DateTime;
    toDecimal(Value: boolean): decimal;
    toDecimal(Value: unknown): decimal;
    toDecimal(Value: string): decimal;
    toDouble(Value: unknown): double;
    toDouble(Value: string): double;
    toGenericParameter<T>(Value: unknown): T;
    toInteger(Value: unknown): int;
    toInteger(Value: string): int;
    toLong(Value: unknown): long;
    toLong(Value: string): long;
    toSByte(Value: unknown): sbyte;
    toSByte(Value: string): sbyte;
    toShort(Value: unknown): short;
    toShort(Value: string): short;
    toSingle(Value: unknown): float;
    toSingle(Value: string): float;
    toString(Value: boolean): string;
    toString(Value: byte): string;
    toString(Value: char): string;
    toString(Value: DateTime): string;
    toString(Value: decimal, NumberFormat: NumberFormatInfo): string;
    toString(Value: decimal): string;
    toString(Value: double, NumberFormat: NumberFormatInfo): string;
    toString(Value: double): string;
    toString(Value: short): string;
    toString(Value: int): string;
    toString(Value: long): string;
    toString(Value: unknown): string;
    toString(Value: float, NumberFormat: NumberFormatInfo): string;
    toString(Value: float): string;
    toString(Value: uint): string;
    toString(Value: ulong): string;
    toUInteger(Value: unknown): uint;
    toUInteger(Value: string): uint;
    toULong(Value: unknown): ulong;
    toULong(Value: string): ulong;
    toUShort(Value: unknown): ushort;
    toUShort(Value: string): ushort;
};


export type Conversions = Conversions$instance;

export interface DateType$instance {
}


export const DateType: {
    new(): DateType$instance;
    fromObject(Value: unknown): DateTime;
    fromString(Value: string, culture: CultureInfo): DateTime;
    fromString(Value: string): DateTime;
};


export type DateType = DateType$instance;

export interface DecimalType$instance {
}


export const DecimalType: {
    new(): DecimalType$instance;
    fromBoolean(Value: boolean): decimal;
    fromObject(Value: unknown, NumberFormat: NumberFormatInfo): decimal;
    fromObject(Value: unknown): decimal;
    fromString(Value: string, NumberFormat: NumberFormatInfo): decimal;
    fromString(Value: string): decimal;
    parse(Value: string, NumberFormat: NumberFormatInfo): decimal;
};


export type DecimalType = DecimalType$instance;

export interface DesignerGeneratedAttribute$instance extends Attribute {
}


export const DesignerGeneratedAttribute: {
    new(): DesignerGeneratedAttribute$instance;
};


export type DesignerGeneratedAttribute = DesignerGeneratedAttribute$instance;

export interface DoubleType$instance {
}


export const DoubleType: {
    new(): DoubleType$instance;
    fromObject(Value: unknown, NumberFormat: NumberFormatInfo): double;
    fromObject(Value: unknown): double;
    fromString(Value: string, NumberFormat: NumberFormatInfo): double;
    fromString(Value: string): double;
    parse(Value: string, NumberFormat: NumberFormatInfo): double;
    parse(Value: string): double;
};


export type DoubleType = DoubleType$instance;

export interface IncompleteInitialization$instance extends Exception {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const IncompleteInitialization: {
    new(): IncompleteInitialization$instance;
};


export interface __IncompleteInitialization$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type IncompleteInitialization = IncompleteInitialization$instance & __IncompleteInitialization$views;


export interface IntegerType$instance {
}


export const IntegerType: {
    new(): IntegerType$instance;
    fromObject(Value: unknown): int;
    fromString(Value: string): int;
};


export type IntegerType = IntegerType$instance;

export interface LateBinding$instance {
}


export const LateBinding: {
    new(): LateBinding$instance;
    lateCall(o: unknown, objType: Type, name: string, args: unknown[], paramnames: string[], CopyBack: boolean[]): void;
    lateGet(o: unknown, objType: Type, name: string, args: unknown[], paramnames: string[], CopyBack: boolean[]): unknown;
    lateIndexGet(o: unknown, args: unknown[], paramnames: string[]): unknown;
    lateIndexSet(o: unknown, args: unknown[], paramnames: string[]): void;
    lateIndexSetComplex(o: unknown, args: unknown[], paramnames: string[], OptimisticSet: boolean, RValueBase: boolean): void;
    lateSet(o: unknown, objType: Type, name: string, args: unknown[], paramnames: string[]): void;
    lateSetComplex(o: unknown, objType: Type, name: string, args: unknown[], paramnames: string[], OptimisticSet: boolean, RValueBase: boolean): void;
};


export type LateBinding = LateBinding$instance;

export interface LikeOperator$instance {
}


export const LikeOperator: {
    new(): LikeOperator$instance;
    likeObject(Source: unknown, Pattern: unknown, CompareOption: CompareMethod): unknown;
    likeString(Source: string, Pattern: string, CompareOption: CompareMethod): boolean;
};


export type LikeOperator = LikeOperator$instance;

export interface LongType$instance {
}


export const LongType: {
    new(): LongType$instance;
    fromObject(Value: unknown): long;
    fromString(Value: string): long;
};


export type LongType = LongType$instance;

export interface NewLateBinding$instance {
}


export const NewLateBinding: {
    new(): NewLateBinding$instance;
    fallbackCall(Instance: unknown, MemberName: string, Arguments: unknown[], ArgumentNames: string[], IgnoreReturn: boolean): unknown;
    fallbackGet(Instance: unknown, MemberName: string, Arguments: unknown[], ArgumentNames: string[]): unknown;
    fallbackIndexSet(Instance: unknown, Arguments: unknown[], ArgumentNames: string[]): void;
    fallbackIndexSetComplex(Instance: unknown, Arguments: unknown[], ArgumentNames: string[], OptimisticSet: boolean, RValueBase: boolean): void;
    fallbackInvokeDefault1(Instance: unknown, Arguments: unknown[], ArgumentNames: string[], ReportErrors: boolean): unknown;
    fallbackInvokeDefault2(Instance: unknown, Arguments: unknown[], ArgumentNames: string[], ReportErrors: boolean): unknown;
    fallbackSet(Instance: unknown, MemberName: string, Arguments: unknown[]): void;
    fallbackSetComplex(Instance: unknown, MemberName: string, Arguments: unknown[], OptimisticSet: boolean, RValueBase: boolean): void;
    lateCall(Instance: unknown, Type: Type, MemberName: string, Arguments: unknown[], ArgumentNames: string[], TypeArguments: Type[], CopyBack: boolean[], IgnoreReturn: boolean): unknown;
    lateCallInvokeDefault(Instance: unknown, Arguments: unknown[], ArgumentNames: string[], ReportErrors: boolean): unknown;
    lateGet(Instance: unknown, Type: Type, MemberName: string, Arguments: unknown[], ArgumentNames: string[], TypeArguments: Type[], CopyBack: boolean[]): unknown;
    lateGetInvokeDefault(Instance: unknown, Arguments: unknown[], ArgumentNames: string[], ReportErrors: boolean): unknown;
    lateIndexGet(Instance: unknown, Arguments: unknown[], ArgumentNames: string[]): unknown;
    lateIndexSet(Instance: unknown, Arguments: unknown[], ArgumentNames: string[]): void;
    lateIndexSetComplex(Instance: unknown, Arguments: unknown[], ArgumentNames: string[], OptimisticSet: boolean, RValueBase: boolean): void;
    lateSet(Instance: unknown, Type: Type, MemberName: string, Arguments: unknown[], ArgumentNames: string[], TypeArguments: Type[], OptimisticSet: boolean, RValueBase: boolean, CallType: CallType): void;
    lateSet(Instance: unknown, Type: Type, MemberName: string, Arguments: unknown[], ArgumentNames: string[], TypeArguments: Type[]): void;
    lateSetComplex(Instance: unknown, Type: Type, MemberName: string, Arguments: unknown[], ArgumentNames: string[], TypeArguments: Type[], OptimisticSet: boolean, RValueBase: boolean): void;
};


export type NewLateBinding = NewLateBinding$instance;

export interface ObjectFlowControl$instance {
}


export const ObjectFlowControl: {
    new(): ObjectFlowControl$instance;
    checkForSyncLockOnValueType(Expression: unknown): void;
};


export type ObjectFlowControl = ObjectFlowControl$instance;

export interface ObjectFlowControl_ForLoopControl$instance {
}


export const ObjectFlowControl_ForLoopControl: {
    new(): ObjectFlowControl_ForLoopControl$instance;
    forLoopInitObj(Counter: unknown, Start: unknown, Limit: unknown, StepValue: unknown, LoopForResult: { value: ref<unknown> }, CounterResult: { value: ref<unknown> }): boolean;
    forNextCheckDec(count: decimal, limit: decimal, StepValue: decimal): boolean;
    forNextCheckObj(Counter: unknown, LoopObj: unknown, CounterResult: { value: ref<unknown> }): boolean;
    forNextCheckR4(count: float, limit: float, StepValue: float): boolean;
    forNextCheckR8(count: double, limit: double, StepValue: double): boolean;
};


export type ObjectFlowControl_ForLoopControl = ObjectFlowControl_ForLoopControl$instance;

export interface ObjectType$instance {
}


export const ObjectType: {
    new(): ObjectType$instance;
    addObj(o1: unknown, o2: unknown): unknown;
    bitAndObj(obj1: unknown, obj2: unknown): unknown;
    bitOrObj(obj1: unknown, obj2: unknown): unknown;
    bitXorObj(obj1: unknown, obj2: unknown): unknown;
    divObj(o1: unknown, o2: unknown): unknown;
    getObjectValuePrimitive(o: unknown): unknown;
    iDivObj(o1: unknown, o2: unknown): unknown;
    likeObj(vLeft: unknown, vRight: unknown, CompareOption: CompareMethod): boolean;
    modObj(o1: unknown, o2: unknown): unknown;
    mulObj(o1: unknown, o2: unknown): unknown;
    negObj(obj: unknown): unknown;
    notObj(obj: unknown): unknown;
    objTst(o1: unknown, o2: unknown, TextCompare: boolean): int;
    plusObj(obj: unknown): unknown;
    powObj(obj1: unknown, obj2: unknown): unknown;
    shiftLeftObj(o1: unknown, amount: int): unknown;
    shiftRightObj(o1: unknown, amount: int): unknown;
    strCatObj(vLeft: unknown, vRight: unknown): unknown;
    subObj(o1: unknown, o2: unknown): unknown;
    xorObj(obj1: unknown, obj2: unknown): unknown;
};


export type ObjectType = ObjectType$instance;

export interface Operators$instance {
}


export const Operators: {
    new(): Operators$instance;
    addObject(Left: unknown, Right: unknown): unknown;
    andObject(Left: unknown, Right: unknown): unknown;
    compareObjectEqual(Left: unknown, Right: unknown, TextCompare: boolean): unknown;
    compareObjectGreater(Left: unknown, Right: unknown, TextCompare: boolean): unknown;
    compareObjectGreaterEqual(Left: unknown, Right: unknown, TextCompare: boolean): unknown;
    compareObjectLess(Left: unknown, Right: unknown, TextCompare: boolean): unknown;
    compareObjectLessEqual(Left: unknown, Right: unknown, TextCompare: boolean): unknown;
    compareObjectNotEqual(Left: unknown, Right: unknown, TextCompare: boolean): unknown;
    compareString(Left: string, Right: string, TextCompare: boolean): int;
    concatenateObject(Left: unknown, Right: unknown): unknown;
    conditionalCompareObjectEqual(Left: unknown, Right: unknown, TextCompare: boolean): boolean;
    conditionalCompareObjectGreater(Left: unknown, Right: unknown, TextCompare: boolean): boolean;
    conditionalCompareObjectGreaterEqual(Left: unknown, Right: unknown, TextCompare: boolean): boolean;
    conditionalCompareObjectLess(Left: unknown, Right: unknown, TextCompare: boolean): boolean;
    conditionalCompareObjectLessEqual(Left: unknown, Right: unknown, TextCompare: boolean): boolean;
    conditionalCompareObjectNotEqual(Left: unknown, Right: unknown, TextCompare: boolean): boolean;
    divideObject(Left: unknown, Right: unknown): unknown;
    exponentObject(Left: unknown, Right: unknown): unknown;
    fallbackInvokeUserDefinedOperator(vbOp: unknown, arguments: unknown[]): unknown;
    intDivideObject(Left: unknown, Right: unknown): unknown;
    leftShiftObject(Operand: unknown, Amount: unknown): unknown;
    modObject(Left: unknown, Right: unknown): unknown;
    multiplyObject(Left: unknown, Right: unknown): unknown;
    negateObject(Operand: unknown): unknown;
    notObject(Operand: unknown): unknown;
    orObject(Left: unknown, Right: unknown): unknown;
    plusObject(Operand: unknown): unknown;
    rightShiftObject(Operand: unknown, Amount: unknown): unknown;
    subtractObject(Left: unknown, Right: unknown): unknown;
    xorObject(Left: unknown, Right: unknown): unknown;
};


export type Operators = Operators$instance;

export interface OptionCompareAttribute$instance extends Attribute {
}


export const OptionCompareAttribute: {
    new(): OptionCompareAttribute$instance;
};


export type OptionCompareAttribute = OptionCompareAttribute$instance;

export interface OptionTextAttribute$instance extends Attribute {
}


export const OptionTextAttribute: {
    new(): OptionTextAttribute$instance;
};


export type OptionTextAttribute = OptionTextAttribute$instance;

export interface ProjectData$instance {
}


export const ProjectData: {
    new(): ProjectData$instance;
    clearProjectError(): void;
    createProjectError(hr: int): Exception;
    endApp(): void;
    setProjectError(ex: Exception, lErl: int): void;
    setProjectError(ex: Exception): void;
};


export type ProjectData = ProjectData$instance;

export interface ShortType$instance {
}


export const ShortType: {
    new(): ShortType$instance;
    fromObject(Value: unknown): short;
    fromString(Value: string): short;
};


export type ShortType = ShortType$instance;

export interface SingleType$instance {
}


export const SingleType: {
    new(): SingleType$instance;
    fromObject(Value: unknown, NumberFormat: NumberFormatInfo): float;
    fromObject(Value: unknown): float;
    fromString(Value: string, NumberFormat: NumberFormatInfo): float;
    fromString(Value: string): float;
};


export type SingleType = SingleType$instance;

export interface StandardModuleAttribute$instance extends Attribute {
}


export const StandardModuleAttribute: {
    new(): StandardModuleAttribute$instance;
};


export type StandardModuleAttribute = StandardModuleAttribute$instance;

export interface StaticLocalInitFlag$instance {
    state: short;
}


export const StaticLocalInitFlag: {
    new(): StaticLocalInitFlag$instance;
};


export type StaticLocalInitFlag = StaticLocalInitFlag$instance;

export interface StringType$instance {
}


export const StringType: {
    new(): StringType$instance;
    fromBoolean(Value: boolean): string;
    fromByte(Value: byte): string;
    fromChar(Value: char): string;
    fromDate(Value: DateTime): string;
    fromDecimal(Value: decimal, NumberFormat: NumberFormatInfo): string;
    fromDecimal(Value: decimal): string;
    fromDouble(Value: double, NumberFormat: NumberFormatInfo): string;
    fromDouble(Value: double): string;
    fromInteger(Value: int): string;
    fromLong(Value: long): string;
    fromObject(Value: unknown): string;
    fromShort(Value: short): string;
    fromSingle(Value: float, NumberFormat: NumberFormatInfo): string;
    fromSingle(Value: float): string;
    midStmtStr(sDest: { value: ref<string> }, StartPosition: int, MaxInsertLength: int, sInsert: string): void;
    strCmp(sLeft: string, sRight: string, TextCompare: boolean): int;
    strLike(Source: string, Pattern: string, CompareOption: CompareMethod): boolean;
    strLikeBinary(Source: string, Pattern: string): boolean;
    strLikeText(Source: string, Pattern: string): boolean;
};


export type StringType = StringType$instance;

export interface Utils$instance {
}


export const Utils: {
    new(): Utils$instance;
    copyArray(arySrc: ClrArray, aryDest: ClrArray): ClrArray;
    getResourceString(ResourceKey: string, Args: string[]): string;
};


export type Utils = Utils$instance;

export interface Versioned$instance {
}


export const Versioned: {
    new(): Versioned$instance;
    callByName(Instance: unknown, MethodName: string, UseCallType: CallType, Arguments: unknown[]): unknown;
    isNumeric(Expression: unknown): boolean;
    systemTypeName(VbName: string): string;
    typeName(Expression: unknown): string;
    vbTypeName(SystemName: string): string;
};


export type Versioned = Versioned$instance;

