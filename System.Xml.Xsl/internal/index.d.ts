// Generated by tsbindgen - Architecture
// Namespace: System.Xml.Xsl
// Assembly: System.Private.Xml

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { IDictionary_2 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { Stream, TextWriter } from "../../System.IO/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { IXPathNavigable, XPathNavigator, XPathResultType } from "../../System.Xml.XPath/internal/index.js";
import * as System_Xml_Internal from "../../System.Xml/internal/index.js";
import type { IXmlNamespaceResolver, XmlNamespaceManager, XmlNamespaceScope, XmlNameTable, XmlReader, XmlResolver, XmlWriter, XmlWriterSettings } from "../../System.Xml/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { AsyncCallback, Boolean as ClrBoolean, Byte, Delegate, EventArgs, Exception, IAsyncResult, ICloneable, Int32, IntPtr, MulticastDelegate, Object as ClrObject, String as ClrString, SystemException, Type, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export type XsltMessageEncounteredEventHandler = (sender: unknown, e: XsltMessageEncounteredEventArgs) => void;


export interface IXsltContextFunction$instance {
    readonly minargs: int;
    readonly maxargs: int;
    readonly returnType: XPathResultType;
    readonly argTypes: XPathResultType[];
    invoke(xsltContext: XsltContext, args: unknown[], docContext: XPathNavigator): unknown;
}


export type IXsltContextFunction = IXsltContextFunction$instance;

export interface IXsltContextVariable$instance {
    readonly isLocal: boolean;
    readonly isParam: boolean;
    readonly variableType: XPathResultType;
    evaluate(xsltContext: XsltContext): unknown;
}


export type IXsltContextVariable = IXsltContextVariable$instance;

export interface XslCompiledTransform$instance {
    readonly outputSettings: XmlWriterSettings;
    load(stylesheet: XmlReader): void;
    load(stylesheet: XmlReader, settings: XsltSettings, stylesheetResolver: XmlResolver): void;
    load(stylesheet: IXPathNavigable): void;
    load(stylesheet: IXPathNavigable, settings: XsltSettings, stylesheetResolver: XmlResolver): void;
    load(stylesheetUri: string): void;
    load(stylesheetUri: string, settings: XsltSettings, stylesheetResolver: XmlResolver): void;
    load(compiledStylesheet: Type): void;
    load(executeMethod: MethodInfo, queryData: byte[], earlyBoundTypes: Type[]): void;
    transform(input: IXPathNavigable, results: XmlWriter): void;
    transform(input: IXPathNavigable, arguments: XsltArgumentList, results: XmlWriter): void;
    transform(input: IXPathNavigable, arguments: XsltArgumentList, results: TextWriter): void;
    transform(input: IXPathNavigable, arguments: XsltArgumentList, results: Stream): void;
    transform(input: XmlReader, results: XmlWriter): void;
    transform(input: XmlReader, arguments: XsltArgumentList, results: XmlWriter): void;
    transform(input: XmlReader, arguments: XsltArgumentList, results: TextWriter): void;
    transform(input: XmlReader, arguments: XsltArgumentList, results: Stream): void;
    transform(inputUri: string, results: XmlWriter): void;
    transform(inputUri: string, arguments: XsltArgumentList, results: XmlWriter): void;
    transform(inputUri: string, arguments: XsltArgumentList, results: TextWriter): void;
    transform(inputUri: string, arguments: XsltArgumentList, results: Stream): void;
    transform(inputUri: string, resultsFile: string): void;
    transform(input: XmlReader, arguments: XsltArgumentList, results: XmlWriter, documentResolver: XmlResolver): void;
    transform(input: IXPathNavigable, arguments: XsltArgumentList, results: XmlWriter, documentResolver: XmlResolver): void;
}


export const XslCompiledTransform: {
    new(): XslCompiledTransform$instance;
    new(enableDebug: boolean): XslCompiledTransform$instance;
};


export type XslCompiledTransform = XslCompiledTransform$instance;

export interface XsltArgumentList$instance {
    addExtensionObject(namespaceUri: string, extension: unknown): void;
    addParam(name: string, namespaceUri: string, parameter: unknown): void;
    clear(): void;
    getExtensionObject(namespaceUri: string): unknown;
    getParam(name: string, namespaceUri: string): unknown;
    removeExtensionObject(namespaceUri: string): unknown;
    removeParam(name: string, namespaceUri: string): unknown;
}


export const XsltArgumentList: {
    new(): XsltArgumentList$instance;
};


export type XsltArgumentList = XsltArgumentList$instance;

export interface XsltCompileException$instance extends XsltException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const XsltCompileException: {
    new(): XsltCompileException$instance;
    new(message: string): XsltCompileException$instance;
    new(message: string, innerException: Exception): XsltCompileException$instance;
    new(inner: Exception, sourceUri: string, lineNumber: int, linePosition: int): XsltCompileException$instance;
};


export interface __XsltCompileException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XsltCompileException = XsltCompileException$instance & __XsltCompileException$views;


export interface XsltContext$instance extends XmlNamespaceManager {
    readonly whitespace: boolean;
    compareDocument(baseUri: string, nextbaseUri: string): int;
    getEnumerator(): IEnumerator;
    getNamespacesInScope(scope: XmlNamespaceScope): IDictionary_2<CLROf<string>, CLROf<string>>;
    lookupNamespace(prefix: string): string;
    preserveWhitespace(node: XPathNavigator): boolean;
    resolveFunction(prefix: string, name: string, ArgTypes: XPathResultType[]): IXsltContextFunction;
    resolveVariable(prefix: string, name: string): IXsltContextVariable;
}


export const XsltContext: {
};


export interface __XsltContext$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IXmlNamespaceResolver(): System_Xml_Internal.IXmlNamespaceResolver$instance;
}

export type XsltContext = XsltContext$instance & __XsltContext$views;


export interface XsltException$instance extends SystemException {
    readonly lineNumber: int;
    readonly linePosition: int;
    readonly message: string;
    readonly sourceUri: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const XsltException: {
    new(): XsltException$instance;
    new(message: string): XsltException$instance;
    new(message: string, innerException: Exception): XsltException$instance;
};


export interface __XsltException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XsltException = XsltException$instance & __XsltException$views;


export interface XsltMessageEncounteredEventArgs$instance extends EventArgs {
    readonly message: string;
}


export const XsltMessageEncounteredEventArgs: {
};


export type XsltMessageEncounteredEventArgs = XsltMessageEncounteredEventArgs$instance;

export interface XslTransform$instance {
    xmlResolver: XmlResolver;
    load(stylesheet: XmlReader): void;
    load(stylesheet: XmlReader, resolver: XmlResolver): void;
    load(stylesheet: IXPathNavigable): void;
    load(stylesheet: IXPathNavigable, resolver: XmlResolver): void;
    load(stylesheet: XPathNavigator): void;
    load(stylesheet: XPathNavigator, resolver: XmlResolver): void;
    load(url: string): void;
    load(url: string, resolver: XmlResolver): void;
    transform(input: XPathNavigator, args: XsltArgumentList, resolver: XmlResolver): XmlReader;
    transform(input: XPathNavigator, args: XsltArgumentList): XmlReader;
    transform(input: XPathNavigator, args: XsltArgumentList, output: XmlWriter, resolver: XmlResolver): void;
    transform(input: XPathNavigator, args: XsltArgumentList, output: XmlWriter): void;
    transform(input: XPathNavigator, args: XsltArgumentList, output: Stream, resolver: XmlResolver): void;
    transform(input: XPathNavigator, args: XsltArgumentList, output: Stream): void;
    transform(input: XPathNavigator, args: XsltArgumentList, output: TextWriter, resolver: XmlResolver): void;
    transform(input: XPathNavigator, args: XsltArgumentList, output: TextWriter): void;
    transform(input: IXPathNavigable, args: XsltArgumentList, resolver: XmlResolver): XmlReader;
    transform(input: IXPathNavigable, args: XsltArgumentList): XmlReader;
    transform(input: IXPathNavigable, args: XsltArgumentList, output: TextWriter, resolver: XmlResolver): void;
    transform(input: IXPathNavigable, args: XsltArgumentList, output: TextWriter): void;
    transform(input: IXPathNavigable, args: XsltArgumentList, output: Stream, resolver: XmlResolver): void;
    transform(input: IXPathNavigable, args: XsltArgumentList, output: Stream): void;
    transform(input: IXPathNavigable, args: XsltArgumentList, output: XmlWriter, resolver: XmlResolver): void;
    transform(input: IXPathNavigable, args: XsltArgumentList, output: XmlWriter): void;
    transform(inputfile: string, outputfile: string, resolver: XmlResolver): void;
    transform(inputfile: string, outputfile: string): void;
}


export const XslTransform: {
    new(): XslTransform$instance;
};


export type XslTransform = XslTransform$instance;

export interface XsltSettings$instance {
    enableDocumentFunction: boolean;
    enableScript: boolean;
}


export const XsltSettings: {
    new(): XsltSettings$instance;
    new(enableDocumentFunction: boolean, enableScript: boolean): XsltSettings$instance;
    readonly default_: XsltSettings;
    readonly trustedXslt: XsltSettings;
};


export type XsltSettings = XsltSettings$instance;

