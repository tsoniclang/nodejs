// Generated by tsbindgen - Architecture
// Namespace: System.Resources
// Assembly: System.Private.CoreLib, System.Resources.Writer

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { CultureInfo } from "../../System.Globalization/internal/index.js";
import type { Stream, UnmanagedMemoryStream } from "../../System.IO/internal/index.js";
import type { Assembly, MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Attribute, Boolean as ClrBoolean, Byte, Enum, Exception, Func_2, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, ISpanFormattable, Object as ClrObject, String as ClrString, SystemException, Type, TypeCode, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum UltimateResourceFallbackLocation {
    mainAssembly = 0,
    satellite = 1
}


export interface IResourceReader$instance extends IEnumerable, IDisposable {
    close(): void;
    getEnumerator(): IEnumerator;
    getEnumerator(): IDictionaryEnumerator;
}


export interface IResourceReader$instance extends System_Collections_Internal.IEnumerable$instance, System_Internal.IDisposable$instance {}

export type IResourceReader = IResourceReader$instance;

export interface IResourceWriter$instance extends IDisposable {
    addResource(name: string, value: byte[]): void;
    addResource(name: string, value: unknown): void;
    addResource(name: string, value: string): void;
    close(): void;
}


export interface IResourceWriter$instance extends System_Internal.IDisposable$instance {}

export type IResourceWriter = IResourceWriter$instance;

export interface MissingManifestResourceException$instance extends SystemException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const MissingManifestResourceException: {
    new(): MissingManifestResourceException$instance;
    new(message: string): MissingManifestResourceException$instance;
    new(message: string, inner: Exception): MissingManifestResourceException$instance;
};


export interface __MissingManifestResourceException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MissingManifestResourceException = MissingManifestResourceException$instance & __MissingManifestResourceException$views;


export interface MissingSatelliteAssemblyException$instance extends SystemException {
    readonly cultureName: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const MissingSatelliteAssemblyException: {
    new(): MissingSatelliteAssemblyException$instance;
    new(message: string): MissingSatelliteAssemblyException$instance;
    new(message: string, cultureName: string): MissingSatelliteAssemblyException$instance;
    new(message: string, inner: Exception): MissingSatelliteAssemblyException$instance;
};


export interface __MissingSatelliteAssemblyException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MissingSatelliteAssemblyException = MissingSatelliteAssemblyException$instance & __MissingSatelliteAssemblyException$views;


export interface NeutralResourcesLanguageAttribute$instance extends Attribute {
    readonly cultureName: string;
    readonly location: UltimateResourceFallbackLocation;
}


export const NeutralResourcesLanguageAttribute: {
    new(cultureName: string): NeutralResourcesLanguageAttribute$instance;
    new(cultureName: string, location: UltimateResourceFallbackLocation): NeutralResourcesLanguageAttribute$instance;
};


export type NeutralResourcesLanguageAttribute = NeutralResourcesLanguageAttribute$instance;

export interface ResourceManager$instance {
    readonly baseName: string;
    ignoreCase: boolean;
    readonly resourceSetType: Type;
    getObject(name: string): unknown;
    getObject(name: string, culture: CultureInfo): unknown;
    getResourceSet(culture: CultureInfo, createIfNotExists: boolean, tryParents: boolean): ResourceSet;
    getStream(name: string): UnmanagedMemoryStream;
    getStream(name: string, culture: CultureInfo): UnmanagedMemoryStream;
    getString(name: string): string;
    getString(name: string, culture: CultureInfo): string;
    releaseAllResources(): void;
}


export const ResourceManager: {
    new(baseName: string, assembly: Assembly): ResourceManager$instance;
    new(baseName: string, assembly: Assembly, usingResourceSet: Type): ResourceManager$instance;
    new(resourceSource: Type): ResourceManager$instance;
    readonly magicNumber: int;
    readonly headerVersionNumber: int;
    createFileBasedResourceManager(baseName: string, resourceDir: string, usingResourceSet: Type): ResourceManager;
};


export type ResourceManager = ResourceManager$instance;

export interface ResourceReader$instance {
    close(): void;
    dispose(): void;
    getEnumerator(): IDictionaryEnumerator;
    getResourceData(resourceName: string, resourceType: { value: ref<string> }, resourceData: { value: ref<byte[]> }): void;
}


export const ResourceReader: {
    new(fileName: string): ResourceReader$instance;
    new(stream: Stream): ResourceReader$instance;
};


export interface __ResourceReader$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IResourceReader(): IResourceReader$instance;
}

export type ResourceReader = ResourceReader$instance & __ResourceReader$views;


export interface ResourceSet$instance {
    close(): void;
    dispose(): void;
    getDefaultReader(): Type;
    getDefaultWriter(): Type;
    getEnumerator(): IDictionaryEnumerator;
    getObject(name: string): unknown;
    getObject(name: string, ignoreCase: boolean): unknown;
    getString(name: string): string;
    getString(name: string, ignoreCase: boolean): string;
}


export const ResourceSet: {
    new(fileName: string): ResourceSet$instance;
    new(stream: Stream): ResourceSet$instance;
    new(reader: IResourceReader): ResourceSet$instance;
};


export interface __ResourceSet$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ResourceSet$instance extends System_Internal.IDisposable$instance {}

export type ResourceSet = ResourceSet$instance & __ResourceSet$views;


export interface ResourceWriter$instance {
    typeNameConverter: Func_2<Type, CLROf<string>>;
    addResource(name: string, value: Stream): void;
    addResource(name: string, value: string): void;
    addResource(name: string, value: unknown): void;
    addResource(name: string, value: Stream, closeAfterWrite?: boolean): void;
    addResource(name: string, value: byte[]): void;
    addResourceData(name: string, typeName: string, serializedData: byte[]): void;
    close(): void;
    dispose(): void;
    generate(): void;
}


export const ResourceWriter: {
    new(fileName: string): ResourceWriter$instance;
    new(stream: Stream): ResourceWriter$instance;
};


export interface __ResourceWriter$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IResourceWriter(): IResourceWriter$instance;
}

export type ResourceWriter = ResourceWriter$instance & __ResourceWriter$views;


export interface SatelliteContractVersionAttribute$instance extends Attribute {
    readonly version: string;
}


export const SatelliteContractVersionAttribute: {
    new(version: string): SatelliteContractVersionAttribute$instance;
};


export type SatelliteContractVersionAttribute = SatelliteContractVersionAttribute$instance;

