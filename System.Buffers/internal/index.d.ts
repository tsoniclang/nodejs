// Generated by tsbindgen - Architecture
// Namespace: System.Buffers
// Assembly: System.Memory, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { MethodInfo } from "../../System.Reflection/internal/index.js";
import type { GCHandle } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { AsyncCallback, Boolean as ClrBoolean, Byte, Char, Delegate, Enum, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, Memory_1, MulticastDelegate, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, SequencePosition, Span_1, String as ClrString, StringComparison, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum OperationStatus {
    done = 0,
    destinationTooSmall = 1,
    needMoreData = 2,
    invalidData = 3
}


export type ReadOnlySpanAction_2<T, TArg> = (span: ReadOnlySpan_1<T>, arg: TArg) => void;


export type SpanAction_2<T, TArg> = (span: Span_1<T>, arg: TArg) => void;


export interface IBufferWriter_1$instance<T> {
    advance(count: int): void;
    getMemory(sizeHint?: int): Memory_1<T>;
    getSpan(sizeHint?: int): Span_1<T>;
}


export type IBufferWriter_1<T> = IBufferWriter_1$instance<T>;

export interface IMemoryOwner_1$instance<T> extends IDisposable {
    readonly memory: Memory_1<T>;
    dispose(): void;
}


export interface IMemoryOwner_1$instance<T> extends System_Internal.IDisposable$instance {}

export type IMemoryOwner_1<T> = IMemoryOwner_1$instance<T>;

export interface IPinnable$instance {
    pin(elementIndex: int): MemoryHandle;
    unpin(): void;
}


export type IPinnable = IPinnable$instance;

export interface MemoryHandle$instance {
    readonly pointer: ptr<void>;
    dispose(): void;
}


export const MemoryHandle: {
    new(pointer: ptr<void>, handle: GCHandle, pinnable: IPinnable): MemoryHandle$instance;
};


export interface __MemoryHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MemoryHandle$instance extends System_Internal.IDisposable$instance {}

export type MemoryHandle = MemoryHandle$instance & __MemoryHandle$views;


export interface ReadOnlySequence_1$instance<T> {
    readonly end: SequencePosition;
    readonly first: ReadOnlyMemory_1<T>;
    readonly firstSpan: ReadOnlySpan_1<T>;
    readonly isEmpty: boolean;
    readonly isSingleSegment: boolean;
    readonly length: long;
    readonly start: SequencePosition;
    getEnumerator(): ReadOnlySequence_1_Enumerator<T>;
    getOffset(position: SequencePosition): long;
    getPosition(offset: long): SequencePosition;
    getPosition(offset: long, origin: SequencePosition): SequencePosition;
    slice(start: long, length: long): ReadOnlySequence_1<T>;
    slice(start: long, end: SequencePosition): ReadOnlySequence_1<T>;
    slice(start: SequencePosition, length: long): ReadOnlySequence_1<T>;
    slice(start: int, length: int): ReadOnlySequence_1<T>;
    slice(start: int, end: SequencePosition): ReadOnlySequence_1<T>;
    slice(start: SequencePosition, length: int): ReadOnlySequence_1<T>;
    slice(start: SequencePosition, end: SequencePosition): ReadOnlySequence_1<T>;
    slice(start: SequencePosition): ReadOnlySequence_1<T>;
    slice(start: long): ReadOnlySequence_1<T>;
    toString(): string;
    tryGet(position: { value: ref<SequencePosition> }, memory: { value: ref<ReadOnlyMemory_1<T>> }, advance?: boolean): boolean;
}


export const ReadOnlySequence_1: {
    new<T>(startSegment: ReadOnlySequenceSegment_1<T>, startIndex: int, endSegment: ReadOnlySequenceSegment_1<T>, endIndex: int): ReadOnlySequence_1$instance<T>;
    new<T>(array: T[]): ReadOnlySequence_1$instance<T>;
    new<T>(array: T[], start: int, length: int): ReadOnlySequence_1$instance<T>;
    new<T>(memory: ReadOnlyMemory_1<T>): ReadOnlySequence_1$instance<T>;
    readonly empty: unknown;
};


export type ReadOnlySequence_1<T> = ReadOnlySequence_1$instance<T>;

export interface ReadOnlySequence_1_Enumerator$instance<T> {
    readonly current: ReadOnlyMemory_1<T>;
    moveNext(): boolean;
}


export const ReadOnlySequence_1_Enumerator: {
    new<T>(sequence: ref<ReadOnlySequence_1<T>>): ReadOnlySequence_1_Enumerator$instance<T>;
};


export type ReadOnlySequence_1_Enumerator<T> = ReadOnlySequence_1_Enumerator$instance<T>;

export interface SequenceReader_1$instance<T extends (IEquatable_1<T> | number | string | boolean)> {
    readonly consumed: long;
    readonly currentSpan: ReadOnlySpan_1<T>;
    readonly currentSpanIndex: int;
    readonly end: boolean;
    readonly length: long;
    readonly position: SequencePosition;
    readonly remaining: long;
    readonly sequence: ReadOnlySequence_1<T>;
    readonly unreadSequence: ReadOnlySequence_1<T>;
    readonly unreadSpan: ReadOnlySpan_1<T>;
    advance(count: long): void;
    advancePast(value: T): long;
    advancePastAny(values: ReadOnlySpan_1<T>): long;
    advancePastAny(value0: T, value1: T, value2: T, value3: T): long;
    advancePastAny(value0: T, value1: T, value2: T): long;
    advancePastAny(value0: T, value1: T): long;
    advanceToEnd(): void;
    isNext(next: T, advancePast?: boolean): boolean;
    isNext(next: ReadOnlySpan_1<T>, advancePast?: boolean): boolean;
    rewind(count: long): void;
    tryAdvanceTo(delimiter: T, advancePastDelimiter?: boolean): boolean;
    tryAdvanceToAny(delimiters: ReadOnlySpan_1<T>, advancePastDelimiter?: boolean): boolean;
    tryCopyTo(destination: Span_1<T>): boolean;
    tryPeek(value: { value: ref<T> }): boolean;
    tryPeek(offset: long, value: { value: ref<T> }): boolean;
    tryRead(value: { value: ref<T> }): boolean;
    tryReadExact(count: int, sequence: { value: ref<ReadOnlySequence_1<T>> }): boolean;
    tryReadTo(span: { value: ref<ReadOnlySpan_1<T>> }, delimiter: T, advancePastDelimiter?: boolean): boolean;
    tryReadTo(span: { value: ref<ReadOnlySpan_1<T>> }, delimiter: T, delimiterEscape: T, advancePastDelimiter?: boolean): boolean;
    tryReadTo(sequence: { value: ref<ReadOnlySequence_1<T>> }, delimiter: T, advancePastDelimiter?: boolean): boolean;
    tryReadTo(sequence: { value: ref<ReadOnlySequence_1<T>> }, delimiter: T, delimiterEscape: T, advancePastDelimiter?: boolean): boolean;
    tryReadTo(span: { value: ref<ReadOnlySpan_1<T>> }, delimiter: ReadOnlySpan_1<T>, advancePastDelimiter?: boolean): boolean;
    tryReadTo(sequence: { value: ref<ReadOnlySequence_1<T>> }, delimiter: ReadOnlySpan_1<T>, advancePastDelimiter?: boolean): boolean;
    tryReadToAny(span: { value: ref<ReadOnlySpan_1<T>> }, delimiters: ReadOnlySpan_1<T>, advancePastDelimiter?: boolean): boolean;
    tryReadToAny(sequence: { value: ref<ReadOnlySequence_1<T>> }, delimiters: ReadOnlySpan_1<T>, advancePastDelimiter?: boolean): boolean;
}


export const SequenceReader_1: {
    new<T extends (IEquatable_1<T> | number | string | boolean)>(sequence: ReadOnlySequence_1<T>): SequenceReader_1$instance<T>;
};


export type SequenceReader_1<T extends (IEquatable_1<T> | number | string | boolean)> = SequenceReader_1$instance<T>;

export interface StandardFormat$instance {
    readonly hasPrecision: boolean;
    readonly isDefault: boolean;
    readonly precision: byte;
    readonly symbol_: char;
    equals(obj: unknown): boolean;
    equals(other: StandardFormat): boolean;
    getHashCode(): int;
    toString(): string;
}


export const StandardFormat: {
    new(symbol_: char, precision: byte): StandardFormat$instance;
    readonly noPrecision: byte;
    readonly maxPrecision: byte;
    parse(format: ReadOnlySpan_1<CLROf<char>>): StandardFormat;
    parse(format: string): StandardFormat;
    tryParse(format: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<StandardFormat> }): boolean;
};


export interface __StandardFormat$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<StandardFormat>;

    // Structural method bridges for numeric interface constraints
    Equals(other: StandardFormat): boolean;
}

export type StandardFormat = StandardFormat$instance & __StandardFormat$views;


export interface ArrayBufferWriter_1$instance<T> {
    readonly capacity: int;
    readonly freeCapacity: int;
    readonly writtenCount: int;
    readonly writtenMemory: ReadOnlyMemory_1<T>;
    readonly writtenSpan: ReadOnlySpan_1<T>;
    advance(count: int): void;
    clear(): void;
    getMemory(sizeHint?: int): Memory_1<T>;
    getSpan(sizeHint?: int): Span_1<T>;
    resetWrittenCount(): void;
}


export const ArrayBufferWriter_1: {
    new<T>(): ArrayBufferWriter_1$instance<T>;
    new<T>(initialCapacity: int): ArrayBufferWriter_1$instance<T>;
};


export interface __ArrayBufferWriter_1$views<T> {
    As_IBufferWriter_1(): IBufferWriter_1$instance<T>;
}

export interface ArrayBufferWriter_1$instance<T> extends IBufferWriter_1$instance<T> {}

export type ArrayBufferWriter_1<T> = ArrayBufferWriter_1$instance<T> & __ArrayBufferWriter_1$views<T>;


export interface ArrayPool_1$instance<T> {
    rent(minimumLength: int): T[];
    return_(array: T[], clearArray?: boolean): void;
}


export const ArrayPool_1: {
    readonly shared: unknown;
    create<T>(): ArrayPool_1<T>;
    create<T>(maxArrayLength: int, maxArraysPerBucket: int): ArrayPool_1<T>;
};


export type ArrayPool_1<T> = ArrayPool_1$instance<T>;

export interface MemoryManager_1$instance<T> {
    readonly memory: Memory_1<T>;
    getSpan(): Span_1<T>;
    pin(elementIndex?: int): MemoryHandle;
    unpin(): void;
}


export const MemoryManager_1: {
};


export interface __MemoryManager_1$views<T> {
    As_IMemoryOwner_1(): IMemoryOwner_1$instance<T>;
    As_IPinnable(): IPinnable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MemoryManager_1$instance<T> extends IMemoryOwner_1$instance<T> {}

export type MemoryManager_1<T> = MemoryManager_1$instance<T> & __MemoryManager_1$views<T>;


export interface MemoryPool_1$instance<T> {
    readonly maxBufferSize: int;
    dispose(): void;
    rent(minBufferSize?: int): IMemoryOwner_1<T>;
}


export const MemoryPool_1: {
    readonly shared: unknown;
};


export interface __MemoryPool_1$views<T> {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MemoryPool_1$instance<T> extends System_Internal.IDisposable$instance {}

export type MemoryPool_1<T> = MemoryPool_1$instance<T> & __MemoryPool_1$views<T>;


export interface ReadOnlySequenceSegment_1$instance<T> {
    readonly memory: ReadOnlyMemory_1<T>;
    readonly next: ReadOnlySequenceSegment_1<T>;
    readonly runningIndex: long;
}


export const ReadOnlySequenceSegment_1: {
};


export type ReadOnlySequenceSegment_1<T> = ReadOnlySequenceSegment_1$instance<T>;

export interface SearchValues_1$instance<T extends (IEquatable_1<T> | number | string | boolean)> {
    contains(value: T): boolean;
}


export const SearchValues_1: {
    new<T extends (IEquatable_1<T> | number | string | boolean)>(): SearchValues_1$instance<T>;
};


export type SearchValues_1<T extends (IEquatable_1<T> | number | string | boolean)> = SearchValues_1$instance<T>;

export abstract class BuffersExtensions$instance {
    static copyTo<T>(source: { value: ref<ReadOnlySequence_1<T>> }, destination: Span_1<T>): void;
    static positionOf<T extends IEquatable_1<T>>(source: { value: ref<ReadOnlySequence_1<T>> }, value: T): Nullable_1<SequencePosition>;
    static toArray<T>(sequence: { value: ref<ReadOnlySequence_1<T>> }): T[];
    static write<T>(writer: IBufferWriter_1<T>, value: ReadOnlySpan_1<T>): void;
}


export type BuffersExtensions = BuffersExtensions$instance;

export abstract class SearchValues$instance {
    static create(values: ReadOnlySpan_1<CLROf<byte>>): SearchValues_1<CLROf<byte>>;
    static create(values: ReadOnlySpan_1<CLROf<char>>): SearchValues_1<CLROf<char>>;
    static create(values: ReadOnlySpan_1<CLROf<string>>, comparisonType: StringComparison): SearchValues_1<CLROf<string>>;
}


export type SearchValues = SearchValues$instance;

export abstract class SequenceReaderExtensions$instance {
    static tryReadBigEndian(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<short> }): boolean;
    static tryReadBigEndian(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<int> }): boolean;
    static tryReadBigEndian(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<long> }): boolean;
    static tryReadLittleEndian(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<short> }): boolean;
    static tryReadLittleEndian(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<int> }): boolean;
    static tryReadLittleEndian(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<long> }): boolean;
}


export type SequenceReaderExtensions = SequenceReaderExtensions$instance;

