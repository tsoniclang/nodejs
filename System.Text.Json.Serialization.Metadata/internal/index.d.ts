// Generated by tsbindgen - Architecture
// Namespace: System.Text.Json.Serialization.Metadata
// Assembly: System.Text.Json

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { ConcurrentQueue_1, ConcurrentStack_1 } from "../../System.Collections.Concurrent/internal/index.js";
import type { Dictionary_2, IAsyncEnumerable_1, ICollection_1, IDictionary_2, IEnumerable_1, IList_1, IReadOnlyDictionary_2, ISet_1, KeyValuePair_2, List_1, Queue_1, Stack_1 } from "../../System.Collections.Generic/internal/index.js";
import type { IEnumerable, IList } from "../../System.Collections/internal/index.js";
import type { ICustomAttributeProvider } from "../../System.Reflection/internal/index.js";
import type { JsonArray, JsonNode, JsonObject, JsonValue } from "../../System.Text.Json.Nodes/internal/index.js";
import type { JsonConverter, JsonConverter_1, JsonIgnoreCondition, JsonNumberHandling, JsonObjectCreationHandling, JsonSerializerContext, JsonUnknownDerivedTypeHandling, JsonUnmappedMemberHandling } from "../../System.Text.Json.Serialization/internal/index.js";
import type { JsonDocument, JsonElement, JsonSerializerOptions, Utf8JsonWriter } from "../../System.Text.Json/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Action_2, Boolean as ClrBoolean, Byte, Char, DateOnly, DateTime, DateTimeOffset, Decimal, Double, Enum, Func_1, Func_2, Func_3, Guid, Half, IComparable, IConvertible, IFormatProvider, IFormattable, Int128, Int16, Int32, Int64, ISpanFormattable, Memory_1, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, SByte, Single, String as ClrString, TimeOnly, TimeSpan, Type, TypeCode, UInt128, UInt16, UInt32, UInt64, Uri, ValueType, Version, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum JsonTypeInfoKind {
    none = 0,
    object_ = 1,
    enumerable = 2,
    dictionary = 3
}


export interface IJsonTypeInfoResolver$instance {
    getTypeInfo(type_: Type, options: JsonSerializerOptions): JsonTypeInfo;
}


export type IJsonTypeInfoResolver = IJsonTypeInfoResolver$instance;

export interface JsonDerivedType$instance {
    readonly derivedType: Type;
    readonly typeDiscriminator: unknown;
}


export const JsonDerivedType: {
    new(derivedType: Type): JsonDerivedType$instance;
    new(derivedType: Type, typeDiscriminator: int): JsonDerivedType$instance;
    new(derivedType: Type, typeDiscriminator: string): JsonDerivedType$instance;
};


export type JsonDerivedType = JsonDerivedType$instance;

export interface DefaultJsonTypeInfoResolver$instance {
    readonly modifiers: IList_1<Action_1<JsonTypeInfo>>;
    getTypeInfo(type_: Type, options: JsonSerializerOptions): JsonTypeInfo;
}


export const DefaultJsonTypeInfoResolver: {
    new(): DefaultJsonTypeInfoResolver$instance;
};


export interface __DefaultJsonTypeInfoResolver$views {
    As_IJsonTypeInfoResolver(): IJsonTypeInfoResolver$instance;
}

export interface DefaultJsonTypeInfoResolver$instance extends IJsonTypeInfoResolver$instance {}

export type DefaultJsonTypeInfoResolver = DefaultJsonTypeInfoResolver$instance & __DefaultJsonTypeInfoResolver$views;


export interface JsonCollectionInfoValues_1$instance<TCollection> {
    elementInfo: JsonTypeInfo;
    keyInfo: JsonTypeInfo;
    numberHandling: JsonNumberHandling;
    objectCreator: Func_1<TCollection>;
    serializeHandler: Action_2<Utf8JsonWriter, TCollection>;
}


export const JsonCollectionInfoValues_1: {
    new<TCollection>(): JsonCollectionInfoValues_1$instance<TCollection>;
};


export type JsonCollectionInfoValues_1<TCollection> = JsonCollectionInfoValues_1$instance<TCollection>;

export interface JsonObjectInfoValues_1$instance<T> {
    constructorAttributeProviderFactory: Func_1<ICustomAttributeProvider>;
    constructorParameterMetadataInitializer: Func_1<JsonParameterInfoValues[]>;
    numberHandling: JsonNumberHandling;
    objectCreator: Func_1<T>;
    objectWithParameterizedConstructorCreator: Func_2<unknown[], T>;
    propertyMetadataInitializer: Func_2<JsonSerializerContext, JsonPropertyInfo[]>;
    serializeHandler: Action_2<Utf8JsonWriter, T>;
}


export const JsonObjectInfoValues_1: {
    new<T>(): JsonObjectInfoValues_1$instance<T>;
};


export type JsonObjectInfoValues_1<T> = JsonObjectInfoValues_1$instance<T>;

export interface JsonParameterInfo$instance {
    readonly attributeProvider: ICustomAttributeProvider;
    readonly declaringType: Type;
    readonly defaultValue: unknown;
    readonly hasDefaultValue: boolean;
    readonly isMemberInitializer: boolean;
    readonly isNullable: boolean;
    readonly name: string;
    readonly parameterType: Type;
    readonly position: int;
}


export const JsonParameterInfo: {
};


export type JsonParameterInfo = JsonParameterInfo$instance;

export interface JsonParameterInfoValues$instance {
    defaultValue: unknown;
    hasDefaultValue: boolean;
    isMemberInitializer: boolean;
    isNullable: boolean;
    name: string;
    parameterType: Type;
    position: int;
}


export const JsonParameterInfoValues: {
    new(): JsonParameterInfoValues$instance;
};


export type JsonParameterInfoValues = JsonParameterInfoValues$instance;

export interface JsonPolymorphismOptions$instance {
    readonly derivedTypes: IList_1<JsonDerivedType>;
    ignoreUnrecognizedTypeDiscriminators: boolean;
    typeDiscriminatorPropertyName: string;
    unknownDerivedTypeHandling: JsonUnknownDerivedTypeHandling;
}


export const JsonPolymorphismOptions: {
    new(): JsonPolymorphismOptions$instance;
};


export type JsonPolymorphismOptions = JsonPolymorphismOptions$instance;

export interface JsonPropertyInfo$instance {
    readonly associatedParameter: JsonParameterInfo;
    attributeProvider: ICustomAttributeProvider;
    customConverter: JsonConverter;
    readonly declaringType: Type;
    get_: Func_2<unknown, unknown>;
    isExtensionData: boolean;
    isGetNullable: boolean;
    isRequired: boolean;
    isSetNullable: boolean;
    name: string;
    numberHandling: Nullable_1<JsonNumberHandling>;
    objectCreationHandling: Nullable_1<JsonObjectCreationHandling>;
    readonly options: JsonSerializerOptions;
    order: int;
    readonly propertyType: Type;
    set_: Action_2<unknown, unknown>;
    shouldSerialize: Func_3<unknown, unknown, CLROf<boolean>>;
}


export const JsonPropertyInfo: {
};


export type JsonPropertyInfo = JsonPropertyInfo$instance;

export interface JsonPropertyInfoValues_1$instance<T> {
    attributeProviderFactory: Func_1<ICustomAttributeProvider>;
    converter: JsonConverter_1<T>;
    declaringType: Type;
    getter: Func_2<unknown, T>;
    hasJsonInclude: boolean;
    ignoreCondition: Nullable_1<JsonIgnoreCondition>;
    isExtensionData: boolean;
    isProperty: boolean;
    isPublic: boolean;
    isVirtual: boolean;
    jsonPropertyName: string;
    numberHandling: Nullable_1<JsonNumberHandling>;
    propertyName: string;
    propertyTypeInfo: JsonTypeInfo;
    setter: Action_2<unknown, T>;
}


export const JsonPropertyInfoValues_1: {
    new<T>(): JsonPropertyInfoValues_1$instance<T>;
};


export type JsonPropertyInfoValues_1<T> = JsonPropertyInfoValues_1$instance<T>;

export interface JsonTypeInfo$instance {
    readonly constructorAttributeProvider: ICustomAttributeProvider;
    readonly converter: JsonConverter;
    createObject: Func_1<unknown>;
    readonly elementType: Type;
    readonly isReadOnly: boolean;
    readonly keyType: Type;
    readonly kind: JsonTypeInfoKind;
    numberHandling: Nullable_1<JsonNumberHandling>;
    onDeserialized: Action_1<unknown>;
    onDeserializing: Action_1<unknown>;
    onSerialized: Action_1<unknown>;
    onSerializing: Action_1<unknown>;
    readonly options: JsonSerializerOptions;
    originatingResolver: IJsonTypeInfoResolver;
    polymorphismOptions: JsonPolymorphismOptions;
    preferredPropertyObjectCreationHandling: Nullable_1<JsonObjectCreationHandling>;
    readonly properties: IList_1<JsonPropertyInfo>;
    readonly type_: Type;
    unmappedMemberHandling: Nullable_1<JsonUnmappedMemberHandling>;
    createJsonPropertyInfo(propertyType: Type, name: string): JsonPropertyInfo;
    makeReadOnly(): void;
}


export const JsonTypeInfo: {
    createJsonTypeInfo<T>(options: JsonSerializerOptions): JsonTypeInfo_1<T>;
    createJsonTypeInfo(type_: Type, options: JsonSerializerOptions): JsonTypeInfo;
};


export type JsonTypeInfo = JsonTypeInfo$instance;

export interface JsonTypeInfo_1$instance<T> extends JsonTypeInfo {
    createObject: Func_1<T>;
    readonly serializeHandler: Action_2<Utf8JsonWriter, T>;
}


export const JsonTypeInfo_1: {
    new<T>(): JsonTypeInfo_1$instance<T>;
};


export type JsonTypeInfo_1<T> = JsonTypeInfo_1$instance<T>;

export abstract class JsonMetadataServices$instance {
    static readonly booleanConverter: JsonConverter_1<CLROf<boolean>>;
    static readonly byteArrayConverter: JsonConverter_1<byte[]>;
    static readonly byteConverter: JsonConverter_1<CLROf<byte>>;
    static readonly charConverter: JsonConverter_1<CLROf<char>>;
    static readonly dateTimeConverter: JsonConverter_1<DateTime>;
    static readonly dateTimeOffsetConverter: JsonConverter_1<DateTimeOffset>;
    static readonly dateOnlyConverter: JsonConverter_1<DateOnly>;
    static readonly timeOnlyConverter: JsonConverter_1<TimeOnly>;
    static readonly decimalConverter: JsonConverter_1<CLROf<decimal>>;
    static readonly doubleConverter: JsonConverter_1<CLROf<double>>;
    static readonly guidConverter: JsonConverter_1<Guid>;
    static readonly int16Converter: JsonConverter_1<CLROf<short>>;
    static readonly int32Converter: JsonConverter_1<CLROf<int>>;
    static readonly int64Converter: JsonConverter_1<CLROf<long>>;
    static readonly int128Converter: JsonConverter_1<CLROf<int128>>;
    static readonly uInt128Converter: JsonConverter_1<CLROf<uint128>>;
    static readonly jsonArrayConverter: JsonConverter_1<JsonArray>;
    static readonly jsonElementConverter: JsonConverter_1<JsonElement>;
    static readonly jsonNodeConverter: JsonConverter_1<JsonNode>;
    static readonly jsonObjectConverter: JsonConverter_1<JsonObject>;
    static readonly jsonValueConverter: JsonConverter_1<JsonValue>;
    static readonly jsonDocumentConverter: JsonConverter_1<JsonDocument>;
    static readonly memoryByteConverter: JsonConverter_1<Memory_1<CLROf<byte>>>;
    static readonly readOnlyMemoryByteConverter: JsonConverter_1<ReadOnlyMemory_1<CLROf<byte>>>;
    static readonly objectConverter: JsonConverter_1<unknown>;
    static readonly halfConverter: JsonConverter_1<CLROf<half>>;
    static readonly singleConverter: JsonConverter_1<CLROf<float>>;
    static readonly sByteConverter: JsonConverter_1<CLROf<sbyte>>;
    static readonly stringConverter: JsonConverter_1<CLROf<string>>;
    static readonly timeSpanConverter: JsonConverter_1<TimeSpan>;
    static readonly uInt16Converter: JsonConverter_1<CLROf<ushort>>;
    static readonly uInt32Converter: JsonConverter_1<CLROf<uint>>;
    static readonly uInt64Converter: JsonConverter_1<CLROf<ulong>>;
    static readonly uriConverter: JsonConverter_1<Uri>;
    static readonly versionConverter: JsonConverter_1<Version>;
    static createArrayInfo<TElement>(options: JsonSerializerOptions, collectionInfo: JsonCollectionInfoValues_1<TElement[]>): JsonTypeInfo_1<TElement[]>;
    static createConcurrentQueueInfo<TCollection extends ConcurrentQueue_1<TElement>, TElement>(options: JsonSerializerOptions, collectionInfo: JsonCollectionInfoValues_1<TCollection>): JsonTypeInfo_1<TCollection>;
    static createConcurrentStackInfo<TCollection extends ConcurrentStack_1<TElement>, TElement>(options: JsonSerializerOptions, collectionInfo: JsonCollectionInfoValues_1<TCollection>): JsonTypeInfo_1<TCollection>;
    static createDictionaryInfo<TCollection extends Dictionary_2<TKey, TValue>, TKey, TValue>(options: JsonSerializerOptions, collectionInfo: JsonCollectionInfoValues_1<TCollection>): JsonTypeInfo_1<TCollection>;
    static createIAsyncEnumerableInfo<TCollection extends IAsyncEnumerable_1<TElement>, TElement>(options: JsonSerializerOptions, collectionInfo: JsonCollectionInfoValues_1<TCollection>): JsonTypeInfo_1<TCollection>;
    static createICollectionInfo<TCollection extends ICollection_1<TElement>, TElement>(options: JsonSerializerOptions, collectionInfo: JsonCollectionInfoValues_1<TCollection>): JsonTypeInfo_1<TCollection>;
    static createIDictionaryInfo<TCollection extends IDictionary_2<TKey, TValue>, TKey, TValue>(options: JsonSerializerOptions, collectionInfo: JsonCollectionInfoValues_1<TCollection>): JsonTypeInfo_1<TCollection>;
    static createIEnumerableInfo<TCollection extends IEnumerable_1<TElement>, TElement>(options: JsonSerializerOptions, collectionInfo: JsonCollectionInfoValues_1<TCollection>): JsonTypeInfo_1<TCollection>;
    static createIListInfo<TCollection extends IList>(options: JsonSerializerOptions, collectionInfo: JsonCollectionInfoValues_1<TCollection>): JsonTypeInfo_1<TCollection>;
    static createImmutableDictionaryInfo<TCollection extends IReadOnlyDictionary_2<TKey, TValue>, TKey, TValue>(options: JsonSerializerOptions, collectionInfo: JsonCollectionInfoValues_1<TCollection>, createRangeFunc: Func_2<IEnumerable_1<KeyValuePair_2<TKey, TValue>>, TCollection>): JsonTypeInfo_1<TCollection>;
    static createImmutableEnumerableInfo<TCollection extends IEnumerable_1<TElement>, TElement>(options: JsonSerializerOptions, collectionInfo: JsonCollectionInfoValues_1<TCollection>, createRangeFunc: Func_2<IEnumerable_1<TElement>, TCollection>): JsonTypeInfo_1<TCollection>;
    static createIReadOnlyDictionaryInfo<TCollection extends IReadOnlyDictionary_2<TKey, TValue>, TKey, TValue>(options: JsonSerializerOptions, collectionInfo: JsonCollectionInfoValues_1<TCollection>): JsonTypeInfo_1<TCollection>;
    static createISetInfo<TCollection extends ISet_1<TElement>, TElement>(options: JsonSerializerOptions, collectionInfo: JsonCollectionInfoValues_1<TCollection>): JsonTypeInfo_1<TCollection>;
    static createListInfo<TCollection extends List_1<TElement>, TElement>(options: JsonSerializerOptions, collectionInfo: JsonCollectionInfoValues_1<TCollection>): JsonTypeInfo_1<TCollection>;
    static createMemoryInfo<TElement>(options: JsonSerializerOptions, collectionInfo: JsonCollectionInfoValues_1<Memory_1<TElement>>): JsonTypeInfo_1<Memory_1<TElement>>;
    static createObjectInfo<T>(options: JsonSerializerOptions, objectInfo: JsonObjectInfoValues_1<T>): JsonTypeInfo_1<T>;
    static createPropertyInfo<T>(options: JsonSerializerOptions, propertyInfo: JsonPropertyInfoValues_1<T>): JsonPropertyInfo;
    static createQueueInfo<TCollection extends IEnumerable>(options: JsonSerializerOptions, collectionInfo: JsonCollectionInfoValues_1<TCollection>, addFunc: Action_2<TCollection, unknown>): JsonTypeInfo_1<TCollection>;
    static createQueueInfo<TCollection extends Queue_1<TElement>, TElement>(options: JsonSerializerOptions, collectionInfo: JsonCollectionInfoValues_1<TCollection>): JsonTypeInfo_1<TCollection>;
    static createReadOnlyMemoryInfo<TElement>(options: JsonSerializerOptions, collectionInfo: JsonCollectionInfoValues_1<ReadOnlyMemory_1<TElement>>): JsonTypeInfo_1<ReadOnlyMemory_1<TElement>>;
    static createStackInfo<TCollection extends IEnumerable>(options: JsonSerializerOptions, collectionInfo: JsonCollectionInfoValues_1<TCollection>, addFunc: Action_2<TCollection, unknown>): JsonTypeInfo_1<TCollection>;
    static createStackInfo<TCollection extends Stack_1<TElement>, TElement>(options: JsonSerializerOptions, collectionInfo: JsonCollectionInfoValues_1<TCollection>): JsonTypeInfo_1<TCollection>;
    static createValueInfo<T>(options: JsonSerializerOptions, converter: JsonConverter): JsonTypeInfo_1<T>;
    static getEnumConverter<T extends number>(options: JsonSerializerOptions): JsonConverter_1<T>;
    static getNullableConverter<T extends unknown>(underlyingTypeInfo: JsonTypeInfo_1<T>): JsonConverter_1<Nullable_1<T>>;
    static getNullableConverter<T extends unknown>(options: JsonSerializerOptions): JsonConverter_1<Nullable_1<T>>;
    static getUnsupportedTypeConverter<T>(): JsonConverter_1<T>;
}


export type JsonMetadataServices = JsonMetadataServices$instance;

export abstract class JsonTypeInfoResolver$instance {
    static combine(resolvers: ReadOnlySpan_1<IJsonTypeInfoResolver>): IJsonTypeInfoResolver;
    static combine(resolvers: IJsonTypeInfoResolver[]): IJsonTypeInfoResolver;
    static withAddedModifier(resolver: IJsonTypeInfoResolver, modifier: Action_1<JsonTypeInfo>): IJsonTypeInfoResolver;
}


export type JsonTypeInfoResolver = JsonTypeInfoResolver$instance;

