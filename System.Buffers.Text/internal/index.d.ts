// Generated by tsbindgen - Architecture
// Namespace: System.Buffers.Text
// Assembly: System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { OperationStatus, StandardFormat } from "../../System.Buffers/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Byte, Char, DateTime, DateTimeOffset, Decimal, Double, Guid, Int16, Int32, Int64, Object as ClrObject, ReadOnlySpan_1, SByte, Single, Span_1, String as ClrString, TimeSpan, Type, UInt16, UInt32, UInt64 } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export abstract class Base64$instance {
    static decodeFromUtf8(utf8: ReadOnlySpan_1<CLROf<byte>>, bytes: Span_1<CLROf<byte>>, bytesConsumed: { value: ref<int> }, bytesWritten: { value: ref<int> }, isFinalBlock?: boolean): OperationStatus;
    static decodeFromUtf8InPlace(buffer: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static encodeToUtf8(bytes: ReadOnlySpan_1<CLROf<byte>>, utf8: Span_1<CLROf<byte>>, bytesConsumed: { value: ref<int> }, bytesWritten: { value: ref<int> }, isFinalBlock?: boolean): OperationStatus;
    static encodeToUtf8InPlace(buffer: Span_1<CLROf<byte>>, dataLength: int, bytesWritten: { value: ref<int> }): OperationStatus;
    static getMaxDecodedFromUtf8Length(length: int): int;
    static getMaxEncodedToUtf8Length(length: int): int;
    static isValid(base64TextUtf8: ReadOnlySpan_1<CLROf<byte>>, decodedLength: { value: ref<int> }): boolean;
    static isValid(base64TextUtf8: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static isValid(base64Text: ReadOnlySpan_1<CLROf<char>>, decodedLength: { value: ref<int> }): boolean;
    static isValid(base64Text: ReadOnlySpan_1<CLROf<char>>): boolean;
}


export type Base64 = Base64$instance;

export abstract class Base64Url$instance {
    static decodeFromChars(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<byte>>, charsConsumed: { value: ref<int> }, bytesWritten: { value: ref<int> }, isFinalBlock?: boolean): OperationStatus;
    static decodeFromChars(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<byte>>): int;
    static decodeFromChars(source: ReadOnlySpan_1<CLROf<char>>): byte[];
    static decodeFromUtf8(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesConsumed: { value: ref<int> }, bytesWritten: { value: ref<int> }, isFinalBlock?: boolean): OperationStatus;
    static decodeFromUtf8(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static decodeFromUtf8(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static decodeFromUtf8InPlace(buffer: Span_1<CLROf<byte>>): int;
    static encodeToChars(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<char>>, bytesConsumed: { value: ref<int> }, charsWritten: { value: ref<int> }, isFinalBlock?: boolean): OperationStatus;
    static encodeToChars(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<char>>): int;
    static encodeToChars(source: ReadOnlySpan_1<CLROf<byte>>): char[];
    static encodeToString(source: ReadOnlySpan_1<CLROf<byte>>): string;
    static encodeToUtf8(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesConsumed: { value: ref<int> }, bytesWritten: { value: ref<int> }, isFinalBlock?: boolean): OperationStatus;
    static encodeToUtf8(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static encodeToUtf8(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static getEncodedLength(bytesLength: int): int;
    static getMaxDecodedLength(base64Length: int): int;
    static isValid(utf8Base64UrlText: ReadOnlySpan_1<CLROf<byte>>, decodedLength: { value: ref<int> }): boolean;
    static isValid(utf8Base64UrlText: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static isValid(base64UrlText: ReadOnlySpan_1<CLROf<char>>, decodedLength: { value: ref<int> }): boolean;
    static isValid(base64UrlText: ReadOnlySpan_1<CLROf<char>>): boolean;
    static tryDecodeFromChars(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static tryDecodeFromUtf8(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static tryEncodeToChars(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    static tryEncodeToUtf8(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static tryEncodeToUtf8InPlace(buffer: Span_1<CLROf<byte>>, dataLength: int, bytesWritten: { value: ref<int> }): boolean;
}


export type Base64Url = Base64Url$instance;

export abstract class Utf8Formatter$instance {
    static tryFormat(value: boolean, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: StandardFormat): boolean;
    static tryFormat(value: byte, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: StandardFormat): boolean;
    static tryFormat(value: DateTime, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: StandardFormat): boolean;
    static tryFormat(value: DateTimeOffset, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: StandardFormat): boolean;
    static tryFormat(value: decimal, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: StandardFormat): boolean;
    static tryFormat(value: double, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: StandardFormat): boolean;
    static tryFormat(value: Guid, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: StandardFormat): boolean;
    static tryFormat(value: short, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: StandardFormat): boolean;
    static tryFormat(value: int, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: StandardFormat): boolean;
    static tryFormat(value: long, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: StandardFormat): boolean;
    static tryFormat(value: sbyte, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: StandardFormat): boolean;
    static tryFormat(value: float, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: StandardFormat): boolean;
    static tryFormat(value: TimeSpan, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: StandardFormat): boolean;
    static tryFormat(value: ushort, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: StandardFormat): boolean;
    static tryFormat(value: uint, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: StandardFormat): boolean;
    static tryFormat(value: ulong, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: StandardFormat): boolean;
}


export type Utf8Formatter = Utf8Formatter$instance;

export abstract class Utf8Parser$instance {
    static tryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: ref<boolean> }, bytesConsumed: { value: ref<int> }, standardFormat?: char): boolean;
    static tryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: ref<byte> }, bytesConsumed: { value: ref<int> }, standardFormat?: char): boolean;
    static tryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: ref<DateTime> }, bytesConsumed: { value: ref<int> }, standardFormat?: char): boolean;
    static tryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: ref<DateTimeOffset> }, bytesConsumed: { value: ref<int> }, standardFormat?: char): boolean;
    static tryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: ref<decimal> }, bytesConsumed: { value: ref<int> }, standardFormat?: char): boolean;
    static tryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: ref<double> }, bytesConsumed: { value: ref<int> }, standardFormat?: char): boolean;
    static tryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: ref<Guid> }, bytesConsumed: { value: ref<int> }, standardFormat?: char): boolean;
    static tryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: ref<short> }, bytesConsumed: { value: ref<int> }, standardFormat?: char): boolean;
    static tryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: ref<int> }, bytesConsumed: { value: ref<int> }, standardFormat?: char): boolean;
    static tryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: ref<long> }, bytesConsumed: { value: ref<int> }, standardFormat?: char): boolean;
    static tryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: ref<sbyte> }, bytesConsumed: { value: ref<int> }, standardFormat?: char): boolean;
    static tryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: ref<float> }, bytesConsumed: { value: ref<int> }, standardFormat?: char): boolean;
    static tryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: ref<TimeSpan> }, bytesConsumed: { value: ref<int> }, standardFormat?: char): boolean;
    static tryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: ref<ushort> }, bytesConsumed: { value: ref<int> }, standardFormat?: char): boolean;
    static tryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: ref<uint> }, bytesConsumed: { value: ref<int> }, standardFormat?: char): boolean;
    static tryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: ref<ulong> }, bytesConsumed: { value: ref<int> }, standardFormat?: char): boolean;
}


export type Utf8Parser = Utf8Parser$instance;

