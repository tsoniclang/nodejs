// Generated by tsbindgen - Architecture
// Namespace: System.Collections.Frozen
// Assembly: System.Collections.Immutable

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IDictionary_2, IEnumerable_1, IEnumerator_1, IEqualityComparer_1, IReadOnlyCollection_1, IReadOnlyDictionary_2, IReadOnlySet_1, ISet_1, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import type { ImmutableArray_1 } from "../../System.Collections.Immutable/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Boolean as ClrBoolean, Func_2, IDisposable, Int32, Object as ClrObject, ReadOnlySpan_1, Span_1, String as ClrString, Type, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface FrozenDictionary_2_AlternateLookup_1$instance<TKey, TValue, TAlternateKey> {
    readonly dictionary: FrozenDictionary_2<TKey, TValue>;
    readonly item: TValue;
    containsKey(key: TAlternateKey): boolean;
    tryGetValue(key: TAlternateKey, value: { value: ref<TValue> }): boolean;
}


export const FrozenDictionary_2_AlternateLookup_1: {
    new<TKey, TValue, TAlternateKey>(): FrozenDictionary_2_AlternateLookup_1$instance<TKey, TValue, TAlternateKey>;
};


export type FrozenDictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey> = FrozenDictionary_2_AlternateLookup_1$instance<TKey, TValue, TAlternateKey>;

export interface FrozenDictionary_2_Enumerator$instance<TKey, TValue> {
    readonly current: KeyValuePair_2<TKey, TValue>;
    moveNext(): boolean;
    reset(): void;
}


export const FrozenDictionary_2_Enumerator: {
    new<TKey, TValue>(): FrozenDictionary_2_Enumerator$instance<TKey, TValue>;
};


export interface __FrozenDictionary_2_Enumerator$views<TKey, TValue> {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type FrozenDictionary_2_Enumerator<TKey, TValue> = FrozenDictionary_2_Enumerator$instance<TKey, TValue> & __FrozenDictionary_2_Enumerator$views<TKey, TValue>;


export interface FrozenSet_1_AlternateLookup_1$instance<T, TAlternate> {
    readonly set_: FrozenSet_1<T>;
    contains(item: TAlternate): boolean;
    tryGetValue(equalValue: TAlternate, actualValue: { value: ref<T> }): boolean;
}


export const FrozenSet_1_AlternateLookup_1: {
    new<T, TAlternate>(): FrozenSet_1_AlternateLookup_1$instance<T, TAlternate>;
};


export type FrozenSet_1_AlternateLookup_1<T, TAlternate> = FrozenSet_1_AlternateLookup_1$instance<T, TAlternate>;

export interface FrozenSet_1_Enumerator$instance<T> {
    readonly current: T;
    moveNext(): boolean;
    reset(): void;
}


export const FrozenSet_1_Enumerator: {
    new<T>(): FrozenSet_1_Enumerator$instance<T>;
};


export interface __FrozenSet_1_Enumerator$views<T> {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type FrozenSet_1_Enumerator<T> = FrozenSet_1_Enumerator$instance<T> & __FrozenSet_1_Enumerator$views<T>;


export interface FrozenDictionary_2$instance<TKey, TValue> {
    readonly comparer: IEqualityComparer_1<TKey>;
    readonly count: int;
    readonly item: ref<TValue>;
    readonly keys: ImmutableArray_1<TKey>;
    readonly values: ImmutableArray_1<TValue>;
    containsKey(key: TKey): boolean;
    copyTo(destination: KeyValuePair_2<TKey, TValue>[], destinationIndex: int): void;
    copyTo(destination: Span_1<KeyValuePair_2<TKey, TValue>>): void;
    getAlternateLookup<TAlternateKey>(): FrozenDictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>;
    getEnumerator(): FrozenDictionary_2_Enumerator<TKey, TValue>;
    getValueRefOrNullRef(key: TKey): ref<TValue>;
    tryGetAlternateLookup<TAlternateKey>(lookup: { value: ref<FrozenDictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>> }): boolean;
    tryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
}


export const FrozenDictionary_2: {
    readonly empty: unknown;
};


export interface __FrozenDictionary_2$views<TKey, TValue> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionary_2(): System_Collections_Generic_Internal.IDictionary_2$instance<TKey, TValue>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyDictionary_2(): System_Collections_Generic_Internal.IReadOnlyDictionary_2$instance<TKey, TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type FrozenDictionary_2<TKey, TValue> = FrozenDictionary_2$instance<TKey, TValue> & __FrozenDictionary_2$views<TKey, TValue>;


export interface FrozenSet_1$instance<T> {
    readonly comparer: IEqualityComparer_1<T>;
    readonly count: int;
    readonly items: ImmutableArray_1<T>;
    contains(item: T): boolean;
    copyTo(destination: T[], destinationIndex: int): void;
    copyTo(destination: Span_1<T>): void;
    getAlternateLookup<TAlternate>(): FrozenSet_1_AlternateLookup_1<T, TAlternate>;
    getEnumerator(): FrozenSet_1_Enumerator<T>;
    isProperSubsetOf(other: IEnumerable_1<T>): boolean;
    isProperSupersetOf(other: IEnumerable_1<T>): boolean;
    isSubsetOf(other: IEnumerable_1<T>): boolean;
    isSupersetOf(other: IEnumerable_1<T>): boolean;
    overlaps(other: IEnumerable_1<T>): boolean;
    setEquals(other: IEnumerable_1<T>): boolean;
    tryGetAlternateLookup<TAlternate>(lookup: { value: ref<FrozenSet_1_AlternateLookup_1<T, TAlternate>> }): boolean;
    tryGetValue(equalValue: T, actualValue: { value: ref<T> }): boolean;
}


export const FrozenSet_1: {
    readonly empty: unknown;
};


export interface __FrozenSet_1$views<T> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_IReadOnlySet_1(): System_Collections_Generic_Internal.IReadOnlySet_1$instance<T>;
    As_ISet_1(): System_Collections_Generic_Internal.ISet_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type FrozenSet_1<T> = FrozenSet_1$instance<T> & __FrozenSet_1$views<T>;


export abstract class FrozenDictionary$instance {
    static create<TKey, TValue>(comparer: IEqualityComparer_1<TKey>, source: ReadOnlySpan_1<KeyValuePair_2<TKey, TValue>>): FrozenDictionary_2<TKey, TValue>;
    static create<TKey, TValue>(source: ReadOnlySpan_1<KeyValuePair_2<TKey, TValue>>): FrozenDictionary_2<TKey, TValue>;
    static toFrozenDictionary<TSource, TKey, TElement>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TElement>, comparer?: IEqualityComparer_1<TKey>): FrozenDictionary_2<TKey, TElement>;
    static toFrozenDictionary<TSource, TKey>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer?: IEqualityComparer_1<TKey>): FrozenDictionary_2<TKey, TSource>;
    static toFrozenDictionary<TKey, TValue>(source: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, comparer?: IEqualityComparer_1<TKey>): FrozenDictionary_2<TKey, TValue>;
}


export type FrozenDictionary = FrozenDictionary$instance;

export abstract class FrozenSet$instance {
    static create<T>(equalityComparer: IEqualityComparer_1<T>, source: ReadOnlySpan_1<T>): FrozenSet_1<T>;
    static create<T>(source: ReadOnlySpan_1<T>): FrozenSet_1<T>;
    static toFrozenSet<T>(source: IEnumerable_1<T>, comparer?: IEqualityComparer_1<T>): FrozenSet_1<T>;
}


export type FrozenSet = FrozenSet$instance;

