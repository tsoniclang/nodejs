// Generated by tsbindgen - Architecture
// Namespace: System.Runtime.Serialization.DataContracts
// Assembly: System.Private.DataContractSerialization

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { Dictionary_2, IEnumerable_1, List_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ReadOnlyCollection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import type { Hashtable } from "../../System.Collections/internal/index.js";
import type { ISerializationSurrogateProvider } from "../../System.Runtime.Serialization/internal/index.js";
import type { XmlSchemaElement, XmlSchemaSet, XmlSchemaType } from "../../System.Xml.Schema/internal/index.js";
import type { XmlDictionaryString, XmlQualifiedName } from "../../System.Xml/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Int32, Int64, Nullable_1, Object as ClrObject, String as ClrString, Type, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface DataContract$instance {
    readonly baseContract: DataContract;
    readonly contractType: string;
    readonly dataMembers: ReadOnlyCollection_1<DataMember>;
    readonly isBuiltInDataContract: boolean;
    readonly isISerializable: boolean;
    readonly isReference: boolean;
    readonly isValueType: boolean;
    readonly knownDataContracts: Dictionary_2<XmlQualifiedName, DataContract>;
    readonly originalUnderlyingType: Type;
    readonly topLevelElementName: XmlDictionaryString;
    readonly topLevelElementNamespace: XmlDictionaryString;
    readonly underlyingType: Type;
    readonly xmlName: XmlQualifiedName;
    equals(obj: unknown): boolean;
    getArrayTypeName(isNullable: boolean): XmlQualifiedName;
    getHashCode(): int;
    isDictionaryLike(keyName: { value: ref<string> }, valueName: { value: ref<string> }, itemName: { value: ref<string> }): boolean;
}


export const DataContract: {
    getBuiltInDataContract(name: string, ns: string): DataContract;
    getXmlName(type_: Type): XmlQualifiedName;
};


export type DataContract = DataContract$instance;

export interface DataContractSet$instance {
    readonly contracts: Dictionary_2<XmlQualifiedName, DataContract>;
    readonly knownTypesForObject: Dictionary_2<XmlQualifiedName, DataContract>;
    readonly processedContracts: Dictionary_2<DataContract, unknown>;
    readonly surrogateData: Hashtable;
    getDataContract(type_: Type): DataContract;
    getDataContract(key: XmlQualifiedName): DataContract;
    getReferencedType(xmlName: XmlQualifiedName, dataContract: DataContract, referencedContract: { value: ref<DataContract> }, genericParameters: { value: ref<unknown[]> }, supportGenericTypes?: Nullable_1<CLROf<boolean>>): Type;
    importSchemaSet(schemaSet: XmlSchemaSet, typeNames: IEnumerable_1<XmlQualifiedName>, importXmlDataType: boolean): void;
    importSchemaSet(schemaSet: XmlSchemaSet, elements: IEnumerable_1<XmlSchemaElement>, importXmlDataType: boolean): List_1<XmlQualifiedName>;
}


export const DataContractSet: {
    new(dataContractSurrogate: ISerializationSurrogateProvider, referencedTypes: IEnumerable_1<Type>, referencedCollectionTypes: IEnumerable_1<Type>): DataContractSet$instance;
    new(dataContractSet: DataContractSet): DataContractSet$instance;
};


export type DataContractSet = DataContractSet$instance;

export interface DataMember$instance {
    readonly emitDefaultValue: boolean;
    readonly isNullable: boolean;
    readonly isRequired: boolean;
    readonly memberTypeContract: DataContract;
    readonly name: string;
    readonly order: long;
}


export const DataMember: {
    new(): DataMember$instance;
};


export type DataMember = DataMember$instance;

export interface XmlDataContract$instance extends DataContract {
    readonly contractType: string;
    readonly hasRoot: boolean;
    readonly isAnonymous: boolean;
    readonly isBuiltInDataContract: boolean;
    readonly isTopLevelElementNullable: boolean;
    isTypeDefinedOnImport: boolean;
    isValueType: boolean;
    readonly knownDataContracts: Dictionary_2<XmlQualifiedName, DataContract>;
    readonly topLevelElementName: XmlDictionaryString;
    readonly topLevelElementNamespace: XmlDictionaryString;
    readonly xsdType: XmlSchemaType;
}


export const XmlDataContract: {
    new(): XmlDataContract$instance;
};


export type XmlDataContract = XmlDataContract$instance;

