// Generated by tsbindgen - Architecture
// Namespace: System.Numerics
// Assembly: System.Private.CoreLib, System.Runtime.Numerics

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { IComparer_1, IEqualityComparer_1 } from "../../System.Collections.Generic/internal/index.js";
import type { NumberStyles } from "../../System.Globalization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Byte, Char, Decimal, Double, IComparable, IComparable_1, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, IParsable_1, ISpanFormattable, ISpanParsable_1, IUtf8SpanFormattable, IUtf8SpanParsable_1, MidpointRounding, Object as ClrObject, ReadOnlySpan_1, SByte, Single, Span_1, String as ClrString, Type, UInt16, UInt32, UInt64, UIntPtr, ValueTuple_2, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface IAdditionOperators_3$instance<TSelf extends IAdditionOperators_3<TSelf, TOther, TResult>, TOther, TResult> {
}


export type IAdditionOperators_3<TSelf extends IAdditionOperators_3<TSelf, TOther, TResult>, TOther, TResult> = IAdditionOperators_3$instance<TSelf, TOther, TResult>;

export interface IAdditiveIdentity_2$instance<TSelf extends IAdditiveIdentity_2<TSelf, TResult>, TResult> {
}


export type IAdditiveIdentity_2<TSelf extends IAdditiveIdentity_2<TSelf, TResult>, TResult> = IAdditiveIdentity_2$instance<TSelf, TResult>;

export interface IBinaryFloatingPointIeee754_1$instance<TSelf extends IBinaryFloatingPointIeee754_1<TSelf>> extends IBinaryNumber_1<TSelf>, IBitwiseOperators_3<TSelf, TSelf, TSelf>, INumber_1<TSelf>, IComparable, IComparable_1<TSelf>, IComparisonOperators_3<TSelf, TSelf, CLROf<boolean>>, IEqualityOperators_3<TSelf, TSelf, CLROf<boolean>>, IModulusOperators_3<TSelf, TSelf, TSelf>, INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf>, IFloatingPointIeee754_1<TSelf>, IExponentialFunctions_1<TSelf>, IFloatingPointConstants_1<TSelf>, IFloatingPoint_1<TSelf>, ISignedNumber_1<TSelf>, IHyperbolicFunctions_1<TSelf>, ILogarithmicFunctions_1<TSelf>, IPowerFunctions_1<TSelf>, IRootFunctions_1<TSelf>, ITrigonometricFunctions_1<TSelf> {
    compareTo(obj: unknown): int;
    getExponentByteCount(): int;
    toString(format: string, formatProvider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
    tryWriteExponentBigEndian(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    writeExponentBigEndian(destination: byte[], startIndex: int): int;
    writeExponentBigEndian(destination: byte[]): int;
    writeExponentBigEndian(destination: Span_1<CLROf<byte>>): int;
}


export type IBinaryFloatingPointIeee754_1<TSelf extends IBinaryFloatingPointIeee754_1<TSelf>> = IBinaryFloatingPointIeee754_1$instance<TSelf>;

export interface IBinaryInteger_1$instance<TSelf extends IBinaryInteger_1<TSelf>> extends IBinaryNumber_1<TSelf>, IBitwiseOperators_3<TSelf, TSelf, TSelf>, INumber_1<TSelf>, IComparable, IComparable_1<TSelf>, IComparisonOperators_3<TSelf, TSelf, CLROf<boolean>>, IEqualityOperators_3<TSelf, TSelf, CLROf<boolean>>, IModulusOperators_3<TSelf, TSelf, TSelf>, INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf>, IShiftOperators_3<TSelf, CLROf<int>, TSelf> {
    compareTo(obj: unknown): int;
    getByteCount(): int;
    toString(format: string, formatProvider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
    tryWriteBigEndian(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    writeBigEndian(destination: byte[], startIndex: int): int;
    writeBigEndian(destination: byte[]): int;
    writeBigEndian(destination: Span_1<CLROf<byte>>): int;
}


export interface IBinaryInteger_1$instance<TSelf extends IBinaryInteger_1<TSelf>> extends IShiftOperators_3$instance<TSelf, CLROf<int>, TSelf> {}

export type IBinaryInteger_1<TSelf extends IBinaryInteger_1<TSelf>> = IBinaryInteger_1$instance<TSelf>;

export interface IBinaryNumber_1$instance<TSelf extends IBinaryNumber_1<TSelf>> extends IBitwiseOperators_3<TSelf, TSelf, TSelf>, INumber_1<TSelf>, IComparable, IComparable_1<TSelf>, IComparisonOperators_3<TSelf, TSelf, CLROf<boolean>>, IEqualityOperators_3<TSelf, TSelf, CLROf<boolean>>, IModulusOperators_3<TSelf, TSelf, TSelf>, INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf> {
    compareTo(obj: unknown): int;
    toString(format: string, formatProvider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
}


export interface IBinaryNumber_1$instance<TSelf extends IBinaryNumber_1<TSelf>> extends IBitwiseOperators_3$instance<TSelf, TSelf, TSelf> {}

export type IBinaryNumber_1<TSelf extends IBinaryNumber_1<TSelf>> = IBinaryNumber_1$instance<TSelf>;

export interface IBitwiseOperators_3$instance<TSelf extends IBitwiseOperators_3<TSelf, TOther, TResult>, TOther, TResult> {
}


export type IBitwiseOperators_3<TSelf extends IBitwiseOperators_3<TSelf, TOther, TResult>, TOther, TResult> = IBitwiseOperators_3$instance<TSelf, TOther, TResult>;

export interface IComparisonOperators_3$instance<TSelf extends IComparisonOperators_3<TSelf, TOther, TResult>, TOther, TResult> extends IEqualityOperators_3<TSelf, TOther, TResult> {
}


export interface IComparisonOperators_3$instance<TSelf extends IComparisonOperators_3<TSelf, TOther, TResult>, TOther, TResult> extends IEqualityOperators_3$instance<TSelf, TOther, TResult> {}

export type IComparisonOperators_3<TSelf extends IComparisonOperators_3<TSelf, TOther, TResult>, TOther, TResult> = IComparisonOperators_3$instance<TSelf, TOther, TResult>;

export interface IDecrementOperators_1$instance<TSelf extends IDecrementOperators_1<TSelf>> {
}


export type IDecrementOperators_1<TSelf extends IDecrementOperators_1<TSelf>> = IDecrementOperators_1$instance<TSelf>;

export interface IDivisionOperators_3$instance<TSelf extends IDivisionOperators_3<TSelf, TOther, TResult>, TOther, TResult> {
}


export type IDivisionOperators_3<TSelf extends IDivisionOperators_3<TSelf, TOther, TResult>, TOther, TResult> = IDivisionOperators_3$instance<TSelf, TOther, TResult>;

export interface IEqualityOperators_3$instance<TSelf extends IEqualityOperators_3<TSelf, TOther, TResult>, TOther, TResult> {
}


export type IEqualityOperators_3<TSelf extends IEqualityOperators_3<TSelf, TOther, TResult>, TOther, TResult> = IEqualityOperators_3$instance<TSelf, TOther, TResult>;

export interface IExponentialFunctions_1$instance<TSelf extends IExponentialFunctions_1<TSelf>> extends IFloatingPointConstants_1<TSelf>, INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IEqualityOperators_3<TSelf, TSelf, CLROf<boolean>>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf> {
    toString(format: string, formatProvider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
}


export type IExponentialFunctions_1<TSelf extends IExponentialFunctions_1<TSelf>> = IExponentialFunctions_1$instance<TSelf>;

export interface IFloatingPoint_1$instance<TSelf extends IFloatingPoint_1<TSelf>> extends IFloatingPointConstants_1<TSelf>, INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IEqualityOperators_3<TSelf, TSelf, CLROf<boolean>>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf>, INumber_1<TSelf>, IComparable, IComparable_1<TSelf>, IComparisonOperators_3<TSelf, TSelf, CLROf<boolean>>, IModulusOperators_3<TSelf, TSelf, TSelf>, ISignedNumber_1<TSelf> {
    compareTo(obj: unknown): int;
    getExponentByteCount(): int;
    toString(format: string, formatProvider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
    tryWriteExponentBigEndian(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    writeExponentBigEndian(destination: byte[], startIndex: int): int;
    writeExponentBigEndian(destination: byte[]): int;
    writeExponentBigEndian(destination: Span_1<CLROf<byte>>): int;
}


export type IFloatingPoint_1<TSelf extends IFloatingPoint_1<TSelf>> = IFloatingPoint_1$instance<TSelf>;

export interface IFloatingPointConstants_1$instance<TSelf extends IFloatingPointConstants_1<TSelf>> extends INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IEqualityOperators_3<TSelf, TSelf, CLROf<boolean>>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf> {
    toString(format: string, formatProvider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
}


export type IFloatingPointConstants_1<TSelf extends IFloatingPointConstants_1<TSelf>> = IFloatingPointConstants_1$instance<TSelf>;

export interface IFloatingPointIeee754_1$instance<TSelf extends IFloatingPointIeee754_1<TSelf>> extends IExponentialFunctions_1<TSelf>, IFloatingPointConstants_1<TSelf>, INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IEqualityOperators_3<TSelf, TSelf, CLROf<boolean>>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf>, IFloatingPoint_1<TSelf>, INumber_1<TSelf>, IComparable, IComparable_1<TSelf>, IComparisonOperators_3<TSelf, TSelf, CLROf<boolean>>, IModulusOperators_3<TSelf, TSelf, TSelf>, ISignedNumber_1<TSelf>, IHyperbolicFunctions_1<TSelf>, ILogarithmicFunctions_1<TSelf>, IPowerFunctions_1<TSelf>, IRootFunctions_1<TSelf>, ITrigonometricFunctions_1<TSelf> {
    compareTo(obj: unknown): int;
    getExponentByteCount(): int;
    toString(format: string, formatProvider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
    tryWriteExponentBigEndian(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    writeExponentBigEndian(destination: byte[], startIndex: int): int;
    writeExponentBigEndian(destination: byte[]): int;
    writeExponentBigEndian(destination: Span_1<CLROf<byte>>): int;
}


export type IFloatingPointIeee754_1<TSelf extends IFloatingPointIeee754_1<TSelf>> = IFloatingPointIeee754_1$instance<TSelf>;

export interface IHyperbolicFunctions_1$instance<TSelf extends IHyperbolicFunctions_1<TSelf>> extends IFloatingPointConstants_1<TSelf>, INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IEqualityOperators_3<TSelf, TSelf, CLROf<boolean>>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf> {
    toString(format: string, formatProvider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
}


export type IHyperbolicFunctions_1<TSelf extends IHyperbolicFunctions_1<TSelf>> = IHyperbolicFunctions_1$instance<TSelf>;

export interface IIncrementOperators_1$instance<TSelf extends IIncrementOperators_1<TSelf>> {
}


export type IIncrementOperators_1<TSelf extends IIncrementOperators_1<TSelf>> = IIncrementOperators_1$instance<TSelf>;

export interface ILogarithmicFunctions_1$instance<TSelf extends ILogarithmicFunctions_1<TSelf>> extends IFloatingPointConstants_1<TSelf>, INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IEqualityOperators_3<TSelf, TSelf, CLROf<boolean>>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf> {
    toString(format: string, formatProvider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
}


export type ILogarithmicFunctions_1<TSelf extends ILogarithmicFunctions_1<TSelf>> = ILogarithmicFunctions_1$instance<TSelf>;

export interface IMinMaxValue_1$instance<TSelf extends IMinMaxValue_1<TSelf>> {
}


export type IMinMaxValue_1<TSelf extends IMinMaxValue_1<TSelf>> = IMinMaxValue_1$instance<TSelf>;

export interface IModulusOperators_3$instance<TSelf extends IModulusOperators_3<TSelf, TOther, TResult>, TOther, TResult> {
}


export type IModulusOperators_3<TSelf extends IModulusOperators_3<TSelf, TOther, TResult>, TOther, TResult> = IModulusOperators_3$instance<TSelf, TOther, TResult>;

export interface IMultiplicativeIdentity_2$instance<TSelf extends IMultiplicativeIdentity_2<TSelf, TResult>, TResult> {
}


export type IMultiplicativeIdentity_2<TSelf extends IMultiplicativeIdentity_2<TSelf, TResult>, TResult> = IMultiplicativeIdentity_2$instance<TSelf, TResult>;

export interface IMultiplyOperators_3$instance<TSelf extends IMultiplyOperators_3<TSelf, TOther, TResult>, TOther, TResult> {
}


export type IMultiplyOperators_3<TSelf extends IMultiplyOperators_3<TSelf, TOther, TResult>, TOther, TResult> = IMultiplyOperators_3$instance<TSelf, TOther, TResult>;

export interface INumber_1$instance<TSelf extends INumber_1<TSelf>> extends IComparable, IComparable_1<TSelf>, IComparisonOperators_3<TSelf, TSelf, CLROf<boolean>>, IEqualityOperators_3<TSelf, TSelf, CLROf<boolean>>, IModulusOperators_3<TSelf, TSelf, TSelf>, INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf> {
    compareTo(obj: unknown): int;
    toString(format: string, formatProvider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
}


export interface INumber_1$instance<TSelf extends INumber_1<TSelf>> extends System_Internal.IComparable$instance, IComparisonOperators_3$instance<TSelf, TSelf, CLROf<boolean>>, IModulusOperators_3$instance<TSelf, TSelf, TSelf> {}

export type INumber_1<TSelf extends INumber_1<TSelf>> = INumber_1$instance<TSelf>;

export interface INumberBase_1$instance<TSelf extends INumberBase_1<TSelf>> extends IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IEqualityOperators_3<TSelf, TSelf, CLROf<boolean>>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf> {
    toString(format: string, formatProvider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
}


export interface INumberBase_1$instance<TSelf extends INumberBase_1<TSelf>> extends System_Internal.IEquatable_1$instance<TSelf>, System_Internal.ISpanParsable_1$instance<TSelf>, IAdditionOperators_3$instance<TSelf, TSelf, TSelf>, IAdditiveIdentity_2$instance<TSelf, TSelf>, IDecrementOperators_1$instance<TSelf>, IDivisionOperators_3$instance<TSelf, TSelf, TSelf>, IEqualityOperators_3$instance<TSelf, TSelf, CLROf<boolean>>, IIncrementOperators_1$instance<TSelf>, IMultiplicativeIdentity_2$instance<TSelf, TSelf>, IMultiplyOperators_3$instance<TSelf, TSelf, TSelf>, ISubtractionOperators_3$instance<TSelf, TSelf, TSelf>, IUnaryNegationOperators_2$instance<TSelf, TSelf>, IUnaryPlusOperators_2$instance<TSelf, TSelf> {}

export type INumberBase_1<TSelf extends INumberBase_1<TSelf>> = INumberBase_1$instance<TSelf>;

export interface IPowerFunctions_1$instance<TSelf extends IPowerFunctions_1<TSelf>> extends INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IEqualityOperators_3<TSelf, TSelf, CLROf<boolean>>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf> {
    toString(format: string, formatProvider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
}


export type IPowerFunctions_1<TSelf extends IPowerFunctions_1<TSelf>> = IPowerFunctions_1$instance<TSelf>;

export interface IRootFunctions_1$instance<TSelf extends IRootFunctions_1<TSelf>> extends IFloatingPointConstants_1<TSelf>, INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IEqualityOperators_3<TSelf, TSelf, CLROf<boolean>>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf> {
    toString(format: string, formatProvider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
}


export type IRootFunctions_1<TSelf extends IRootFunctions_1<TSelf>> = IRootFunctions_1$instance<TSelf>;

export interface IShiftOperators_3$instance<TSelf extends IShiftOperators_3<TSelf, TOther, TResult>, TOther, TResult> {
}


export type IShiftOperators_3<TSelf extends IShiftOperators_3<TSelf, TOther, TResult>, TOther, TResult> = IShiftOperators_3$instance<TSelf, TOther, TResult>;

export interface ISignedNumber_1$instance<TSelf extends ISignedNumber_1<TSelf>> extends INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IEqualityOperators_3<TSelf, TSelf, CLROf<boolean>>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf> {
    toString(format: string, formatProvider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
}


export type ISignedNumber_1<TSelf extends ISignedNumber_1<TSelf>> = ISignedNumber_1$instance<TSelf>;

export interface ISubtractionOperators_3$instance<TSelf extends ISubtractionOperators_3<TSelf, TOther, TResult>, TOther, TResult> {
}


export type ISubtractionOperators_3<TSelf extends ISubtractionOperators_3<TSelf, TOther, TResult>, TOther, TResult> = ISubtractionOperators_3$instance<TSelf, TOther, TResult>;

export interface ITrigonometricFunctions_1$instance<TSelf extends ITrigonometricFunctions_1<TSelf>> extends IFloatingPointConstants_1<TSelf>, INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IEqualityOperators_3<TSelf, TSelf, CLROf<boolean>>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf> {
    toString(format: string, formatProvider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
}


export type ITrigonometricFunctions_1<TSelf extends ITrigonometricFunctions_1<TSelf>> = ITrigonometricFunctions_1$instance<TSelf>;

export interface IUnaryNegationOperators_2$instance<TSelf extends IUnaryNegationOperators_2<TSelf, TResult>, TResult> {
}


export type IUnaryNegationOperators_2<TSelf extends IUnaryNegationOperators_2<TSelf, TResult>, TResult> = IUnaryNegationOperators_2$instance<TSelf, TResult>;

export interface IUnaryPlusOperators_2$instance<TSelf extends IUnaryPlusOperators_2<TSelf, TResult>, TResult> {
}


export type IUnaryPlusOperators_2<TSelf extends IUnaryPlusOperators_2<TSelf, TResult>, TResult> = IUnaryPlusOperators_2$instance<TSelf, TResult>;

export interface IUnsignedNumber_1$instance<TSelf extends IUnsignedNumber_1<TSelf>> extends INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IEqualityOperators_3<TSelf, TSelf, CLROf<boolean>>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf> {
    toString(format: string, formatProvider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
}


export type IUnsignedNumber_1<TSelf extends IUnsignedNumber_1<TSelf>> = IUnsignedNumber_1$instance<TSelf>;

export interface BigInteger$instance extends IAdditionOperators_3<BigInteger, BigInteger, BigInteger>, IBitwiseOperators_3<BigInteger, BigInteger, BigInteger>, IComparisonOperators_3<BigInteger, BigInteger, CLROf<boolean>>, IEqualityOperators_3<BigInteger, BigInteger, CLROf<boolean>>, IDecrementOperators_1<BigInteger>, IDivisionOperators_3<BigInteger, BigInteger, BigInteger>, IIncrementOperators_1<BigInteger>, IModulusOperators_3<BigInteger, BigInteger, BigInteger>, IMultiplyOperators_3<BigInteger, BigInteger, BigInteger>, ISubtractionOperators_3<BigInteger, BigInteger, BigInteger>, IUnaryNegationOperators_2<BigInteger, BigInteger>, IUnaryPlusOperators_2<BigInteger, BigInteger>, IShiftOperators_3<BigInteger, CLROf<int>, BigInteger> {
    readonly isEven: boolean;
    readonly isOne: boolean;
    readonly isPowerOfTwo: boolean;
    readonly isZero: boolean;
    readonly sign: int;
    compareTo(other: long): int;
    compareTo(other: ulong): int;
    compareTo(other: BigInteger): int;
    compareTo(obj: unknown): int;
    equals(obj: unknown): boolean;
    equals(other: long): boolean;
    equals(other: ulong): boolean;
    equals(other: BigInteger): boolean;
    getBitLength(): long;
    getByteCount(isUnsigned?: boolean): int;
    getHashCode(): int;
    toByteArray(): byte[];
    toByteArray(isUnsigned?: boolean, isBigEndian?: boolean): byte[];
    toString(): string;
    toString(provider: IFormatProvider): string;
    toString(format: string): string;
    toString(format: string, provider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    tryWriteBytes(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, isUnsigned?: boolean, isBigEndian?: boolean): boolean;
}


export const BigInteger: {
    new(value: int): BigInteger$instance;
    new(value: uint): BigInteger$instance;
    new(value: long): BigInteger$instance;
    new(value: ulong): BigInteger$instance;
    new(value: float): BigInteger$instance;
    new(value: double): BigInteger$instance;
    new(value: decimal): BigInteger$instance;
    new(value: byte[]): BigInteger$instance;
    new(value: ReadOnlySpan_1<CLROf<byte>>, isUnsigned: boolean, isBigEndian: boolean): BigInteger$instance;
    readonly zero: BigInteger;
    readonly one: BigInteger;
    readonly minusOne: BigInteger;
    abs(value: BigInteger): BigInteger;
    add(left: BigInteger, right: BigInteger): BigInteger;
    clamp(value: BigInteger, min: BigInteger, max: BigInteger): BigInteger;
    compare(left: BigInteger, right: BigInteger): int;
    copySign(value: BigInteger, sign: BigInteger): BigInteger;
    createChecked<TOther extends INumberBase_1<TOther>>(value: TOther): BigInteger;
    createSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): BigInteger;
    createTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): BigInteger;
    divide(dividend: BigInteger, divisor: BigInteger): BigInteger;
    divRem(dividend: BigInteger, divisor: BigInteger, remainder: { value: ref<BigInteger> }): BigInteger;
    divRem(left: BigInteger, right: BigInteger): ValueTuple_2<BigInteger, BigInteger>;
    greatestCommonDivisor(left: BigInteger, right: BigInteger): BigInteger;
    isEvenInteger(value: BigInteger): boolean;
    isNegative(value: BigInteger): boolean;
    isOddInteger(value: BigInteger): boolean;
    isPositive(value: BigInteger): boolean;
    isPow2(value: BigInteger): boolean;
    leadingZeroCount(value: BigInteger): BigInteger;
    log(value: BigInteger, baseValue: double): double;
    log(value: BigInteger): double;
    log10(value: BigInteger): double;
    log2(value: BigInteger): BigInteger;
    max(left: BigInteger, right: BigInteger): BigInteger;
    maxMagnitude(x: BigInteger, y: BigInteger): BigInteger;
    min(left: BigInteger, right: BigInteger): BigInteger;
    minMagnitude(x: BigInteger, y: BigInteger): BigInteger;
    modPow(value: BigInteger, exponent: BigInteger, modulus: BigInteger): BigInteger;
    multiply(left: BigInteger, right: BigInteger): BigInteger;
    negate(value: BigInteger): BigInteger;
    parse(value: ReadOnlySpan_1<CLROf<char>>, style?: NumberStyles, provider?: IFormatProvider): BigInteger;
    parse(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): BigInteger;
    parse(value: string, style: NumberStyles, provider: IFormatProvider): BigInteger;
    parse(value: string, style: NumberStyles): BigInteger;
    parse(value: string, provider: IFormatProvider): BigInteger;
    parse(value: string): BigInteger;
    popCount(value: BigInteger): BigInteger;
    pow(value: BigInteger, exponent: int): BigInteger;
    remainder(dividend: BigInteger, divisor: BigInteger): BigInteger;
    rotateLeft(value: BigInteger, rotateAmount: int): BigInteger;
    rotateRight(value: BigInteger, rotateAmount: int): BigInteger;
    subtract(left: BigInteger, right: BigInteger): BigInteger;
    trailingZeroCount(value: BigInteger): BigInteger;
    tryParse(value: ReadOnlySpan_1<CLROf<char>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<BigInteger> }): boolean;
    tryParse(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<BigInteger> }): boolean;
    tryParse(value: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<BigInteger> }): boolean;
    tryParse(value: string, style: NumberStyles, provider: IFormatProvider, result: { value: ref<BigInteger> }): boolean;
    tryParse(s: string, provider: IFormatProvider, result: { value: ref<BigInteger> }): boolean;
    tryParse(value: string, result: { value: ref<BigInteger> }): boolean;
};


export interface __BigInteger$views {
    As_IComparable(): System_Internal.IComparable$instance;
    As_IComparable_1(): System_Internal.IComparable_1$instance<BigInteger>;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<BigInteger>;
    As_IFormattable(): System_Internal.IFormattable$instance;
    As_IParsable_1(): System_Internal.IParsable_1$instance<BigInteger>;
    As_ISpanFormattable(): System_Internal.ISpanFormattable$instance;
    As_ISpanParsable_1(): System_Internal.ISpanParsable_1$instance<BigInteger>;
    As_IUtf8SpanFormattable(): System_Internal.IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): System_Internal.IUtf8SpanParsable_1$instance<BigInteger>;
    As_IAdditiveIdentity_2(): IAdditiveIdentity_2$instance<BigInteger, BigInteger>;
    As_IBinaryInteger_1(): IBinaryInteger_1$instance<BigInteger>;
    As_INumber_1(): INumber_1$instance<BigInteger>;
    As_INumberBase_1(): INumberBase_1$instance<BigInteger>;

    // Structural method bridges for numeric interface constraints
    Equals(other: BigInteger): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: import("../../System/internal/index").IFormatProvider): string;
    TryFormat(destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").CLROf<char>>, charsWritten: { value: ref<int> }, format: import("../../System/internal/index").ReadOnlySpan_1<import("../../System/internal/index").CLROf<char>>, provider: import("../../System/internal/index").IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").CLROf<byte>>): int;
}

export type BigInteger = BigInteger$instance & __BigInteger$views;


export interface Complex$instance extends IAdditionOperators_3<Complex, Complex, Complex>, IDecrementOperators_1<Complex>, IDivisionOperators_3<Complex, Complex, Complex>, IEqualityOperators_3<Complex, Complex, CLROf<boolean>>, IIncrementOperators_1<Complex>, IMultiplyOperators_3<Complex, Complex, Complex>, ISubtractionOperators_3<Complex, Complex, Complex>, IUnaryNegationOperators_2<Complex, Complex>, IUnaryPlusOperators_2<Complex, Complex> {
    readonly imaginary: double;
    readonly magnitude: double;
    readonly phase: double;
    readonly real: double;
    equals(obj: unknown): boolean;
    equals(value: Complex): boolean;
    getHashCode(): int;
    toString(): string;
    toString(format: string): string;
    toString(provider: IFormatProvider): string;
    toString(format: string, provider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
}


export const Complex: {
    new(real: double, imaginary: double): Complex$instance;
    readonly zero: Complex;
    readonly one: Complex;
    readonly imaginaryOne: Complex;
    readonly naN: Complex;
    readonly infinity: Complex;
    abs(value: Complex): double;
    acos(value: Complex): Complex;
    add(left: double, right: Complex): Complex;
    add(left: Complex, right: double): Complex;
    add(left: Complex, right: Complex): Complex;
    asin(value: Complex): Complex;
    atan(value: Complex): Complex;
    conjugate(value: Complex): Complex;
    cos(value: Complex): Complex;
    cosh(value: Complex): Complex;
    createChecked<TOther extends INumberBase_1<TOther>>(value: TOther): Complex;
    createSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): Complex;
    createTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): Complex;
    divide(dividend: double, divisor: Complex): Complex;
    divide(dividend: Complex, divisor: double): Complex;
    divide(dividend: Complex, divisor: Complex): Complex;
    exp(value: Complex): Complex;
    fromPolarCoordinates(magnitude: double, phase: double): Complex;
    isComplexNumber(value: Complex): boolean;
    isEvenInteger(value: Complex): boolean;
    isFinite(value: Complex): boolean;
    isImaginaryNumber(value: Complex): boolean;
    isInfinity(value: Complex): boolean;
    isInteger(value: Complex): boolean;
    isNaN(value: Complex): boolean;
    isNegative(value: Complex): boolean;
    isNegativeInfinity(value: Complex): boolean;
    isNormal(value: Complex): boolean;
    isOddInteger(value: Complex): boolean;
    isPositive(value: Complex): boolean;
    isPositiveInfinity(value: Complex): boolean;
    isRealNumber(value: Complex): boolean;
    isSubnormal(value: Complex): boolean;
    log(value: Complex, baseValue: double): Complex;
    log(value: Complex): Complex;
    log10(value: Complex): Complex;
    maxMagnitude(x: Complex, y: Complex): Complex;
    minMagnitude(x: Complex, y: Complex): Complex;
    multiply(left: double, right: Complex): Complex;
    multiply(left: Complex, right: double): Complex;
    multiply(left: Complex, right: Complex): Complex;
    negate(value: Complex): Complex;
    parse(s: ReadOnlySpan_1<CLROf<char>>, style: NumberStyles, provider: IFormatProvider): Complex;
    parse(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): Complex;
    parse(s: string, style: NumberStyles, provider: IFormatProvider): Complex;
    parse(s: string, provider: IFormatProvider): Complex;
    pow(value: Complex, power: double): Complex;
    pow(value: Complex, power: Complex): Complex;
    reciprocal(value: Complex): Complex;
    sin(value: Complex): Complex;
    sinh(value: Complex): Complex;
    sqrt(value: Complex): Complex;
    subtract(left: double, right: Complex): Complex;
    subtract(left: Complex, right: double): Complex;
    subtract(left: Complex, right: Complex): Complex;
    tan(value: Complex): Complex;
    tanh(value: Complex): Complex;
    tryParse(s: ReadOnlySpan_1<CLROf<char>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<Complex> }): boolean;
    tryParse(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<Complex> }): boolean;
    tryParse(s: string, style: NumberStyles, provider: IFormatProvider, result: { value: ref<Complex> }): boolean;
    tryParse(s: string, provider: IFormatProvider, result: { value: ref<Complex> }): boolean;
};


export interface __Complex$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Complex>;
    As_IFormattable(): System_Internal.IFormattable$instance;
    As_IParsable_1(): System_Internal.IParsable_1$instance<Complex>;
    As_ISpanParsable_1(): System_Internal.ISpanParsable_1$instance<Complex>;
    As_IUtf8SpanFormattable(): System_Internal.IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): System_Internal.IUtf8SpanParsable_1$instance<Complex>;
    As_IAdditiveIdentity_2(): IAdditiveIdentity_2$instance<Complex, Complex>;
    As_INumberBase_1(): INumberBase_1$instance<Complex>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Complex): boolean;
    ToString(format: string, formatProvider: import("../../System/internal/index").IFormatProvider): string;
    TryFormat(destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").CLROf<char>>, charsWritten: { value: ref<int> }, format: import("../../System/internal/index").ReadOnlySpan_1<import("../../System/internal/index").CLROf<char>>, provider: import("../../System/internal/index").IFormatProvider): boolean;
}

export type Complex = Complex$instance & __Complex$views;


export interface Matrix3x2$instance {
    M11: float;
    M12: float;
    M21: float;
    M22: float;
    M31: float;
    M32: float;
    readonly isIdentity: boolean;
    translation: Vector2;
    X: Vector2;
    Y: Vector2;
    Z: Vector2;
    equals(obj: unknown): boolean;
    equals(other: Matrix3x2): boolean;
    get_Item(row: int): Vector2;
    get_Item(row: int, column: int): float;
    getDeterminant(): float;
    getElement(row: int, column: int): float;
    getHashCode(): int;
    getRow(index: int): Vector2;
    set_Item(row: int, value: Vector2): void;
    set_Item(row: int, column: int, value: float): void;
    toString(): string;
    withElement(row: int, column: int, value: float): Matrix3x2;
    withRow(index: int, value: Vector2): Matrix3x2;
}


export const Matrix3x2: {
    new(m11: float, m12: float, m21: float, m22: float, m31: float, m32: float): Matrix3x2$instance;
    readonly identity: Matrix3x2;
    add(value1: Matrix3x2, value2: Matrix3x2): Matrix3x2;
    create(x: Vector2, y: Vector2, z: Vector2): Matrix3x2;
    create(value: Vector2): Matrix3x2;
    create(m11: float, m12: float, m21: float, m22: float, m31: float, m32: float): Matrix3x2;
    create(value: float): Matrix3x2;
    createRotation(radians: float, centerPoint: Vector2): Matrix3x2;
    createRotation(radians: float): Matrix3x2;
    createScale(scales: Vector2, centerPoint: Vector2): Matrix3x2;
    createScale(scales: Vector2): Matrix3x2;
    createScale(scale: float, centerPoint: Vector2): Matrix3x2;
    createScale(xScale: float, yScale: float, centerPoint: Vector2): Matrix3x2;
    createScale(xScale: float, yScale: float): Matrix3x2;
    createScale(scale: float): Matrix3x2;
    createSkew(radiansX: float, radiansY: float, centerPoint: Vector2): Matrix3x2;
    createSkew(radiansX: float, radiansY: float): Matrix3x2;
    createTranslation(position: Vector2): Matrix3x2;
    createTranslation(xPosition: float, yPosition: float): Matrix3x2;
    invert(matrix: Matrix3x2, result: { value: ref<Matrix3x2> }): boolean;
    lerp(matrix1: Matrix3x2, matrix2: Matrix3x2, amount: float): Matrix3x2;
    multiply(value1: Matrix3x2, value2: Matrix3x2): Matrix3x2;
    multiply(value1: Matrix3x2, value2: float): Matrix3x2;
    negate(value: Matrix3x2): Matrix3x2;
    subtract(value1: Matrix3x2, value2: Matrix3x2): Matrix3x2;
};


export interface __Matrix3x2$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Matrix3x2>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Matrix3x2): boolean;
}

export type Matrix3x2 = Matrix3x2$instance & __Matrix3x2$views;


export interface Matrix4x4$instance {
    M11: float;
    M12: float;
    M13: float;
    M14: float;
    M21: float;
    M22: float;
    M23: float;
    M24: float;
    M31: float;
    M32: float;
    M33: float;
    M34: float;
    M41: float;
    M42: float;
    M43: float;
    M44: float;
    readonly isIdentity: boolean;
    translation: Vector3;
    W: Vector4;
    X: Vector4;
    Y: Vector4;
    Z: Vector4;
    equals(obj: unknown): boolean;
    equals(other: Matrix4x4): boolean;
    get_Item(row: int): Vector4;
    get_Item(row: int, column: int): float;
    getDeterminant(): float;
    getElement(row: int, column: int): float;
    getHashCode(): int;
    getRow(index: int): Vector4;
    set_Item(row: int, value: Vector4): void;
    set_Item(row: int, column: int, value: float): void;
    toString(): string;
    withElement(row: int, column: int, value: float): Matrix4x4;
    withRow(index: int, value: Vector4): Matrix4x4;
}


export const Matrix4x4: {
    new(m11: float, m12: float, m13: float, m14: float, m21: float, m22: float, m23: float, m24: float, m31: float, m32: float, m33: float, m34: float, m41: float, m42: float, m43: float, m44: float): Matrix4x4$instance;
    new(value: Matrix3x2): Matrix4x4$instance;
    readonly identity: Matrix4x4;
    add(value1: Matrix4x4, value2: Matrix4x4): Matrix4x4;
    create(value: Matrix3x2): Matrix4x4;
    create(x: Vector4, y: Vector4, z: Vector4, w: Vector4): Matrix4x4;
    create(value: Vector4): Matrix4x4;
    create(m11: float, m12: float, m13: float, m14: float, m21: float, m22: float, m23: float, m24: float, m31: float, m32: float, m33: float, m34: float, m41: float, m42: float, m43: float, m44: float): Matrix4x4;
    create(value: float): Matrix4x4;
    createBillboard(objectPosition: Vector3, cameraPosition: Vector3, cameraUpVector: Vector3, cameraForwardVector: Vector3): Matrix4x4;
    createBillboardLeftHanded(objectPosition: Vector3, cameraPosition: Vector3, cameraUpVector: Vector3, cameraForwardVector: Vector3): Matrix4x4;
    createConstrainedBillboard(objectPosition: Vector3, cameraPosition: Vector3, rotateAxis: Vector3, cameraForwardVector: Vector3, objectForwardVector: Vector3): Matrix4x4;
    createConstrainedBillboardLeftHanded(objectPosition: Vector3, cameraPosition: Vector3, rotateAxis: Vector3, cameraForwardVector: Vector3, objectForwardVector: Vector3): Matrix4x4;
    createFromAxisAngle(axis: Vector3, angle: float): Matrix4x4;
    createFromQuaternion(quaternion: Quaternion): Matrix4x4;
    createFromYawPitchRoll(yaw: float, pitch: float, roll: float): Matrix4x4;
    createLookAt(cameraPosition: Vector3, cameraTarget: Vector3, cameraUpVector: Vector3): Matrix4x4;
    createLookAtLeftHanded(cameraPosition: Vector3, cameraTarget: Vector3, cameraUpVector: Vector3): Matrix4x4;
    createLookTo(cameraPosition: Vector3, cameraDirection: Vector3, cameraUpVector: Vector3): Matrix4x4;
    createLookToLeftHanded(cameraPosition: Vector3, cameraDirection: Vector3, cameraUpVector: Vector3): Matrix4x4;
    createOrthographic(width: float, height: float, zNearPlane: float, zFarPlane: float): Matrix4x4;
    createOrthographicLeftHanded(width: float, height: float, zNearPlane: float, zFarPlane: float): Matrix4x4;
    createOrthographicOffCenter(left: float, right: float, bottom: float, top: float, zNearPlane: float, zFarPlane: float): Matrix4x4;
    createOrthographicOffCenterLeftHanded(left: float, right: float, bottom: float, top: float, zNearPlane: float, zFarPlane: float): Matrix4x4;
    createPerspective(width: float, height: float, nearPlaneDistance: float, farPlaneDistance: float): Matrix4x4;
    createPerspectiveFieldOfView(fieldOfView: float, aspectRatio: float, nearPlaneDistance: float, farPlaneDistance: float): Matrix4x4;
    createPerspectiveFieldOfViewLeftHanded(fieldOfView: float, aspectRatio: float, nearPlaneDistance: float, farPlaneDistance: float): Matrix4x4;
    createPerspectiveLeftHanded(width: float, height: float, nearPlaneDistance: float, farPlaneDistance: float): Matrix4x4;
    createPerspectiveOffCenter(left: float, right: float, bottom: float, top: float, nearPlaneDistance: float, farPlaneDistance: float): Matrix4x4;
    createPerspectiveOffCenterLeftHanded(left: float, right: float, bottom: float, top: float, nearPlaneDistance: float, farPlaneDistance: float): Matrix4x4;
    createReflection(value: Plane): Matrix4x4;
    createRotationX(radians: float, centerPoint: Vector3): Matrix4x4;
    createRotationX(radians: float): Matrix4x4;
    createRotationY(radians: float, centerPoint: Vector3): Matrix4x4;
    createRotationY(radians: float): Matrix4x4;
    createRotationZ(radians: float, centerPoint: Vector3): Matrix4x4;
    createRotationZ(radians: float): Matrix4x4;
    createScale(scales: Vector3, centerPoint: Vector3): Matrix4x4;
    createScale(scales: Vector3): Matrix4x4;
    createScale(scale: float, centerPoint: Vector3): Matrix4x4;
    createScale(xScale: float, yScale: float, zScale: float, centerPoint: Vector3): Matrix4x4;
    createScale(xScale: float, yScale: float, zScale: float): Matrix4x4;
    createScale(scale: float): Matrix4x4;
    createShadow(lightDirection: Vector3, plane: Plane): Matrix4x4;
    createTranslation(position: Vector3): Matrix4x4;
    createTranslation(xPosition: float, yPosition: float, zPosition: float): Matrix4x4;
    createViewport(x: float, y: float, width: float, height: float, minDepth: float, maxDepth: float): Matrix4x4;
    createViewportLeftHanded(x: float, y: float, width: float, height: float, minDepth: float, maxDepth: float): Matrix4x4;
    createWorld(position: Vector3, forward: Vector3, up: Vector3): Matrix4x4;
    decompose(matrix: Matrix4x4, scale: { value: ref<Vector3> }, rotation: { value: ref<Quaternion> }, translation: { value: ref<Vector3> }): boolean;
    invert(matrix: Matrix4x4, result: { value: ref<Matrix4x4> }): boolean;
    lerp(matrix1: Matrix4x4, matrix2: Matrix4x4, amount: float): Matrix4x4;
    multiply(value1: Matrix4x4, value2: Matrix4x4): Matrix4x4;
    multiply(value1: Matrix4x4, value2: float): Matrix4x4;
    negate(value: Matrix4x4): Matrix4x4;
    subtract(value1: Matrix4x4, value2: Matrix4x4): Matrix4x4;
    transform(value: Matrix4x4, rotation: Quaternion): Matrix4x4;
    transpose(matrix: Matrix4x4): Matrix4x4;
};


export interface __Matrix4x4$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Matrix4x4>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Matrix4x4): boolean;
}

export type Matrix4x4 = Matrix4x4$instance & __Matrix4x4$views;


export interface Plane$instance {
    normal: Vector3;
    D: float;
    equals(obj: unknown): boolean;
    equals(other: Plane): boolean;
    getHashCode(): int;
    toString(): string;
}


export const Plane: {
    new(x: float, y: float, z: float, d: float): Plane$instance;
    new(normal: Vector3, d: float): Plane$instance;
    new(value: Vector4): Plane$instance;
    create(normal: Vector3, d: float): Plane;
    create(value: Vector4): Plane;
    create(x: float, y: float, z: float, d: float): Plane;
    createFromVertices(point1: Vector3, point2: Vector3, point3: Vector3): Plane;
    dot(plane: Plane, value: Vector4): float;
    dotCoordinate(plane: Plane, value: Vector3): float;
    dotNormal(plane: Plane, value: Vector3): float;
    normalize(value: Plane): Plane;
    transform(plane: Plane, matrix: Matrix4x4): Plane;
    transform(plane: Plane, rotation: Quaternion): Plane;
};


export interface __Plane$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Plane>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Plane): boolean;
}

export type Plane = Plane$instance & __Plane$views;


export interface Quaternion$instance {
    X: float;
    Y: float;
    Z: float;
    W: float;
    readonly isIdentity: boolean;
    item: float;
    equals(obj: unknown): boolean;
    equals(other: Quaternion): boolean;
    getHashCode(): int;
    length(): float;
    lengthSquared(): float;
    toString(): string;
}


export const Quaternion: {
    new(x: float, y: float, z: float, w: float): Quaternion$instance;
    new(vectorPart: Vector3, scalarPart: float): Quaternion$instance;
    readonly zero: Quaternion;
    readonly identity: Quaternion;
    add(value1: Quaternion, value2: Quaternion): Quaternion;
    concatenate(value1: Quaternion, value2: Quaternion): Quaternion;
    conjugate(value: Quaternion): Quaternion;
    create(vectorPart: Vector3, scalarPart: float): Quaternion;
    create(x: float, y: float, z: float, w: float): Quaternion;
    createFromAxisAngle(axis: Vector3, angle: float): Quaternion;
    createFromRotationMatrix(matrix: Matrix4x4): Quaternion;
    createFromYawPitchRoll(yaw: float, pitch: float, roll: float): Quaternion;
    divide(value1: Quaternion, value2: Quaternion): Quaternion;
    dot(quaternion1: Quaternion, quaternion2: Quaternion): float;
    inverse(value: Quaternion): Quaternion;
    lerp(quaternion1: Quaternion, quaternion2: Quaternion, amount: float): Quaternion;
    multiply(value1: Quaternion, value2: Quaternion): Quaternion;
    multiply(value1: Quaternion, value2: float): Quaternion;
    negate(value: Quaternion): Quaternion;
    normalize(value: Quaternion): Quaternion;
    slerp(quaternion1: Quaternion, quaternion2: Quaternion, amount: float): Quaternion;
    subtract(value1: Quaternion, value2: Quaternion): Quaternion;
};


export interface __Quaternion$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Quaternion>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Quaternion): boolean;
}

export type Quaternion = Quaternion$instance & __Quaternion$views;


export interface TotalOrderIeee754Comparer_1$instance<T extends IFloatingPointIeee754_1<T>> {
    compare(x: T, y: T): int;
    equals(x: T, y: T): boolean;
    equals(other: TotalOrderIeee754Comparer_1<T>): boolean;
    equals(obj: unknown): boolean;
    getHashCode(obj: T): int;
    getHashCode(): int;
}


export const TotalOrderIeee754Comparer_1: {
    new<T extends IFloatingPointIeee754_1<T>>(): TotalOrderIeee754Comparer_1$instance<T>;
};


export interface __TotalOrderIeee754Comparer_1$views<T extends IFloatingPointIeee754_1<T>> {
    As_IComparer_1(): System_Collections_Generic_Internal.IComparer_1$instance<T>;
    As_IEqualityComparer_1(): System_Collections_Generic_Internal.IEqualityComparer_1$instance<T>;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<TotalOrderIeee754Comparer_1<T>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: TotalOrderIeee754Comparer_1<T>): boolean;
}

export interface TotalOrderIeee754Comparer_1$instance<T extends IFloatingPointIeee754_1<T>> extends System_Collections_Generic_Internal.IComparer_1$instance<T> {}

export type TotalOrderIeee754Comparer_1<T extends IFloatingPointIeee754_1<T>> = TotalOrderIeee754Comparer_1$instance<T> & __TotalOrderIeee754Comparer_1$views<T>;


export interface Vector_1$instance<T> extends IAdditionOperators_3<Vector_1<T>, Vector_1<T>, Vector_1<T>>, IBitwiseOperators_3<Vector_1<T>, Vector_1<T>, Vector_1<T>>, IDivisionOperators_3<Vector_1<T>, Vector_1<T>, Vector_1<T>>, IEqualityOperators_3<Vector_1<T>, Vector_1<T>, CLROf<boolean>>, IMultiplyOperators_3<Vector_1<T>, Vector_1<T>, Vector_1<T>>, IShiftOperators_3<Vector_1<T>, CLROf<int>, Vector_1<T>>, ISubtractionOperators_3<Vector_1<T>, Vector_1<T>, Vector_1<T>>, IUnaryNegationOperators_2<Vector_1<T>, Vector_1<T>>, IUnaryPlusOperators_2<Vector_1<T>, Vector_1<T>> {
    readonly item: T;
    copyTo(destination: T[]): void;
    copyTo(destination: T[], startIndex: int): void;
    copyTo(destination: Span_1<CLROf<byte>>): void;
    copyTo(destination: Span_1<T>): void;
    equals(obj: unknown): boolean;
    equals(other: Vector_1<T>): boolean;
    getHashCode(): int;
    toString(): string;
    toString(format: string): string;
    toString(format: string, formatProvider: IFormatProvider): string;
    tryCopyTo(destination: Span_1<CLROf<byte>>): boolean;
    tryCopyTo(destination: Span_1<T>): boolean;
}


export const Vector_1: {
    new<T>(value: T): Vector_1$instance<T>;
    new<T>(values: T[]): Vector_1$instance<T>;
    new<T>(values: T[], index: int): Vector_1$instance<T>;
    new<T>(values: ReadOnlySpan_1<T>): Vector_1$instance<T>;
    new<T>(values: ReadOnlySpan_1<CLROf<byte>>): Vector_1$instance<T>;
    new<T>(values: Span_1<T>): Vector_1$instance<T>;
    readonly allBitsSet: unknown;
    readonly count: int;
    readonly indices: unknown;
    readonly isSupported: boolean;
    readonly one: unknown;
    readonly zero: unknown;
};


export interface __Vector_1$views<T> {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Vector_1<T>>;
    As_IFormattable(): System_Internal.IFormattable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: Vector_1<T>): boolean;
}

export interface Vector_1$instance<T> extends IAdditionOperators_3$instance<Vector_1<T>, Vector_1<T>, Vector_1<T>>, IBitwiseOperators_3$instance<Vector_1<T>, Vector_1<T>, Vector_1<T>>, IDivisionOperators_3$instance<Vector_1<T>, Vector_1<T>, Vector_1<T>>, IEqualityOperators_3$instance<Vector_1<T>, Vector_1<T>, CLROf<boolean>>, IMultiplyOperators_3$instance<Vector_1<T>, Vector_1<T>, Vector_1<T>>, IShiftOperators_3$instance<Vector_1<T>, CLROf<int>, Vector_1<T>>, ISubtractionOperators_3$instance<Vector_1<T>, Vector_1<T>, Vector_1<T>>, IUnaryNegationOperators_2$instance<Vector_1<T>, Vector_1<T>>, IUnaryPlusOperators_2$instance<Vector_1<T>, Vector_1<T>> {}

export type Vector_1<T> = Vector_1$instance<T> & __Vector_1$views<T>;


export interface Vector2$instance {
    X: float;
    Y: float;
    item: float;
    copyTo(array: float[]): void;
    copyTo(array: float[], index: int): void;
    copyTo(destination: Span_1<CLROf<float>>): void;
    equals(obj: unknown): boolean;
    equals(other: Vector2): boolean;
    getHashCode(): int;
    length(): float;
    lengthSquared(): float;
    toString(): string;
    toString(format: string): string;
    toString(format: string, formatProvider: IFormatProvider): string;
    tryCopyTo(destination: Span_1<CLROf<float>>): boolean;
}


export const Vector2: {
    new(value: float): Vector2$instance;
    new(x: float, y: float): Vector2$instance;
    new(values: ReadOnlySpan_1<CLROf<float>>): Vector2$instance;
    readonly allBitsSet: Vector2;
    readonly E: Vector2;
    readonly epsilon: Vector2;
    readonly naN: Vector2;
    readonly negativeInfinity: Vector2;
    readonly negativeZero: Vector2;
    readonly one: Vector2;
    readonly pi: Vector2;
    readonly positiveInfinity: Vector2;
    readonly tau: Vector2;
    readonly unitX: Vector2;
    readonly unitY: Vector2;
    readonly zero: Vector2;
    abs(value: Vector2): Vector2;
    add(left: Vector2, right: Vector2): Vector2;
    all(vector: Vector2, value: float): boolean;
    allWhereAllBitsSet(vector: Vector2): boolean;
    andNot(left: Vector2, right: Vector2): Vector2;
    any_(vector: Vector2, value: float): boolean;
    anyWhereAllBitsSet(vector: Vector2): boolean;
    bitwiseAnd(left: Vector2, right: Vector2): Vector2;
    bitwiseOr(left: Vector2, right: Vector2): Vector2;
    clamp(value1: Vector2, min: Vector2, max: Vector2): Vector2;
    clampNative(value1: Vector2, min: Vector2, max: Vector2): Vector2;
    conditionalSelect(condition: Vector2, left: Vector2, right: Vector2): Vector2;
    copySign(value: Vector2, sign: Vector2): Vector2;
    cos(vector: Vector2): Vector2;
    count(vector: Vector2, value: float): int;
    countWhereAllBitsSet(vector: Vector2): int;
    create(values: ReadOnlySpan_1<CLROf<float>>): Vector2;
    create(x: float, y: float): Vector2;
    create(value: float): Vector2;
    createScalar(x: float): Vector2;
    createScalarUnsafe(x: float): Vector2;
    cross(value1: Vector2, value2: Vector2): float;
    degreesToRadians(degrees: Vector2): Vector2;
    distance(value1: Vector2, value2: Vector2): float;
    distanceSquared(value1: Vector2, value2: Vector2): float;
    divide(left: Vector2, right: Vector2): Vector2;
    divide(left: Vector2, divisor: float): Vector2;
    dot(value1: Vector2, value2: Vector2): float;
    equals(left: Vector2, right: Vector2): Vector2;
    equalsAll(left: Vector2, right: Vector2): boolean;
    equalsAny(left: Vector2, right: Vector2): boolean;
    exp(vector: Vector2): Vector2;
    fusedMultiplyAdd(left: Vector2, right: Vector2, addend: Vector2): Vector2;
    greaterThan(left: Vector2, right: Vector2): Vector2;
    greaterThanAll(left: Vector2, right: Vector2): boolean;
    greaterThanAny(left: Vector2, right: Vector2): boolean;
    greaterThanOrEqual(left: Vector2, right: Vector2): Vector2;
    greaterThanOrEqualAll(left: Vector2, right: Vector2): boolean;
    greaterThanOrEqualAny(left: Vector2, right: Vector2): boolean;
    hypot(x: Vector2, y: Vector2): Vector2;
    indexOf(vector: Vector2, value: float): int;
    indexOfWhereAllBitsSet(vector: Vector2): int;
    isEvenInteger(vector: Vector2): Vector2;
    isFinite(vector: Vector2): Vector2;
    isInfinity(vector: Vector2): Vector2;
    isInteger(vector: Vector2): Vector2;
    isNaN(vector: Vector2): Vector2;
    isNegative(vector: Vector2): Vector2;
    isNegativeInfinity(vector: Vector2): Vector2;
    isNormal(vector: Vector2): Vector2;
    isOddInteger(vector: Vector2): Vector2;
    isPositive(vector: Vector2): Vector2;
    isPositiveInfinity(vector: Vector2): Vector2;
    isSubnormal(vector: Vector2): Vector2;
    isZero(vector: Vector2): Vector2;
    lastIndexOf(vector: Vector2, value: float): int;
    lastIndexOfWhereAllBitsSet(vector: Vector2): int;
    lerp(value1: Vector2, value2: Vector2, amount: Vector2): Vector2;
    lerp(value1: Vector2, value2: Vector2, amount: float): Vector2;
    lessThan(left: Vector2, right: Vector2): Vector2;
    lessThanAll(left: Vector2, right: Vector2): boolean;
    lessThanAny(left: Vector2, right: Vector2): boolean;
    lessThanOrEqual(left: Vector2, right: Vector2): Vector2;
    lessThanOrEqualAll(left: Vector2, right: Vector2): boolean;
    lessThanOrEqualAny(left: Vector2, right: Vector2): boolean;
    load(source: ptr<float>): Vector2;
    loadAligned(source: ptr<float>): Vector2;
    loadAlignedNonTemporal(source: ptr<float>): Vector2;
    loadUnsafe(source: { value: ref<float> }, elementOffset: nuint): Vector2;
    loadUnsafe(source: { value: ref<float> }): Vector2;
    log(vector: Vector2): Vector2;
    log2(vector: Vector2): Vector2;
    max(value1: Vector2, value2: Vector2): Vector2;
    maxMagnitude(value1: Vector2, value2: Vector2): Vector2;
    maxMagnitudeNumber(value1: Vector2, value2: Vector2): Vector2;
    maxNative(value1: Vector2, value2: Vector2): Vector2;
    maxNumber(value1: Vector2, value2: Vector2): Vector2;
    min(value1: Vector2, value2: Vector2): Vector2;
    minMagnitude(value1: Vector2, value2: Vector2): Vector2;
    minMagnitudeNumber(value1: Vector2, value2: Vector2): Vector2;
    minNative(value1: Vector2, value2: Vector2): Vector2;
    minNumber(value1: Vector2, value2: Vector2): Vector2;
    multiply(left: Vector2, right: Vector2): Vector2;
    multiply(left: Vector2, right: float): Vector2;
    multiply(left: float, right: Vector2): Vector2;
    multiplyAddEstimate(left: Vector2, right: Vector2, addend: Vector2): Vector2;
    negate(value: Vector2): Vector2;
    none(vector: Vector2, value: float): boolean;
    noneWhereAllBitsSet(vector: Vector2): boolean;
    normalize(value: Vector2): Vector2;
    onesComplement(value: Vector2): Vector2;
    radiansToDegrees(radians: Vector2): Vector2;
    reflect(vector: Vector2, normal: Vector2): Vector2;
    round(vector: Vector2, mode: MidpointRounding): Vector2;
    round(vector: Vector2): Vector2;
    shuffle(vector: Vector2, xIndex: byte, yIndex: byte): Vector2;
    sin(vector: Vector2): Vector2;
    sinCos(vector: Vector2): ValueTuple_2<Vector2, Vector2>;
    squareRoot(value: Vector2): Vector2;
    subtract(left: Vector2, right: Vector2): Vector2;
    sum(value: Vector2): float;
    transform(position: Vector2, matrix: Matrix3x2): Vector2;
    transform(position: Vector2, matrix: Matrix4x4): Vector2;
    transform(value: Vector2, rotation: Quaternion): Vector2;
    transformNormal(normal: Vector2, matrix: Matrix3x2): Vector2;
    transformNormal(normal: Vector2, matrix: Matrix4x4): Vector2;
    truncate(vector: Vector2): Vector2;
    xor(left: Vector2, right: Vector2): Vector2;
};


export interface __Vector2$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Vector2>;
    As_IFormattable(): System_Internal.IFormattable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: Vector2): boolean;
}

export type Vector2 = Vector2$instance & __Vector2$views;


export interface Vector3$instance {
    X: float;
    Y: float;
    Z: float;
    item: float;
    copyTo(array: float[]): void;
    copyTo(array: float[], index: int): void;
    copyTo(destination: Span_1<CLROf<float>>): void;
    equals(obj: unknown): boolean;
    equals(other: Vector3): boolean;
    getHashCode(): int;
    length(): float;
    lengthSquared(): float;
    toString(): string;
    toString(format: string): string;
    toString(format: string, formatProvider: IFormatProvider): string;
    tryCopyTo(destination: Span_1<CLROf<float>>): boolean;
}


export const Vector3: {
    new(value: float): Vector3$instance;
    new(value: Vector2, z: float): Vector3$instance;
    new(x: float, y: float, z: float): Vector3$instance;
    new(values: ReadOnlySpan_1<CLROf<float>>): Vector3$instance;
    readonly allBitsSet: Vector3;
    readonly E: Vector3;
    readonly epsilon: Vector3;
    readonly naN: Vector3;
    readonly negativeInfinity: Vector3;
    readonly negativeZero: Vector3;
    readonly one: Vector3;
    readonly pi: Vector3;
    readonly positiveInfinity: Vector3;
    readonly tau: Vector3;
    readonly unitX: Vector3;
    readonly unitY: Vector3;
    readonly unitZ: Vector3;
    readonly zero: Vector3;
    abs(value: Vector3): Vector3;
    add(left: Vector3, right: Vector3): Vector3;
    all(vector: Vector3, value: float): boolean;
    allWhereAllBitsSet(vector: Vector3): boolean;
    andNot(left: Vector3, right: Vector3): Vector3;
    any_(vector: Vector3, value: float): boolean;
    anyWhereAllBitsSet(vector: Vector3): boolean;
    bitwiseAnd(left: Vector3, right: Vector3): Vector3;
    bitwiseOr(left: Vector3, right: Vector3): Vector3;
    clamp(value1: Vector3, min: Vector3, max: Vector3): Vector3;
    clampNative(value1: Vector3, min: Vector3, max: Vector3): Vector3;
    conditionalSelect(condition: Vector3, left: Vector3, right: Vector3): Vector3;
    copySign(value: Vector3, sign: Vector3): Vector3;
    cos(vector: Vector3): Vector3;
    count(vector: Vector3, value: float): int;
    countWhereAllBitsSet(vector: Vector3): int;
    create(vector: Vector2, z: float): Vector3;
    create(values: ReadOnlySpan_1<CLROf<float>>): Vector3;
    create(x: float, y: float, z: float): Vector3;
    create(value: float): Vector3;
    createScalar(x: float): Vector3;
    createScalarUnsafe(x: float): Vector3;
    cross(vector1: Vector3, vector2: Vector3): Vector3;
    degreesToRadians(degrees: Vector3): Vector3;
    distance(value1: Vector3, value2: Vector3): float;
    distanceSquared(value1: Vector3, value2: Vector3): float;
    divide(left: Vector3, right: Vector3): Vector3;
    divide(left: Vector3, divisor: float): Vector3;
    dot(vector1: Vector3, vector2: Vector3): float;
    equals(left: Vector3, right: Vector3): Vector3;
    equalsAll(left: Vector3, right: Vector3): boolean;
    equalsAny(left: Vector3, right: Vector3): boolean;
    exp(vector: Vector3): Vector3;
    fusedMultiplyAdd(left: Vector3, right: Vector3, addend: Vector3): Vector3;
    greaterThan(left: Vector3, right: Vector3): Vector3;
    greaterThanAll(left: Vector3, right: Vector3): boolean;
    greaterThanAny(left: Vector3, right: Vector3): boolean;
    greaterThanOrEqual(left: Vector3, right: Vector3): Vector3;
    greaterThanOrEqualAll(left: Vector3, right: Vector3): boolean;
    greaterThanOrEqualAny(left: Vector3, right: Vector3): boolean;
    hypot(x: Vector3, y: Vector3): Vector3;
    indexOf(vector: Vector3, value: float): int;
    indexOfWhereAllBitsSet(vector: Vector3): int;
    isEvenInteger(vector: Vector3): Vector3;
    isFinite(vector: Vector3): Vector3;
    isInfinity(vector: Vector3): Vector3;
    isInteger(vector: Vector3): Vector3;
    isNaN(vector: Vector3): Vector3;
    isNegative(vector: Vector3): Vector3;
    isNegativeInfinity(vector: Vector3): Vector3;
    isNormal(vector: Vector3): Vector3;
    isOddInteger(vector: Vector3): Vector3;
    isPositive(vector: Vector3): Vector3;
    isPositiveInfinity(vector: Vector3): Vector3;
    isSubnormal(vector: Vector3): Vector3;
    isZero(vector: Vector3): Vector3;
    lastIndexOf(vector: Vector3, value: float): int;
    lastIndexOfWhereAllBitsSet(vector: Vector3): int;
    lerp(value1: Vector3, value2: Vector3, amount: Vector3): Vector3;
    lerp(value1: Vector3, value2: Vector3, amount: float): Vector3;
    lessThan(left: Vector3, right: Vector3): Vector3;
    lessThanAll(left: Vector3, right: Vector3): boolean;
    lessThanAny(left: Vector3, right: Vector3): boolean;
    lessThanOrEqual(left: Vector3, right: Vector3): Vector3;
    lessThanOrEqualAll(left: Vector3, right: Vector3): boolean;
    lessThanOrEqualAny(left: Vector3, right: Vector3): boolean;
    load(source: ptr<float>): Vector3;
    loadAligned(source: ptr<float>): Vector3;
    loadAlignedNonTemporal(source: ptr<float>): Vector3;
    loadUnsafe(source: { value: ref<float> }, elementOffset: nuint): Vector3;
    loadUnsafe(source: { value: ref<float> }): Vector3;
    log(vector: Vector3): Vector3;
    log2(vector: Vector3): Vector3;
    max(value1: Vector3, value2: Vector3): Vector3;
    maxMagnitude(value1: Vector3, value2: Vector3): Vector3;
    maxMagnitudeNumber(value1: Vector3, value2: Vector3): Vector3;
    maxNative(value1: Vector3, value2: Vector3): Vector3;
    maxNumber(value1: Vector3, value2: Vector3): Vector3;
    min(value1: Vector3, value2: Vector3): Vector3;
    minMagnitude(value1: Vector3, value2: Vector3): Vector3;
    minMagnitudeNumber(value1: Vector3, value2: Vector3): Vector3;
    minNative(value1: Vector3, value2: Vector3): Vector3;
    minNumber(value1: Vector3, value2: Vector3): Vector3;
    multiply(left: Vector3, right: Vector3): Vector3;
    multiply(left: Vector3, right: float): Vector3;
    multiply(left: float, right: Vector3): Vector3;
    multiplyAddEstimate(left: Vector3, right: Vector3, addend: Vector3): Vector3;
    negate(value: Vector3): Vector3;
    none(vector: Vector3, value: float): boolean;
    noneWhereAllBitsSet(vector: Vector3): boolean;
    normalize(value: Vector3): Vector3;
    onesComplement(value: Vector3): Vector3;
    radiansToDegrees(radians: Vector3): Vector3;
    reflect(vector: Vector3, normal: Vector3): Vector3;
    round(vector: Vector3, mode: MidpointRounding): Vector3;
    round(vector: Vector3): Vector3;
    shuffle(vector: Vector3, xIndex: byte, yIndex: byte, zIndex: byte): Vector3;
    sin(vector: Vector3): Vector3;
    sinCos(vector: Vector3): ValueTuple_2<Vector3, Vector3>;
    squareRoot(value: Vector3): Vector3;
    subtract(left: Vector3, right: Vector3): Vector3;
    sum(value: Vector3): float;
    transform(position: Vector3, matrix: Matrix4x4): Vector3;
    transform(value: Vector3, rotation: Quaternion): Vector3;
    transformNormal(normal: Vector3, matrix: Matrix4x4): Vector3;
    truncate(vector: Vector3): Vector3;
    xor(left: Vector3, right: Vector3): Vector3;
};


export interface __Vector3$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Vector3>;
    As_IFormattable(): System_Internal.IFormattable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: Vector3): boolean;
}

export type Vector3 = Vector3$instance & __Vector3$views;


export interface Vector4$instance {
    X: float;
    Y: float;
    Z: float;
    W: float;
    item: float;
    copyTo(array: float[]): void;
    copyTo(array: float[], index: int): void;
    copyTo(destination: Span_1<CLROf<float>>): void;
    equals(other: Vector4): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    length(): float;
    lengthSquared(): float;
    toString(): string;
    toString(format: string): string;
    toString(format: string, formatProvider: IFormatProvider): string;
    tryCopyTo(destination: Span_1<CLROf<float>>): boolean;
}


export const Vector4: {
    new(value: float): Vector4$instance;
    new(value: Vector2, z: float, w: float): Vector4$instance;
    new(value: Vector3, w: float): Vector4$instance;
    new(x: float, y: float, z: float, w: float): Vector4$instance;
    new(values: ReadOnlySpan_1<CLROf<float>>): Vector4$instance;
    readonly allBitsSet: Vector4;
    readonly E: Vector4;
    readonly epsilon: Vector4;
    readonly naN: Vector4;
    readonly negativeInfinity: Vector4;
    readonly negativeZero: Vector4;
    readonly one: Vector4;
    readonly pi: Vector4;
    readonly positiveInfinity: Vector4;
    readonly tau: Vector4;
    readonly unitX: Vector4;
    readonly unitY: Vector4;
    readonly unitZ: Vector4;
    readonly unitW: Vector4;
    readonly zero: Vector4;
    abs(value: Vector4): Vector4;
    add(left: Vector4, right: Vector4): Vector4;
    all(vector: Vector4, value: float): boolean;
    allWhereAllBitsSet(vector: Vector4): boolean;
    andNot(left: Vector4, right: Vector4): Vector4;
    any_(vector: Vector4, value: float): boolean;
    anyWhereAllBitsSet(vector: Vector4): boolean;
    bitwiseAnd(left: Vector4, right: Vector4): Vector4;
    bitwiseOr(left: Vector4, right: Vector4): Vector4;
    clamp(value1: Vector4, min: Vector4, max: Vector4): Vector4;
    clampNative(value1: Vector4, min: Vector4, max: Vector4): Vector4;
    conditionalSelect(condition: Vector4, left: Vector4, right: Vector4): Vector4;
    copySign(value: Vector4, sign: Vector4): Vector4;
    cos(vector: Vector4): Vector4;
    count(vector: Vector4, value: float): int;
    countWhereAllBitsSet(vector: Vector4): int;
    create(vector: Vector2, z: float, w: float): Vector4;
    create(vector: Vector3, w: float): Vector4;
    create(values: ReadOnlySpan_1<CLROf<float>>): Vector4;
    create(x: float, y: float, z: float, w: float): Vector4;
    create(value: float): Vector4;
    createScalar(x: float): Vector4;
    createScalarUnsafe(x: float): Vector4;
    cross(vector1: Vector4, vector2: Vector4): Vector4;
    degreesToRadians(degrees: Vector4): Vector4;
    distance(value1: Vector4, value2: Vector4): float;
    distanceSquared(value1: Vector4, value2: Vector4): float;
    divide(left: Vector4, right: Vector4): Vector4;
    divide(left: Vector4, divisor: float): Vector4;
    dot(vector1: Vector4, vector2: Vector4): float;
    equals(left: Vector4, right: Vector4): Vector4;
    equalsAll(left: Vector4, right: Vector4): boolean;
    equalsAny(left: Vector4, right: Vector4): boolean;
    exp(vector: Vector4): Vector4;
    fusedMultiplyAdd(left: Vector4, right: Vector4, addend: Vector4): Vector4;
    greaterThan(left: Vector4, right: Vector4): Vector4;
    greaterThanAll(left: Vector4, right: Vector4): boolean;
    greaterThanAny(left: Vector4, right: Vector4): boolean;
    greaterThanOrEqual(left: Vector4, right: Vector4): Vector4;
    greaterThanOrEqualAll(left: Vector4, right: Vector4): boolean;
    greaterThanOrEqualAny(left: Vector4, right: Vector4): boolean;
    hypot(x: Vector4, y: Vector4): Vector4;
    indexOf(vector: Vector4, value: float): int;
    indexOfWhereAllBitsSet(vector: Vector4): int;
    isEvenInteger(vector: Vector4): Vector4;
    isFinite(vector: Vector4): Vector4;
    isInfinity(vector: Vector4): Vector4;
    isInteger(vector: Vector4): Vector4;
    isNaN(vector: Vector4): Vector4;
    isNegative(vector: Vector4): Vector4;
    isNegativeInfinity(vector: Vector4): Vector4;
    isNormal(vector: Vector4): Vector4;
    isOddInteger(vector: Vector4): Vector4;
    isPositive(vector: Vector4): Vector4;
    isPositiveInfinity(vector: Vector4): Vector4;
    isSubnormal(vector: Vector4): Vector4;
    isZero(vector: Vector4): Vector4;
    lastIndexOf(vector: Vector4, value: float): int;
    lastIndexOfWhereAllBitsSet(vector: Vector4): int;
    lerp(value1: Vector4, value2: Vector4, amount: Vector4): Vector4;
    lerp(value1: Vector4, value2: Vector4, amount: float): Vector4;
    lessThan(left: Vector4, right: Vector4): Vector4;
    lessThanAll(left: Vector4, right: Vector4): boolean;
    lessThanAny(left: Vector4, right: Vector4): boolean;
    lessThanOrEqual(left: Vector4, right: Vector4): Vector4;
    lessThanOrEqualAll(left: Vector4, right: Vector4): boolean;
    lessThanOrEqualAny(left: Vector4, right: Vector4): boolean;
    load(source: ptr<float>): Vector4;
    loadAligned(source: ptr<float>): Vector4;
    loadAlignedNonTemporal(source: ptr<float>): Vector4;
    loadUnsafe(source: { value: ref<float> }, elementOffset: nuint): Vector4;
    loadUnsafe(source: { value: ref<float> }): Vector4;
    log(vector: Vector4): Vector4;
    log2(vector: Vector4): Vector4;
    max(value1: Vector4, value2: Vector4): Vector4;
    maxMagnitude(value1: Vector4, value2: Vector4): Vector4;
    maxMagnitudeNumber(value1: Vector4, value2: Vector4): Vector4;
    maxNative(value1: Vector4, value2: Vector4): Vector4;
    maxNumber(value1: Vector4, value2: Vector4): Vector4;
    min(value1: Vector4, value2: Vector4): Vector4;
    minMagnitude(value1: Vector4, value2: Vector4): Vector4;
    minMagnitudeNumber(value1: Vector4, value2: Vector4): Vector4;
    minNative(value1: Vector4, value2: Vector4): Vector4;
    minNumber(value1: Vector4, value2: Vector4): Vector4;
    multiply(left: Vector4, right: Vector4): Vector4;
    multiply(left: Vector4, right: float): Vector4;
    multiply(left: float, right: Vector4): Vector4;
    multiplyAddEstimate(left: Vector4, right: Vector4, addend: Vector4): Vector4;
    negate(value: Vector4): Vector4;
    none(vector: Vector4, value: float): boolean;
    noneWhereAllBitsSet(vector: Vector4): boolean;
    normalize(vector: Vector4): Vector4;
    onesComplement(value: Vector4): Vector4;
    radiansToDegrees(radians: Vector4): Vector4;
    round(vector: Vector4, mode: MidpointRounding): Vector4;
    round(vector: Vector4): Vector4;
    shuffle(vector: Vector4, xIndex: byte, yIndex: byte, zIndex: byte, wIndex: byte): Vector4;
    sin(vector: Vector4): Vector4;
    sinCos(vector: Vector4): ValueTuple_2<Vector4, Vector4>;
    squareRoot(value: Vector4): Vector4;
    subtract(left: Vector4, right: Vector4): Vector4;
    sum(value: Vector4): float;
    transform(position: Vector2, matrix: Matrix4x4): Vector4;
    transform(value: Vector2, rotation: Quaternion): Vector4;
    transform(position: Vector3, matrix: Matrix4x4): Vector4;
    transform(value: Vector3, rotation: Quaternion): Vector4;
    transform(vector: Vector4, matrix: Matrix4x4): Vector4;
    transform(value: Vector4, rotation: Quaternion): Vector4;
    truncate(vector: Vector4): Vector4;
    xor(left: Vector4, right: Vector4): Vector4;
};


export interface __Vector4$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Vector4>;
    As_IFormattable(): System_Internal.IFormattable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: Vector4): boolean;
}

export type Vector4 = Vector4$instance & __Vector4$views;


export abstract class BitOperations$instance {
    static crc32C(crc: uint, data: byte): uint;
    static crc32C(crc: uint, data: ushort): uint;
    static crc32C(crc: uint, data: uint): uint;
    static crc32C(crc: uint, data: ulong): uint;
    static isPow2(value: int): boolean;
    static isPow2(value: long): boolean;
    static isPow2(value: nint): boolean;
    static isPow2(value: uint): boolean;
    static isPow2(value: ulong): boolean;
    static isPow2(value: nuint): boolean;
    static leadingZeroCount(value: uint): int;
    static leadingZeroCount(value: ulong): int;
    static leadingZeroCount(value: nuint): int;
    static log2(value: uint): int;
    static log2(value: ulong): int;
    static log2(value: nuint): int;
    static popCount(value: uint): int;
    static popCount(value: ulong): int;
    static popCount(value: nuint): int;
    static rotateLeft(value: uint, offset: int): uint;
    static rotateLeft(value: ulong, offset: int): ulong;
    static rotateLeft(value: nuint, offset: int): nuint;
    static rotateRight(value: uint, offset: int): uint;
    static rotateRight(value: ulong, offset: int): ulong;
    static rotateRight(value: nuint, offset: int): nuint;
    static roundUpToPowerOf2(value: uint): uint;
    static roundUpToPowerOf2(value: ulong): ulong;
    static roundUpToPowerOf2(value: nuint): nuint;
    static trailingZeroCount(value: int): int;
    static trailingZeroCount(value: long): int;
    static trailingZeroCount(value: nint): int;
    static trailingZeroCount(value: uint): int;
    static trailingZeroCount(value: ulong): int;
    static trailingZeroCount(value: nuint): int;
}


export type BitOperations = BitOperations$instance;

export abstract class Vector$instance {
    static readonly isHardwareAccelerated: boolean;
    static abs<T>(value: Vector_1<T>): Vector_1<T>;
    static add<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static addSaturate<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static all<T>(vector: Vector_1<T>, value: T): boolean;
    static allWhereAllBitsSet<T>(vector: Vector_1<T>): boolean;
    static andNot<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static any_<T>(vector: Vector_1<T>, value: T): boolean;
    static anyWhereAllBitsSet<T>(vector: Vector_1<T>): boolean;
    static as_<TFrom, TTo>(vector: Vector_1<TFrom>): Vector_1<TTo>;
    static asPlane(value: Vector4): Plane;
    static asQuaternion(value: Vector4): Quaternion;
    static asVector2(value: Vector3): Vector2;
    static asVector2(value: Vector4): Vector2;
    static asVector3(value: Vector2): Vector3;
    static asVector3(value: Vector4): Vector3;
    static asVector3Unsafe(value: Vector2): Vector3;
    static asVector4(value: Plane): Vector4;
    static asVector4(value: Quaternion): Vector4;
    static asVector4(value: Vector2): Vector4;
    static asVector4(value: Vector3): Vector4;
    static asVector4Unsafe(value: Vector2): Vector4;
    static asVector4Unsafe(value: Vector3): Vector4;
    static asVectorByte<T>(value: Vector_1<T>): Vector_1<CLROf<byte>>;
    static asVectorDouble<T>(value: Vector_1<T>): Vector_1<CLROf<double>>;
    static asVectorInt16<T>(value: Vector_1<T>): Vector_1<CLROf<short>>;
    static asVectorInt32<T>(value: Vector_1<T>): Vector_1<CLROf<int>>;
    static asVectorInt64<T>(value: Vector_1<T>): Vector_1<CLROf<long>>;
    static asVectorNInt<T>(value: Vector_1<T>): Vector_1<CLROf<nint>>;
    static asVectorNUInt<T>(value: Vector_1<T>): Vector_1<CLROf<nuint>>;
    static asVectorSByte<T>(value: Vector_1<T>): Vector_1<CLROf<sbyte>>;
    static asVectorSingle<T>(value: Vector_1<T>): Vector_1<CLROf<float>>;
    static asVectorUInt16<T>(value: Vector_1<T>): Vector_1<CLROf<ushort>>;
    static asVectorUInt32<T>(value: Vector_1<T>): Vector_1<CLROf<uint>>;
    static asVectorUInt64<T>(value: Vector_1<T>): Vector_1<CLROf<ulong>>;
    static bitwiseAnd<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static bitwiseOr<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static ceiling(value: Vector_1<CLROf<double>>): Vector_1<CLROf<double>>;
    static ceiling(value: Vector_1<CLROf<float>>): Vector_1<CLROf<float>>;
    static clamp<T>(value: Vector_1<T>, min: Vector_1<T>, max: Vector_1<T>): Vector_1<T>;
    static clampNative<T>(value: Vector_1<T>, min: Vector_1<T>, max: Vector_1<T>): Vector_1<T>;
    static conditionalSelect(condition: Vector_1<CLROf<int>>, left: Vector_1<CLROf<float>>, right: Vector_1<CLROf<float>>): Vector_1<CLROf<float>>;
    static conditionalSelect(condition: Vector_1<CLROf<long>>, left: Vector_1<CLROf<double>>, right: Vector_1<CLROf<double>>): Vector_1<CLROf<double>>;
    static conditionalSelect<T>(condition: Vector_1<T>, left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static convertToDouble(value: Vector_1<CLROf<long>>): Vector_1<CLROf<double>>;
    static convertToDouble(value: Vector_1<CLROf<ulong>>): Vector_1<CLROf<double>>;
    static convertToInt32(value: Vector_1<CLROf<float>>): Vector_1<CLROf<int>>;
    static convertToInt32Native(value: Vector_1<CLROf<float>>): Vector_1<CLROf<int>>;
    static convertToInt64(value: Vector_1<CLROf<double>>): Vector_1<CLROf<long>>;
    static convertToInt64Native(value: Vector_1<CLROf<double>>): Vector_1<CLROf<long>>;
    static convertToSingle(value: Vector_1<CLROf<int>>): Vector_1<CLROf<float>>;
    static convertToSingle(value: Vector_1<CLROf<uint>>): Vector_1<CLROf<float>>;
    static convertToUInt32(value: Vector_1<CLROf<float>>): Vector_1<CLROf<uint>>;
    static convertToUInt32Native(value: Vector_1<CLROf<float>>): Vector_1<CLROf<uint>>;
    static convertToUInt64(value: Vector_1<CLROf<double>>): Vector_1<CLROf<ulong>>;
    static convertToUInt64Native(value: Vector_1<CLROf<double>>): Vector_1<CLROf<ulong>>;
    static copySign<T>(value: Vector_1<T>, sign: Vector_1<T>): Vector_1<T>;
    static cos(vector: Vector_1<CLROf<double>>): Vector_1<CLROf<double>>;
    static cos(vector: Vector_1<CLROf<float>>): Vector_1<CLROf<float>>;
    static count<T>(vector: Vector_1<T>, value: T): int;
    static countWhereAllBitsSet<T>(vector: Vector_1<T>): int;
    static create<T>(values: ReadOnlySpan_1<T>): Vector_1<T>;
    static create<T>(value: T): Vector_1<T>;
    static createScalar<T>(value: T): Vector_1<T>;
    static createScalarUnsafe<T>(value: T): Vector_1<T>;
    static createSequence<T>(start: T, step: T): Vector_1<T>;
    static degreesToRadians(degrees: Vector_1<CLROf<double>>): Vector_1<CLROf<double>>;
    static degreesToRadians(degrees: Vector_1<CLROf<float>>): Vector_1<CLROf<float>>;
    static divide<T>(left: Vector_1<T>, right: T): Vector_1<T>;
    static divide<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static dot<T>(left: Vector_1<T>, right: Vector_1<T>): T;
    static equals(left: Vector_1<CLROf<double>>, right: Vector_1<CLROf<double>>): Vector_1<CLROf<long>>;
    static equals(left: Vector_1<CLROf<int>>, right: Vector_1<CLROf<int>>): Vector_1<CLROf<int>>;
    static equals(left: Vector_1<CLROf<long>>, right: Vector_1<CLROf<long>>): Vector_1<CLROf<long>>;
    static equals(left: Vector_1<CLROf<float>>, right: Vector_1<CLROf<float>>): Vector_1<CLROf<int>>;
    static equals<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static equalsAll<T>(left: Vector_1<T>, right: Vector_1<T>): boolean;
    static equalsAny<T>(left: Vector_1<T>, right: Vector_1<T>): boolean;
    static exp(vector: Vector_1<CLROf<double>>): Vector_1<CLROf<double>>;
    static exp(vector: Vector_1<CLROf<float>>): Vector_1<CLROf<float>>;
    static extractMostSignificantBits(vector: Vector2): uint;
    static extractMostSignificantBits(vector: Vector3): uint;
    static extractMostSignificantBits(vector: Vector4): uint;
    static floor(value: Vector_1<CLROf<double>>): Vector_1<CLROf<double>>;
    static floor(value: Vector_1<CLROf<float>>): Vector_1<CLROf<float>>;
    static fusedMultiplyAdd(left: Vector_1<CLROf<double>>, right: Vector_1<CLROf<double>>, addend: Vector_1<CLROf<double>>): Vector_1<CLROf<double>>;
    static fusedMultiplyAdd(left: Vector_1<CLROf<float>>, right: Vector_1<CLROf<float>>, addend: Vector_1<CLROf<float>>): Vector_1<CLROf<float>>;
    static getElement(vector: Vector2, index: int): float;
    static getElement(vector: Vector3, index: int): float;
    static getElement(vector: Vector4, index: int): float;
    static getElement<T>(vector: Vector_1<T>, index: int): T;
    static greaterThan(left: Vector_1<CLROf<double>>, right: Vector_1<CLROf<double>>): Vector_1<CLROf<long>>;
    static greaterThan(left: Vector_1<CLROf<int>>, right: Vector_1<CLROf<int>>): Vector_1<CLROf<int>>;
    static greaterThan(left: Vector_1<CLROf<long>>, right: Vector_1<CLROf<long>>): Vector_1<CLROf<long>>;
    static greaterThan(left: Vector_1<CLROf<float>>, right: Vector_1<CLROf<float>>): Vector_1<CLROf<int>>;
    static greaterThan<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static greaterThanAll<T>(left: Vector_1<T>, right: Vector_1<T>): boolean;
    static greaterThanAny<T>(left: Vector_1<T>, right: Vector_1<T>): boolean;
    static greaterThanOrEqual(left: Vector_1<CLROf<double>>, right: Vector_1<CLROf<double>>): Vector_1<CLROf<long>>;
    static greaterThanOrEqual(left: Vector_1<CLROf<int>>, right: Vector_1<CLROf<int>>): Vector_1<CLROf<int>>;
    static greaterThanOrEqual(left: Vector_1<CLROf<long>>, right: Vector_1<CLROf<long>>): Vector_1<CLROf<long>>;
    static greaterThanOrEqual(left: Vector_1<CLROf<float>>, right: Vector_1<CLROf<float>>): Vector_1<CLROf<int>>;
    static greaterThanOrEqual<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static greaterThanOrEqualAll<T>(left: Vector_1<T>, right: Vector_1<T>): boolean;
    static greaterThanOrEqualAny<T>(left: Vector_1<T>, right: Vector_1<T>): boolean;
    static hypot(x: Vector_1<CLROf<double>>, y: Vector_1<CLROf<double>>): Vector_1<CLROf<double>>;
    static hypot(x: Vector_1<CLROf<float>>, y: Vector_1<CLROf<float>>): Vector_1<CLROf<float>>;
    static indexOf<T>(vector: Vector_1<T>, value: T): int;
    static indexOfWhereAllBitsSet<T>(vector: Vector_1<T>): int;
    static isEvenInteger<T>(vector: Vector_1<T>): Vector_1<T>;
    static isFinite<T>(vector: Vector_1<T>): Vector_1<T>;
    static isInfinity<T>(vector: Vector_1<T>): Vector_1<T>;
    static isInteger<T>(vector: Vector_1<T>): Vector_1<T>;
    static isNaN<T>(vector: Vector_1<T>): Vector_1<T>;
    static isNegative<T>(vector: Vector_1<T>): Vector_1<T>;
    static isNegativeInfinity<T>(vector: Vector_1<T>): Vector_1<T>;
    static isNormal<T>(vector: Vector_1<T>): Vector_1<T>;
    static isOddInteger<T>(vector: Vector_1<T>): Vector_1<T>;
    static isPositive<T>(vector: Vector_1<T>): Vector_1<T>;
    static isPositiveInfinity<T>(vector: Vector_1<T>): Vector_1<T>;
    static isSubnormal<T>(vector: Vector_1<T>): Vector_1<T>;
    static isZero<T>(vector: Vector_1<T>): Vector_1<T>;
    static lastIndexOf<T>(vector: Vector_1<T>, value: T): int;
    static lastIndexOfWhereAllBitsSet<T>(vector: Vector_1<T>): int;
    static lerp(x: Vector_1<CLROf<double>>, y: Vector_1<CLROf<double>>, amount: Vector_1<CLROf<double>>): Vector_1<CLROf<double>>;
    static lerp(x: Vector_1<CLROf<float>>, y: Vector_1<CLROf<float>>, amount: Vector_1<CLROf<float>>): Vector_1<CLROf<float>>;
    static lessThan(left: Vector_1<CLROf<double>>, right: Vector_1<CLROf<double>>): Vector_1<CLROf<long>>;
    static lessThan(left: Vector_1<CLROf<int>>, right: Vector_1<CLROf<int>>): Vector_1<CLROf<int>>;
    static lessThan(left: Vector_1<CLROf<long>>, right: Vector_1<CLROf<long>>): Vector_1<CLROf<long>>;
    static lessThan(left: Vector_1<CLROf<float>>, right: Vector_1<CLROf<float>>): Vector_1<CLROf<int>>;
    static lessThan<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static lessThanAll<T>(left: Vector_1<T>, right: Vector_1<T>): boolean;
    static lessThanAny<T>(left: Vector_1<T>, right: Vector_1<T>): boolean;
    static lessThanOrEqual(left: Vector_1<CLROf<double>>, right: Vector_1<CLROf<double>>): Vector_1<CLROf<long>>;
    static lessThanOrEqual(left: Vector_1<CLROf<int>>, right: Vector_1<CLROf<int>>): Vector_1<CLROf<int>>;
    static lessThanOrEqual(left: Vector_1<CLROf<long>>, right: Vector_1<CLROf<long>>): Vector_1<CLROf<long>>;
    static lessThanOrEqual(left: Vector_1<CLROf<float>>, right: Vector_1<CLROf<float>>): Vector_1<CLROf<int>>;
    static lessThanOrEqual<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static lessThanOrEqualAll<T>(left: Vector_1<T>, right: Vector_1<T>): boolean;
    static lessThanOrEqualAny<T>(left: Vector_1<T>, right: Vector_1<T>): boolean;
    static load<T>(source: ptr<T>): Vector_1<T>;
    static loadAligned<T>(source: ptr<T>): Vector_1<T>;
    static loadAlignedNonTemporal<T>(source: ptr<T>): Vector_1<T>;
    static loadUnsafe<T>(source: { value: ref<T> }, elementOffset: nuint): Vector_1<T>;
    static loadUnsafe<T>(source: { value: ref<T> }): Vector_1<T>;
    static log(vector: Vector_1<CLROf<double>>): Vector_1<CLROf<double>>;
    static log(vector: Vector_1<CLROf<float>>): Vector_1<CLROf<float>>;
    static log2(vector: Vector_1<CLROf<double>>): Vector_1<CLROf<double>>;
    static log2(vector: Vector_1<CLROf<float>>): Vector_1<CLROf<float>>;
    static max<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static maxMagnitude<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static maxMagnitudeNumber<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static maxNative<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static maxNumber<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static min<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static minMagnitude<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static minMagnitudeNumber<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static minNative<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static minNumber<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static multiply<T>(left: T, right: Vector_1<T>): Vector_1<T>;
    static multiply<T>(left: Vector_1<T>, right: T): Vector_1<T>;
    static multiply<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static multiplyAddEstimate(left: Vector_1<CLROf<double>>, right: Vector_1<CLROf<double>>, addend: Vector_1<CLROf<double>>): Vector_1<CLROf<double>>;
    static multiplyAddEstimate(left: Vector_1<CLROf<float>>, right: Vector_1<CLROf<float>>, addend: Vector_1<CLROf<float>>): Vector_1<CLROf<float>>;
    static narrow(low: Vector_1<CLROf<double>>, high: Vector_1<CLROf<double>>): Vector_1<CLROf<float>>;
    static narrow(low: Vector_1<CLROf<short>>, high: Vector_1<CLROf<short>>): Vector_1<CLROf<sbyte>>;
    static narrow(low: Vector_1<CLROf<int>>, high: Vector_1<CLROf<int>>): Vector_1<CLROf<short>>;
    static narrow(low: Vector_1<CLROf<long>>, high: Vector_1<CLROf<long>>): Vector_1<CLROf<int>>;
    static narrow(low: Vector_1<CLROf<ushort>>, high: Vector_1<CLROf<ushort>>): Vector_1<CLROf<byte>>;
    static narrow(low: Vector_1<CLROf<uint>>, high: Vector_1<CLROf<uint>>): Vector_1<CLROf<ushort>>;
    static narrow(low: Vector_1<CLROf<ulong>>, high: Vector_1<CLROf<ulong>>): Vector_1<CLROf<uint>>;
    static narrowWithSaturation(low: Vector_1<CLROf<double>>, high: Vector_1<CLROf<double>>): Vector_1<CLROf<float>>;
    static narrowWithSaturation(low: Vector_1<CLROf<short>>, high: Vector_1<CLROf<short>>): Vector_1<CLROf<sbyte>>;
    static narrowWithSaturation(low: Vector_1<CLROf<int>>, high: Vector_1<CLROf<int>>): Vector_1<CLROf<short>>;
    static narrowWithSaturation(low: Vector_1<CLROf<long>>, high: Vector_1<CLROf<long>>): Vector_1<CLROf<int>>;
    static narrowWithSaturation(low: Vector_1<CLROf<ushort>>, high: Vector_1<CLROf<ushort>>): Vector_1<CLROf<byte>>;
    static narrowWithSaturation(low: Vector_1<CLROf<uint>>, high: Vector_1<CLROf<uint>>): Vector_1<CLROf<ushort>>;
    static narrowWithSaturation(low: Vector_1<CLROf<ulong>>, high: Vector_1<CLROf<ulong>>): Vector_1<CLROf<uint>>;
    static negate<T>(value: Vector_1<T>): Vector_1<T>;
    static none<T>(vector: Vector_1<T>, value: T): boolean;
    static noneWhereAllBitsSet<T>(vector: Vector_1<T>): boolean;
    static onesComplement<T>(value: Vector_1<T>): Vector_1<T>;
    static radiansToDegrees(radians: Vector_1<CLROf<double>>): Vector_1<CLROf<double>>;
    static radiansToDegrees(radians: Vector_1<CLROf<float>>): Vector_1<CLROf<float>>;
    static round(vector: Vector_1<CLROf<double>>, mode: MidpointRounding): Vector_1<CLROf<double>>;
    static round(vector: Vector_1<CLROf<double>>): Vector_1<CLROf<double>>;
    static round(vector: Vector_1<CLROf<float>>, mode: MidpointRounding): Vector_1<CLROf<float>>;
    static round(vector: Vector_1<CLROf<float>>): Vector_1<CLROf<float>>;
    static shiftLeft(value: Vector_1<CLROf<byte>>, shiftCount: int): Vector_1<CLROf<byte>>;
    static shiftLeft(value: Vector_1<CLROf<short>>, shiftCount: int): Vector_1<CLROf<short>>;
    static shiftLeft(value: Vector_1<CLROf<int>>, shiftCount: int): Vector_1<CLROf<int>>;
    static shiftLeft(value: Vector_1<CLROf<long>>, shiftCount: int): Vector_1<CLROf<long>>;
    static shiftLeft(value: Vector_1<CLROf<nint>>, shiftCount: int): Vector_1<CLROf<nint>>;
    static shiftLeft(value: Vector_1<CLROf<sbyte>>, shiftCount: int): Vector_1<CLROf<sbyte>>;
    static shiftLeft(value: Vector_1<CLROf<ushort>>, shiftCount: int): Vector_1<CLROf<ushort>>;
    static shiftLeft(value: Vector_1<CLROf<uint>>, shiftCount: int): Vector_1<CLROf<uint>>;
    static shiftLeft(value: Vector_1<CLROf<ulong>>, shiftCount: int): Vector_1<CLROf<ulong>>;
    static shiftLeft(value: Vector_1<CLROf<nuint>>, shiftCount: int): Vector_1<CLROf<nuint>>;
    static shiftRightArithmetic(value: Vector_1<CLROf<short>>, shiftCount: int): Vector_1<CLROf<short>>;
    static shiftRightArithmetic(value: Vector_1<CLROf<int>>, shiftCount: int): Vector_1<CLROf<int>>;
    static shiftRightArithmetic(value: Vector_1<CLROf<long>>, shiftCount: int): Vector_1<CLROf<long>>;
    static shiftRightArithmetic(value: Vector_1<CLROf<nint>>, shiftCount: int): Vector_1<CLROf<nint>>;
    static shiftRightArithmetic(value: Vector_1<CLROf<sbyte>>, shiftCount: int): Vector_1<CLROf<sbyte>>;
    static shiftRightLogical(value: Vector_1<CLROf<byte>>, shiftCount: int): Vector_1<CLROf<byte>>;
    static shiftRightLogical(value: Vector_1<CLROf<short>>, shiftCount: int): Vector_1<CLROf<short>>;
    static shiftRightLogical(value: Vector_1<CLROf<int>>, shiftCount: int): Vector_1<CLROf<int>>;
    static shiftRightLogical(value: Vector_1<CLROf<long>>, shiftCount: int): Vector_1<CLROf<long>>;
    static shiftRightLogical(value: Vector_1<CLROf<nint>>, shiftCount: int): Vector_1<CLROf<nint>>;
    static shiftRightLogical(value: Vector_1<CLROf<sbyte>>, shiftCount: int): Vector_1<CLROf<sbyte>>;
    static shiftRightLogical(value: Vector_1<CLROf<ushort>>, shiftCount: int): Vector_1<CLROf<ushort>>;
    static shiftRightLogical(value: Vector_1<CLROf<uint>>, shiftCount: int): Vector_1<CLROf<uint>>;
    static shiftRightLogical(value: Vector_1<CLROf<ulong>>, shiftCount: int): Vector_1<CLROf<ulong>>;
    static shiftRightLogical(value: Vector_1<CLROf<nuint>>, shiftCount: int): Vector_1<CLROf<nuint>>;
    static sin(vector: Vector_1<CLROf<double>>): Vector_1<CLROf<double>>;
    static sin(vector: Vector_1<CLROf<float>>): Vector_1<CLROf<float>>;
    static sinCos(vector: Vector_1<CLROf<double>>): ValueTuple_2<Vector_1<CLROf<double>>, Vector_1<CLROf<double>>>;
    static sinCos(vector: Vector_1<CLROf<float>>): ValueTuple_2<Vector_1<CLROf<float>>, Vector_1<CLROf<float>>>;
    static squareRoot<T>(value: Vector_1<T>): Vector_1<T>;
    static store(source: Vector2, destination: ptr<float>): void;
    static store(source: Vector3, destination: ptr<float>): void;
    static store(source: Vector4, destination: ptr<float>): void;
    static store<T>(source: Vector_1<T>, destination: ptr<T>): void;
    static storeAligned(source: Vector2, destination: ptr<float>): void;
    static storeAligned(source: Vector3, destination: ptr<float>): void;
    static storeAligned(source: Vector4, destination: ptr<float>): void;
    static storeAligned<T>(source: Vector_1<T>, destination: ptr<T>): void;
    static storeAlignedNonTemporal(source: Vector2, destination: ptr<float>): void;
    static storeAlignedNonTemporal(source: Vector3, destination: ptr<float>): void;
    static storeAlignedNonTemporal(source: Vector4, destination: ptr<float>): void;
    static storeAlignedNonTemporal<T>(source: Vector_1<T>, destination: ptr<T>): void;
    static storeUnsafe(source: Vector2, destination: { value: ref<float> }, elementOffset: nuint): void;
    static storeUnsafe(source: Vector2, destination: { value: ref<float> }): void;
    static storeUnsafe(source: Vector3, destination: { value: ref<float> }, elementOffset: nuint): void;
    static storeUnsafe(source: Vector3, destination: { value: ref<float> }): void;
    static storeUnsafe(source: Vector4, destination: { value: ref<float> }, elementOffset: nuint): void;
    static storeUnsafe(source: Vector4, destination: { value: ref<float> }): void;
    static storeUnsafe<T>(source: Vector_1<T>, destination: { value: ref<T> }, elementOffset: nuint): void;
    static storeUnsafe<T>(source: Vector_1<T>, destination: { value: ref<T> }): void;
    static subtract<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static subtractSaturate<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static sum<T>(value: Vector_1<T>): T;
    static toScalar(vector: Vector2): float;
    static toScalar(vector: Vector3): float;
    static toScalar(vector: Vector4): float;
    static toScalar<T>(vector: Vector_1<T>): T;
    static truncate(vector: Vector_1<CLROf<double>>): Vector_1<CLROf<double>>;
    static truncate(vector: Vector_1<CLROf<float>>): Vector_1<CLROf<float>>;
    static widen(source: Vector_1<CLROf<byte>>, low: { value: ref<Vector_1<CLROf<ushort>>> }, high: { value: ref<Vector_1<CLROf<ushort>>> }): void;
    static widen(source: Vector_1<CLROf<short>>, low: { value: ref<Vector_1<CLROf<int>>> }, high: { value: ref<Vector_1<CLROf<int>>> }): void;
    static widen(source: Vector_1<CLROf<int>>, low: { value: ref<Vector_1<CLROf<long>>> }, high: { value: ref<Vector_1<CLROf<long>>> }): void;
    static widen(source: Vector_1<CLROf<sbyte>>, low: { value: ref<Vector_1<CLROf<short>>> }, high: { value: ref<Vector_1<CLROf<short>>> }): void;
    static widen(source: Vector_1<CLROf<float>>, low: { value: ref<Vector_1<CLROf<double>>> }, high: { value: ref<Vector_1<CLROf<double>>> }): void;
    static widen(source: Vector_1<CLROf<ushort>>, low: { value: ref<Vector_1<CLROf<uint>>> }, high: { value: ref<Vector_1<CLROf<uint>>> }): void;
    static widen(source: Vector_1<CLROf<uint>>, low: { value: ref<Vector_1<CLROf<ulong>>> }, high: { value: ref<Vector_1<CLROf<ulong>>> }): void;
    static widenLower(source: Vector_1<CLROf<byte>>): Vector_1<CLROf<ushort>>;
    static widenLower(source: Vector_1<CLROf<short>>): Vector_1<CLROf<int>>;
    static widenLower(source: Vector_1<CLROf<int>>): Vector_1<CLROf<long>>;
    static widenLower(source: Vector_1<CLROf<sbyte>>): Vector_1<CLROf<short>>;
    static widenLower(source: Vector_1<CLROf<float>>): Vector_1<CLROf<double>>;
    static widenLower(source: Vector_1<CLROf<ushort>>): Vector_1<CLROf<uint>>;
    static widenLower(source: Vector_1<CLROf<uint>>): Vector_1<CLROf<ulong>>;
    static widenUpper(source: Vector_1<CLROf<byte>>): Vector_1<CLROf<ushort>>;
    static widenUpper(source: Vector_1<CLROf<short>>): Vector_1<CLROf<int>>;
    static widenUpper(source: Vector_1<CLROf<int>>): Vector_1<CLROf<long>>;
    static widenUpper(source: Vector_1<CLROf<sbyte>>): Vector_1<CLROf<short>>;
    static widenUpper(source: Vector_1<CLROf<float>>): Vector_1<CLROf<double>>;
    static widenUpper(source: Vector_1<CLROf<ushort>>): Vector_1<CLROf<uint>>;
    static widenUpper(source: Vector_1<CLROf<uint>>): Vector_1<CLROf<ulong>>;
    static withElement(vector: Vector2, index: int, value: float): Vector2;
    static withElement(vector: Vector3, index: int, value: float): Vector3;
    static withElement(vector: Vector4, index: int, value: float): Vector4;
    static withElement<T>(vector: Vector_1<T>, index: int, value: T): Vector_1<T>;
    static xor<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
}


export type Vector = Vector$instance;

