// Generated by tsbindgen - Architecture
// Namespace: System.Xml.Xsl.Runtime
// Assembly: System.Private.Xml

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IComparer_1, IEnumerable_1, IEnumerator_1, IList_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import type { Task, ValueTask } from "../../System.Threading.Tasks/internal/index.js";
import type { XmlAtomicValue, XmlTypeCode } from "../../System.Xml.Schema/internal/index.js";
import * as System_Xml_XPath_Internal from "../../System.Xml.XPath/internal/index.js";
import type { XPathItem, XPathNavigator, XPathNodeType } from "../../System.Xml.XPath/internal/index.js";
import * as System_Xml_Internal from "../../System.Xml/internal/index.js";
import type { WriteState, XmlNameTable, XmlQualifiedName, XmlReader, XmlSpace, XmlWriter, XmlWriterSettings } from "../../System.Xml/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Boolean as ClrBoolean, Byte, Char, DateTime, DateTimeOffset, Decimal, Double, Enum, IAsyncDisposable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, Int64, ISpanFormattable, Object as ClrObject, Single, String as ClrString, TimeSpan, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum IteratorResult {
    noMoreNodes = 0,
    needInputNode = 1,
    haveCurrentNode = 2
}


export enum SetIteratorResult {
    noMoreNodes = 0,
    initRightIterator = 1,
    needLeftNode = 2,
    needRightNode = 3,
    haveCurrentNode = 4
}


export interface AncestorDocOrderIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator, filter: XmlNavigatorFilter, orSelf: boolean): void;
    moveNext(): boolean;
}


export const AncestorDocOrderIterator: {
    new(): AncestorDocOrderIterator$instance;
};


export type AncestorDocOrderIterator = AncestorDocOrderIterator$instance;

export interface AncestorIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator, filter: XmlNavigatorFilter, orSelf: boolean): void;
    moveNext(): boolean;
}


export const AncestorIterator: {
    new(): AncestorIterator$instance;
};


export type AncestorIterator = AncestorIterator$instance;

export interface AttributeContentIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator): void;
    moveNext(): boolean;
}


export const AttributeContentIterator: {
    new(): AttributeContentIterator$instance;
};


export type AttributeContentIterator = AttributeContentIterator$instance;

export interface AttributeIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator): void;
    moveNext(): boolean;
}


export const AttributeIterator: {
    new(): AttributeIterator$instance;
};


export type AttributeIterator = AttributeIterator$instance;

export interface ContentIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator): void;
    moveNext(): boolean;
}


export const ContentIterator: {
    new(): ContentIterator$instance;
};


export type ContentIterator = ContentIterator$instance;

export interface ContentMergeIterator$instance {
    readonly current: XPathNavigator;
    create(filter: XmlNavigatorFilter): void;
    moveNext(input: XPathNavigator): IteratorResult;
}


export const ContentMergeIterator: {
    new(): ContentMergeIterator$instance;
};


export type ContentMergeIterator = ContentMergeIterator$instance;

export interface DecimalAggregator$instance {
    readonly averageResult: decimal;
    readonly isEmpty: boolean;
    readonly maximumResult: decimal;
    readonly minimumResult: decimal;
    readonly sumResult: decimal;
    average(value: decimal): void;
    create(): void;
    maximum(value: decimal): void;
    minimum(value: decimal): void;
    sum(value: decimal): void;
}


export const DecimalAggregator: {
    new(): DecimalAggregator$instance;
};


export type DecimalAggregator = DecimalAggregator$instance;

export interface DescendantIterator$instance {
    readonly current: XPathNavigator;
    create(input: XPathNavigator, filter: XmlNavigatorFilter, orSelf: boolean): void;
    moveNext(): boolean;
}


export const DescendantIterator: {
    new(): DescendantIterator$instance;
};


export type DescendantIterator = DescendantIterator$instance;

export interface DescendantMergeIterator$instance {
    readonly current: XPathNavigator;
    create(filter: XmlNavigatorFilter, orSelf: boolean): void;
    moveNext(input: XPathNavigator): IteratorResult;
}


export const DescendantMergeIterator: {
    new(): DescendantMergeIterator$instance;
};


export type DescendantMergeIterator = DescendantMergeIterator$instance;

export interface DifferenceIterator$instance {
    readonly current: XPathNavigator;
    create(runtime: XmlQueryRuntime): void;
    moveNext(nestedNavigator: XPathNavigator): SetIteratorResult;
}


export const DifferenceIterator: {
    new(): DifferenceIterator$instance;
};


export type DifferenceIterator = DifferenceIterator$instance;

export interface DodSequenceMerge$instance {
    addSequence(sequence: IList_1<XPathNavigator>): void;
    create(runtime: XmlQueryRuntime): void;
    mergeSequences(): IList_1<XPathNavigator>;
}


export const DodSequenceMerge: {
    new(): DodSequenceMerge$instance;
};


export type DodSequenceMerge = DodSequenceMerge$instance;

export interface DoubleAggregator$instance {
    readonly averageResult: double;
    readonly isEmpty: boolean;
    readonly maximumResult: double;
    readonly minimumResult: double;
    readonly sumResult: double;
    average(value: double): void;
    create(): void;
    maximum(value: double): void;
    minimum(value: double): void;
    sum(value: double): void;
}


export const DoubleAggregator: {
    new(): DoubleAggregator$instance;
};


export type DoubleAggregator = DoubleAggregator$instance;

export interface ElementContentIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator, localName: string, ns: string): void;
    moveNext(): boolean;
}


export const ElementContentIterator: {
    new(): ElementContentIterator$instance;
};


export type ElementContentIterator = ElementContentIterator$instance;

export interface FollowingSiblingIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator, filter: XmlNavigatorFilter): void;
    moveNext(): boolean;
}


export const FollowingSiblingIterator: {
    new(): FollowingSiblingIterator$instance;
};


export type FollowingSiblingIterator = FollowingSiblingIterator$instance;

export interface FollowingSiblingMergeIterator$instance {
    readonly current: XPathNavigator;
    create(filter: XmlNavigatorFilter): void;
    moveNext(navigator: XPathNavigator): IteratorResult;
}


export const FollowingSiblingMergeIterator: {
    new(): FollowingSiblingMergeIterator$instance;
};


export type FollowingSiblingMergeIterator = FollowingSiblingMergeIterator$instance;

export interface IdIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator, value: string): void;
    moveNext(): boolean;
}


export const IdIterator: {
    new(): IdIterator$instance;
};


export type IdIterator = IdIterator$instance;

export interface Int32Aggregator$instance {
    readonly averageResult: int;
    readonly isEmpty: boolean;
    readonly maximumResult: int;
    readonly minimumResult: int;
    readonly sumResult: int;
    average(value: int): void;
    create(): void;
    maximum(value: int): void;
    minimum(value: int): void;
    sum(value: int): void;
}


export const Int32Aggregator: {
    new(): Int32Aggregator$instance;
};


export type Int32Aggregator = Int32Aggregator$instance;

export interface Int64Aggregator$instance {
    readonly averageResult: long;
    readonly isEmpty: boolean;
    readonly maximumResult: long;
    readonly minimumResult: long;
    readonly sumResult: long;
    average(value: long): void;
    create(): void;
    maximum(value: long): void;
    minimum(value: long): void;
    sum(value: long): void;
}


export const Int64Aggregator: {
    new(): Int64Aggregator$instance;
};


export type Int64Aggregator = Int64Aggregator$instance;

export interface IntersectIterator$instance {
    readonly current: XPathNavigator;
    create(runtime: XmlQueryRuntime): void;
    moveNext(nestedNavigator: XPathNavigator): SetIteratorResult;
}


export const IntersectIterator: {
    new(): IntersectIterator$instance;
};


export type IntersectIterator = IntersectIterator$instance;

export interface NamespaceIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator): void;
    moveNext(): boolean;
}


export const NamespaceIterator: {
    new(): NamespaceIterator$instance;
};


export type NamespaceIterator = NamespaceIterator$instance;

export interface NodeKindContentIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator, nodeType: XPathNodeType): void;
    moveNext(): boolean;
}


export const NodeKindContentIterator: {
    new(): NodeKindContentIterator$instance;
};


export type NodeKindContentIterator = NodeKindContentIterator$instance;

export interface NodeRangeIterator$instance {
    readonly current: XPathNavigator;
    create(start: XPathNavigator, filter: XmlNavigatorFilter, end: XPathNavigator): void;
    moveNext(): boolean;
}


export const NodeRangeIterator: {
    new(): NodeRangeIterator$instance;
};


export type NodeRangeIterator = NodeRangeIterator$instance;

export interface ParentIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator, filter: XmlNavigatorFilter): void;
    moveNext(): boolean;
}


export const ParentIterator: {
    new(): ParentIterator$instance;
};


export type ParentIterator = ParentIterator$instance;

export interface PrecedingIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator, filter: XmlNavigatorFilter): void;
    moveNext(): boolean;
}


export const PrecedingIterator: {
    new(): PrecedingIterator$instance;
};


export type PrecedingIterator = PrecedingIterator$instance;

export interface PrecedingSiblingDocOrderIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator, filter: XmlNavigatorFilter): void;
    moveNext(): boolean;
}


export const PrecedingSiblingDocOrderIterator: {
    new(): PrecedingSiblingDocOrderIterator$instance;
};


export type PrecedingSiblingDocOrderIterator = PrecedingSiblingDocOrderIterator$instance;

export interface PrecedingSiblingIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator, filter: XmlNavigatorFilter): void;
    moveNext(): boolean;
}


export const PrecedingSiblingIterator: {
    new(): PrecedingSiblingIterator$instance;
};


export type PrecedingSiblingIterator = PrecedingSiblingIterator$instance;

export interface StringConcat$instance {
    delimiter: string;
    clear(): void;
    concat(value: string): void;
    getResult(): string;
}


export const StringConcat: {
    new(): StringConcat$instance;
};


export type StringConcat = StringConcat$instance;

export interface UnionIterator$instance {
    readonly current: XPathNavigator;
    create(runtime: XmlQueryRuntime): void;
    moveNext(nestedNavigator: XPathNavigator): SetIteratorResult;
}


export const UnionIterator: {
    new(): UnionIterator$instance;
};


export type UnionIterator = UnionIterator$instance;

export interface XmlSortKeyAccumulator$instance {
    readonly keys: ClrArray;
    addDateTimeSortKey(collation: XmlCollation, value: DateTime): void;
    addDecimalSortKey(collation: XmlCollation, value: decimal): void;
    addDoubleSortKey(collation: XmlCollation, value: double): void;
    addEmptySortKey(collation: XmlCollation): void;
    addIntegerSortKey(collation: XmlCollation, value: long): void;
    addIntSortKey(collation: XmlCollation, value: int): void;
    addStringSortKey(collation: XmlCollation, value: string): void;
    create(): void;
    finishSortKeys(): void;
}


export const XmlSortKeyAccumulator: {
    new(): XmlSortKeyAccumulator$instance;
};


export type XmlSortKeyAccumulator = XmlSortKeyAccumulator$instance;

export interface XPathFollowingIterator$instance {
    readonly current: XPathNavigator;
    create(input: XPathNavigator, filter: XmlNavigatorFilter): void;
    moveNext(): boolean;
}


export const XPathFollowingIterator: {
    new(): XPathFollowingIterator$instance;
};


export type XPathFollowingIterator = XPathFollowingIterator$instance;

export interface XPathFollowingMergeIterator$instance {
    readonly current: XPathNavigator;
    create(filter: XmlNavigatorFilter): void;
    moveNext(input: XPathNavigator): IteratorResult;
}


export const XPathFollowingMergeIterator: {
    new(): XPathFollowingMergeIterator$instance;
};


export type XPathFollowingMergeIterator = XPathFollowingMergeIterator$instance;

export interface XPathPrecedingDocOrderIterator$instance {
    readonly current: XPathNavigator;
    create(input: XPathNavigator, filter: XmlNavigatorFilter): void;
    moveNext(): boolean;
}


export const XPathPrecedingDocOrderIterator: {
    new(): XPathPrecedingDocOrderIterator$instance;
};


export type XPathPrecedingDocOrderIterator = XPathPrecedingDocOrderIterator$instance;

export interface XPathPrecedingIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator, filter: XmlNavigatorFilter): void;
    moveNext(): boolean;
}


export const XPathPrecedingIterator: {
    new(): XPathPrecedingIterator$instance;
};


export type XPathPrecedingIterator = XPathPrecedingIterator$instance;

export interface XPathPrecedingMergeIterator$instance {
    readonly current: XPathNavigator;
    create(filter: XmlNavigatorFilter): void;
    moveNext(input: XPathNavigator): IteratorResult;
}


export const XPathPrecedingMergeIterator: {
    new(): XPathPrecedingMergeIterator$instance;
};


export type XPathPrecedingMergeIterator = XPathPrecedingMergeIterator$instance;

export interface XmlCollation$instance {
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const XmlCollation: {
    new(): XmlCollation$instance;
};


export type XmlCollation = XmlCollation$instance;

export interface XmlILIndex$instance {
    add(key: string, navigator: XPathNavigator): void;
    lookup(key: string): XmlQueryNodeSequence;
}


export const XmlILIndex: {
    new(): XmlILIndex$instance;
};


export type XmlILIndex = XmlILIndex$instance;

export interface XmlNavigatorFilter$instance {
    isFiltered(navigator: XPathNavigator): boolean;
    moveToContent(navigator: XPathNavigator): boolean;
    moveToFollowing(navigator: XPathNavigator, navigatorEnd: XPathNavigator): boolean;
    moveToFollowingSibling(navigator: XPathNavigator): boolean;
    moveToNextContent(navigator: XPathNavigator): boolean;
    moveToPreviousSibling(navigator: XPathNavigator): boolean;
}


export const XmlNavigatorFilter: {
};


export type XmlNavigatorFilter = XmlNavigatorFilter$instance;

export interface XmlQueryContext$instance {
    readonly defaultDataSource: XPathNavigator;
    readonly defaultNameTable: XmlNameTable;
    readonly queryNameTable: XmlNameTable;
    getDataSource(uriRelative: string, uriBase: string): XPathNavigator;
    getLateBoundObject(namespaceUri: string): unknown;
    getParameter(localName: string, namespaceUri: string): unknown;
    invokeXsltLateBoundFunction(name: string, namespaceUri: string, args: IList_1<XPathItem>[]): IList_1<XPathItem>;
    lateBoundFunctionExists(name: string, namespaceUri: string): boolean;
    onXsltMessageEncountered(message: string): void;
}


export const XmlQueryContext: {
    new(): XmlQueryContext$instance;
};


export type XmlQueryContext = XmlQueryContext$instance;

export interface XmlQueryItemSequence$instance extends XmlQuerySequence_1$instance<XPathItem> {
    add(value: XPathItem): void;
    add(value: unknown): int;
    addClone(item: XPathItem): void;
    clear(): void;
    contains(value: XPathItem): boolean;
    contains(value: unknown): boolean;
    copyTo(array: XPathItem[], index: int): void;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator_1<XPathItem>;
    getEnumerator(): IEnumerator;
    indexOf(value: XPathItem): int;
    insert(index: int, item: XPathItem): void;
    insert(index: int, value: unknown): void;
    remove(item: XPathItem): boolean;
    remove(value: unknown): void;
    removeAt(index: int): void;
}


export const XmlQueryItemSequence: {
    new(): XmlQueryItemSequence$instance;
    new(capacity: int): XmlQueryItemSequence$instance;
    new(item: XPathItem): XmlQueryItemSequence$instance;
};


export interface __XmlQueryItemSequence$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<XPathItem>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<XPathItem>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<XPathItem>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type XmlQueryItemSequence = XmlQueryItemSequence$instance & __XmlQueryItemSequence$views;


export interface XmlQueryNodeSequence$instance extends XmlQuerySequence_1$instance<XPathNavigator> {
    isDocOrderDistinct: boolean;
    add(value: XPathNavigator): void;
    add(value: unknown): int;
    addClone(navigator: XPathNavigator): void;
    clear(): void;
    contains(value: XPathNavigator): boolean;
    contains(value: unknown): boolean;
    copyTo(array: XPathNavigator[], index: int): void;
    copyTo(array: ClrArray, index: int): void;
    docOrderDistinct(comparer: IComparer_1<XPathNavigator>): XmlQueryNodeSequence;
    getEnumerator(): IEnumerator_1<XPathNavigator>;
    getEnumerator(): IEnumerator;
    indexOf(value: XPathNavigator): int;
    insert(index: int, item: XPathNavigator): void;
    insert(index: int, value: unknown): void;
    remove(item: XPathNavigator): boolean;
    remove(value: unknown): void;
    removeAt(index: int): void;
}


export const XmlQueryNodeSequence: {
    new(): XmlQueryNodeSequence$instance;
    new(capacity: int): XmlQueryNodeSequence$instance;
    new(list: IList_1<XPathNavigator>): XmlQueryNodeSequence$instance;
    new(array: XPathNavigator[], size: int): XmlQueryNodeSequence$instance;
    new(navigator: XPathNavigator): XmlQueryNodeSequence$instance;
};


export interface __XmlQueryNodeSequence$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<XPathNavigator>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<XPathNavigator>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<XPathNavigator>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type XmlQueryNodeSequence = XmlQueryNodeSequence$instance & __XmlQueryNodeSequence$views;


export interface XmlQueryOutput$instance extends XmlWriter {
    readonly writeState: WriteState;
    readonly xmlLang: string;
    readonly xmlSpace: XmlSpace;
    close(): void;
    dispose(): void;
    disposeAsync(): ValueTask;
    endCopy(navigator: XPathNavigator): void;
    endTree(): void;
    flush(): void;
    lookupPrefix(ns: string): string;
    startCopy(navigator: XPathNavigator): boolean;
    startElementContentUnchecked(): void;
    startTree(rootType: XPathNodeType): void;
    writeBase64(buffer: byte[], index: int, count: int): void;
    writeCData(text: string): void;
    writeCharEntity(ch: char): void;
    writeChars(buffer: char[], index: int, count: int): void;
    writeComment(text: string): void;
    writeCommentString(text: string): void;
    writeDocType(name: string, pubid: string, sysid: string, subset: string): void;
    writeEndAttribute(): void;
    writeEndAttributeUnchecked(): void;
    writeEndComment(): void;
    writeEndDocument(): void;
    writeEndElement(): void;
    writeEndElementUnchecked(prefix: string, localName: string, ns: string): void;
    writeEndElementUnchecked(localName: string): void;
    writeEndNamespace(): void;
    writeEndProcessingInstruction(): void;
    writeEndRoot(): void;
    writeEntityRef(name: string): void;
    writeFullEndElement(): void;
    writeItem(item: XPathItem): void;
    writeNamespaceDeclaration(prefix: string, ns: string): void;
    writeNamespaceDeclarationUnchecked(prefix: string, ns: string): void;
    writeNamespaceString(text: string): void;
    writeProcessingInstruction(target: string, text: string): void;
    writeProcessingInstructionString(text: string): void;
    writeRaw(buffer: char[], index: int, count: int): void;
    writeRaw(data: string): void;
    writeRawUnchecked(text: string): void;
    writeStartAttribute(prefix: string, localName: string, ns: string): void;
    writeStartAttribute(localName: string, ns: string): void;
    writeStartAttribute(localName: string): void;
    writeStartAttributeComputed(tagName: string, prefixMappingsIndex: int): void;
    writeStartAttributeComputed(tagName: string, ns: string): void;
    writeStartAttributeComputed(navigator: XPathNavigator): void;
    writeStartAttributeComputed(name: XmlQualifiedName): void;
    writeStartAttributeLocalName(localName: string): void;
    writeStartAttributeUnchecked(prefix: string, localName: string, ns: string): void;
    writeStartAttributeUnchecked(localName: string): void;
    writeStartComment(): void;
    writeStartDocument(): void;
    writeStartDocument(standalone: boolean): void;
    writeStartElement(prefix: string, localName: string, ns: string): void;
    writeStartElement(localName: string, ns: string): void;
    writeStartElement(localName: string): void;
    writeStartElementComputed(tagName: string, prefixMappingsIndex: int): void;
    writeStartElementComputed(tagName: string, ns: string): void;
    writeStartElementComputed(navigator: XPathNavigator): void;
    writeStartElementComputed(name: XmlQualifiedName): void;
    writeStartElementLocalName(localName: string): void;
    writeStartElementUnchecked(prefix: string, localName: string, ns: string): void;
    writeStartElementUnchecked(localName: string): void;
    writeStartNamespace(prefix: string): void;
    writeStartProcessingInstruction(target: string): void;
    writeStartRoot(): void;
    writeString(text: string): void;
    writeStringUnchecked(text: string): void;
    writeSurrogateCharEntity(lowChar: char, highChar: char): void;
    writeWhitespace(ws: string): void;
    xsltCopyOf(navigator: XPathNavigator): void;
}


export const XmlQueryOutput: {
    new(): XmlQueryOutput$instance;
};


export interface __XmlQueryOutput$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type XmlQueryOutput = XmlQueryOutput$instance & __XmlQueryOutput$views;


export interface XmlQueryRuntime$instance {
    readonly externalContext: XmlQueryContext;
    readonly nameTable: XmlNameTable;
    readonly output: XmlQueryOutput;
    readonly xsltFunctions: XsltLibrary;
    addNewIndex(context: XPathNavigator, indexId: int, index: XmlILIndex): void;
    changeTypeXsltArgument(indexType: int, value: unknown, destinationType: Type): unknown;
    changeTypeXsltResult(indexType: int, value: unknown): unknown;
    comparePosition(navigatorThis: XPathNavigator, navigatorThat: XPathNavigator): int;
    createCollation(collation: string): XmlCollation;
    debugGetGlobalNames(): string[];
    debugGetGlobalValue(name: string): IList;
    debugGetXsltValue(seq: IList): unknown;
    debugSetGlobalValue(name: string, value: unknown): void;
    docOrderDistinct(seq: IList_1<XPathNavigator>): IList_1<XPathNavigator>;
    earlyBoundFunctionExists(name: string, namespaceUri: string): boolean;
    endRtfConstruction(output: { value: ref<XmlQueryOutput> }): XPathNavigator;
    endSequenceConstruction(output: { value: ref<XmlQueryOutput> }): IList_1<XPathItem>;
    findIndex(context: XPathNavigator, indexId: int, index: { value: ref<XmlILIndex> }): boolean;
    generateId(navigator: XPathNavigator): string;
    getAtomizedName(index: int): string;
    getCollation(index: int): XmlCollation;
    getEarlyBoundObject(index: int): unknown;
    getGlobalValue(index: int): unknown;
    getNameFilter(index: int): XmlNavigatorFilter;
    getTypeFilter(nodeType: XPathNodeType): XmlNavigatorFilter;
    isGlobalComputed(index: int): boolean;
    isQNameEqual(n1: XPathNavigator, n2: XPathNavigator): boolean;
    isQNameEqual(navigator: XPathNavigator, indexLocalName: int, indexNamespaceUri: int): boolean;
    matchesXmlType(seq: IList_1<XPathItem>, indexType: int): boolean;
    matchesXmlType(item: XPathItem, indexType: int): boolean;
    matchesXmlType(seq: IList_1<XPathItem>, code: XmlTypeCode): boolean;
    matchesXmlType(item: XPathItem, code: XmlTypeCode): boolean;
    parseTagName(tagName: string, indexPrefixMappings: int): XmlQualifiedName;
    parseTagName(tagName: string, ns: string): XmlQualifiedName;
    sendMessage(message: string): void;
    setGlobalValue(index: int, value: unknown): void;
    startRtfConstruction(baseUri: string, output: { value: ref<XmlQueryOutput> }): void;
    startSequenceConstruction(output: { value: ref<XmlQueryOutput> }): void;
    textRtfConstruction(text: string, baseUri: string): XPathNavigator;
    throwException(text: string): void;
}


export const XmlQueryRuntime: {
    new(): XmlQueryRuntime$instance;
    onCurrentNodeChanged(currentNode: XPathNavigator): int;
};


export type XmlQueryRuntime = XmlQueryRuntime$instance;

export interface XmlQuerySequence_1$instance<T> {
    readonly count: int;
    item: T;
    add(value: T): void;
    clear(): void;
    contains(value: T): boolean;
    copyTo(array: T[], index: int): void;
    getEnumerator(): IEnumerator_1<T>;
    indexOf(value: T): int;
    sortByKeys(keys: ClrArray): void;
}


export const XmlQuerySequence_1: {
    new<T>(): XmlQuerySequence_1$instance<T>;
    new<T>(capacity: int): XmlQuerySequence_1$instance<T>;
    new<T>(array: T[], size: int): XmlQuerySequence_1$instance<T>;
    new<T>(value: T): XmlQuerySequence_1$instance<T>;
    readonly empty: unknown;
    createOrReuse<T>(seq: XmlQuerySequence_1<T>, item: T): XmlQuerySequence_1<T>;
    createOrReuse<T>(seq: XmlQuerySequence_1<T>): XmlQuerySequence_1<T>;
};


export interface __XmlQuerySequence_1$views<T> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type XmlQuerySequence_1<T> = XmlQuerySequence_1$instance<T> & __XmlQuerySequence_1$views<T>;


export interface XsltLibrary$instance {
    checkScriptNamespace(nsUri: string): int;
    elementAvailable(name: XmlQualifiedName): boolean;
    equalityOperator(opCode: double, left: IList_1<XPathItem>, right: IList_1<XPathItem>): boolean;
    formatMessage(res: string, args: IList_1<CLROf<string>>): string;
    formatNumberDynamic(value: double, formatPicture: string, decimalFormatName: XmlQualifiedName, errorMessageName: string): string;
    formatNumberStatic(value: double, decimalFormatterIndex: double): string;
    functionAvailable(name: XmlQualifiedName): boolean;
    isSameNodeSort(nav1: XPathNavigator, nav2: XPathNavigator): boolean;
    langToLcid(lang: string, forwardCompatibility: boolean): int;
    numberFormat(value: IList_1<XPathItem>, formatString: string, lang: double, letterValue: string, groupingSeparator: string, groupingSize: double): string;
    registerDecimalFormat(name: XmlQualifiedName, infinitySymbol: string, nanSymbol: string, characters: string): int;
    registerDecimalFormatter(formatPicture: string, infinitySymbol: string, nanSymbol: string, characters: string): double;
    relationalOperator(opCode: double, left: IList_1<XPathItem>, right: IList_1<XPathItem>): boolean;
}


export const XsltLibrary: {
    new(): XsltLibrary$instance;
};


export type XsltLibrary = XsltLibrary$instance;

export abstract class XmlILStorageConverter$instance {
    static booleanToAtomicValue(value: boolean, index: int, runtime: XmlQueryRuntime): XmlAtomicValue;
    static bytesToAtomicValue(value: byte[], index: int, runtime: XmlQueryRuntime): XmlAtomicValue;
    static dateTimeToAtomicValue(value: DateTime, index: int, runtime: XmlQueryRuntime): XmlAtomicValue;
    static decimalToAtomicValue(value: decimal, index: int, runtime: XmlQueryRuntime): XmlAtomicValue;
    static doubleToAtomicValue(value: double, index: int, runtime: XmlQueryRuntime): XmlAtomicValue;
    static int32ToAtomicValue(value: int, index: int, runtime: XmlQueryRuntime): XmlAtomicValue;
    static int64ToAtomicValue(value: long, index: int, runtime: XmlQueryRuntime): XmlAtomicValue;
    static itemsToNavigators(listItems: IList_1<XPathItem>): IList_1<XPathNavigator>;
    static navigatorsToItems(listNavigators: IList_1<XPathNavigator>): IList_1<XPathItem>;
    static singleToAtomicValue(value: float, index: int, runtime: XmlQueryRuntime): XmlAtomicValue;
    static stringToAtomicValue(value: string, index: int, runtime: XmlQueryRuntime): XmlAtomicValue;
    static timeSpanToAtomicValue(value: TimeSpan, index: int, runtime: XmlQueryRuntime): XmlAtomicValue;
    static xmlQualifiedNameToAtomicValue(value: XmlQualifiedName, index: int, runtime: XmlQueryRuntime): XmlAtomicValue;
}


export type XmlILStorageConverter = XmlILStorageConverter$instance;

export abstract class XsltConvert$instance {
    static ensureNodeSet(listItems: IList_1<XPathItem>): IList_1<XPathNavigator>;
    static toBoolean(listItems: IList_1<XPathItem>): boolean;
    static toBoolean(item: XPathItem): boolean;
    static toDateTime(value: string): DateTime;
    static toDecimal(value: double): decimal;
    static toDouble(listItems: IList_1<XPathItem>): double;
    static toDouble(value: decimal): double;
    static toDouble(value: int): double;
    static toDouble(value: long): double;
    static toDouble(value: string): double;
    static toDouble(item: XPathItem): double;
    static toInt(value: double): int;
    static toLong(value: double): long;
    static toNode(listItems: IList_1<XPathItem>): XPathNavigator;
    static toNode(item: XPathItem): XPathNavigator;
    static toNodeSet(listItems: IList_1<XPathItem>): IList_1<XPathNavigator>;
    static toNodeSet(item: XPathItem): IList_1<XPathNavigator>;
    static toString(listItems: IList_1<XPathItem>): string;
    static toString(value: DateTime): string;
    static toString(value: double): string;
    static toString(item: XPathItem): string;
}


export type XsltConvert = XsltConvert$instance;

export abstract class XsltFunctions$instance {
    static baseUri(navigator: XPathNavigator): string;
    static contains(s1: string, s2: string): boolean;
    static eXslObjectType(value: IList_1<XPathItem>): string;
    static lang(value: string, context: XPathNavigator): boolean;
    static msFormatDateTime(dateTime: string, format: string, lang: string, isDate: boolean): string;
    static msLocalName(name: string): string;
    static msNamespaceUri(name: string, currentNode: XPathNavigator): string;
    static msNumber(value: IList_1<XPathItem>): double;
    static msStringCompare(s1: string, s2: string, lang: string, options: string): double;
    static msUtc(dateTime: string): string;
    static normalizeSpace(value: string): string;
    static outerXml(navigator: XPathNavigator): string;
    static round(value: double): double;
    static startsWith(s1: string, s2: string): boolean;
    static substring(value: string, startIndex: double, length: double): string;
    static substring(value: string, startIndex: double): string;
    static substringAfter(s1: string, s2: string): string;
    static substringBefore(s1: string, s2: string): string;
    static systemProperty(name: XmlQualifiedName): XPathItem;
    static translate(arg: string, mapString: string, transString: string): string;
}


export type XsltFunctions = XsltFunctions$instance;

