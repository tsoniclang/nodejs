// Generated by tsbindgen - Architecture
// Namespace: System.Xml.Schema
// Assembly: System.Private.Xml, System.Private.Xml.Linq

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ArrayList, CollectionBase, ICollection, IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import type { Stream, TextReader, TextWriter } from "../../System.IO/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { XAttribute, XDocument, XElement } from "../../System.Xml.Linq/internal/index.js";
import type { XmlSerializerNamespaces } from "../../System.Xml.Serialization/internal/index.js";
import * as System_Xml_XPath_Internal from "../../System.Xml.XPath/internal/index.js";
import type { XPathItem } from "../../System.Xml.XPath/internal/index.js";
import type { IXmlLineInfo, IXmlNamespaceResolver, XmlAttribute, XmlNamespaceManager, XmlNameTable, XmlNode, XmlQualifiedName, XmlReader, XmlResolver, XmlTokenizedType, XmlWriter } from "../../System.Xml/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, AsyncCallback, Boolean as ClrBoolean, DateTime, Decimal, Delegate, Double, Enum, EventArgs, Exception, IAsyncResult, ICloneable, IComparable, IConvertible, IFormatProvider, IFormattable, Int32, Int64, IntPtr, ISpanFormattable, MulticastDelegate, Object as ClrObject, String as ClrString, SystemException, Type, TypeCode, Uri, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum XmlSchemaContentProcessing {
    none = 0,
    skip = 1,
    lax = 2,
    strict = 3
}


export enum XmlSchemaContentType {
    textOnly = 0,
    empty = 1,
    elementOnly = 2,
    mixed = 3
}


export enum XmlSchemaDatatypeVariety {
    atomic = 0,
    list = 1,
    union = 2
}


export enum XmlSchemaDerivationMethod {
    empty = 0,
    substitution = 1,
    extension = 2,
    restriction = 4,
    list = 8,
    union = 16,
    all = 255,
    none = 256
}


export enum XmlSchemaForm {
    none = 0,
    qualified = 1,
    unqualified = 2
}


export enum XmlSchemaInference_InferenceOption {
    restricted = 0,
    relaxed = 1
}


export enum XmlSchemaUse {
    none = 0,
    optional = 1,
    prohibited = 2,
    required = 3
}


export enum XmlSchemaValidationFlags {
    none = 0,
    processInlineSchema = 1,
    processSchemaLocation = 2,
    reportValidationWarnings = 4,
    processIdentityConstraints = 8,
    allowXmlAttributes = 16
}


export enum XmlSchemaValidity {
    notKnown = 0,
    valid = 1,
    invalid = 2
}


export enum XmlSeverityType {
    error = 0,
    warning = 1
}


export enum XmlTypeCode {
    none = 0,
    item = 1,
    node = 2,
    document = 3,
    element = 4,
    attribute = 5,
    namespace_ = 6,
    processingInstruction = 7,
    comment = 8,
    text = 9,
    anyAtomicType = 10,
    untypedAtomic = 11,
    string_ = 12,
    boolean_ = 13,
    decimal = 14,
    float = 15,
    double = 16,
    duration = 17,
    dateTime = 18,
    time = 19,
    date = 20,
    gYearMonth = 21,
    gYear = 22,
    gMonthDay = 23,
    gDay = 24,
    gMonth = 25,
    hexBinary = 26,
    base64Binary = 27,
    anyUri = 28,
    qName = 29,
    notation = 30,
    normalizedString = 31,
    token = 32,
    language = 33,
    nmToken = 34,
    name = 35,
    ncName = 36,
    id = 37,
    idref = 38,
    entity = 39,
    integer = 40,
    nonPositiveInteger = 41,
    negativeInteger = 42,
    long = 43,
    int = 44,
    short = 45,
    byte = 46,
    nonNegativeInteger = 47,
    unsignedLong = 48,
    unsignedInt = 49,
    unsignedShort = 50,
    unsignedByte = 51,
    positiveInteger = 52,
    yearMonthDuration = 53,
    dayTimeDuration = 54
}


export type ValidationEventHandler = (sender: unknown, e: ValidationEventArgs) => void;


export type XmlValueGetter = () => unknown;


export interface IXmlSchemaInfo$instance {
    readonly validity: XmlSchemaValidity;
    readonly isDefault: boolean;
    readonly isNil: boolean;
    readonly memberType: XmlSchemaSimpleType;
    readonly schemaType: XmlSchemaType;
    readonly schemaElement: XmlSchemaElement;
    readonly schemaAttribute: XmlSchemaAttribute;
}


export type IXmlSchemaInfo = IXmlSchemaInfo$instance;

export interface ValidationEventArgs$instance extends EventArgs {
    readonly exception: XmlSchemaException;
    readonly message: string;
    readonly severity: XmlSeverityType;
}


export const ValidationEventArgs: {
    new(): ValidationEventArgs$instance;
};


export type ValidationEventArgs = ValidationEventArgs$instance;

export interface XmlAtomicValue$instance extends XPathItem {
    readonly isNode: boolean;
    readonly typedValue: unknown;
    readonly value: string;
    readonly valueAsBoolean: boolean;
    readonly valueAsDateTime: DateTime;
    readonly valueAsDouble: double;
    readonly valueAsInt: int;
    readonly valueAsLong: long;
    readonly valueType: Type;
    readonly xmlType: XmlSchemaType;
    clone(): XmlAtomicValue;
    toString(): string;
    valueAs(type_: Type, nsResolver: IXmlNamespaceResolver): unknown;
    valueAs(returnType: Type): unknown;
}


export const XmlAtomicValue: {
    new(): XmlAtomicValue$instance;
};


export interface __XmlAtomicValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type XmlAtomicValue = XmlAtomicValue$instance & __XmlAtomicValue$views;


export interface XmlSchema$instance extends XmlSchemaObject {
    attributeFormDefault: XmlSchemaForm;
    readonly attributeGroups: XmlSchemaObjectTable;
    readonly attributes: XmlSchemaObjectTable;
    blockDefault: XmlSchemaDerivationMethod;
    elementFormDefault: XmlSchemaForm;
    readonly elements: XmlSchemaObjectTable;
    finalDefault: XmlSchemaDerivationMethod;
    readonly groups: XmlSchemaObjectTable;
    id: string;
    readonly includes: XmlSchemaObjectCollection;
    readonly isCompiled: boolean;
    readonly items: XmlSchemaObjectCollection;
    readonly notations: XmlSchemaObjectTable;
    readonly schemaTypes: XmlSchemaObjectTable;
    targetNamespace: string;
    unhandledAttributes: XmlAttribute[];
    version: string;
    compile(validationEventHandler: ValidationEventHandler): void;
    compile(validationEventHandler: ValidationEventHandler, resolver: XmlResolver): void;
    write(stream: Stream): void;
    write(stream: Stream, namespaceManager: XmlNamespaceManager): void;
    write(writer: TextWriter): void;
    write(writer: TextWriter, namespaceManager: XmlNamespaceManager): void;
    write(writer: XmlWriter): void;
    write(writer: XmlWriter, namespaceManager: XmlNamespaceManager): void;
}


export const XmlSchema: {
    new(): XmlSchema$instance;
    readonly namespace_: string;
    readonly instanceNamespace: string;
    read(stream: Stream, validationEventHandler: ValidationEventHandler): XmlSchema;
    read(reader: TextReader, validationEventHandler: ValidationEventHandler): XmlSchema;
    read(reader: XmlReader, validationEventHandler: ValidationEventHandler): XmlSchema;
};


export type XmlSchema = XmlSchema$instance;

export interface XmlSchemaAll$instance extends XmlSchemaGroupBase {
    readonly items: XmlSchemaObjectCollection;
}


export const XmlSchemaAll: {
    new(): XmlSchemaAll$instance;
};


export type XmlSchemaAll = XmlSchemaAll$instance;

export interface XmlSchemaAnnotated$instance extends XmlSchemaObject {
    annotation: XmlSchemaAnnotation;
    id: string;
    unhandledAttributes: XmlAttribute[];
}


export const XmlSchemaAnnotated: {
    new(): XmlSchemaAnnotated$instance;
};


export type XmlSchemaAnnotated = XmlSchemaAnnotated$instance;

export interface XmlSchemaAnnotation$instance extends XmlSchemaObject {
    id: string;
    readonly items: XmlSchemaObjectCollection;
    unhandledAttributes: XmlAttribute[];
}


export const XmlSchemaAnnotation: {
    new(): XmlSchemaAnnotation$instance;
};


export type XmlSchemaAnnotation = XmlSchemaAnnotation$instance;

export interface XmlSchemaAny$instance extends XmlSchemaParticle {
    namespace_: string;
    processContents: XmlSchemaContentProcessing;
}


export const XmlSchemaAny: {
    new(): XmlSchemaAny$instance;
};


export type XmlSchemaAny = XmlSchemaAny$instance;

export interface XmlSchemaAnyAttribute$instance extends XmlSchemaAnnotated {
    namespace_: string;
    processContents: XmlSchemaContentProcessing;
}


export const XmlSchemaAnyAttribute: {
    new(): XmlSchemaAnyAttribute$instance;
};


export type XmlSchemaAnyAttribute = XmlSchemaAnyAttribute$instance;

export interface XmlSchemaAppInfo$instance extends XmlSchemaObject {
    markup: XmlNode[];
    source: string;
}


export const XmlSchemaAppInfo: {
    new(): XmlSchemaAppInfo$instance;
};


export type XmlSchemaAppInfo = XmlSchemaAppInfo$instance;

export interface XmlSchemaAttribute$instance extends XmlSchemaAnnotated {
    readonly attributeSchemaType: XmlSchemaSimpleType;
    readonly attributeType: unknown;
    defaultValue: string;
    fixedValue: string;
    form: XmlSchemaForm;
    name: string;
    readonly qualifiedName: XmlQualifiedName;
    refName: XmlQualifiedName;
    schemaType: XmlSchemaSimpleType;
    schemaTypeName: XmlQualifiedName;
    use: XmlSchemaUse;
}


export const XmlSchemaAttribute: {
    new(): XmlSchemaAttribute$instance;
};


export type XmlSchemaAttribute = XmlSchemaAttribute$instance;

export interface XmlSchemaAttributeGroup$instance extends XmlSchemaAnnotated {
    anyAttribute: XmlSchemaAnyAttribute;
    readonly attributes: XmlSchemaObjectCollection;
    name: string;
    readonly qualifiedName: XmlQualifiedName;
    readonly redefinedAttributeGroup: XmlSchemaAttributeGroup;
}


export const XmlSchemaAttributeGroup: {
    new(): XmlSchemaAttributeGroup$instance;
};


export type XmlSchemaAttributeGroup = XmlSchemaAttributeGroup$instance;

export interface XmlSchemaAttributeGroupRef$instance extends XmlSchemaAnnotated {
    refName: XmlQualifiedName;
}


export const XmlSchemaAttributeGroupRef: {
    new(): XmlSchemaAttributeGroupRef$instance;
};


export type XmlSchemaAttributeGroupRef = XmlSchemaAttributeGroupRef$instance;

export interface XmlSchemaChoice$instance extends XmlSchemaGroupBase {
    readonly items: XmlSchemaObjectCollection;
}


export const XmlSchemaChoice: {
    new(): XmlSchemaChoice$instance;
};


export type XmlSchemaChoice = XmlSchemaChoice$instance;

export interface XmlSchemaCollection$instance {
    readonly count: int;
    readonly item: XmlSchema;
    readonly nameTable: XmlNameTable;
    add(ns: string, uri: string): XmlSchema;
    add(ns: string, reader: XmlReader): XmlSchema;
    add(ns: string, reader: XmlReader, resolver: XmlResolver): XmlSchema;
    add(schema: XmlSchema): XmlSchema;
    add(schema: XmlSchema, resolver: XmlResolver): XmlSchema;
    add(schema: XmlSchemaCollection): void;
    contains(schema: XmlSchema): boolean;
    contains(ns: string): boolean;
    copyTo(array: XmlSchema[], index: int): void;
    getEnumerator(): XmlSchemaCollectionEnumerator;
}


export const XmlSchemaCollection: {
    new(): XmlSchemaCollection$instance;
    new(nametable: XmlNameTable): XmlSchemaCollection$instance;
};


export interface __XmlSchemaCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type XmlSchemaCollection = XmlSchemaCollection$instance & __XmlSchemaCollection$views;


export interface XmlSchemaCollectionEnumerator$instance {
    readonly current: unknown | XmlSchema;
    moveNext(): boolean;
    reset(): void;
}


export const XmlSchemaCollectionEnumerator: {
    new(): XmlSchemaCollectionEnumerator$instance;
};


export interface __XmlSchemaCollectionEnumerator$views {
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type XmlSchemaCollectionEnumerator = XmlSchemaCollectionEnumerator$instance & __XmlSchemaCollectionEnumerator$views;


export interface XmlSchemaCompilationSettings$instance {
    enableUpaCheck: boolean;
}


export const XmlSchemaCompilationSettings: {
    new(): XmlSchemaCompilationSettings$instance;
};


export type XmlSchemaCompilationSettings = XmlSchemaCompilationSettings$instance;

export interface XmlSchemaComplexContent$instance extends XmlSchemaContentModel {
    content: XmlSchemaContent;
    isMixed: boolean;
}


export const XmlSchemaComplexContent: {
    new(): XmlSchemaComplexContent$instance;
};


export type XmlSchemaComplexContent = XmlSchemaComplexContent$instance;

export interface XmlSchemaComplexContentExtension$instance extends XmlSchemaContent {
    anyAttribute: XmlSchemaAnyAttribute;
    readonly attributes: XmlSchemaObjectCollection;
    baseTypeName: XmlQualifiedName;
    particle: XmlSchemaParticle;
}


export const XmlSchemaComplexContentExtension: {
    new(): XmlSchemaComplexContentExtension$instance;
};


export type XmlSchemaComplexContentExtension = XmlSchemaComplexContentExtension$instance;

export interface XmlSchemaComplexContentRestriction$instance extends XmlSchemaContent {
    anyAttribute: XmlSchemaAnyAttribute;
    readonly attributes: XmlSchemaObjectCollection;
    baseTypeName: XmlQualifiedName;
    particle: XmlSchemaParticle;
}


export const XmlSchemaComplexContentRestriction: {
    new(): XmlSchemaComplexContentRestriction$instance;
};


export type XmlSchemaComplexContentRestriction = XmlSchemaComplexContentRestriction$instance;

export interface XmlSchemaComplexType$instance extends XmlSchemaType {
    anyAttribute: XmlSchemaAnyAttribute;
    readonly attributes: XmlSchemaObjectCollection;
    readonly attributeUses: XmlSchemaObjectTable;
    readonly attributeWildcard: XmlSchemaAnyAttribute;
    block: XmlSchemaDerivationMethod;
    readonly blockResolved: XmlSchemaDerivationMethod;
    contentModel: XmlSchemaContentModel;
    readonly contentType: XmlSchemaContentType;
    readonly contentTypeParticle: XmlSchemaParticle;
    isAbstract: boolean;
    isMixed: boolean;
    particle: XmlSchemaParticle;
}


export const XmlSchemaComplexType: {
    new(): XmlSchemaComplexType$instance;
};


export type XmlSchemaComplexType = XmlSchemaComplexType$instance;

export interface XmlSchemaContent$instance extends XmlSchemaAnnotated {
}


export const XmlSchemaContent: {
};


export type XmlSchemaContent = XmlSchemaContent$instance;

export interface XmlSchemaContentModel$instance extends XmlSchemaAnnotated {
    content: XmlSchemaContent;
}


export const XmlSchemaContentModel: {
};


export type XmlSchemaContentModel = XmlSchemaContentModel$instance;

export interface XmlSchemaDatatype$instance {
    readonly tokenizedType: XmlTokenizedType;
    readonly typeCode: XmlTypeCode;
    readonly valueType: Type;
    readonly variety: XmlSchemaDatatypeVariety;
    changeType(value: unknown, targetType: Type): unknown;
    changeType(value: unknown, targetType: Type, namespaceResolver: IXmlNamespaceResolver): unknown;
    isDerivedFrom(datatype: XmlSchemaDatatype): boolean;
    parseValue(s: string, nameTable: XmlNameTable, nsmgr: IXmlNamespaceResolver): unknown;
}


export const XmlSchemaDatatype: {
};


export type XmlSchemaDatatype = XmlSchemaDatatype$instance;

export interface XmlSchemaDocumentation$instance extends XmlSchemaObject {
    language: string;
    markup: XmlNode[];
    source: string;
}


export const XmlSchemaDocumentation: {
    new(): XmlSchemaDocumentation$instance;
};


export type XmlSchemaDocumentation = XmlSchemaDocumentation$instance;

export interface XmlSchemaElement$instance extends XmlSchemaParticle {
    block: XmlSchemaDerivationMethod;
    readonly blockResolved: XmlSchemaDerivationMethod;
    readonly constraints: XmlSchemaObjectCollection;
    defaultValue: string;
    readonly elementSchemaType: XmlSchemaType;
    readonly elementType: unknown;
    final: XmlSchemaDerivationMethod;
    readonly finalResolved: XmlSchemaDerivationMethod;
    fixedValue: string;
    form: XmlSchemaForm;
    isAbstract: boolean;
    isNillable: boolean;
    name: string;
    readonly qualifiedName: XmlQualifiedName;
    refName: XmlQualifiedName;
    schemaType: XmlSchemaType;
    schemaTypeName: XmlQualifiedName;
    substitutionGroup: XmlQualifiedName;
}


export const XmlSchemaElement: {
    new(): XmlSchemaElement$instance;
};


export type XmlSchemaElement = XmlSchemaElement$instance;

export interface XmlSchemaEnumerationFacet$instance extends XmlSchemaFacet {
}


export const XmlSchemaEnumerationFacet: {
    new(): XmlSchemaEnumerationFacet$instance;
};


export type XmlSchemaEnumerationFacet = XmlSchemaEnumerationFacet$instance;

export interface XmlSchemaException$instance extends SystemException {
    readonly lineNumber: int;
    readonly linePosition: int;
    readonly message: string;
    readonly sourceSchemaObject: XmlSchemaObject;
    readonly sourceUri: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const XmlSchemaException: {
    new(): XmlSchemaException$instance;
    new(message: string): XmlSchemaException$instance;
    new(message: string, innerException: Exception): XmlSchemaException$instance;
    new(message: string, innerException: Exception, lineNumber: int, linePosition: int): XmlSchemaException$instance;
};


export interface __XmlSchemaException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XmlSchemaException = XmlSchemaException$instance & __XmlSchemaException$views;


export interface XmlSchemaExternal$instance extends XmlSchemaObject {
    id: string;
    schema: XmlSchema;
    schemaLocation: string;
    unhandledAttributes: XmlAttribute[];
}


export const XmlSchemaExternal: {
};


export type XmlSchemaExternal = XmlSchemaExternal$instance;

export interface XmlSchemaFacet$instance extends XmlSchemaAnnotated {
    isFixed: boolean;
    value: string;
}


export const XmlSchemaFacet: {
};


export type XmlSchemaFacet = XmlSchemaFacet$instance;

export interface XmlSchemaFractionDigitsFacet$instance extends XmlSchemaNumericFacet {
}


export const XmlSchemaFractionDigitsFacet: {
    new(): XmlSchemaFractionDigitsFacet$instance;
};


export type XmlSchemaFractionDigitsFacet = XmlSchemaFractionDigitsFacet$instance;

export interface XmlSchemaGroup$instance extends XmlSchemaAnnotated {
    name: string;
    particle: XmlSchemaGroupBase;
    readonly qualifiedName: XmlQualifiedName;
}


export const XmlSchemaGroup: {
    new(): XmlSchemaGroup$instance;
};


export type XmlSchemaGroup = XmlSchemaGroup$instance;

export interface XmlSchemaGroupBase$instance extends XmlSchemaParticle {
    readonly items: XmlSchemaObjectCollection;
}


export const XmlSchemaGroupBase: {
};


export type XmlSchemaGroupBase = XmlSchemaGroupBase$instance;

export interface XmlSchemaGroupRef$instance extends XmlSchemaParticle {
    readonly particle: XmlSchemaGroupBase;
    refName: XmlQualifiedName;
}


export const XmlSchemaGroupRef: {
    new(): XmlSchemaGroupRef$instance;
};


export type XmlSchemaGroupRef = XmlSchemaGroupRef$instance;

export interface XmlSchemaIdentityConstraint$instance extends XmlSchemaAnnotated {
    readonly fields: XmlSchemaObjectCollection;
    name: string;
    readonly qualifiedName: XmlQualifiedName;
    selector: XmlSchemaXPath;
}


export const XmlSchemaIdentityConstraint: {
    new(): XmlSchemaIdentityConstraint$instance;
};


export type XmlSchemaIdentityConstraint = XmlSchemaIdentityConstraint$instance;

export interface XmlSchemaImport$instance extends XmlSchemaExternal {
    annotation: XmlSchemaAnnotation;
    namespace_: string;
}


export const XmlSchemaImport: {
    new(): XmlSchemaImport$instance;
};


export type XmlSchemaImport = XmlSchemaImport$instance;

export interface XmlSchemaInclude$instance extends XmlSchemaExternal {
    annotation: XmlSchemaAnnotation;
}


export const XmlSchemaInclude: {
    new(): XmlSchemaInclude$instance;
};


export type XmlSchemaInclude = XmlSchemaInclude$instance;

export interface XmlSchemaInference$instance {
    occurrence: XmlSchemaInference_InferenceOption;
    typeInference: XmlSchemaInference_InferenceOption;
    inferSchema(instanceDocument: XmlReader): XmlSchemaSet;
    inferSchema(instanceDocument: XmlReader, schemas: XmlSchemaSet): XmlSchemaSet;
}


export const XmlSchemaInference: {
    new(): XmlSchemaInference$instance;
};


export type XmlSchemaInference = XmlSchemaInference$instance;

export interface XmlSchemaInferenceException$instance extends XmlSchemaException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const XmlSchemaInferenceException: {
    new(): XmlSchemaInferenceException$instance;
    new(message: string): XmlSchemaInferenceException$instance;
    new(message: string, innerException: Exception): XmlSchemaInferenceException$instance;
    new(message: string, innerException: Exception, lineNumber: int, linePosition: int): XmlSchemaInferenceException$instance;
};


export interface __XmlSchemaInferenceException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XmlSchemaInferenceException = XmlSchemaInferenceException$instance & __XmlSchemaInferenceException$views;


export interface XmlSchemaInfo$instance {
    contentType: XmlSchemaContentType;
    isDefault: boolean;
    isNil: boolean;
    memberType: XmlSchemaSimpleType;
    schemaAttribute: XmlSchemaAttribute;
    schemaElement: XmlSchemaElement;
    schemaType: XmlSchemaType;
    validity: XmlSchemaValidity;
}


export const XmlSchemaInfo: {
    new(): XmlSchemaInfo$instance;
};


export interface __XmlSchemaInfo$views {
    As_IXmlSchemaInfo(): IXmlSchemaInfo$instance;
}

export type XmlSchemaInfo = XmlSchemaInfo$instance & __XmlSchemaInfo$views;


export interface XmlSchemaKey$instance extends XmlSchemaIdentityConstraint {
}


export const XmlSchemaKey: {
    new(): XmlSchemaKey$instance;
};


export type XmlSchemaKey = XmlSchemaKey$instance;

export interface XmlSchemaKeyref$instance extends XmlSchemaIdentityConstraint {
    refer: XmlQualifiedName;
}


export const XmlSchemaKeyref: {
    new(): XmlSchemaKeyref$instance;
};


export type XmlSchemaKeyref = XmlSchemaKeyref$instance;

export interface XmlSchemaLengthFacet$instance extends XmlSchemaNumericFacet {
}


export const XmlSchemaLengthFacet: {
    new(): XmlSchemaLengthFacet$instance;
};


export type XmlSchemaLengthFacet = XmlSchemaLengthFacet$instance;

export interface XmlSchemaMaxExclusiveFacet$instance extends XmlSchemaFacet {
}


export const XmlSchemaMaxExclusiveFacet: {
    new(): XmlSchemaMaxExclusiveFacet$instance;
};


export type XmlSchemaMaxExclusiveFacet = XmlSchemaMaxExclusiveFacet$instance;

export interface XmlSchemaMaxInclusiveFacet$instance extends XmlSchemaFacet {
}


export const XmlSchemaMaxInclusiveFacet: {
    new(): XmlSchemaMaxInclusiveFacet$instance;
};


export type XmlSchemaMaxInclusiveFacet = XmlSchemaMaxInclusiveFacet$instance;

export interface XmlSchemaMaxLengthFacet$instance extends XmlSchemaNumericFacet {
}


export const XmlSchemaMaxLengthFacet: {
    new(): XmlSchemaMaxLengthFacet$instance;
};


export type XmlSchemaMaxLengthFacet = XmlSchemaMaxLengthFacet$instance;

export interface XmlSchemaMinExclusiveFacet$instance extends XmlSchemaFacet {
}


export const XmlSchemaMinExclusiveFacet: {
    new(): XmlSchemaMinExclusiveFacet$instance;
};


export type XmlSchemaMinExclusiveFacet = XmlSchemaMinExclusiveFacet$instance;

export interface XmlSchemaMinInclusiveFacet$instance extends XmlSchemaFacet {
}


export const XmlSchemaMinInclusiveFacet: {
    new(): XmlSchemaMinInclusiveFacet$instance;
};


export type XmlSchemaMinInclusiveFacet = XmlSchemaMinInclusiveFacet$instance;

export interface XmlSchemaMinLengthFacet$instance extends XmlSchemaNumericFacet {
}


export const XmlSchemaMinLengthFacet: {
    new(): XmlSchemaMinLengthFacet$instance;
};


export type XmlSchemaMinLengthFacet = XmlSchemaMinLengthFacet$instance;

export interface XmlSchemaNotation$instance extends XmlSchemaAnnotated {
    name: string;
    public_: string;
    system: string;
}


export const XmlSchemaNotation: {
    new(): XmlSchemaNotation$instance;
};


export type XmlSchemaNotation = XmlSchemaNotation$instance;

export interface XmlSchemaNumericFacet$instance extends XmlSchemaFacet {
}


export const XmlSchemaNumericFacet: {
};


export type XmlSchemaNumericFacet = XmlSchemaNumericFacet$instance;

export interface XmlSchemaObject$instance {
    lineNumber: int;
    linePosition: int;
    namespaces: XmlSerializerNamespaces;
    parent: XmlSchemaObject;
    sourceUri: string;
}


export const XmlSchemaObject: {
};


export type XmlSchemaObject = XmlSchemaObject$instance;

export interface XmlSchemaObjectCollection$instance extends CollectionBase {
    item: XmlSchemaObject;
    add(value: unknown): int;
    clear(): void;
    contains(value: unknown): boolean;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator;
    indexOf(item: XmlSchemaObject): int;
    insert(index: int, value: unknown): void;
    remove(value: unknown): void;
    removeAt(index: int): void;
}


export const XmlSchemaObjectCollection: {
    new(): XmlSchemaObjectCollection$instance;
    new(parent: XmlSchemaObject): XmlSchemaObjectCollection$instance;
};


export interface __XmlSchemaObjectCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type XmlSchemaObjectCollection = XmlSchemaObjectCollection$instance & __XmlSchemaObjectCollection$views;


export interface XmlSchemaObjectEnumerator$instance {
    readonly current: unknown | XmlSchemaObject;
    moveNext(): boolean;
    reset(): void;
}


export const XmlSchemaObjectEnumerator: {
    new(): XmlSchemaObjectEnumerator$instance;
};


export interface __XmlSchemaObjectEnumerator$views {
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type XmlSchemaObjectEnumerator = XmlSchemaObjectEnumerator$instance & __XmlSchemaObjectEnumerator$views;


export interface XmlSchemaObjectTable$instance {
    readonly count: int;
    readonly item: XmlSchemaObject;
    readonly names: ICollection;
    readonly values: ICollection;
    contains(name: XmlQualifiedName): boolean;
    getEnumerator(): IDictionaryEnumerator;
}


export const XmlSchemaObjectTable: {
    new(): XmlSchemaObjectTable$instance;
};


export type XmlSchemaObjectTable = XmlSchemaObjectTable$instance;

export interface XmlSchemaParticle$instance extends XmlSchemaAnnotated {
    maxOccurs: decimal;
    maxOccursString: string;
    minOccurs: decimal;
    minOccursString: string;
}


export const XmlSchemaParticle: {
};


export type XmlSchemaParticle = XmlSchemaParticle$instance;

export interface XmlSchemaPatternFacet$instance extends XmlSchemaFacet {
}


export const XmlSchemaPatternFacet: {
    new(): XmlSchemaPatternFacet$instance;
};


export type XmlSchemaPatternFacet = XmlSchemaPatternFacet$instance;

export interface XmlSchemaRedefine$instance extends XmlSchemaExternal {
    readonly attributeGroups: XmlSchemaObjectTable;
    readonly groups: XmlSchemaObjectTable;
    readonly items: XmlSchemaObjectCollection;
    readonly schemaTypes: XmlSchemaObjectTable;
}


export const XmlSchemaRedefine: {
    new(): XmlSchemaRedefine$instance;
};


export type XmlSchemaRedefine = XmlSchemaRedefine$instance;

export interface XmlSchemaSequence$instance extends XmlSchemaGroupBase {
    readonly items: XmlSchemaObjectCollection;
}


export const XmlSchemaSequence: {
    new(): XmlSchemaSequence$instance;
};


export type XmlSchemaSequence = XmlSchemaSequence$instance;

export interface XmlSchemaSet$instance {
    compilationSettings: XmlSchemaCompilationSettings;
    readonly count: int;
    readonly globalAttributes: XmlSchemaObjectTable;
    readonly globalElements: XmlSchemaObjectTable;
    readonly globalTypes: XmlSchemaObjectTable;
    readonly isCompiled: boolean;
    readonly nameTable: XmlNameTable;
    xmlResolver: XmlResolver;
    add(targetNamespace: string, schemaUri: string): XmlSchema;
    add(targetNamespace: string, schemaDocument: XmlReader): XmlSchema;
    add(schemas: XmlSchemaSet): void;
    add(schema: XmlSchema): XmlSchema;
    compile(): void;
    contains(targetNamespace: string): boolean;
    contains(schema: XmlSchema): boolean;
    copyTo(schemas: XmlSchema[], index: int): void;
    remove(schema: XmlSchema): XmlSchema;
    removeRecursive(schemaToRemove: XmlSchema): boolean;
    reprocess(schema: XmlSchema): XmlSchema;
    schemas(): ICollection;
    schemas(targetNamespace: string): ICollection;
}


export const XmlSchemaSet: {
    new(): XmlSchemaSet$instance;
    new(nameTable: XmlNameTable): XmlSchemaSet$instance;
};


export type XmlSchemaSet = XmlSchemaSet$instance;

export interface XmlSchemaSimpleContent$instance extends XmlSchemaContentModel {
    content: XmlSchemaContent;
}


export const XmlSchemaSimpleContent: {
    new(): XmlSchemaSimpleContent$instance;
};


export type XmlSchemaSimpleContent = XmlSchemaSimpleContent$instance;

export interface XmlSchemaSimpleContentExtension$instance extends XmlSchemaContent {
    anyAttribute: XmlSchemaAnyAttribute;
    readonly attributes: XmlSchemaObjectCollection;
    baseTypeName: XmlQualifiedName;
}


export const XmlSchemaSimpleContentExtension: {
    new(): XmlSchemaSimpleContentExtension$instance;
};


export type XmlSchemaSimpleContentExtension = XmlSchemaSimpleContentExtension$instance;

export interface XmlSchemaSimpleContentRestriction$instance extends XmlSchemaContent {
    anyAttribute: XmlSchemaAnyAttribute;
    readonly attributes: XmlSchemaObjectCollection;
    baseType: XmlSchemaSimpleType;
    baseTypeName: XmlQualifiedName;
    readonly facets: XmlSchemaObjectCollection;
}


export const XmlSchemaSimpleContentRestriction: {
    new(): XmlSchemaSimpleContentRestriction$instance;
};


export type XmlSchemaSimpleContentRestriction = XmlSchemaSimpleContentRestriction$instance;

export interface XmlSchemaSimpleType$instance extends XmlSchemaType {
    content: XmlSchemaSimpleTypeContent;
}


export const XmlSchemaSimpleType: {
    new(): XmlSchemaSimpleType$instance;
};


export type XmlSchemaSimpleType = XmlSchemaSimpleType$instance;

export interface XmlSchemaSimpleTypeContent$instance extends XmlSchemaAnnotated {
}


export const XmlSchemaSimpleTypeContent: {
};


export type XmlSchemaSimpleTypeContent = XmlSchemaSimpleTypeContent$instance;

export interface XmlSchemaSimpleTypeList$instance extends XmlSchemaSimpleTypeContent {
    baseItemType: XmlSchemaSimpleType;
    itemType: XmlSchemaSimpleType;
    itemTypeName: XmlQualifiedName;
}


export const XmlSchemaSimpleTypeList: {
    new(): XmlSchemaSimpleTypeList$instance;
};


export type XmlSchemaSimpleTypeList = XmlSchemaSimpleTypeList$instance;

export interface XmlSchemaSimpleTypeRestriction$instance extends XmlSchemaSimpleTypeContent {
    baseType: XmlSchemaSimpleType;
    baseTypeName: XmlQualifiedName;
    readonly facets: XmlSchemaObjectCollection;
}


export const XmlSchemaSimpleTypeRestriction: {
    new(): XmlSchemaSimpleTypeRestriction$instance;
};


export type XmlSchemaSimpleTypeRestriction = XmlSchemaSimpleTypeRestriction$instance;

export interface XmlSchemaSimpleTypeUnion$instance extends XmlSchemaSimpleTypeContent {
    readonly baseMemberTypes: XmlSchemaSimpleType[];
    readonly baseTypes: XmlSchemaObjectCollection;
    memberTypes: XmlQualifiedName[];
}


export const XmlSchemaSimpleTypeUnion: {
    new(): XmlSchemaSimpleTypeUnion$instance;
};


export type XmlSchemaSimpleTypeUnion = XmlSchemaSimpleTypeUnion$instance;

export interface XmlSchemaTotalDigitsFacet$instance extends XmlSchemaNumericFacet {
}


export const XmlSchemaTotalDigitsFacet: {
    new(): XmlSchemaTotalDigitsFacet$instance;
};


export type XmlSchemaTotalDigitsFacet = XmlSchemaTotalDigitsFacet$instance;

export interface XmlSchemaType$instance extends XmlSchemaAnnotated {
    readonly baseSchemaType: unknown;
    readonly baseXmlSchemaType: XmlSchemaType;
    readonly datatype: XmlSchemaDatatype;
    readonly derivedBy: XmlSchemaDerivationMethod;
    final: XmlSchemaDerivationMethod;
    readonly finalResolved: XmlSchemaDerivationMethod;
    isMixed: boolean;
    name: string;
    readonly qualifiedName: XmlQualifiedName;
    readonly typeCode: XmlTypeCode;
}


export const XmlSchemaType: {
    new(): XmlSchemaType$instance;
    getBuiltInComplexType(typeCode: XmlTypeCode): XmlSchemaComplexType;
    getBuiltInComplexType(qualifiedName: XmlQualifiedName): XmlSchemaComplexType;
    getBuiltInSimpleType(typeCode: XmlTypeCode): XmlSchemaSimpleType;
    getBuiltInSimpleType(qualifiedName: XmlQualifiedName): XmlSchemaSimpleType;
    isDerivedFrom(derivedType: XmlSchemaType, baseType: XmlSchemaType, except: XmlSchemaDerivationMethod): boolean;
};


export type XmlSchemaType = XmlSchemaType$instance;

export interface XmlSchemaUnique$instance extends XmlSchemaIdentityConstraint {
}


export const XmlSchemaUnique: {
    new(): XmlSchemaUnique$instance;
};


export type XmlSchemaUnique = XmlSchemaUnique$instance;

export interface XmlSchemaValidationException$instance extends XmlSchemaException$instance {
    readonly sourceObject: unknown;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const XmlSchemaValidationException: {
    new(): XmlSchemaValidationException$instance;
    new(message: string): XmlSchemaValidationException$instance;
    new(message: string, innerException: Exception): XmlSchemaValidationException$instance;
    new(message: string, innerException: Exception, lineNumber: int, linePosition: int): XmlSchemaValidationException$instance;
};


export interface __XmlSchemaValidationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XmlSchemaValidationException = XmlSchemaValidationException$instance & __XmlSchemaValidationException$views;


export interface XmlSchemaValidator$instance {
    lineInfoProvider: IXmlLineInfo;
    sourceUri: Uri;
    validationEventSender: unknown;
    xmlResolver: XmlResolver;
    addSchema(schema: XmlSchema): void;
    endValidation(): void;
    getExpectedAttributes(): XmlSchemaAttribute[];
    getExpectedParticles(): XmlSchemaParticle[];
    getUnspecifiedDefaultAttributes(defaultAttributes: ArrayList): void;
    initialize(): void;
    initialize(partialValidationType: XmlSchemaObject): void;
    skipToEndElement(schemaInfo: XmlSchemaInfo): void;
    validateAttribute(localName: string, namespaceUri: string, attributeValue: string, schemaInfo: XmlSchemaInfo): unknown;
    validateAttribute(localName: string, namespaceUri: string, attributeValue: XmlValueGetter, schemaInfo: XmlSchemaInfo): unknown;
    validateElement(localName: string, namespaceUri: string, schemaInfo: XmlSchemaInfo): void;
    validateElement(localName: string, namespaceUri: string, schemaInfo: XmlSchemaInfo, xsiType: string, xsiNil: string, xsiSchemaLocation: string, xsiNoNamespaceSchemaLocation: string): void;
    validateEndElement(schemaInfo: XmlSchemaInfo): unknown;
    validateEndElement(schemaInfo: XmlSchemaInfo, typedValue: unknown): unknown;
    validateEndOfAttributes(schemaInfo: XmlSchemaInfo): void;
    validateText(elementValue: string): void;
    validateText(elementValue: XmlValueGetter): void;
    validateWhitespace(elementValue: string): void;
    validateWhitespace(elementValue: XmlValueGetter): void;
}


export const XmlSchemaValidator: {
    new(nameTable: XmlNameTable, schemas: XmlSchemaSet, namespaceResolver: IXmlNamespaceResolver, validationFlags: XmlSchemaValidationFlags): XmlSchemaValidator$instance;
};


export type XmlSchemaValidator = XmlSchemaValidator$instance;

export interface XmlSchemaWhiteSpaceFacet$instance extends XmlSchemaFacet {
}


export const XmlSchemaWhiteSpaceFacet: {
    new(): XmlSchemaWhiteSpaceFacet$instance;
};


export type XmlSchemaWhiteSpaceFacet = XmlSchemaWhiteSpaceFacet$instance;

export interface XmlSchemaXPath$instance extends XmlSchemaAnnotated {
    xPath: string;
}


export const XmlSchemaXPath: {
    new(): XmlSchemaXPath$instance;
};


export type XmlSchemaXPath = XmlSchemaXPath$instance;

export abstract class Extensions$instance {
    static getSchemaInfo(source: XAttribute): IXmlSchemaInfo;
    static getSchemaInfo(source: XElement): IXmlSchemaInfo;
    static validate(source: XAttribute, partialValidationType: XmlSchemaObject, schemas: XmlSchemaSet, validationEventHandler: ValidationEventHandler, addSchemaInfo: boolean): void;
    static validate(source: XAttribute, partialValidationType: XmlSchemaObject, schemas: XmlSchemaSet, validationEventHandler: ValidationEventHandler): void;
    static validate(source: XDocument, schemas: XmlSchemaSet, validationEventHandler: ValidationEventHandler, addSchemaInfo: boolean): void;
    static validate(source: XDocument, schemas: XmlSchemaSet, validationEventHandler: ValidationEventHandler): void;
    static validate(source: XElement, partialValidationType: XmlSchemaObject, schemas: XmlSchemaSet, validationEventHandler: ValidationEventHandler, addSchemaInfo: boolean): void;
    static validate(source: XElement, partialValidationType: XmlSchemaObject, schemas: XmlSchemaSet, validationEventHandler: ValidationEventHandler): void;
}


export type Extensions = Extensions$instance;

