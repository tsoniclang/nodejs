// Generated by tsbindgen - Architecture
// Namespace: System.Text.Json.Serialization
// Assembly: System.Text.Json

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Text_Json_Serialization_Metadata_Internal from "../../System.Text.Json.Serialization.Metadata/internal/index.js";
import type { IJsonTypeInfoResolver, JsonTypeInfo } from "../../System.Text.Json.Serialization.Metadata/internal/index.js";
import type { JsonCommentHandling, JsonNamingPolicy, JsonSerializerDefaults, JsonSerializerOptions, Utf8JsonReader, Utf8JsonWriter } from "../../System.Text.Json/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Attribute, Boolean as ClrBoolean, Char, Enum, IComparable, IConvertible, IFormatProvider, IFormattable, Int32, ISpanFormattable, Object as ClrObject, String as ClrString, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum JsonIgnoreCondition {
    never_ = 0,
    always = 1,
    whenWritingDefault = 2,
    whenWritingNull = 3,
    whenWriting = 4,
    whenReading = 5
}


export enum JsonKnownNamingPolicy {
    unspecified = 0,
    camelCase = 1,
    snakeCaseLower = 2,
    snakeCaseUpper = 3,
    kebabCaseLower = 4,
    kebabCaseUpper = 5
}


export enum JsonKnownReferenceHandler {
    unspecified = 0,
    preserve = 1,
    ignoreCycles = 2
}


export enum JsonNumberHandling {
    strict = 0,
    allowReadingFromString = 1,
    writeAsString = 2,
    allowNamedFloatingPointLiterals = 4
}


export enum JsonObjectCreationHandling {
    replace = 0,
    populate = 1
}


export enum JsonSourceGenerationMode {
    default_ = 0,
    metadata = 1,
    serialization = 2
}


export enum JsonUnknownDerivedTypeHandling {
    failSerialization = 0,
    fallBackToBaseType = 1,
    fallBackToNearestAncestor = 2
}


export enum JsonUnknownTypeHandling {
    jsonElement = 0,
    jsonNode = 1
}


export enum JsonUnmappedMemberHandling {
    skip = 0,
    disallow = 1
}


export interface IJsonOnDeserialized$instance {
    onDeserialized(): void;
}


export type IJsonOnDeserialized = IJsonOnDeserialized$instance;

export interface IJsonOnDeserializing$instance {
    onDeserializing(): void;
}


export type IJsonOnDeserializing = IJsonOnDeserializing$instance;

export interface IJsonOnSerialized$instance {
    onSerialized(): void;
}


export type IJsonOnSerialized = IJsonOnSerialized$instance;

export interface IJsonOnSerializing$instance {
    onSerializing(): void;
}


export type IJsonOnSerializing = IJsonOnSerializing$instance;

export interface JsonAttribute$instance extends Attribute {
}


export const JsonAttribute: {
};


export type JsonAttribute = JsonAttribute$instance;

export interface JsonConstructorAttribute$instance extends JsonAttribute {
}


export const JsonConstructorAttribute: {
    new(): JsonConstructorAttribute$instance;
};


export type JsonConstructorAttribute = JsonConstructorAttribute$instance;

export interface JsonConverter$instance {
    readonly type_: Type;
    canConvert(typeToConvert: Type): boolean;
}


export const JsonConverter: {
};


export type JsonConverter = JsonConverter$instance;

export interface JsonConverter_1$instance<T> extends JsonConverter {
    readonly handleNull: boolean;
    readonly type_: Type;
    canConvert(typeToConvert: Type): boolean;
    read(reader: { value: ref<Utf8JsonReader> }, typeToConvert: Type, options: JsonSerializerOptions): T;
    readAsPropertyName(reader: { value: ref<Utf8JsonReader> }, typeToConvert: Type, options: JsonSerializerOptions): T;
    write(writer: Utf8JsonWriter, value: T, options: JsonSerializerOptions): void;
    writeAsPropertyName(writer: Utf8JsonWriter, value: T, options: JsonSerializerOptions): void;
}


export const JsonConverter_1: {
};


export type JsonConverter_1<T> = JsonConverter_1$instance<T>;

export interface JsonConverterAttribute$instance extends JsonAttribute {
    readonly converterType: Type;
    createConverter(typeToConvert: Type): JsonConverter;
}


export const JsonConverterAttribute: {
    new(converterType: Type): JsonConverterAttribute$instance;
};


export type JsonConverterAttribute = JsonConverterAttribute$instance;

export interface JsonConverterFactory$instance extends JsonConverter {
    readonly type_: Type;
    createConverter(typeToConvert: Type, options: JsonSerializerOptions): JsonConverter;
}


export const JsonConverterFactory: {
};


export type JsonConverterFactory = JsonConverterFactory$instance;

export interface JsonDerivedTypeAttribute$instance extends JsonAttribute {
    readonly derivedType: Type;
    readonly typeDiscriminator: unknown;
}


export const JsonDerivedTypeAttribute: {
    new(derivedType: Type): JsonDerivedTypeAttribute$instance;
    new(derivedType: Type, typeDiscriminator: string): JsonDerivedTypeAttribute$instance;
    new(derivedType: Type, typeDiscriminator: int): JsonDerivedTypeAttribute$instance;
};


export type JsonDerivedTypeAttribute = JsonDerivedTypeAttribute$instance;

export interface JsonExtensionDataAttribute$instance extends JsonAttribute {
}


export const JsonExtensionDataAttribute: {
    new(): JsonExtensionDataAttribute$instance;
};


export type JsonExtensionDataAttribute = JsonExtensionDataAttribute$instance;

export interface JsonIgnoreAttribute$instance extends JsonAttribute {
    condition: JsonIgnoreCondition;
}


export const JsonIgnoreAttribute: {
    new(): JsonIgnoreAttribute$instance;
};


export type JsonIgnoreAttribute = JsonIgnoreAttribute$instance;

export interface JsonIncludeAttribute$instance extends JsonAttribute {
}


export const JsonIncludeAttribute: {
    new(): JsonIncludeAttribute$instance;
};


export type JsonIncludeAttribute = JsonIncludeAttribute$instance;

export interface JsonNumberEnumConverter_1$instance<TEnum extends number> extends JsonConverterFactory {
    canConvert(typeToConvert: Type): boolean;
    createConverter(typeToConvert: Type, options: JsonSerializerOptions): JsonConverter;
}


export const JsonNumberEnumConverter_1: {
    new<TEnum extends number>(): JsonNumberEnumConverter_1$instance<TEnum>;
};


export type JsonNumberEnumConverter_1<TEnum extends number> = JsonNumberEnumConverter_1$instance<TEnum>;

export interface JsonNumberHandlingAttribute$instance extends JsonAttribute {
    readonly handling: JsonNumberHandling;
}


export const JsonNumberHandlingAttribute: {
    new(handling: JsonNumberHandling): JsonNumberHandlingAttribute$instance;
};


export type JsonNumberHandlingAttribute = JsonNumberHandlingAttribute$instance;

export interface JsonObjectCreationHandlingAttribute$instance extends JsonAttribute {
    readonly handling: JsonObjectCreationHandling;
}


export const JsonObjectCreationHandlingAttribute: {
    new(handling: JsonObjectCreationHandling): JsonObjectCreationHandlingAttribute$instance;
};


export type JsonObjectCreationHandlingAttribute = JsonObjectCreationHandlingAttribute$instance;

export interface JsonPolymorphicAttribute$instance extends JsonAttribute {
    ignoreUnrecognizedTypeDiscriminators: boolean;
    typeDiscriminatorPropertyName: string;
    unknownDerivedTypeHandling: JsonUnknownDerivedTypeHandling;
}


export const JsonPolymorphicAttribute: {
    new(): JsonPolymorphicAttribute$instance;
};


export type JsonPolymorphicAttribute = JsonPolymorphicAttribute$instance;

export interface JsonPropertyNameAttribute$instance extends JsonAttribute {
    readonly name: string;
}


export const JsonPropertyNameAttribute: {
    new(name: string): JsonPropertyNameAttribute$instance;
};


export type JsonPropertyNameAttribute = JsonPropertyNameAttribute$instance;

export interface JsonPropertyOrderAttribute$instance extends JsonAttribute {
    readonly order: int;
}


export const JsonPropertyOrderAttribute: {
    new(order: int): JsonPropertyOrderAttribute$instance;
};


export type JsonPropertyOrderAttribute = JsonPropertyOrderAttribute$instance;

export interface JsonRequiredAttribute$instance extends JsonAttribute {
}


export const JsonRequiredAttribute: {
    new(): JsonRequiredAttribute$instance;
};


export type JsonRequiredAttribute = JsonRequiredAttribute$instance;

export interface JsonSerializableAttribute$instance extends JsonAttribute {
    generationMode: JsonSourceGenerationMode;
    typeInfoPropertyName: string;
}


export const JsonSerializableAttribute: {
    new(type_: Type): JsonSerializableAttribute$instance;
};


export type JsonSerializableAttribute = JsonSerializableAttribute$instance;

export interface JsonSerializerContext$instance {
    readonly options: JsonSerializerOptions;
    getTypeInfo(type_: Type): JsonTypeInfo;
}


export const JsonSerializerContext: {
};


export interface __JsonSerializerContext$views {
    As_IJsonTypeInfoResolver(): System_Text_Json_Serialization_Metadata_Internal.IJsonTypeInfoResolver$instance;
}

export type JsonSerializerContext = JsonSerializerContext$instance & __JsonSerializerContext$views;


export interface JsonSourceGenerationOptionsAttribute$instance extends JsonAttribute {
    allowDuplicateProperties: boolean;
    allowOutOfOrderMetadataProperties: boolean;
    allowTrailingCommas: boolean;
    converters: Type[];
    defaultBufferSize: int;
    defaultIgnoreCondition: JsonIgnoreCondition;
    dictionaryKeyPolicy: JsonKnownNamingPolicy;
    generationMode: JsonSourceGenerationMode;
    ignoreReadOnlyFields: boolean;
    ignoreReadOnlyProperties: boolean;
    includeFields: boolean;
    indentCharacter: char;
    indentSize: int;
    maxDepth: int;
    newLine: string;
    numberHandling: JsonNumberHandling;
    preferredObjectCreationHandling: JsonObjectCreationHandling;
    propertyNameCaseInsensitive: boolean;
    propertyNamingPolicy: JsonKnownNamingPolicy;
    readCommentHandling: JsonCommentHandling;
    referenceHandler: JsonKnownReferenceHandler;
    respectNullableAnnotations: boolean;
    respectRequiredConstructorParameters: boolean;
    unknownTypeHandling: JsonUnknownTypeHandling;
    unmappedMemberHandling: JsonUnmappedMemberHandling;
    useStringEnumConverter: boolean;
    writeIndented: boolean;
}


export const JsonSourceGenerationOptionsAttribute: {
    new(): JsonSourceGenerationOptionsAttribute$instance;
    new(defaults: JsonSerializerDefaults): JsonSourceGenerationOptionsAttribute$instance;
};


export type JsonSourceGenerationOptionsAttribute = JsonSourceGenerationOptionsAttribute$instance;

export interface JsonStringEnumConverter$instance extends JsonConverterFactory {
    canConvert(typeToConvert: Type): boolean;
    createConverter(typeToConvert: Type, options: JsonSerializerOptions): JsonConverter;
}


export const JsonStringEnumConverter: {
    new(): JsonStringEnumConverter$instance;
    new(namingPolicy: JsonNamingPolicy, allowIntegerValues: boolean): JsonStringEnumConverter$instance;
};


export type JsonStringEnumConverter = JsonStringEnumConverter$instance;

export interface JsonStringEnumConverter_1$instance<TEnum extends number> extends JsonConverterFactory {
    canConvert(typeToConvert: Type): boolean;
    createConverter(typeToConvert: Type, options: JsonSerializerOptions): JsonConverter;
}


export const JsonStringEnumConverter_1: {
    new<TEnum extends number>(): JsonStringEnumConverter_1$instance<TEnum>;
    new<TEnum extends number>(namingPolicy: JsonNamingPolicy, allowIntegerValues: boolean): JsonStringEnumConverter_1$instance<TEnum>;
};


export type JsonStringEnumConverter_1<TEnum extends number> = JsonStringEnumConverter_1$instance<TEnum>;

export interface JsonStringEnumMemberNameAttribute$instance extends Attribute {
    readonly name: string;
}


export const JsonStringEnumMemberNameAttribute: {
    new(name: string): JsonStringEnumMemberNameAttribute$instance;
};


export type JsonStringEnumMemberNameAttribute = JsonStringEnumMemberNameAttribute$instance;

export interface JsonUnmappedMemberHandlingAttribute$instance extends JsonAttribute {
    readonly unmappedMemberHandling: JsonUnmappedMemberHandling;
}


export const JsonUnmappedMemberHandlingAttribute: {
    new(unmappedMemberHandling: JsonUnmappedMemberHandling): JsonUnmappedMemberHandlingAttribute$instance;
};


export type JsonUnmappedMemberHandlingAttribute = JsonUnmappedMemberHandlingAttribute$instance;

export interface ReferenceHandler$instance {
    createResolver(): ReferenceResolver;
}


export const ReferenceHandler: {
    readonly preserve: ReferenceHandler;
    readonly ignoreCycles: ReferenceHandler;
};


export type ReferenceHandler = ReferenceHandler$instance;

export interface ReferenceHandler_1$instance<T extends ReferenceResolver> extends ReferenceHandler {
    createResolver(): ReferenceResolver;
}


export const ReferenceHandler_1: {
    new<T extends ReferenceResolver>(): ReferenceHandler_1$instance<T>;
};


export type ReferenceHandler_1<T extends ReferenceResolver> = ReferenceHandler_1$instance<T>;

export interface ReferenceResolver$instance {
    addReference(referenceId: string, value: unknown): void;
    getReference(value: unknown, alreadyExists: { value: ref<boolean> }): string;
    resolveReference(referenceId: string): unknown;
}


export const ReferenceResolver: {
};


export type ReferenceResolver = ReferenceResolver$instance;

