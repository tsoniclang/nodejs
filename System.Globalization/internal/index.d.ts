// Generated by tsbindgen - Architecture
// Namespace: System.Globalization
// Assembly: System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IDictionary, IEnumerator } from "../../System.Collections/internal/index.js";
import type { Assembly, MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { Rune } from "../../System.Text/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ArgumentException, Boolean as ClrBoolean, Byte, Char, DateOnly, DateTime, DayOfWeek, Double, Enum, Exception, Guid, ICloneable, IComparable, IConvertible, IEquatable_1, IFormatProvider, IFormattable, Int32, ISpanFormattable, Nullable_1, Object as ClrObject, ReadOnlySpan_1, Span_1, String as ClrString, StringComparer, TimeSpan, Type, TypeCode, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum CalendarAlgorithmType {
    unknown_ = 0,
    solarCalendar = 1,
    lunarCalendar = 2,
    lunisolarCalendar = 3
}


export enum CalendarWeekRule {
    firstDay = 0,
    firstFullWeek = 1,
    firstFourDayWeek = 2
}


export enum CompareOptions {
    none = 0,
    ignoreCase = 1,
    ignoreNonSpace = 2,
    ignoreSymbols = 4,
    ignoreKanaType = 8,
    ignoreWidth = 16,
    numericOrdering = 32,
    ordinalIgnoreCase = 268435456,
    stringSort = 536870912,
    ordinal = 1073741824
}


export enum CultureTypes {
    neutralCultures = 1,
    specificCultures = 2,
    installedWin32Cultures = 4,
    allCultures = 7,
    userCustomCulture = 8,
    replacementCultures = 16,
    windowsOnlyCultures = 32,
    frameworkCultures = 64
}


export enum DateTimeStyles {
    none = 0,
    allowLeadingWhite = 1,
    allowTrailingWhite = 2,
    allowInnerWhite = 4,
    allowWhiteSpaces = 7,
    noCurrentDateDefault = 8,
    adjustToUniversal = 16,
    assumeLocal = 32,
    assumeUniversal = 64,
    roundtripKind = 128
}


export enum DigitShapes {
    context = 0,
    none = 1,
    nativeNational = 2
}


export enum GregorianCalendarTypes {
    localized = 1,
    usEnglish = 2,
    middleEastFrench = 9,
    arabic = 10,
    transliteratedEnglish = 11,
    transliteratedFrench = 12
}


export enum NumberStyles {
    none = 0,
    allowLeadingWhite = 1,
    allowTrailingWhite = 2,
    allowLeadingSign = 4,
    allowTrailingSign = 8,
    allowParentheses = 16,
    allowDecimalPoint = 32,
    allowThousands = 64,
    allowExponent = 128,
    allowCurrencySymbol = 256,
    allowHexSpecifier = 512,
    allowBinarySpecifier = 1024,
    integer = 7,
    hexNumber = 515,
    binaryNumber = 1027,
    number_ = 111,
    float = 167,
    currency = 383,
    any_ = 511
}


export enum TimeSpanStyles {
    none = 0,
    assumeNegative = 1
}


export enum UnicodeCategory {
    uppercaseLetter = 0,
    lowercaseLetter = 1,
    titlecaseLetter = 2,
    modifierLetter = 3,
    otherLetter = 4,
    nonSpacingMark = 5,
    spacingCombiningMark = 6,
    enclosingMark = 7,
    decimalDigitNumber = 8,
    letterNumber = 9,
    otherNumber = 10,
    spaceSeparator = 11,
    lineSeparator = 12,
    paragraphSeparator = 13,
    control = 14,
    format = 15,
    surrogate = 16,
    privateUse = 17,
    connectorPunctuation = 18,
    dashPunctuation = 19,
    openPunctuation = 20,
    closePunctuation = 21,
    initialQuotePunctuation = 22,
    finalQuotePunctuation = 23,
    otherPunctuation = 24,
    mathSymbol = 25,
    currencySymbol = 26,
    modifierSymbol = 27,
    otherSymbol = 28,
    otherNotAssigned = 29
}


export interface Calendar$instance {
    readonly algorithmType: CalendarAlgorithmType;
    readonly eras: int[];
    readonly isReadOnly: boolean;
    readonly maxSupportedDateTime: DateTime;
    readonly minSupportedDateTime: DateTime;
    twoDigitYearMax: int;
    addDays(time: DateTime, days: int): DateTime;
    addHours(time: DateTime, hours: int): DateTime;
    addMilliseconds(time: DateTime, milliseconds: double): DateTime;
    addMinutes(time: DateTime, minutes: int): DateTime;
    addMonths(time: DateTime, months: int): DateTime;
    addSeconds(time: DateTime, seconds: int): DateTime;
    addWeeks(time: DateTime, weeks: int): DateTime;
    addYears(time: DateTime, years: int): DateTime;
    clone(): unknown;
    getDayOfMonth(time: DateTime): int;
    getDayOfWeek(time: DateTime): DayOfWeek;
    getDayOfYear(time: DateTime): int;
    getDaysInMonth(year: int, month: int): int;
    getDaysInMonth(year: int, month: int, era: int): int;
    getDaysInYear(year: int): int;
    getDaysInYear(year: int, era: int): int;
    getEra(time: DateTime): int;
    getHour(time: DateTime): int;
    getLeapMonth(year: int): int;
    getLeapMonth(year: int, era: int): int;
    getMilliseconds(time: DateTime): double;
    getMinute(time: DateTime): int;
    getMonth(time: DateTime): int;
    getMonthsInYear(year: int): int;
    getMonthsInYear(year: int, era: int): int;
    getSecond(time: DateTime): int;
    getWeekOfYear(time: DateTime, rule: CalendarWeekRule, firstDayOfWeek: DayOfWeek): int;
    getYear(time: DateTime): int;
    isLeapDay(year: int, month: int, day: int): boolean;
    isLeapDay(year: int, month: int, day: int, era: int): boolean;
    isLeapMonth(year: int, month: int): boolean;
    isLeapMonth(year: int, month: int, era: int): boolean;
    isLeapYear(year: int): boolean;
    isLeapYear(year: int, era: int): boolean;
    toDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    toDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    toFourDigitYear(year: int): int;
}


export const Calendar: {
    readonly currentEra: int;
    readOnly(calendar: Calendar): Calendar;
};


export interface __Calendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface Calendar$instance extends System_Internal.ICloneable$instance {}

export type Calendar = Calendar$instance & __Calendar$views;


export interface ChineseLunisolarCalendar$instance extends EastAsianLunisolarCalendar$instance {
    readonly eras: int[];
    readonly maxSupportedDateTime: DateTime;
    readonly minSupportedDateTime: DateTime;
    clone(): unknown;
    getEra(time: DateTime): int;
}


export const ChineseLunisolarCalendar: {
    new(): ChineseLunisolarCalendar$instance;
    readonly chineseEra: int;
};


export interface __ChineseLunisolarCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type ChineseLunisolarCalendar = ChineseLunisolarCalendar$instance & __ChineseLunisolarCalendar$views;


export interface CompareInfo$instance {
    readonly LCID: int;
    readonly name: string;
    readonly version: SortVersion;
    compare(string1: string, string2: string): int;
    compare(string1: string, string2: string, options: CompareOptions): int;
    compare(string1: string, offset1: int, length1: int, string2: string, offset2: int, length2: int): int;
    compare(string1: string, offset1: int, string2: string, offset2: int, options: CompareOptions): int;
    compare(string1: string, offset1: int, string2: string, offset2: int): int;
    compare(string1: string, offset1: int, length1: int, string2: string, offset2: int, length2: int, options: CompareOptions): int;
    compare(string1: ReadOnlySpan_1<CLROf<char>>, string2: ReadOnlySpan_1<CLROf<char>>, options?: CompareOptions): int;
    equals(value: unknown): boolean;
    getHashCode(): int;
    getHashCode(source: string, options: CompareOptions): int;
    getHashCode(source: ReadOnlySpan_1<CLROf<char>>, options: CompareOptions): int;
    getSortKey(source: string, options: CompareOptions): SortKey;
    getSortKey(source: string): SortKey;
    getSortKey(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<byte>>, options?: CompareOptions): int;
    getSortKeyLength(source: ReadOnlySpan_1<CLROf<char>>, options?: CompareOptions): int;
    indexOf(source: string, value: char): int;
    indexOf(source: string, value: string): int;
    indexOf(source: string, value: char, options: CompareOptions): int;
    indexOf(source: string, value: string, options: CompareOptions): int;
    indexOf(source: string, value: char, startIndex: int): int;
    indexOf(source: string, value: string, startIndex: int): int;
    indexOf(source: string, value: char, startIndex: int, options: CompareOptions): int;
    indexOf(source: string, value: string, startIndex: int, options: CompareOptions): int;
    indexOf(source: string, value: char, startIndex: int, count: int): int;
    indexOf(source: string, value: string, startIndex: int, count: int): int;
    indexOf(source: string, value: char, startIndex: int, count: int, options: CompareOptions): int;
    indexOf(source: string, value: string, startIndex: int, count: int, options: CompareOptions): int;
    indexOf(source: ReadOnlySpan_1<CLROf<char>>, value: ReadOnlySpan_1<CLROf<char>>, options?: CompareOptions): int;
    indexOf(source: ReadOnlySpan_1<CLROf<char>>, value: ReadOnlySpan_1<CLROf<char>>, options: CompareOptions, matchLength: { value: ref<int> }): int;
    indexOf(source: ReadOnlySpan_1<CLROf<char>>, value: Rune, options?: CompareOptions): int;
    isPrefix(source: string, prefix: string, options: CompareOptions): boolean;
    isPrefix(source: ReadOnlySpan_1<CLROf<char>>, prefix: ReadOnlySpan_1<CLROf<char>>, options?: CompareOptions): boolean;
    isPrefix(source: ReadOnlySpan_1<CLROf<char>>, prefix: ReadOnlySpan_1<CLROf<char>>, options: CompareOptions, matchLength: { value: ref<int> }): boolean;
    isPrefix(source: string, prefix: string): boolean;
    isSuffix(source: string, suffix: string, options: CompareOptions): boolean;
    isSuffix(source: ReadOnlySpan_1<CLROf<char>>, suffix: ReadOnlySpan_1<CLROf<char>>, options?: CompareOptions): boolean;
    isSuffix(source: ReadOnlySpan_1<CLROf<char>>, suffix: ReadOnlySpan_1<CLROf<char>>, options: CompareOptions, matchLength: { value: ref<int> }): boolean;
    isSuffix(source: string, suffix: string): boolean;
    lastIndexOf(source: string, value: char): int;
    lastIndexOf(source: string, value: string): int;
    lastIndexOf(source: string, value: char, options: CompareOptions): int;
    lastIndexOf(source: string, value: string, options: CompareOptions): int;
    lastIndexOf(source: string, value: char, startIndex: int): int;
    lastIndexOf(source: string, value: string, startIndex: int): int;
    lastIndexOf(source: string, value: char, startIndex: int, options: CompareOptions): int;
    lastIndexOf(source: string, value: string, startIndex: int, options: CompareOptions): int;
    lastIndexOf(source: string, value: char, startIndex: int, count: int): int;
    lastIndexOf(source: string, value: string, startIndex: int, count: int): int;
    lastIndexOf(source: string, value: char, startIndex: int, count: int, options: CompareOptions): int;
    lastIndexOf(source: string, value: string, startIndex: int, count: int, options: CompareOptions): int;
    lastIndexOf(source: ReadOnlySpan_1<CLROf<char>>, value: ReadOnlySpan_1<CLROf<char>>, options?: CompareOptions): int;
    lastIndexOf(source: ReadOnlySpan_1<CLROf<char>>, value: ReadOnlySpan_1<CLROf<char>>, options: CompareOptions, matchLength: { value: ref<int> }): int;
    lastIndexOf(source: ReadOnlySpan_1<CLROf<char>>, value: Rune, options?: CompareOptions): int;
    toString(): string;
}


export const CompareInfo: {
    new(): CompareInfo$instance;
    getCompareInfo(culture: int, assembly: Assembly): CompareInfo;
    getCompareInfo(culture: int): CompareInfo;
    getCompareInfo(name: string, assembly: Assembly): CompareInfo;
    getCompareInfo(name: string): CompareInfo;
    isSortable(ch: char): boolean;
    isSortable(text: ReadOnlySpan_1<CLROf<char>>): boolean;
    isSortable(text: string): boolean;
    isSortable(value: Rune): boolean;
};


export interface __CompareInfo$views {
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
}

export interface CompareInfo$instance extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance {}

export type CompareInfo = CompareInfo$instance & __CompareInfo$views;


export interface CultureInfo$instance {
    readonly calendar: Calendar;
    readonly compareInfo: CompareInfo;
    readonly cultureTypes: CultureTypes;
    dateTimeFormat: DateTimeFormatInfo;
    readonly displayName: string;
    readonly englishName: string;
    readonly ietfLanguageTag: string;
    readonly isNeutralCulture: boolean;
    readonly isReadOnly: boolean;
    readonly keyboardLayoutId: int;
    readonly LCID: int;
    readonly name: string;
    readonly nativeName: string;
    numberFormat: NumberFormatInfo;
    readonly optionalCalendars: Calendar[];
    readonly parent: CultureInfo;
    readonly textInfo: TextInfo;
    readonly threeLetterISOLanguageName: string;
    readonly threeLetterWindowsLanguageName: string;
    readonly twoLetterISOLanguageName: string;
    readonly useUserOverride: boolean;
    clearCachedData(): void;
    clone(): unknown;
    equals(value: unknown): boolean;
    getConsoleFallbackUICulture(): CultureInfo;
    getFormat(formatType: Type): unknown;
    getHashCode(): int;
    toString(): string;
}


export const CultureInfo: {
    new(name: string): CultureInfo$instance;
    new(name: string, useUserOverride: boolean): CultureInfo$instance;
    new(culture: int): CultureInfo$instance;
    new(culture: int, useUserOverride: boolean): CultureInfo$instance;
    currentCulture: CultureInfo;
    currentUICulture: CultureInfo;
    readonly installedUICulture: CultureInfo;
    defaultThreadCurrentCulture: CultureInfo;
    defaultThreadCurrentUICulture: CultureInfo;
    readonly invariantCulture: CultureInfo;
    createSpecificCulture(name: string): CultureInfo;
    getCultureInfo(culture: int): CultureInfo;
    getCultureInfo(name: string, predefinedOnly: boolean): CultureInfo;
    getCultureInfo(name: string, altName: string): CultureInfo;
    getCultureInfo(name: string): CultureInfo;
    getCultureInfoByIetfLanguageTag(name: string): CultureInfo;
    getCultures(types: CultureTypes): CultureInfo[];
    readOnly(ci: CultureInfo): CultureInfo;
};


export interface __CultureInfo$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IFormatProvider(): System_Internal.IFormatProvider$instance;
}

export interface CultureInfo$instance extends System_Internal.ICloneable$instance, System_Internal.IFormatProvider$instance {}

export type CultureInfo = CultureInfo$instance & __CultureInfo$views;


export interface CultureNotFoundException$instance extends ArgumentException {
    readonly invalidCultureId: Nullable_1<CLROf<int>>;
    readonly invalidCultureName: string;
    readonly message: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const CultureNotFoundException: {
    new(): CultureNotFoundException$instance;
    new(message: string): CultureNotFoundException$instance;
    new(paramName: string, message: string): CultureNotFoundException$instance;
    new(message: string, innerException: Exception): CultureNotFoundException$instance;
    new(paramName: string, invalidCultureName: string, message: string): CultureNotFoundException$instance;
    new(message: string, invalidCultureName: string, innerException: Exception): CultureNotFoundException$instance;
    new(message: string, invalidCultureId: int, innerException: Exception): CultureNotFoundException$instance;
    new(paramName: string, invalidCultureId: int, message: string): CultureNotFoundException$instance;
};


export interface __CultureNotFoundException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type CultureNotFoundException = CultureNotFoundException$instance & __CultureNotFoundException$views;


export interface DateTimeFormatInfo$instance {
    abbreviatedDayNames: string[];
    abbreviatedMonthGenitiveNames: string[];
    abbreviatedMonthNames: string[];
    amDesignator: string;
    calendar: Calendar;
    calendarWeekRule: CalendarWeekRule;
    dateSeparator: string;
    dayNames: string[];
    firstDayOfWeek: DayOfWeek;
    fullDateTimePattern: string;
    readonly isReadOnly: boolean;
    longDatePattern: string;
    longTimePattern: string;
    monthDayPattern: string;
    monthGenitiveNames: string[];
    monthNames: string[];
    readonly nativeCalendarName: string;
    pmDesignator: string;
    readonly rfC1123Pattern: string;
    shortDatePattern: string;
    shortestDayNames: string[];
    shortTimePattern: string;
    readonly sortableDateTimePattern: string;
    timeSeparator: string;
    readonly universalSortableDateTimePattern: string;
    yearMonthPattern: string;
    clone(): unknown;
    getAbbreviatedDayName(dayofweek: DayOfWeek): string;
    getAbbreviatedEraName(era: int): string;
    getAbbreviatedMonthName(month: int): string;
    getAllDateTimePatterns(): string[];
    getAllDateTimePatterns(format: char): string[];
    getDayName(dayofweek: DayOfWeek): string;
    getEra(eraName: string): int;
    getEraName(era: int): string;
    getFormat(formatType: Type): unknown;
    getMonthName(month: int): string;
    getShortestDayName(dayOfWeek: DayOfWeek): string;
    setAllDateTimePatterns(patterns: string[], format: char): void;
}


export const DateTimeFormatInfo: {
    new(): DateTimeFormatInfo$instance;
    readonly invariantInfo: DateTimeFormatInfo;
    readonly currentInfo: DateTimeFormatInfo;
    getInstance(provider: IFormatProvider): DateTimeFormatInfo;
    readOnly(dtfi: DateTimeFormatInfo): DateTimeFormatInfo;
};


export interface __DateTimeFormatInfo$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IFormatProvider(): System_Internal.IFormatProvider$instance;
}

export interface DateTimeFormatInfo$instance extends System_Internal.ICloneable$instance, System_Internal.IFormatProvider$instance {}

export type DateTimeFormatInfo = DateTimeFormatInfo$instance & __DateTimeFormatInfo$views;


export interface DaylightTime$instance {
    readonly delta: TimeSpan;
    readonly end: DateTime;
    readonly start: DateTime;
}


export const DaylightTime: {
    new(start: DateTime, end: DateTime, delta: TimeSpan): DaylightTime$instance;
};


export type DaylightTime = DaylightTime$instance;

export interface EastAsianLunisolarCalendar$instance extends Calendar$instance {
    readonly algorithmType: CalendarAlgorithmType;
    twoDigitYearMax: int;
    addMonths(time: DateTime, months: int): DateTime;
    addYears(time: DateTime, years: int): DateTime;
    clone(): unknown;
    getCelestialStem(sexagenaryYear: int): int;
    getDayOfMonth(time: DateTime): int;
    getDayOfWeek(time: DateTime): DayOfWeek;
    getDayOfYear(time: DateTime): int;
    getDaysInMonth(year: int, month: int, era: int): int;
    getDaysInMonth(year: int, month: int): int;
    getDaysInYear(year: int, era: int): int;
    getDaysInYear(year: int): int;
    getLeapMonth(year: int, era: int): int;
    getLeapMonth(year: int): int;
    getMonth(time: DateTime): int;
    getMonthsInYear(year: int, era: int): int;
    getMonthsInYear(year: int): int;
    getSexagenaryYear(time: DateTime): int;
    getTerrestrialBranch(sexagenaryYear: int): int;
    getYear(time: DateTime): int;
    isLeapDay(year: int, month: int, day: int, era: int): boolean;
    isLeapDay(year: int, month: int, day: int): boolean;
    isLeapMonth(year: int, month: int, era: int): boolean;
    isLeapMonth(year: int, month: int): boolean;
    isLeapYear(year: int, era: int): boolean;
    isLeapYear(year: int): boolean;
    toDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    toDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    toFourDigitYear(year: int): int;
}


export const EastAsianLunisolarCalendar: {
};


export interface __EastAsianLunisolarCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type EastAsianLunisolarCalendar = EastAsianLunisolarCalendar$instance & __EastAsianLunisolarCalendar$views;


export interface GregorianCalendar$instance extends Calendar$instance {
    readonly algorithmType: CalendarAlgorithmType;
    calendarType: GregorianCalendarTypes;
    readonly eras: int[];
    readonly maxSupportedDateTime: DateTime;
    readonly minSupportedDateTime: DateTime;
    twoDigitYearMax: int;
    addMonths(time: DateTime, months: int): DateTime;
    addYears(time: DateTime, years: int): DateTime;
    clone(): unknown;
    getDayOfMonth(time: DateTime): int;
    getDayOfWeek(time: DateTime): DayOfWeek;
    getDayOfYear(time: DateTime): int;
    getDaysInMonth(year: int, month: int, era: int): int;
    getDaysInMonth(year: int, month: int): int;
    getDaysInYear(year: int, era: int): int;
    getDaysInYear(year: int): int;
    getEra(time: DateTime): int;
    getLeapMonth(year: int, era: int): int;
    getLeapMonth(year: int): int;
    getMonth(time: DateTime): int;
    getMonthsInYear(year: int, era: int): int;
    getMonthsInYear(year: int): int;
    getYear(time: DateTime): int;
    isLeapDay(year: int, month: int, day: int, era: int): boolean;
    isLeapDay(year: int, month: int, day: int): boolean;
    isLeapMonth(year: int, month: int, era: int): boolean;
    isLeapMonth(year: int, month: int): boolean;
    isLeapYear(year: int, era: int): boolean;
    isLeapYear(year: int): boolean;
    toDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    toDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    toFourDigitYear(year: int): int;
}


export const GregorianCalendar: {
    new(): GregorianCalendar$instance;
    new(type_: GregorianCalendarTypes): GregorianCalendar$instance;
    readonly adEra: int;
};


export interface __GregorianCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type GregorianCalendar = GregorianCalendar$instance & __GregorianCalendar$views;


export interface HebrewCalendar$instance extends Calendar$instance {
    readonly algorithmType: CalendarAlgorithmType;
    readonly eras: int[];
    readonly maxSupportedDateTime: DateTime;
    readonly minSupportedDateTime: DateTime;
    twoDigitYearMax: int;
    addMonths(time: DateTime, months: int): DateTime;
    addYears(time: DateTime, years: int): DateTime;
    clone(): unknown;
    getDayOfMonth(time: DateTime): int;
    getDayOfWeek(time: DateTime): DayOfWeek;
    getDayOfYear(time: DateTime): int;
    getDaysInMonth(year: int, month: int, era: int): int;
    getDaysInMonth(year: int, month: int): int;
    getDaysInYear(year: int, era: int): int;
    getDaysInYear(year: int): int;
    getEra(time: DateTime): int;
    getLeapMonth(year: int, era: int): int;
    getLeapMonth(year: int): int;
    getMonth(time: DateTime): int;
    getMonthsInYear(year: int, era: int): int;
    getMonthsInYear(year: int): int;
    getYear(time: DateTime): int;
    isLeapDay(year: int, month: int, day: int, era: int): boolean;
    isLeapDay(year: int, month: int, day: int): boolean;
    isLeapMonth(year: int, month: int, era: int): boolean;
    isLeapMonth(year: int, month: int): boolean;
    isLeapYear(year: int, era: int): boolean;
    isLeapYear(year: int): boolean;
    toDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    toDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    toFourDigitYear(year: int): int;
}


export const HebrewCalendar: {
    new(): HebrewCalendar$instance;
    readonly hebrewEra: int;
};


export interface __HebrewCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type HebrewCalendar = HebrewCalendar$instance & __HebrewCalendar$views;


export interface HijriCalendar$instance extends Calendar$instance {
    readonly algorithmType: CalendarAlgorithmType;
    readonly eras: int[];
    hijriAdjustment: int;
    readonly maxSupportedDateTime: DateTime;
    readonly minSupportedDateTime: DateTime;
    twoDigitYearMax: int;
    addMonths(time: DateTime, months: int): DateTime;
    addYears(time: DateTime, years: int): DateTime;
    clone(): unknown;
    getDayOfMonth(time: DateTime): int;
    getDayOfWeek(time: DateTime): DayOfWeek;
    getDayOfYear(time: DateTime): int;
    getDaysInMonth(year: int, month: int, era: int): int;
    getDaysInMonth(year: int, month: int): int;
    getDaysInYear(year: int, era: int): int;
    getDaysInYear(year: int): int;
    getEra(time: DateTime): int;
    getLeapMonth(year: int, era: int): int;
    getLeapMonth(year: int): int;
    getMonth(time: DateTime): int;
    getMonthsInYear(year: int, era: int): int;
    getMonthsInYear(year: int): int;
    getYear(time: DateTime): int;
    isLeapDay(year: int, month: int, day: int, era: int): boolean;
    isLeapDay(year: int, month: int, day: int): boolean;
    isLeapMonth(year: int, month: int, era: int): boolean;
    isLeapMonth(year: int, month: int): boolean;
    isLeapYear(year: int, era: int): boolean;
    isLeapYear(year: int): boolean;
    toDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    toDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    toFourDigitYear(year: int): int;
}


export const HijriCalendar: {
    new(): HijriCalendar$instance;
    readonly hijriEra: int;
};


export interface __HijriCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type HijriCalendar = HijriCalendar$instance & __HijriCalendar$views;


export interface IdnMapping$instance {
    allowUnassigned: boolean;
    useStd3AsciiRules: boolean;
    equals(obj: unknown): boolean;
    getAscii(unicode: string): string;
    getAscii(unicode: string, index: int): string;
    getAscii(unicode: string, index: int, count: int): string;
    getHashCode(): int;
    getUnicode(ascii: string): string;
    getUnicode(ascii: string, index: int): string;
    getUnicode(ascii: string, index: int, count: int): string;
}


export const IdnMapping: {
    new(): IdnMapping$instance;
};


export type IdnMapping = IdnMapping$instance;

export interface JapaneseCalendar$instance extends Calendar$instance {
    readonly algorithmType: CalendarAlgorithmType;
    readonly eras: int[];
    readonly maxSupportedDateTime: DateTime;
    readonly minSupportedDateTime: DateTime;
    twoDigitYearMax: int;
    addMonths(time: DateTime, months: int): DateTime;
    addYears(time: DateTime, years: int): DateTime;
    clone(): unknown;
    getDayOfMonth(time: DateTime): int;
    getDayOfWeek(time: DateTime): DayOfWeek;
    getDayOfYear(time: DateTime): int;
    getDaysInMonth(year: int, month: int, era: int): int;
    getDaysInMonth(year: int, month: int): int;
    getDaysInYear(year: int, era: int): int;
    getDaysInYear(year: int): int;
    getEra(time: DateTime): int;
    getLeapMonth(year: int, era: int): int;
    getLeapMonth(year: int): int;
    getMonth(time: DateTime): int;
    getMonthsInYear(year: int, era: int): int;
    getMonthsInYear(year: int): int;
    getWeekOfYear(time: DateTime, rule: CalendarWeekRule, firstDayOfWeek: DayOfWeek): int;
    getYear(time: DateTime): int;
    isLeapDay(year: int, month: int, day: int, era: int): boolean;
    isLeapDay(year: int, month: int, day: int): boolean;
    isLeapMonth(year: int, month: int, era: int): boolean;
    isLeapMonth(year: int, month: int): boolean;
    isLeapYear(year: int, era: int): boolean;
    isLeapYear(year: int): boolean;
    toDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    toDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    toFourDigitYear(year: int): int;
}


export const JapaneseCalendar: {
    new(): JapaneseCalendar$instance;
};


export interface __JapaneseCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type JapaneseCalendar = JapaneseCalendar$instance & __JapaneseCalendar$views;


export interface JapaneseLunisolarCalendar$instance extends EastAsianLunisolarCalendar$instance {
    readonly eras: int[];
    readonly maxSupportedDateTime: DateTime;
    readonly minSupportedDateTime: DateTime;
    clone(): unknown;
    getEra(time: DateTime): int;
}


export const JapaneseLunisolarCalendar: {
    new(): JapaneseLunisolarCalendar$instance;
    readonly japaneseEra: int;
};


export interface __JapaneseLunisolarCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type JapaneseLunisolarCalendar = JapaneseLunisolarCalendar$instance & __JapaneseLunisolarCalendar$views;


export interface JulianCalendar$instance extends Calendar$instance {
    readonly algorithmType: CalendarAlgorithmType;
    readonly eras: int[];
    readonly maxSupportedDateTime: DateTime;
    readonly minSupportedDateTime: DateTime;
    twoDigitYearMax: int;
    addMonths(time: DateTime, months: int): DateTime;
    addYears(time: DateTime, years: int): DateTime;
    clone(): unknown;
    getDayOfMonth(time: DateTime): int;
    getDayOfWeek(time: DateTime): DayOfWeek;
    getDayOfYear(time: DateTime): int;
    getDaysInMonth(year: int, month: int, era: int): int;
    getDaysInMonth(year: int, month: int): int;
    getDaysInYear(year: int, era: int): int;
    getDaysInYear(year: int): int;
    getEra(time: DateTime): int;
    getLeapMonth(year: int, era: int): int;
    getLeapMonth(year: int): int;
    getMonth(time: DateTime): int;
    getMonthsInYear(year: int, era: int): int;
    getMonthsInYear(year: int): int;
    getYear(time: DateTime): int;
    isLeapDay(year: int, month: int, day: int, era: int): boolean;
    isLeapDay(year: int, month: int, day: int): boolean;
    isLeapMonth(year: int, month: int, era: int): boolean;
    isLeapMonth(year: int, month: int): boolean;
    isLeapYear(year: int, era: int): boolean;
    isLeapYear(year: int): boolean;
    toDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    toDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    toFourDigitYear(year: int): int;
}


export const JulianCalendar: {
    new(): JulianCalendar$instance;
    readonly julianEra: int;
};


export interface __JulianCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type JulianCalendar = JulianCalendar$instance & __JulianCalendar$views;


export interface KoreanCalendar$instance extends Calendar$instance {
    readonly algorithmType: CalendarAlgorithmType;
    readonly eras: int[];
    readonly maxSupportedDateTime: DateTime;
    readonly minSupportedDateTime: DateTime;
    twoDigitYearMax: int;
    addMonths(time: DateTime, months: int): DateTime;
    addYears(time: DateTime, years: int): DateTime;
    clone(): unknown;
    getDayOfMonth(time: DateTime): int;
    getDayOfWeek(time: DateTime): DayOfWeek;
    getDayOfYear(time: DateTime): int;
    getDaysInMonth(year: int, month: int, era: int): int;
    getDaysInMonth(year: int, month: int): int;
    getDaysInYear(year: int, era: int): int;
    getDaysInYear(year: int): int;
    getEra(time: DateTime): int;
    getLeapMonth(year: int, era: int): int;
    getLeapMonth(year: int): int;
    getMonth(time: DateTime): int;
    getMonthsInYear(year: int, era: int): int;
    getMonthsInYear(year: int): int;
    getWeekOfYear(time: DateTime, rule: CalendarWeekRule, firstDayOfWeek: DayOfWeek): int;
    getYear(time: DateTime): int;
    isLeapDay(year: int, month: int, day: int, era: int): boolean;
    isLeapDay(year: int, month: int, day: int): boolean;
    isLeapMonth(year: int, month: int, era: int): boolean;
    isLeapMonth(year: int, month: int): boolean;
    isLeapYear(year: int, era: int): boolean;
    isLeapYear(year: int): boolean;
    toDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    toDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    toFourDigitYear(year: int): int;
}


export const KoreanCalendar: {
    new(): KoreanCalendar$instance;
    readonly koreanEra: int;
};


export interface __KoreanCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type KoreanCalendar = KoreanCalendar$instance & __KoreanCalendar$views;


export interface KoreanLunisolarCalendar$instance extends EastAsianLunisolarCalendar$instance {
    readonly eras: int[];
    readonly maxSupportedDateTime: DateTime;
    readonly minSupportedDateTime: DateTime;
    clone(): unknown;
    getEra(time: DateTime): int;
}


export const KoreanLunisolarCalendar: {
    new(): KoreanLunisolarCalendar$instance;
    readonly gregorianEra: int;
};


export interface __KoreanLunisolarCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type KoreanLunisolarCalendar = KoreanLunisolarCalendar$instance & __KoreanLunisolarCalendar$views;


export interface NumberFormatInfo$instance {
    currencyDecimalDigits: int;
    currencyDecimalSeparator: string;
    currencyGroupSeparator: string;
    currencyGroupSizes: int[];
    currencyNegativePattern: int;
    currencyPositivePattern: int;
    currencySymbol: string;
    digitSubstitution: DigitShapes;
    readonly isReadOnly: boolean;
    naNSymbol: string;
    nativeDigits: string[];
    negativeInfinitySymbol: string;
    negativeSign: string;
    numberDecimalDigits: int;
    numberDecimalSeparator: string;
    numberGroupSeparator: string;
    numberGroupSizes: int[];
    numberNegativePattern: int;
    percentDecimalDigits: int;
    percentDecimalSeparator: string;
    percentGroupSeparator: string;
    percentGroupSizes: int[];
    percentNegativePattern: int;
    percentPositivePattern: int;
    percentSymbol: string;
    perMilleSymbol: string;
    positiveInfinitySymbol: string;
    positiveSign: string;
    clone(): unknown;
    getFormat(formatType: Type): unknown;
}


export const NumberFormatInfo: {
    new(): NumberFormatInfo$instance;
    readonly invariantInfo: NumberFormatInfo;
    readonly currentInfo: NumberFormatInfo;
    getInstance(formatProvider: IFormatProvider): NumberFormatInfo;
    readOnly(nfi: NumberFormatInfo): NumberFormatInfo;
};


export interface __NumberFormatInfo$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IFormatProvider(): System_Internal.IFormatProvider$instance;
}

export interface NumberFormatInfo$instance extends System_Internal.ICloneable$instance, System_Internal.IFormatProvider$instance {}

export type NumberFormatInfo = NumberFormatInfo$instance & __NumberFormatInfo$views;


export interface PersianCalendar$instance extends Calendar$instance {
    readonly algorithmType: CalendarAlgorithmType;
    readonly eras: int[];
    readonly maxSupportedDateTime: DateTime;
    readonly minSupportedDateTime: DateTime;
    twoDigitYearMax: int;
    addMonths(time: DateTime, months: int): DateTime;
    addYears(time: DateTime, years: int): DateTime;
    clone(): unknown;
    getDayOfMonth(time: DateTime): int;
    getDayOfWeek(time: DateTime): DayOfWeek;
    getDayOfYear(time: DateTime): int;
    getDaysInMonth(year: int, month: int, era: int): int;
    getDaysInMonth(year: int, month: int): int;
    getDaysInYear(year: int, era: int): int;
    getDaysInYear(year: int): int;
    getEra(time: DateTime): int;
    getLeapMonth(year: int, era: int): int;
    getLeapMonth(year: int): int;
    getMonth(time: DateTime): int;
    getMonthsInYear(year: int, era: int): int;
    getMonthsInYear(year: int): int;
    getYear(time: DateTime): int;
    isLeapDay(year: int, month: int, day: int, era: int): boolean;
    isLeapDay(year: int, month: int, day: int): boolean;
    isLeapMonth(year: int, month: int, era: int): boolean;
    isLeapMonth(year: int, month: int): boolean;
    isLeapYear(year: int, era: int): boolean;
    isLeapYear(year: int): boolean;
    toDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    toDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    toFourDigitYear(year: int): int;
}


export const PersianCalendar: {
    new(): PersianCalendar$instance;
    readonly persianEra: int;
};


export interface __PersianCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type PersianCalendar = PersianCalendar$instance & __PersianCalendar$views;


export interface RegionInfo$instance {
    readonly currencyEnglishName: string;
    readonly currencyNativeName: string;
    readonly currencySymbol: string;
    readonly displayName: string;
    readonly englishName: string;
    readonly geoId: int;
    readonly isMetric: boolean;
    readonly isoCurrencySymbol: string;
    readonly name: string;
    readonly nativeName: string;
    readonly threeLetterISORegionName: string;
    readonly threeLetterWindowsRegionName: string;
    readonly twoLetterISORegionName: string;
    equals(value: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RegionInfo: {
    new(name: string): RegionInfo$instance;
    new(culture: int): RegionInfo$instance;
    readonly currentRegion: RegionInfo;
};


export type RegionInfo = RegionInfo$instance;

export interface SortKey$instance {
    readonly keyData: byte[];
    readonly originalString: string;
    equals(value: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const SortKey: {
    new(): SortKey$instance;
    compare(sortkey1: SortKey, sortkey2: SortKey): int;
};


export type SortKey = SortKey$instance;

export interface SortVersion$instance {
    readonly fullVersion: int;
    readonly sortId: Guid;
    equals(obj: unknown): boolean;
    equals(other: SortVersion): boolean;
    getHashCode(): int;
}


export const SortVersion: {
    new(fullVersion: int, sortId: Guid): SortVersion$instance;
};


export interface __SortVersion$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SortVersion>;

    // Structural method bridges for numeric interface constraints
    Equals(other: SortVersion): boolean;
}

export type SortVersion = SortVersion$instance & __SortVersion$views;


export interface StringInfo$instance {
    readonly lengthInTextElements: int;
    string_: string;
    equals(value: unknown): boolean;
    getHashCode(): int;
    substringByTextElements(startingTextElement: int): string;
    substringByTextElements(startingTextElement: int, lengthInTextElements: int): string;
}


export const StringInfo: {
    new(): StringInfo$instance;
    new(value: string): StringInfo$instance;
    getNextTextElement(str: string, index: int): string;
    getNextTextElement(str: string): string;
    getNextTextElementLength(str: ReadOnlySpan_1<CLROf<char>>): int;
    getNextTextElementLength(str: string, index: int): int;
    getNextTextElementLength(str: string): int;
    getTextElementEnumerator(str: string, index: int): TextElementEnumerator;
    getTextElementEnumerator(str: string): TextElementEnumerator;
    parseCombiningCharacters(str: string): int[];
};


export type StringInfo = StringInfo$instance;

export interface TaiwanCalendar$instance extends Calendar$instance {
    readonly algorithmType: CalendarAlgorithmType;
    readonly eras: int[];
    readonly maxSupportedDateTime: DateTime;
    readonly minSupportedDateTime: DateTime;
    twoDigitYearMax: int;
    addMonths(time: DateTime, months: int): DateTime;
    addYears(time: DateTime, years: int): DateTime;
    clone(): unknown;
    getDayOfMonth(time: DateTime): int;
    getDayOfWeek(time: DateTime): DayOfWeek;
    getDayOfYear(time: DateTime): int;
    getDaysInMonth(year: int, month: int, era: int): int;
    getDaysInMonth(year: int, month: int): int;
    getDaysInYear(year: int, era: int): int;
    getDaysInYear(year: int): int;
    getEra(time: DateTime): int;
    getLeapMonth(year: int, era: int): int;
    getLeapMonth(year: int): int;
    getMonth(time: DateTime): int;
    getMonthsInYear(year: int, era: int): int;
    getMonthsInYear(year: int): int;
    getWeekOfYear(time: DateTime, rule: CalendarWeekRule, firstDayOfWeek: DayOfWeek): int;
    getYear(time: DateTime): int;
    isLeapDay(year: int, month: int, day: int, era: int): boolean;
    isLeapDay(year: int, month: int, day: int): boolean;
    isLeapMonth(year: int, month: int, era: int): boolean;
    isLeapMonth(year: int, month: int): boolean;
    isLeapYear(year: int, era: int): boolean;
    isLeapYear(year: int): boolean;
    toDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    toDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    toFourDigitYear(year: int): int;
}


export const TaiwanCalendar: {
    new(): TaiwanCalendar$instance;
};


export interface __TaiwanCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type TaiwanCalendar = TaiwanCalendar$instance & __TaiwanCalendar$views;


export interface TaiwanLunisolarCalendar$instance extends EastAsianLunisolarCalendar$instance {
    readonly eras: int[];
    readonly maxSupportedDateTime: DateTime;
    readonly minSupportedDateTime: DateTime;
    clone(): unknown;
    getEra(time: DateTime): int;
}


export const TaiwanLunisolarCalendar: {
    new(): TaiwanLunisolarCalendar$instance;
};


export interface __TaiwanLunisolarCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type TaiwanLunisolarCalendar = TaiwanLunisolarCalendar$instance & __TaiwanLunisolarCalendar$views;


export interface TextElementEnumerator$instance {
    readonly current: unknown;
    readonly elementIndex: int;
    getTextElement(): string;
    moveNext(): boolean;
    reset(): void;
}


export const TextElementEnumerator: {
    new(): TextElementEnumerator$instance;
};


export interface __TextElementEnumerator$views {
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export interface TextElementEnumerator$instance extends System_Collections_Internal.IEnumerator$instance {}

export type TextElementEnumerator = TextElementEnumerator$instance & __TextElementEnumerator$views;


export interface TextInfo$instance {
    readonly ansiCodePage: int;
    readonly cultureName: string;
    readonly ebcdicCodePage: int;
    readonly isReadOnly: boolean;
    readonly isRightToLeft: boolean;
    readonly LCID: int;
    listSeparator: string;
    readonly macCodePage: int;
    readonly oemCodePage: int;
    clone(): unknown;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toLower(c: char): char;
    toLower(str: string): string;
    toString(): string;
    toTitleCase(str: string): string;
    toUpper(c: char): char;
    toUpper(str: string): string;
}


export const TextInfo: {
    new(): TextInfo$instance;
    readOnly(textInfo: TextInfo): TextInfo;
};


export interface __TextInfo$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
}

export interface TextInfo$instance extends System_Internal.ICloneable$instance, System_Runtime_Serialization_Internal.IDeserializationCallback$instance {}

export type TextInfo = TextInfo$instance & __TextInfo$views;


export interface ThaiBuddhistCalendar$instance extends Calendar$instance {
    readonly algorithmType: CalendarAlgorithmType;
    readonly eras: int[];
    readonly maxSupportedDateTime: DateTime;
    readonly minSupportedDateTime: DateTime;
    twoDigitYearMax: int;
    addMonths(time: DateTime, months: int): DateTime;
    addYears(time: DateTime, years: int): DateTime;
    clone(): unknown;
    getDayOfMonth(time: DateTime): int;
    getDayOfWeek(time: DateTime): DayOfWeek;
    getDayOfYear(time: DateTime): int;
    getDaysInMonth(year: int, month: int, era: int): int;
    getDaysInMonth(year: int, month: int): int;
    getDaysInYear(year: int, era: int): int;
    getDaysInYear(year: int): int;
    getEra(time: DateTime): int;
    getLeapMonth(year: int, era: int): int;
    getLeapMonth(year: int): int;
    getMonth(time: DateTime): int;
    getMonthsInYear(year: int, era: int): int;
    getMonthsInYear(year: int): int;
    getWeekOfYear(time: DateTime, rule: CalendarWeekRule, firstDayOfWeek: DayOfWeek): int;
    getYear(time: DateTime): int;
    isLeapDay(year: int, month: int, day: int, era: int): boolean;
    isLeapDay(year: int, month: int, day: int): boolean;
    isLeapMonth(year: int, month: int, era: int): boolean;
    isLeapMonth(year: int, month: int): boolean;
    isLeapYear(year: int, era: int): boolean;
    isLeapYear(year: int): boolean;
    toDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    toDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    toFourDigitYear(year: int): int;
}


export const ThaiBuddhistCalendar: {
    new(): ThaiBuddhistCalendar$instance;
    readonly thaiBuddhistEra: int;
};


export interface __ThaiBuddhistCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type ThaiBuddhistCalendar = ThaiBuddhistCalendar$instance & __ThaiBuddhistCalendar$views;


export interface UmAlQuraCalendar$instance extends Calendar$instance {
    readonly algorithmType: CalendarAlgorithmType;
    readonly eras: int[];
    readonly maxSupportedDateTime: DateTime;
    readonly minSupportedDateTime: DateTime;
    twoDigitYearMax: int;
    addMonths(time: DateTime, months: int): DateTime;
    addYears(time: DateTime, years: int): DateTime;
    clone(): unknown;
    getDayOfMonth(time: DateTime): int;
    getDayOfWeek(time: DateTime): DayOfWeek;
    getDayOfYear(time: DateTime): int;
    getDaysInMonth(year: int, month: int, era: int): int;
    getDaysInMonth(year: int, month: int): int;
    getDaysInYear(year: int, era: int): int;
    getDaysInYear(year: int): int;
    getEra(time: DateTime): int;
    getLeapMonth(year: int, era: int): int;
    getLeapMonth(year: int): int;
    getMonth(time: DateTime): int;
    getMonthsInYear(year: int, era: int): int;
    getMonthsInYear(year: int): int;
    getYear(time: DateTime): int;
    isLeapDay(year: int, month: int, day: int, era: int): boolean;
    isLeapDay(year: int, month: int, day: int): boolean;
    isLeapMonth(year: int, month: int, era: int): boolean;
    isLeapMonth(year: int, month: int): boolean;
    isLeapYear(year: int, era: int): boolean;
    isLeapYear(year: int): boolean;
    toDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    toDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    toFourDigitYear(year: int): int;
}


export const UmAlQuraCalendar: {
    new(): UmAlQuraCalendar$instance;
    readonly umAlQuraEra: int;
};


export interface __UmAlQuraCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type UmAlQuraCalendar = UmAlQuraCalendar$instance & __UmAlQuraCalendar$views;


export abstract class CharUnicodeInfo$instance {
    static getDecimalDigitValue(ch: char): int;
    static getDecimalDigitValue(s: string, index: int): int;
    static getDigitValue(ch: char): int;
    static getDigitValue(s: string, index: int): int;
    static getNumericValue(ch: char): double;
    static getNumericValue(s: string, index: int): double;
    static getUnicodeCategory(ch: char): UnicodeCategory;
    static getUnicodeCategory(codePoint: int): UnicodeCategory;
    static getUnicodeCategory(s: string, index: int): UnicodeCategory;
}


export type CharUnicodeInfo = CharUnicodeInfo$instance;

export abstract class GlobalizationExtensions$instance {
    static getStringComparer(compareInfo: CompareInfo, options: CompareOptions): StringComparer;
}


export type GlobalizationExtensions = GlobalizationExtensions$instance;

export abstract class ISOWeek$instance {
    static getWeekOfYear(date: DateOnly): int;
    static getWeekOfYear(date: DateTime): int;
    static getWeeksInYear(year: int): int;
    static getYear(date: DateOnly): int;
    static getYear(date: DateTime): int;
    static getYearEnd(year: int): DateTime;
    static getYearStart(year: int): DateTime;
    static toDateOnly(year: int, week: int, dayOfWeek: DayOfWeek): DateOnly;
    static toDateTime(year: int, week: int, dayOfWeek: DayOfWeek): DateTime;
}


export type ISOWeek = ISOWeek$instance;

