// Generated by tsbindgen - Architecture
// Namespace: System.Reflection.Metadata.Ecma335
// Assembly: System.Reflection.Metadata

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { IEnumerable_1, IReadOnlyList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ImmutableArray_1 } from "../../System.Collections.Immutable/internal/index.js";
import type { AssemblyDefinitionHandle, AssemblyFileHandle, AssemblyReferenceHandle, Blob, BlobBuilder, BlobContentId, BlobHandle, BlobReader, ConstantHandle, CustomAttributeHandle, CustomDebugInformationHandle, DeclarativeSecurityAttributeHandle, DocumentHandle, DocumentNameBlobHandle, EntityHandle, EventDefinitionHandle, ExceptionRegionKind, ExportedType, ExportedTypeHandle, FieldDefinitionHandle, GenericParameterConstraintHandle, GenericParameterHandle, GuidHandle, Handle, HandleKind, ILOpCode, ImportScopeHandle, InterfaceImplementationHandle, ISignatureTypeProvider_2, LocalConstantHandle, LocalScopeHandle, LocalVariableAttributes, LocalVariableHandle, ManifestResourceHandle, MemberReferenceHandle, MetadataReader, MethodDebugInformationHandle, MethodDefinitionHandle, MethodImplementationHandle, MethodSignature_1, MethodSpecificationHandle, ModuleDefinitionHandle, ModuleReferenceHandle, ParameterHandle, PrimitiveSerializationTypeCode, PrimitiveTypeCode, PropertyDefinitionHandle, ReservedBlob_1, SignatureCallingConvention, SignatureTypeKind, StandaloneSignatureHandle, StringHandle, TypeDefinitionHandle, TypeReferenceHandle, TypeSpecificationHandle, UserStringHandle } from "../../System.Reflection.Metadata/internal/index.js";
import type { AssemblyFlags, AssemblyHashAlgorithm, DeclarativeSecurityAction, EventAttributes, FieldAttributes, GenericParameterAttributes, ManifestResourceAttributes, MethodAttributes, MethodImplAttributes, MethodImportAttributes, MethodSemanticsAttributes, ParameterAttributes, PropertyAttributes, TypeAttributes } from "../../System.Reflection/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Boolean as ClrBoolean, Byte, Double, Enum, Func_2, Guid, IComparable, IConvertible, IEquatable_1, IFormatProvider, IFormattable, Int32, Int64, ISpanFormattable, Object as ClrObject, Single, String as ClrString, Type, TypeCode, UInt16, UInt32, ValueType, Version, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum EditAndContinueOperation {
    default_ = 0,
    addMethod = 1,
    addField = 2,
    addParameter = 3,
    addProperty = 4,
    addEvent = 5
}


export enum FunctionPointerAttributes {
    none = 0,
    hasThis = 32,
    hasExplicitThis = 96
}


export enum HeapIndex {
    userString = 0,
    string_ = 1,
    blob = 2,
    guid = 3
}


export enum MethodBodyAttributes {
    none = 0,
    initLocals = 1
}


export enum TableIndex {
    module_ = 0,
    typeRef = 1,
    typeDef = 2,
    fieldPtr = 3,
    field = 4,
    methodPtr = 5,
    methodDef = 6,
    paramPtr = 7,
    param = 8,
    interfaceImpl = 9,
    memberRef = 10,
    constant = 11,
    customAttribute = 12,
    fieldMarshal = 13,
    declSecurity = 14,
    classLayout = 15,
    fieldLayout = 16,
    standAloneSig = 17,
    eventMap = 18,
    eventPtr = 19,
    event = 20,
    propertyMap = 21,
    propertyPtr = 22,
    property = 23,
    methodSemantics = 24,
    methodImpl = 25,
    moduleRef = 26,
    typeSpec = 27,
    implMap = 28,
    fieldRva = 29,
    encLog = 30,
    encMap = 31,
    assembly = 32,
    assemblyProcessor = 33,
    assemblyOS = 34,
    assemblyRef = 35,
    assemblyRefProcessor = 36,
    assemblyRefOS = 37,
    file = 38,
    exportedType = 39,
    manifestResource = 40,
    nestedClass = 41,
    genericParam = 42,
    methodSpec = 43,
    genericParamConstraint = 44,
    document = 48,
    methodDebugInformation = 49,
    localScope = 50,
    localVariable = 51,
    localConstant = 52,
    importScope = 53,
    stateMachineMethod = 54,
    customDebugInformation = 55
}


export interface ArrayShapeEncoder$instance {
    readonly builder: BlobBuilder;
    shape(rank: int, sizes: ImmutableArray_1<CLROf<int>>, lowerBounds: ImmutableArray_1<CLROf<int>>): void;
}


export const ArrayShapeEncoder: {
    new(builder: BlobBuilder): ArrayShapeEncoder$instance;
};


export type ArrayShapeEncoder = ArrayShapeEncoder$instance;

export interface BlobEncoder$instance {
    readonly builder: BlobBuilder;
    customAttributeSignature(fixedArguments: { value: ref<FixedArgumentsEncoder> }, namedArguments: { value: ref<CustomAttributeNamedArgumentsEncoder> }): void;
    customAttributeSignature(fixedArguments: Action_1<FixedArgumentsEncoder>, namedArguments: Action_1<CustomAttributeNamedArgumentsEncoder>): void;
    field(): FieldTypeEncoder;
    fieldSignature(): SignatureTypeEncoder;
    localVariableSignature(variableCount: int): LocalVariablesEncoder;
    methodSignature(convention?: SignatureCallingConvention, genericParameterCount?: int, isInstanceMethod?: boolean): MethodSignatureEncoder;
    methodSpecificationSignature(genericArgumentCount: int): GenericTypeArgumentsEncoder;
    permissionSetArguments(argumentCount: int): NamedArgumentsEncoder;
    permissionSetBlob(attributeCount: int): PermissionSetEncoder;
    propertySignature(isInstanceProperty?: boolean): MethodSignatureEncoder;
    typeSpecificationSignature(): SignatureTypeEncoder;
}


export const BlobEncoder: {
    new(builder: BlobBuilder): BlobEncoder$instance;
};


export type BlobEncoder = BlobEncoder$instance;

export interface CustomAttributeArrayTypeEncoder$instance {
    readonly builder: BlobBuilder;
    elementType(): CustomAttributeElementTypeEncoder;
    objectArray(): void;
}


export const CustomAttributeArrayTypeEncoder: {
    new(builder: BlobBuilder): CustomAttributeArrayTypeEncoder$instance;
};


export type CustomAttributeArrayTypeEncoder = CustomAttributeArrayTypeEncoder$instance;

export interface CustomAttributeElementTypeEncoder$instance {
    readonly builder: BlobBuilder;
    boolean_(): void;
    byte(): void;
    char(): void;
    double(): void;
    enum_(enumTypeName: string): void;
    int16(): void;
    int32(): void;
    int64(): void;
    primitiveType(type_: PrimitiveSerializationTypeCode): void;
    sByte(): void;
    single(): void;
    string_(): void;
    systemType(): void;
    uInt16(): void;
    uInt32(): void;
    uInt64(): void;
}


export const CustomAttributeElementTypeEncoder: {
    new(builder: BlobBuilder): CustomAttributeElementTypeEncoder$instance;
};


export type CustomAttributeElementTypeEncoder = CustomAttributeElementTypeEncoder$instance;

export interface CustomAttributeNamedArgumentsEncoder$instance {
    readonly builder: BlobBuilder;
    count(count: int): NamedArgumentsEncoder;
}


export const CustomAttributeNamedArgumentsEncoder: {
    new(builder: BlobBuilder): CustomAttributeNamedArgumentsEncoder$instance;
};


export type CustomAttributeNamedArgumentsEncoder = CustomAttributeNamedArgumentsEncoder$instance;

export interface CustomModifiersEncoder$instance {
    readonly builder: BlobBuilder;
    addModifier(type_: EntityHandle, isOptional: boolean): CustomModifiersEncoder;
}


export const CustomModifiersEncoder: {
    new(builder: BlobBuilder): CustomModifiersEncoder$instance;
};


export type CustomModifiersEncoder = CustomModifiersEncoder$instance;

export interface EditAndContinueLogEntry$instance {
    readonly handle: EntityHandle;
    readonly operation: EditAndContinueOperation;
    equals(obj: unknown): boolean;
    equals(other: EditAndContinueLogEntry): boolean;
    getHashCode(): int;
}


export const EditAndContinueLogEntry: {
    new(handle: EntityHandle, operation: EditAndContinueOperation): EditAndContinueLogEntry$instance;
};


export interface __EditAndContinueLogEntry$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<EditAndContinueLogEntry>;

    // Structural method bridges for numeric interface constraints
    Equals(other: EditAndContinueLogEntry): boolean;
}

export type EditAndContinueLogEntry = EditAndContinueLogEntry$instance & __EditAndContinueLogEntry$views;


export interface ExceptionRegionEncoder$instance {
    readonly builder: BlobBuilder;
    readonly hasSmallFormat: boolean;
    add(kind: ExceptionRegionKind, tryOffset: int, tryLength: int, handlerOffset: int, handlerLength: int, catchType?: EntityHandle, filterOffset?: int): ExceptionRegionEncoder;
    addCatch(tryOffset: int, tryLength: int, handlerOffset: int, handlerLength: int, catchType: EntityHandle): ExceptionRegionEncoder;
    addFault(tryOffset: int, tryLength: int, handlerOffset: int, handlerLength: int): ExceptionRegionEncoder;
    addFilter(tryOffset: int, tryLength: int, handlerOffset: int, handlerLength: int, filterOffset: int): ExceptionRegionEncoder;
    addFinally(tryOffset: int, tryLength: int, handlerOffset: int, handlerLength: int): ExceptionRegionEncoder;
}


export const ExceptionRegionEncoder: {
    new(): ExceptionRegionEncoder$instance;
    isSmallExceptionRegion(startOffset: int, length: int): boolean;
    isSmallRegionCount(exceptionRegionCount: int): boolean;
};


export type ExceptionRegionEncoder = ExceptionRegionEncoder$instance;

export interface FieldTypeEncoder$instance {
    readonly builder: BlobBuilder;
    customModifiers(): CustomModifiersEncoder;
    type_(isByRef?: boolean): SignatureTypeEncoder;
    typedReference(): void;
}


export const FieldTypeEncoder: {
    new(builder: BlobBuilder): FieldTypeEncoder$instance;
};


export type FieldTypeEncoder = FieldTypeEncoder$instance;

export interface FixedArgumentsEncoder$instance {
    readonly builder: BlobBuilder;
    addArgument(): LiteralEncoder;
}


export const FixedArgumentsEncoder: {
    new(builder: BlobBuilder): FixedArgumentsEncoder$instance;
};


export type FixedArgumentsEncoder = FixedArgumentsEncoder$instance;

export interface GenericTypeArgumentsEncoder$instance {
    readonly builder: BlobBuilder;
    addArgument(): SignatureTypeEncoder;
}


export const GenericTypeArgumentsEncoder: {
    new(builder: BlobBuilder): GenericTypeArgumentsEncoder$instance;
};


export type GenericTypeArgumentsEncoder = GenericTypeArgumentsEncoder$instance;

export interface InstructionEncoder$instance {
    readonly codeBuilder: BlobBuilder;
    readonly controlFlowBuilder: ControlFlowBuilder;
    readonly offset: int;
    branch(code: ILOpCode, label: LabelHandle): void;
    call(methodHandle: EntityHandle): void;
    call(methodHandle: MethodDefinitionHandle): void;
    call(methodHandle: MethodSpecificationHandle): void;
    call(methodHandle: MemberReferenceHandle): void;
    callIndirect(signature: StandaloneSignatureHandle): void;
    defineLabel(): LabelHandle;
    loadArgument(argumentIndex: int): void;
    loadArgumentAddress(argumentIndex: int): void;
    loadConstantI4(value: int): void;
    loadConstantI8(value: long): void;
    loadConstantR4(value: float): void;
    loadConstantR8(value: double): void;
    loadLocal(slotIndex: int): void;
    loadLocalAddress(slotIndex: int): void;
    loadString(handle: UserStringHandle): void;
    markLabel(label: LabelHandle): void;
    opCode(code: ILOpCode): void;
    storeArgument(argumentIndex: int): void;
    storeLocal(slotIndex: int): void;
    switch_(branchCount: int): SwitchInstructionEncoder;
    token(handle: EntityHandle): void;
    token(token: int): void;
}


export const InstructionEncoder: {
    new(codeBuilder: BlobBuilder, controlFlowBuilder: ControlFlowBuilder): InstructionEncoder$instance;
};


export type InstructionEncoder = InstructionEncoder$instance;

export interface LabelHandle$instance {
    readonly id: int;
    readonly isNil: boolean;
    equals(other: LabelHandle): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const LabelHandle: {
    new(): LabelHandle$instance;
};


export interface __LabelHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<LabelHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: LabelHandle): boolean;
}

export type LabelHandle = LabelHandle$instance & __LabelHandle$views;


export interface LiteralEncoder$instance {
    readonly builder: BlobBuilder;
    scalar(): ScalarEncoder;
    taggedScalar(type_: { value: ref<CustomAttributeElementTypeEncoder> }, scalar: { value: ref<ScalarEncoder> }): void;
    taggedScalar(type_: Action_1<CustomAttributeElementTypeEncoder>, scalar: Action_1<ScalarEncoder>): void;
    taggedVector(arrayType: { value: ref<CustomAttributeArrayTypeEncoder> }, vector: { value: ref<VectorEncoder> }): void;
    taggedVector(arrayType: Action_1<CustomAttributeArrayTypeEncoder>, vector: Action_1<VectorEncoder>): void;
    vector(): VectorEncoder;
}


export const LiteralEncoder: {
    new(builder: BlobBuilder): LiteralEncoder$instance;
};


export type LiteralEncoder = LiteralEncoder$instance;

export interface LiteralsEncoder$instance {
    readonly builder: BlobBuilder;
    addLiteral(): LiteralEncoder;
}


export const LiteralsEncoder: {
    new(builder: BlobBuilder): LiteralsEncoder$instance;
};


export type LiteralsEncoder = LiteralsEncoder$instance;

export interface LocalVariablesEncoder$instance {
    readonly builder: BlobBuilder;
    addVariable(): LocalVariableTypeEncoder;
}


export const LocalVariablesEncoder: {
    new(builder: BlobBuilder): LocalVariablesEncoder$instance;
};


export type LocalVariablesEncoder = LocalVariablesEncoder$instance;

export interface LocalVariableTypeEncoder$instance {
    readonly builder: BlobBuilder;
    customModifiers(): CustomModifiersEncoder;
    type_(isByRef?: boolean, isPinned?: boolean): SignatureTypeEncoder;
    typedReference(): void;
}


export const LocalVariableTypeEncoder: {
    new(builder: BlobBuilder): LocalVariableTypeEncoder$instance;
};


export type LocalVariableTypeEncoder = LocalVariableTypeEncoder$instance;

export interface MethodBodyStreamEncoder$instance {
    readonly builder: BlobBuilder;
    addMethodBody(codeSize: int, maxStack: int, exceptionRegionCount: int, hasSmallExceptionRegions: boolean, localVariablesSignature: StandaloneSignatureHandle, attributes: MethodBodyAttributes): MethodBodyStreamEncoder_MethodBody;
    addMethodBody(codeSize: int, maxStack?: int, exceptionRegionCount?: int, hasSmallExceptionRegions?: boolean, localVariablesSignature?: StandaloneSignatureHandle, attributes?: MethodBodyAttributes, hasDynamicStackAllocation?: boolean): MethodBodyStreamEncoder_MethodBody;
    addMethodBody(instructionEncoder: InstructionEncoder, maxStack: int, localVariablesSignature: StandaloneSignatureHandle, attributes: MethodBodyAttributes): int;
    addMethodBody(instructionEncoder: InstructionEncoder, maxStack?: int, localVariablesSignature?: StandaloneSignatureHandle, attributes?: MethodBodyAttributes, hasDynamicStackAllocation?: boolean): int;
}


export const MethodBodyStreamEncoder: {
    new(builder: BlobBuilder): MethodBodyStreamEncoder$instance;
};


export type MethodBodyStreamEncoder = MethodBodyStreamEncoder$instance;

export interface MethodBodyStreamEncoder_MethodBody$instance {
    readonly exceptionRegions: ExceptionRegionEncoder;
    readonly instructions: Blob;
    readonly offset: int;
}


export const MethodBodyStreamEncoder_MethodBody: {
    new(): MethodBodyStreamEncoder_MethodBody$instance;
};


export type MethodBodyStreamEncoder_MethodBody = MethodBodyStreamEncoder_MethodBody$instance;

export interface MethodSignatureEncoder$instance {
    readonly builder: BlobBuilder;
    readonly hasVarArgs: boolean;
    parameters(parameterCount: int, returnType: { value: ref<ReturnTypeEncoder> }, parameters: { value: ref<ParametersEncoder> }): void;
    parameters(parameterCount: int, returnType: Action_1<ReturnTypeEncoder>, parameters: Action_1<ParametersEncoder>): void;
}


export const MethodSignatureEncoder: {
    new(builder: BlobBuilder, hasVarArgs: boolean): MethodSignatureEncoder$instance;
};


export type MethodSignatureEncoder = MethodSignatureEncoder$instance;

export interface NamedArgumentsEncoder$instance {
    readonly builder: BlobBuilder;
    addArgument(isField: boolean, type_: { value: ref<NamedArgumentTypeEncoder> }, name: { value: ref<NameEncoder> }, literal: { value: ref<LiteralEncoder> }): void;
    addArgument(isField: boolean, type_: Action_1<NamedArgumentTypeEncoder>, name: Action_1<NameEncoder>, literal: Action_1<LiteralEncoder>): void;
}


export const NamedArgumentsEncoder: {
    new(builder: BlobBuilder): NamedArgumentsEncoder$instance;
};


export type NamedArgumentsEncoder = NamedArgumentsEncoder$instance;

export interface NamedArgumentTypeEncoder$instance {
    readonly builder: BlobBuilder;
    object_(): void;
    scalarType(): CustomAttributeElementTypeEncoder;
    szArray(): CustomAttributeArrayTypeEncoder;
}


export const NamedArgumentTypeEncoder: {
    new(builder: BlobBuilder): NamedArgumentTypeEncoder$instance;
};


export type NamedArgumentTypeEncoder = NamedArgumentTypeEncoder$instance;

export interface NameEncoder$instance {
    readonly builder: BlobBuilder;
    name(name: string): void;
}


export const NameEncoder: {
    new(builder: BlobBuilder): NameEncoder$instance;
};


export type NameEncoder = NameEncoder$instance;

export interface ParametersEncoder$instance {
    readonly builder: BlobBuilder;
    readonly hasVarArgs: boolean;
    addParameter(): ParameterTypeEncoder;
    startVarArgs(): ParametersEncoder;
}


export const ParametersEncoder: {
    new(builder: BlobBuilder, hasVarArgs: boolean): ParametersEncoder$instance;
};


export type ParametersEncoder = ParametersEncoder$instance;

export interface ParameterTypeEncoder$instance {
    readonly builder: BlobBuilder;
    customModifiers(): CustomModifiersEncoder;
    type_(isByRef?: boolean): SignatureTypeEncoder;
    typedReference(): void;
}


export const ParameterTypeEncoder: {
    new(builder: BlobBuilder): ParameterTypeEncoder$instance;
};


export type ParameterTypeEncoder = ParameterTypeEncoder$instance;

export interface PermissionSetEncoder$instance {
    readonly builder: BlobBuilder;
    addPermission(typeName: string, encodedArguments: ImmutableArray_1<CLROf<byte>>): PermissionSetEncoder;
    addPermission(typeName: string, encodedArguments: BlobBuilder): PermissionSetEncoder;
}


export const PermissionSetEncoder: {
    new(builder: BlobBuilder): PermissionSetEncoder$instance;
};


export type PermissionSetEncoder = PermissionSetEncoder$instance;

export interface ReturnTypeEncoder$instance {
    readonly builder: BlobBuilder;
    customModifiers(): CustomModifiersEncoder;
    type_(isByRef?: boolean): SignatureTypeEncoder;
    typedReference(): void;
    void_(): void;
}


export const ReturnTypeEncoder: {
    new(builder: BlobBuilder): ReturnTypeEncoder$instance;
};


export type ReturnTypeEncoder = ReturnTypeEncoder$instance;

export interface ScalarEncoder$instance {
    readonly builder: BlobBuilder;
    constant(value: unknown): void;
    nullArray(): void;
    systemType(serializedTypeName: string): void;
}


export const ScalarEncoder: {
    new(builder: BlobBuilder): ScalarEncoder$instance;
};


export type ScalarEncoder = ScalarEncoder$instance;

export interface SignatureDecoder_2$instance<TType, TGenericContext> {
    decodeFieldSignature(blobReader: { value: ref<BlobReader> }): TType;
    decodeLocalSignature(blobReader: { value: ref<BlobReader> }): ImmutableArray_1<TType>;
    decodeMethodSignature(blobReader: { value: ref<BlobReader> }): MethodSignature_1<TType>;
    decodeMethodSpecificationSignature(blobReader: { value: ref<BlobReader> }): ImmutableArray_1<TType>;
    decodeType(blobReader: { value: ref<BlobReader> }, allowTypeSpecifications?: boolean): TType;
}


export const SignatureDecoder_2: {
    new<TType, TGenericContext>(provider: ISignatureTypeProvider_2<TType, TGenericContext>, metadataReader: MetadataReader, genericContext: TGenericContext): SignatureDecoder_2$instance<TType, TGenericContext>;
};


export type SignatureDecoder_2<TType, TGenericContext> = SignatureDecoder_2$instance<TType, TGenericContext>;

export interface SignatureTypeEncoder$instance {
    readonly builder: BlobBuilder;
    array(elementType: { value: ref<SignatureTypeEncoder> }, arrayShape: { value: ref<ArrayShapeEncoder> }): void;
    array(elementType: Action_1<SignatureTypeEncoder>, arrayShape: Action_1<ArrayShapeEncoder>): void;
    boolean_(): void;
    byte(): void;
    char(): void;
    customModifiers(): CustomModifiersEncoder;
    double(): void;
    functionPointer(convention?: SignatureCallingConvention, attributes?: FunctionPointerAttributes, genericParameterCount?: int): MethodSignatureEncoder;
    genericInstantiation(genericType: EntityHandle, genericArgumentCount: int, isValueType: boolean): GenericTypeArgumentsEncoder;
    genericMethodTypeParameter(parameterIndex: int): void;
    genericTypeParameter(parameterIndex: int): void;
    int16(): void;
    int32(): void;
    int64(): void;
    intPtr(): void;
    object_(): void;
    pointer(): SignatureTypeEncoder;
    primitiveType(type_: PrimitiveTypeCode): void;
    sByte(): void;
    single(): void;
    string_(): void;
    szArray(): SignatureTypeEncoder;
    type_(type_: EntityHandle, isValueType: boolean): void;
    typedReference(): void;
    uInt16(): void;
    uInt32(): void;
    uInt64(): void;
    uIntPtr(): void;
    voidPointer(): void;
}


export const SignatureTypeEncoder: {
    new(builder: BlobBuilder): SignatureTypeEncoder$instance;
};


export type SignatureTypeEncoder = SignatureTypeEncoder$instance;

export interface SwitchInstructionEncoder$instance {
    branch(label: LabelHandle): void;
}


export const SwitchInstructionEncoder: {
    new(): SwitchInstructionEncoder$instance;
};


export type SwitchInstructionEncoder = SwitchInstructionEncoder$instance;

export interface VectorEncoder$instance {
    readonly builder: BlobBuilder;
    count(count: int): LiteralsEncoder;
}


export const VectorEncoder: {
    new(builder: BlobBuilder): VectorEncoder$instance;
};


export type VectorEncoder = VectorEncoder$instance;

export interface ControlFlowBuilder$instance {
    addCatchRegion(tryStart: LabelHandle, tryEnd: LabelHandle, handlerStart: LabelHandle, handlerEnd: LabelHandle, catchType: EntityHandle): void;
    addFaultRegion(tryStart: LabelHandle, tryEnd: LabelHandle, handlerStart: LabelHandle, handlerEnd: LabelHandle): void;
    addFilterRegion(tryStart: LabelHandle, tryEnd: LabelHandle, handlerStart: LabelHandle, handlerEnd: LabelHandle, filterStart: LabelHandle): void;
    addFinallyRegion(tryStart: LabelHandle, tryEnd: LabelHandle, handlerStart: LabelHandle, handlerEnd: LabelHandle): void;
    clear(): void;
}


export const ControlFlowBuilder: {
    new(): ControlFlowBuilder$instance;
};


export type ControlFlowBuilder = ControlFlowBuilder$instance;

export interface MetadataAggregator$instance {
    getGenerationHandle(handle: Handle, generation: { value: ref<int> }): Handle;
}


export const MetadataAggregator: {
    new(baseReader: MetadataReader, deltaReaders: IReadOnlyList_1<MetadataReader>): MetadataAggregator$instance;
    new(baseTableRowCounts: IReadOnlyList_1<CLROf<int>>, baseHeapSizes: IReadOnlyList_1<CLROf<int>>, deltaReaders: IReadOnlyList_1<MetadataReader>): MetadataAggregator$instance;
};


export type MetadataAggregator = MetadataAggregator$instance;

export interface MetadataBuilder$instance {
    addAssembly(name: StringHandle, version: Version, culture: StringHandle, publicKey: BlobHandle, flags: AssemblyFlags, hashAlgorithm: AssemblyHashAlgorithm): AssemblyDefinitionHandle;
    addAssemblyFile(name: StringHandle, hashValue: BlobHandle, containsMetadata: boolean): AssemblyFileHandle;
    addAssemblyReference(name: StringHandle, version: Version, culture: StringHandle, publicKeyOrToken: BlobHandle, flags: AssemblyFlags, hashValue: BlobHandle): AssemblyReferenceHandle;
    addConstant(parent: EntityHandle, value: unknown): ConstantHandle;
    addCustomAttribute(parent: EntityHandle, constructor_: EntityHandle, value: BlobHandle): CustomAttributeHandle;
    addCustomDebugInformation(parent: EntityHandle, kind: GuidHandle, value: BlobHandle): CustomDebugInformationHandle;
    addDeclarativeSecurityAttribute(parent: EntityHandle, action: DeclarativeSecurityAction, permissionSet: BlobHandle): DeclarativeSecurityAttributeHandle;
    addDocument(name: BlobHandle, hashAlgorithm: GuidHandle, hash: BlobHandle, language: GuidHandle): DocumentHandle;
    addEncLogEntry(entity: EntityHandle, code: EditAndContinueOperation): void;
    addEncMapEntry(entity: EntityHandle): void;
    addEvent(attributes: EventAttributes, name: StringHandle, type_: EntityHandle): EventDefinitionHandle;
    addEventMap(declaringType: TypeDefinitionHandle, eventList: EventDefinitionHandle): void;
    addExportedType(attributes: TypeAttributes, namespace_: StringHandle, name: StringHandle, implementation: EntityHandle, typeDefinitionId: int): ExportedTypeHandle;
    addFieldDefinition(attributes: FieldAttributes, name: StringHandle, signature: BlobHandle): FieldDefinitionHandle;
    addFieldLayout(field: FieldDefinitionHandle, offset: int): void;
    addFieldRelativeVirtualAddress(field: FieldDefinitionHandle, offset: int): void;
    addGenericParameter(parent: EntityHandle, attributes: GenericParameterAttributes, name: StringHandle, index: int): GenericParameterHandle;
    addGenericParameterConstraint(genericParameter: GenericParameterHandle, constraint: EntityHandle): GenericParameterConstraintHandle;
    addImportScope(parentScope: ImportScopeHandle, imports: BlobHandle): ImportScopeHandle;
    addInterfaceImplementation(type_: TypeDefinitionHandle, implementedInterface: EntityHandle): InterfaceImplementationHandle;
    addLocalConstant(name: StringHandle, signature: BlobHandle): LocalConstantHandle;
    addLocalScope(method: MethodDefinitionHandle, importScope: ImportScopeHandle, variableList: LocalVariableHandle, constantList: LocalConstantHandle, startOffset: int, length: int): LocalScopeHandle;
    addLocalVariable(attributes: LocalVariableAttributes, index: int, name: StringHandle): LocalVariableHandle;
    addManifestResource(attributes: ManifestResourceAttributes, name: StringHandle, implementation: EntityHandle, offset: uint): ManifestResourceHandle;
    addMarshallingDescriptor(parent: EntityHandle, descriptor: BlobHandle): void;
    addMemberReference(parent: EntityHandle, name: StringHandle, signature: BlobHandle): MemberReferenceHandle;
    addMethodDebugInformation(document: DocumentHandle, sequencePoints: BlobHandle): MethodDebugInformationHandle;
    addMethodDefinition(attributes: MethodAttributes, implAttributes: MethodImplAttributes, name: StringHandle, signature: BlobHandle, bodyOffset: int, parameterList: ParameterHandle): MethodDefinitionHandle;
    addMethodImplementation(type_: TypeDefinitionHandle, methodBody: EntityHandle, methodDeclaration: EntityHandle): MethodImplementationHandle;
    addMethodImport(method: MethodDefinitionHandle, attributes: MethodImportAttributes, name: StringHandle, module_: ModuleReferenceHandle): void;
    addMethodSemantics(association: EntityHandle, semantics: MethodSemanticsAttributes, methodDefinition: MethodDefinitionHandle): void;
    addMethodSpecification(method: EntityHandle, instantiation: BlobHandle): MethodSpecificationHandle;
    addModule(generation: int, moduleName: StringHandle, mvid: GuidHandle, encId: GuidHandle, encBaseId: GuidHandle): ModuleDefinitionHandle;
    addModuleReference(moduleName: StringHandle): ModuleReferenceHandle;
    addNestedType(type_: TypeDefinitionHandle, enclosingType: TypeDefinitionHandle): void;
    addParameter(attributes: ParameterAttributes, name: StringHandle, sequenceNumber: int): ParameterHandle;
    addProperty(attributes: PropertyAttributes, name: StringHandle, signature: BlobHandle): PropertyDefinitionHandle;
    addPropertyMap(declaringType: TypeDefinitionHandle, propertyList: PropertyDefinitionHandle): void;
    addStandaloneSignature(signature: BlobHandle): StandaloneSignatureHandle;
    addStateMachineMethod(moveNextMethod: MethodDefinitionHandle, kickoffMethod: MethodDefinitionHandle): void;
    addTypeDefinition(attributes: TypeAttributes, namespace_: StringHandle, name: StringHandle, baseType: EntityHandle, fieldList: FieldDefinitionHandle, methodList: MethodDefinitionHandle): TypeDefinitionHandle;
    addTypeLayout(type_: TypeDefinitionHandle, packingSize: ushort, size: uint): void;
    addTypeReference(resolutionScope: EntityHandle, namespace_: StringHandle, name: StringHandle): TypeReferenceHandle;
    addTypeSpecification(signature: BlobHandle): TypeSpecificationHandle;
    getOrAddBlob(value: BlobBuilder): BlobHandle;
    getOrAddBlob(value: byte[]): BlobHandle;
    getOrAddBlob(value: ImmutableArray_1<CLROf<byte>>): BlobHandle;
    getOrAddBlobUTF16(value: string): BlobHandle;
    getOrAddBlobUTF8(value: string, allowUnpairedSurrogates?: boolean): BlobHandle;
    getOrAddConstantBlob(value: unknown): BlobHandle;
    getOrAddDocumentName(value: string): BlobHandle;
    getOrAddGuid(guid: Guid): GuidHandle;
    getOrAddString(value: string): StringHandle;
    getOrAddUserString(value: string): UserStringHandle;
    getRowCount(table: TableIndex): int;
    getRowCounts(): ImmutableArray_1<CLROf<int>>;
    reserveGuid(): ReservedBlob_1<GuidHandle>;
    reserveUserString(length: int): ReservedBlob_1<UserStringHandle>;
    setCapacity(table: TableIndex, rowCount: int): void;
    setCapacity(heap: HeapIndex, byteCount: int): void;
}


export const MetadataBuilder: {
    new(userStringHeapStartOffset: int, stringHeapStartOffset: int, blobHeapStartOffset: int, guidHeapStartOffset: int): MetadataBuilder$instance;
};


export type MetadataBuilder = MetadataBuilder$instance;

export interface MetadataRootBuilder$instance {
    readonly metadataVersion: string;
    readonly sizes: MetadataSizes;
    readonly suppressValidation: boolean;
    serialize(builder: BlobBuilder, methodBodyStreamRva: int, mappedFieldDataStreamRva: int): void;
}


export const MetadataRootBuilder: {
    new(tablesAndHeaps: MetadataBuilder, metadataVersion: string, suppressValidation: boolean): MetadataRootBuilder$instance;
};


export type MetadataRootBuilder = MetadataRootBuilder$instance;

export interface MetadataSizes$instance {
    readonly externalRowCounts: ImmutableArray_1<CLROf<int>>;
    readonly heapSizes: ImmutableArray_1<CLROf<int>>;
    readonly rowCounts: ImmutableArray_1<CLROf<int>>;
    getAlignedHeapSize(index: HeapIndex): int;
}


export const MetadataSizes: {
    new(): MetadataSizes$instance;
};


export type MetadataSizes = MetadataSizes$instance;

export interface PortablePdbBuilder$instance {
    readonly formatVersion: ushort;
    readonly idProvider: Func_2<IEnumerable_1<Blob>, BlobContentId>;
    readonly metadataVersion: string;
    serialize(builder: BlobBuilder): BlobContentId;
}


export const PortablePdbBuilder: {
    new(tablesAndHeaps: MetadataBuilder, typeSystemRowCounts: ImmutableArray_1<CLROf<int>>, entryPoint: MethodDefinitionHandle, idProvider: Func_2<IEnumerable_1<Blob>, BlobContentId>): PortablePdbBuilder$instance;
};


export type PortablePdbBuilder = PortablePdbBuilder$instance;

export abstract class CodedIndex$instance {
    static customAttributeType(handle: EntityHandle): int;
    static hasConstant(handle: EntityHandle): int;
    static hasCustomAttribute(handle: EntityHandle): int;
    static hasCustomDebugInformation(handle: EntityHandle): int;
    static hasDeclSecurity(handle: EntityHandle): int;
    static hasFieldMarshal(handle: EntityHandle): int;
    static hasSemantics(handle: EntityHandle): int;
    static implementation(handle: EntityHandle): int;
    static memberForwarded(handle: EntityHandle): int;
    static memberRefParent(handle: EntityHandle): int;
    static methodDefOrRef(handle: EntityHandle): int;
    static resolutionScope(handle: EntityHandle): int;
    static typeDefOrRef(handle: EntityHandle): int;
    static typeDefOrRefOrSpec(handle: EntityHandle): int;
    static typeOrMethodDef(handle: EntityHandle): int;
}


export type CodedIndex = CodedIndex$instance;

export abstract class ExportedTypeExtensions$instance {
    static getTypeDefinitionId(exportedType: ExportedType): int;
}


export type ExportedTypeExtensions = ExportedTypeExtensions$instance;

export abstract class MetadataReaderExtensions$instance {
    static getEditAndContinueLogEntries(reader: MetadataReader): IEnumerable_1<EditAndContinueLogEntry>;
    static getEditAndContinueMapEntries(reader: MetadataReader): IEnumerable_1<EntityHandle>;
    static getHeapMetadataOffset(reader: MetadataReader, heapIndex: HeapIndex): int;
    static getHeapSize(reader: MetadataReader, heapIndex: HeapIndex): int;
    static getNextHandle(reader: MetadataReader, handle: BlobHandle): BlobHandle;
    static getNextHandle(reader: MetadataReader, handle: StringHandle): StringHandle;
    static getNextHandle(reader: MetadataReader, handle: UserStringHandle): UserStringHandle;
    static getTableMetadataOffset(reader: MetadataReader, tableIndex: TableIndex): int;
    static getTableRowCount(reader: MetadataReader, tableIndex: TableIndex): int;
    static getTableRowSize(reader: MetadataReader, tableIndex: TableIndex): int;
    static getTypesWithEvents(reader: MetadataReader): IEnumerable_1<TypeDefinitionHandle>;
    static getTypesWithProperties(reader: MetadataReader): IEnumerable_1<TypeDefinitionHandle>;
    static resolveSignatureTypeKind(reader: MetadataReader, typeHandle: EntityHandle, rawTypeKind: byte): SignatureTypeKind;
}


export type MetadataReaderExtensions = MetadataReaderExtensions$instance;

export abstract class MetadataTokens$instance {
    static readonly tableCount: int;
    static readonly heapCount: int;
    static assemblyFileHandle(rowNumber: int): AssemblyFileHandle;
    static assemblyReferenceHandle(rowNumber: int): AssemblyReferenceHandle;
    static blobHandle(offset: int): BlobHandle;
    static constantHandle(rowNumber: int): ConstantHandle;
    static customAttributeHandle(rowNumber: int): CustomAttributeHandle;
    static customDebugInformationHandle(rowNumber: int): CustomDebugInformationHandle;
    static declarativeSecurityAttributeHandle(rowNumber: int): DeclarativeSecurityAttributeHandle;
    static documentHandle(rowNumber: int): DocumentHandle;
    static documentNameBlobHandle(offset: int): DocumentNameBlobHandle;
    static entityHandle(token: int): EntityHandle;
    static entityHandle(tableIndex: TableIndex, rowNumber: int): EntityHandle;
    static eventDefinitionHandle(rowNumber: int): EventDefinitionHandle;
    static exportedTypeHandle(rowNumber: int): ExportedTypeHandle;
    static fieldDefinitionHandle(rowNumber: int): FieldDefinitionHandle;
    static genericParameterConstraintHandle(rowNumber: int): GenericParameterConstraintHandle;
    static genericParameterHandle(rowNumber: int): GenericParameterHandle;
    static getHeapOffset(handle: BlobHandle): int;
    static getHeapOffset(handle: GuidHandle): int;
    static getHeapOffset(handle: Handle): int;
    static getHeapOffset(reader: MetadataReader, handle: Handle): int;
    static getHeapOffset(handle: StringHandle): int;
    static getHeapOffset(handle: UserStringHandle): int;
    static getRowNumber(handle: EntityHandle): int;
    static getRowNumber(reader: MetadataReader, handle: EntityHandle): int;
    static getToken(handle: EntityHandle): int;
    static getToken(handle: Handle): int;
    static getToken(reader: MetadataReader, handle: EntityHandle): int;
    static getToken(reader: MetadataReader, handle: Handle): int;
    static guidHandle(offset: int): GuidHandle;
    static handle(token: int): Handle;
    static handle(tableIndex: TableIndex, rowNumber: int): EntityHandle;
    static importScopeHandle(rowNumber: int): ImportScopeHandle;
    static interfaceImplementationHandle(rowNumber: int): InterfaceImplementationHandle;
    static localConstantHandle(rowNumber: int): LocalConstantHandle;
    static localScopeHandle(rowNumber: int): LocalScopeHandle;
    static localVariableHandle(rowNumber: int): LocalVariableHandle;
    static manifestResourceHandle(rowNumber: int): ManifestResourceHandle;
    static memberReferenceHandle(rowNumber: int): MemberReferenceHandle;
    static methodDebugInformationHandle(rowNumber: int): MethodDebugInformationHandle;
    static methodDefinitionHandle(rowNumber: int): MethodDefinitionHandle;
    static methodImplementationHandle(rowNumber: int): MethodImplementationHandle;
    static methodSpecificationHandle(rowNumber: int): MethodSpecificationHandle;
    static moduleReferenceHandle(rowNumber: int): ModuleReferenceHandle;
    static parameterHandle(rowNumber: int): ParameterHandle;
    static propertyDefinitionHandle(rowNumber: int): PropertyDefinitionHandle;
    static standaloneSignatureHandle(rowNumber: int): StandaloneSignatureHandle;
    static stringHandle(offset: int): StringHandle;
    static tryGetHeapIndex(type_: HandleKind, index: { value: ref<HeapIndex> }): boolean;
    static tryGetTableIndex(type_: HandleKind, index: { value: ref<TableIndex> }): boolean;
    static typeDefinitionHandle(rowNumber: int): TypeDefinitionHandle;
    static typeReferenceHandle(rowNumber: int): TypeReferenceHandle;
    static typeSpecificationHandle(rowNumber: int): TypeSpecificationHandle;
    static userStringHandle(offset: int): UserStringHandle;
}


export type MetadataTokens = MetadataTokens$instance;

