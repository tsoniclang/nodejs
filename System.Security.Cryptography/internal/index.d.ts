// Generated by tsbindgen - Architecture
// Namespace: System.Security.Cryptography
// Assembly: System.Private.CoreLib, System.Security.Cryptography

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { SafeNCryptKeyHandle, SafeNCryptProviderHandle, SafeNCryptSecretHandle } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IList_1, IReadOnlyCollection_1, IReadOnlyList_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_ObjectModel_Internal from "../../System.Collections.ObjectModel/internal/index.js";
import type { Collection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import * as System_IO_Internal from "../../System.IO/internal/index.js";
import type { SeekOrigin, Stream } from "../../System.IO/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_InteropServices_Internal from "../../System.Runtime.InteropServices/internal/index.js";
import type { SafeHandle } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { SecureString, SecurityElement } from "../../System.Security/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, AsyncCallback, Boolean as ClrBoolean, Byte, Char, Enum, Exception, IAsyncDisposable, IAsyncResult, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int32, Int64, IntPtr, ISpanFormattable, Memory_1, Nullable_1, Object as ClrObject, Range, ReadOnlyMemory_1, ReadOnlySpan_1, Span_1, String as ClrString, SystemException, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum CipherMode {
    CBC = 1,
    ECB = 2,
    OFB = 3,
    CFB = 4,
    CTS = 5
}


export enum CngExportPolicies {
    none = 0,
    allowExport = 1,
    allowPlaintextExport = 2,
    allowArchiving = 4,
    allowPlaintextArchiving = 8
}


export enum CngKeyCreationOptions {
    none = 0,
    machineKey = 32,
    overwriteExistingKey = 128,
    preferVbs = 65536,
    requireVbs = 131072,
    usePerBootKey = 262144
}


export enum CngKeyHandleOpenOptions {
    none = 0,
    ephemeralKey = 1
}


export enum CngKeyOpenOptions {
    none = 0,
    userKey = 0,
    machineKey = 32,
    silent = 64
}


export enum CngKeyUsages {
    none = 0,
    decryption = 1,
    signing = 2,
    keyAgreement = 4,
    allUsages = 16777215
}


export enum CngPropertyOptions {
    none = 0,
    customProperty = 1073741824,
    persist = -2147483648
}


export enum CngUIProtectionLevels {
    none = 0,
    protectKey = 1,
    forceHighProtection = 2
}


export enum CryptoStreamMode {
    read = 0,
    write = 1
}


export enum CspProviderFlags {
    noFlags = 0,
    useMachineKeyStore = 1,
    useDefaultKeyContainer = 2,
    useNonExportableKey = 4,
    useExistingKey = 8,
    useArchivableKey = 16,
    useUserProtectedKey = 32,
    noPrompt = 64,
    createEphemeralKey = 128
}


export enum DSASignatureFormat {
    ieeeP1363FixedFieldConcatenation = 0,
    rfc3279DerSequence = 1
}


export enum ECCurve_ECCurveType {
    implicit = 0,
    primeShortWeierstrass = 1,
    primeTwistedEdwards = 2,
    primeMontgomery = 3,
    characteristic2 = 4,
    named = 5
}


export enum ECDiffieHellmanKeyDerivationFunction {
    hash = 0,
    hmac = 1,
    tls = 2
}


export enum ECKeyXmlFormat {
    rfc4050 = 0
}


export enum FromBase64TransformMode {
    ignoreWhiteSpaces = 0,
    doNotIgnoreWhiteSpaces = 1
}


export enum KeyNumber {
    exchange = 1,
    signature = 2
}


export enum OidGroup {
    all = 0,
    hashAlgorithm = 1,
    encryptionAlgorithm = 2,
    publicKeyAlgorithm = 3,
    signatureAlgorithm = 4,
    attribute = 5,
    extensionOrAttribute = 6,
    enhancedKeyUsage = 7,
    policy = 8,
    template = 9,
    keyDerivationFunction = 10
}


export enum PaddingMode {
    none = 1,
    PKCS7 = 2,
    zeros = 3,
    ANSIX923 = 4,
    ISO10126 = 5
}


export enum PbeEncryptionAlgorithm {
    unknown_ = 0,
    aes128Cbc = 1,
    aes192Cbc = 2,
    aes256Cbc = 3,
    tripleDes3KeyPkcs12 = 4
}


export enum RSAEncryptionPaddingMode {
    pkcs1 = 0,
    oaep = 1
}


export enum RSASignaturePaddingMode {
    pkcs1 = 0,
    pss = 1
}


export interface ICryptoTransform$instance extends IDisposable {
    readonly inputBlockSize: int;
    readonly outputBlockSize: int;
    readonly canTransformMultipleBlocks: boolean;
    readonly canReuseTransform: boolean;
    dispose(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface ICryptoTransform$instance extends System_Internal.IDisposable$instance {}

export type ICryptoTransform = ICryptoTransform$instance;

export interface ICspAsymmetricAlgorithm$instance {
    readonly cspKeyContainerInfo: CspKeyContainerInfo;
    exportCspBlob(includePrivateParameters: boolean): byte[];
    importCspBlob(rawData: byte[]): void;
}


export type ICspAsymmetricAlgorithm = ICspAsymmetricAlgorithm$instance;

export interface CngProperty$instance {
    readonly name: string;
    readonly options: CngPropertyOptions;
    equals(obj: unknown): boolean;
    equals(other: CngProperty): boolean;
    getHashCode(): int;
    getValue(): byte[];
}


export const CngProperty: {
    new(name: string, value: byte[], options: CngPropertyOptions): CngProperty$instance;
};


export interface __CngProperty$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CngProperty>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CngProperty): boolean;
}

export type CngProperty = CngProperty$instance & __CngProperty$views;


export interface DSAParameters$instance {
    P: byte[];
    Q: byte[];
    G: byte[];
    Y: byte[];
    J: byte[];
    X: byte[];
    seed: byte[];
    counter: int;
}


export const DSAParameters: {
    new(): DSAParameters$instance;
};


export type DSAParameters = DSAParameters$instance;

export interface ECCurve$instance {
    A: byte[];
    B: byte[];
    G: ECPoint;
    order: byte[];
    cofactor: byte[];
    seed: byte[];
    curveType: ECCurve_ECCurveType;
    hash: Nullable_1<HashAlgorithmName>;
    polynomial: byte[];
    prime: byte[];
    readonly isCharacteristic2: boolean;
    readonly isExplicit: boolean;
    readonly isNamed: boolean;
    readonly isPrime: boolean;
    readonly oid: Oid;
    validate(): void;
}


export const ECCurve: {
    new(): ECCurve$instance;
    createFromFriendlyName(oidFriendlyName: string): ECCurve;
    createFromOid(curveOid: Oid): ECCurve;
    createFromValue(oidValue: string): ECCurve;
};


export type ECCurve = ECCurve$instance;

export interface ECParameters$instance {
    Q: ECPoint;
    D: byte[];
    curve: ECCurve;
    validate(): void;
}


export const ECParameters: {
    new(): ECParameters$instance;
};


export type ECParameters = ECParameters$instance;

export interface ECPoint$instance {
    X: byte[];
    Y: byte[];
}


export const ECPoint: {
    new(): ECPoint$instance;
};


export type ECPoint = ECPoint$instance;

export interface HashAlgorithmName$instance {
    readonly name: string;
    equals(obj: unknown): boolean;
    equals(other: HashAlgorithmName): boolean;
    getHashCode(): int;
    toString(): string;
}


export const HashAlgorithmName: {
    new(name: string): HashAlgorithmName$instance;
    readonly MD5: HashAlgorithmName;
    readonly SHA1: HashAlgorithmName;
    readonly SHA256: HashAlgorithmName;
    readonly SHA384: HashAlgorithmName;
    readonly SHA512: HashAlgorithmName;
    readonly SHA3_256: HashAlgorithmName;
    readonly SHA3_384: HashAlgorithmName;
    readonly SHA3_512: HashAlgorithmName;
    fromOid(oidValue: string): HashAlgorithmName;
    tryFromOid(oidValue: string, value: { value: ref<HashAlgorithmName> }): boolean;
};


export interface __HashAlgorithmName$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<HashAlgorithmName>;

    // Structural method bridges for numeric interface constraints
    Equals(other: HashAlgorithmName): boolean;
}

export type HashAlgorithmName = HashAlgorithmName$instance & __HashAlgorithmName$views;


export interface PemFields$instance {
    readonly base64Data: Range;
    readonly decodedDataLength: int;
    readonly label: Range;
    readonly location: Range;
}


export const PemFields: {
    new(): PemFields$instance;
};


export type PemFields = PemFields$instance;

export interface RSAParameters$instance {
    D: byte[];
    DP: byte[];
    DQ: byte[];
    exponent: byte[];
    inverseQ: byte[];
    modulus: byte[];
    P: byte[];
    Q: byte[];
}


export const RSAParameters: {
    new(): RSAParameters$instance;
};


export type RSAParameters = RSAParameters$instance;

export interface Aes$instance extends SymmetricAlgorithm$instance {
    decryptKeyWrapPadded(ciphertext: byte[]): byte[];
    decryptKeyWrapPadded(ciphertext: ReadOnlySpan_1<CLROf<byte>>): byte[];
    decryptKeyWrapPadded(ciphertext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    dispose(): void;
    encryptKeyWrapPadded(plaintext: byte[]): byte[];
    encryptKeyWrapPadded(plaintext: ReadOnlySpan_1<CLROf<byte>>): byte[];
    encryptKeyWrapPadded(plaintext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): void;
    tryDecryptKeyWrapPadded(ciphertext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export const Aes: {
    getKeyWrapPaddedLength(plaintextLengthInBytes: int): int;
};


export interface __Aes$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type Aes = Aes$instance & __Aes$views;


export interface AesCcm$instance {
    decrypt(nonce: byte[], ciphertext: byte[], tag: byte[], plaintext: byte[], associatedData?: byte[]): void;
    decrypt(nonce: ReadOnlySpan_1<CLROf<byte>>, ciphertext: ReadOnlySpan_1<CLROf<byte>>, tag: ReadOnlySpan_1<CLROf<byte>>, plaintext: Span_1<CLROf<byte>>, associatedData?: ReadOnlySpan_1<CLROf<byte>>): void;
    dispose(): void;
    encrypt(nonce: byte[], plaintext: byte[], ciphertext: byte[], tag: byte[], associatedData?: byte[]): void;
    encrypt(nonce: ReadOnlySpan_1<CLROf<byte>>, plaintext: ReadOnlySpan_1<CLROf<byte>>, ciphertext: Span_1<CLROf<byte>>, tag: Span_1<CLROf<byte>>, associatedData?: ReadOnlySpan_1<CLROf<byte>>): void;
}


export const AesCcm: {
    new(key: ReadOnlySpan_1<CLROf<byte>>): AesCcm$instance;
    new(key: byte[]): AesCcm$instance;
    readonly nonceByteSizes: KeySizes;
    readonly tagByteSizes: KeySizes;
    readonly isSupported: boolean;
};


export interface __AesCcm$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface AesCcm$instance extends System_Internal.IDisposable$instance {}

export type AesCcm = AesCcm$instance & __AesCcm$views;


export interface AesCng$instance extends Aes$instance {
    createDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    createDecryptor(): ICryptoTransform;
    createEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    createEncryptor(): ICryptoTransform;
    dispose(): void;
    generateIV(): void;
    generateKey(): void;
}


export const AesCng: {
    new(): AesCng$instance;
    new(keyName: string): AesCng$instance;
    new(keyName: string, provider: CngProvider): AesCng$instance;
    new(keyName: string, provider: CngProvider, openOptions: CngKeyOpenOptions): AesCng$instance;
    new(key: CngKey): AesCng$instance;
};


export interface __AesCng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type AesCng = AesCng$instance & __AesCng$views;


export interface AesCryptoServiceProvider$instance extends Aes$instance {
    blockSize: int;
    feedbackSize: int;
    IV: byte[];
    key: byte[];
    keySize: int;
    readonly legalBlockSizes: KeySizes[];
    readonly legalKeySizes: KeySizes[];
    mode: CipherMode;
    padding: PaddingMode;
    createDecryptor(): ICryptoTransform;
    createDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    createEncryptor(): ICryptoTransform;
    createEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    dispose(): void;
    generateIV(): void;
    generateKey(): void;
}


export const AesCryptoServiceProvider: {
    new(): AesCryptoServiceProvider$instance;
};


export interface __AesCryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type AesCryptoServiceProvider = AesCryptoServiceProvider$instance & __AesCryptoServiceProvider$views;


export interface AesGcm$instance {
    readonly tagSizeInBytes: Nullable_1<CLROf<int>>;
    decrypt(nonce: byte[], ciphertext: byte[], tag: byte[], plaintext: byte[], associatedData?: byte[]): void;
    decrypt(nonce: ReadOnlySpan_1<CLROf<byte>>, ciphertext: ReadOnlySpan_1<CLROf<byte>>, tag: ReadOnlySpan_1<CLROf<byte>>, plaintext: Span_1<CLROf<byte>>, associatedData?: ReadOnlySpan_1<CLROf<byte>>): void;
    dispose(): void;
    encrypt(nonce: byte[], plaintext: byte[], ciphertext: byte[], tag: byte[], associatedData?: byte[]): void;
    encrypt(nonce: ReadOnlySpan_1<CLROf<byte>>, plaintext: ReadOnlySpan_1<CLROf<byte>>, ciphertext: Span_1<CLROf<byte>>, tag: Span_1<CLROf<byte>>, associatedData?: ReadOnlySpan_1<CLROf<byte>>): void;
}


export const AesGcm: {
    new(key: ReadOnlySpan_1<CLROf<byte>>, tagSizeInBytes: int): AesGcm$instance;
    new(key: byte[], tagSizeInBytes: int): AesGcm$instance;
    new(key: ReadOnlySpan_1<CLROf<byte>>): AesGcm$instance;
    new(key: byte[]): AesGcm$instance;
    readonly nonceByteSizes: KeySizes;
    readonly tagByteSizes: KeySizes;
    readonly isSupported: boolean;
};


export interface __AesGcm$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface AesGcm$instance extends System_Internal.IDisposable$instance {}

export type AesGcm = AesGcm$instance & __AesGcm$views;


export interface AesManaged$instance extends Aes$instance {
    blockSize: int;
    feedbackSize: int;
    IV: byte[];
    key: byte[];
    keySize: int;
    readonly legalBlockSizes: KeySizes[];
    readonly legalKeySizes: KeySizes[];
    mode: CipherMode;
    padding: PaddingMode;
    createDecryptor(): ICryptoTransform;
    createDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    createEncryptor(): ICryptoTransform;
    createEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    dispose(): void;
    generateIV(): void;
    generateKey(): void;
}


export const AesManaged: {
    new(): AesManaged$instance;
};


export interface __AesManaged$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type AesManaged = AesManaged$instance & __AesManaged$views;


export interface AsnEncodedData$instance {
    oid: Oid;
    rawData: byte[];
    copyFrom(asnEncodedData: AsnEncodedData): void;
    format(multiLine: boolean): string;
}


export const AsnEncodedData: {
    new(rawData: byte[]): AsnEncodedData$instance;
    new(rawData: ReadOnlySpan_1<CLROf<byte>>): AsnEncodedData$instance;
    new(asnEncodedData: AsnEncodedData): AsnEncodedData$instance;
    new(oid: Oid, rawData: byte[]): AsnEncodedData$instance;
    new(oid: string, rawData: byte[]): AsnEncodedData$instance;
    new(oid: Oid, rawData: ReadOnlySpan_1<CLROf<byte>>): AsnEncodedData$instance;
    new(oid: string, rawData: ReadOnlySpan_1<CLROf<byte>>): AsnEncodedData$instance;
};


export type AsnEncodedData = AsnEncodedData$instance;

export interface AsnEncodedDataCollection$instance {
    readonly count: int;
    readonly isSynchronized: boolean;
    readonly item: AsnEncodedData;
    readonly syncRoot: unknown;
    add(asnEncodedData: AsnEncodedData): int;
    copyTo(array: AsnEncodedData[], index: int): void;
    getEnumerator(): AsnEncodedDataEnumerator;
    remove(asnEncodedData: AsnEncodedData): void;
}


export const AsnEncodedDataCollection: {
    new(): AsnEncodedDataCollection$instance;
    new(asnEncodedData: AsnEncodedData): AsnEncodedDataCollection$instance;
};


export interface __AsnEncodedDataCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type AsnEncodedDataCollection = AsnEncodedDataCollection$instance & __AsnEncodedDataCollection$views;


export interface AsnEncodedDataEnumerator$instance {
    readonly current: AsnEncodedData | unknown;
    moveNext(): boolean;
    reset(): void;
}


export const AsnEncodedDataEnumerator: {
    new(): AsnEncodedDataEnumerator$instance;
};


export interface __AsnEncodedDataEnumerator$views {
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type AsnEncodedDataEnumerator = AsnEncodedDataEnumerator$instance & __AsnEncodedDataEnumerator$views;


export interface AsymmetricAlgorithm$instance {
    readonly keyExchangeAlgorithm: string;
    keySize: int;
    readonly legalKeySizes: KeySizes[];
    readonly signatureAlgorithm: string;
    clear(): void;
    dispose(): void;
    exportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKeyPem(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): string;
    exportEncryptedPkcs8PrivateKeyPem(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): string;
    exportPkcs8PrivateKey(): byte[];
    exportPkcs8PrivateKeyPem(): string;
    exportSubjectPublicKeyInfo(): byte[];
    exportSubjectPublicKeyInfoPem(): string;
    fromXmlString(xmlString: string): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): void;
    importFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): void;
    importFromPem(input: ReadOnlySpan_1<CLROf<char>>): void;
    importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    toXmlString(includePrivateParameters: boolean): string;
    tryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKeyPem(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKeyPem(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKeyPem(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfoPem(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
}


export const AsymmetricAlgorithm: {
    create(): AsymmetricAlgorithm;
    create(algName: string): AsymmetricAlgorithm;
};


export interface __AsymmetricAlgorithm$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface AsymmetricAlgorithm$instance extends System_Internal.IDisposable$instance {}

export type AsymmetricAlgorithm = AsymmetricAlgorithm$instance & __AsymmetricAlgorithm$views;


export interface AsymmetricKeyExchangeDeformatter$instance {
    parameters: string;
    decryptKeyExchange(rgb: byte[]): byte[];
    setKey(key: AsymmetricAlgorithm): void;
}


export const AsymmetricKeyExchangeDeformatter: {
};


export type AsymmetricKeyExchangeDeformatter = AsymmetricKeyExchangeDeformatter$instance;

export interface AsymmetricKeyExchangeFormatter$instance {
    readonly parameters: string;
    createKeyExchange(data: byte[]): byte[];
    createKeyExchange(data: byte[], symAlgType: Type): byte[];
    setKey(key: AsymmetricAlgorithm): void;
}


export const AsymmetricKeyExchangeFormatter: {
};


export type AsymmetricKeyExchangeFormatter = AsymmetricKeyExchangeFormatter$instance;

export interface AsymmetricSignatureDeformatter$instance {
    setHashAlgorithm(strName: string): void;
    setKey(key: AsymmetricAlgorithm): void;
    verifySignature(hash: HashAlgorithm, rgbSignature: byte[]): boolean;
    verifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
}


export const AsymmetricSignatureDeformatter: {
};


export type AsymmetricSignatureDeformatter = AsymmetricSignatureDeformatter$instance;

export interface AsymmetricSignatureFormatter$instance {
    createSignature(hash: HashAlgorithm): byte[];
    createSignature(rgbHash: byte[]): byte[];
    setHashAlgorithm(strName: string): void;
    setKey(key: AsymmetricAlgorithm): void;
}


export const AsymmetricSignatureFormatter: {
};


export type AsymmetricSignatureFormatter = AsymmetricSignatureFormatter$instance;

export interface AuthenticationTagMismatchException$instance extends CryptographicException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const AuthenticationTagMismatchException: {
    new(): AuthenticationTagMismatchException$instance;
    new(message: string): AuthenticationTagMismatchException$instance;
    new(message: string, inner: Exception): AuthenticationTagMismatchException$instance;
};


export interface __AuthenticationTagMismatchException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AuthenticationTagMismatchException = AuthenticationTagMismatchException$instance & __AuthenticationTagMismatchException$views;


export interface ChaCha20Poly1305$instance {
    decrypt(nonce: byte[], ciphertext: byte[], tag: byte[], plaintext: byte[], associatedData?: byte[]): void;
    decrypt(nonce: ReadOnlySpan_1<CLROf<byte>>, ciphertext: ReadOnlySpan_1<CLROf<byte>>, tag: ReadOnlySpan_1<CLROf<byte>>, plaintext: Span_1<CLROf<byte>>, associatedData?: ReadOnlySpan_1<CLROf<byte>>): void;
    dispose(): void;
    encrypt(nonce: byte[], plaintext: byte[], ciphertext: byte[], tag: byte[], associatedData?: byte[]): void;
    encrypt(nonce: ReadOnlySpan_1<CLROf<byte>>, plaintext: ReadOnlySpan_1<CLROf<byte>>, ciphertext: Span_1<CLROf<byte>>, tag: Span_1<CLROf<byte>>, associatedData?: ReadOnlySpan_1<CLROf<byte>>): void;
}


export const ChaCha20Poly1305: {
    new(key: ReadOnlySpan_1<CLROf<byte>>): ChaCha20Poly1305$instance;
    new(key: byte[]): ChaCha20Poly1305$instance;
    readonly isSupported: boolean;
};


export interface __ChaCha20Poly1305$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ChaCha20Poly1305$instance extends System_Internal.IDisposable$instance {}

export type ChaCha20Poly1305 = ChaCha20Poly1305$instance & __ChaCha20Poly1305$views;


export interface CngAlgorithm$instance {
    readonly algorithm: string;
    equals(obj: unknown): boolean;
    equals(other: CngAlgorithm): boolean;
    getHashCode(): int;
    toString(): string;
}


export const CngAlgorithm: {
    new(algorithm: string): CngAlgorithm$instance;
    readonly rsa: CngAlgorithm;
    readonly ecDiffieHellman: CngAlgorithm;
    readonly ecDiffieHellmanP256: CngAlgorithm;
    readonly ecDiffieHellmanP384: CngAlgorithm;
    readonly ecDiffieHellmanP521: CngAlgorithm;
    readonly ecDsa: CngAlgorithm;
    readonly ecDsaP256: CngAlgorithm;
    readonly ecDsaP384: CngAlgorithm;
    readonly ecDsaP521: CngAlgorithm;
    readonly MD5: CngAlgorithm;
    readonly sha1: CngAlgorithm;
    readonly sha256: CngAlgorithm;
    readonly sha384: CngAlgorithm;
    readonly sha512: CngAlgorithm;
    readonly mlDsa: CngAlgorithm;
    readonly mlKem: CngAlgorithm;
    readonly slhDsa: CngAlgorithm;
};


export interface __CngAlgorithm$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CngAlgorithm>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CngAlgorithm): boolean;
}

export type CngAlgorithm = CngAlgorithm$instance & __CngAlgorithm$views;


export interface CngAlgorithmGroup$instance {
    readonly algorithmGroup: string;
    equals(obj: unknown): boolean;
    equals(other: CngAlgorithmGroup): boolean;
    getHashCode(): int;
    toString(): string;
}


export const CngAlgorithmGroup: {
    new(algorithmGroup: string): CngAlgorithmGroup$instance;
    readonly diffieHellman: CngAlgorithmGroup;
    readonly dsa: CngAlgorithmGroup;
    readonly ecDiffieHellman: CngAlgorithmGroup;
    readonly ecDsa: CngAlgorithmGroup;
    readonly rsa: CngAlgorithmGroup;
    readonly mlDsa: CngAlgorithmGroup;
    readonly mlKem: CngAlgorithmGroup;
    readonly slhDsa: CngAlgorithmGroup;
};


export interface __CngAlgorithmGroup$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CngAlgorithmGroup>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CngAlgorithmGroup): boolean;
}

export type CngAlgorithmGroup = CngAlgorithmGroup$instance & __CngAlgorithmGroup$views;


export interface CngKey$instance {
    readonly algorithm: CngAlgorithm;
    readonly algorithmGroup: CngAlgorithmGroup;
    readonly exportPolicy: CngExportPolicies;
    readonly handle: SafeNCryptKeyHandle;
    readonly isEphemeral: boolean;
    readonly isMachineKey: boolean;
    readonly keyName: string;
    readonly keySize: int;
    readonly keyUsage: CngKeyUsages;
    parentWindowHandle: nint;
    readonly provider: CngProvider;
    readonly providerHandle: SafeNCryptProviderHandle;
    readonly uiPolicy: CngUIPolicy;
    readonly uniqueName: string;
    delete_(): void;
    dispose(): void;
    export_(format: CngKeyBlobFormat): byte[];
    getProperty(name: string, options: CngPropertyOptions): CngProperty;
    hasProperty(name: string, options: CngPropertyOptions): boolean;
    setProperty(property: CngProperty): void;
}


export const CngKey: {
    new(): CngKey$instance;
    create(algorithm: CngAlgorithm, keyName: string, creationParameters: CngKeyCreationParameters): CngKey;
    create(algorithm: CngAlgorithm, keyName: string): CngKey;
    create(algorithm: CngAlgorithm): CngKey;
    exists(keyName: string, provider: CngProvider, options: CngKeyOpenOptions): boolean;
    exists(keyName: string, provider: CngProvider): boolean;
    exists(keyName: string): boolean;
    import_(keyBlob: byte[], format: CngKeyBlobFormat, provider: CngProvider): CngKey;
    import_(keyBlob: byte[], format: CngKeyBlobFormat): CngKey;
    open(keyHandle: SafeNCryptKeyHandle, keyHandleOpenOptions: CngKeyHandleOpenOptions): CngKey;
    open(keyName: string, provider: CngProvider, openOptions: CngKeyOpenOptions): CngKey;
    open(keyName: string, provider: CngProvider): CngKey;
    open(keyName: string): CngKey;
};


export interface __CngKey$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface CngKey$instance extends System_Internal.IDisposable$instance {}

export type CngKey = CngKey$instance & __CngKey$views;


export interface CngKeyBlobFormat$instance {
    readonly format: string;
    equals(obj: unknown): boolean;
    equals(other: CngKeyBlobFormat): boolean;
    getHashCode(): int;
    toString(): string;
}


export const CngKeyBlobFormat: {
    new(format: string): CngKeyBlobFormat$instance;
    readonly eccPrivateBlob: CngKeyBlobFormat;
    readonly eccPublicBlob: CngKeyBlobFormat;
    readonly eccFullPrivateBlob: CngKeyBlobFormat;
    readonly eccFullPublicBlob: CngKeyBlobFormat;
    readonly genericPrivateBlob: CngKeyBlobFormat;
    readonly genericPublicBlob: CngKeyBlobFormat;
    readonly pqDsaPublicBlob: CngKeyBlobFormat;
    readonly pqDsaPrivateBlob: CngKeyBlobFormat;
    readonly pqDsaPrivateSeedBlob: CngKeyBlobFormat;
    readonly mlKemPublicBlob: CngKeyBlobFormat;
    readonly mlKemPrivateBlob: CngKeyBlobFormat;
    readonly mlKemPrivateSeedBlob: CngKeyBlobFormat;
    readonly opaqueTransportBlob: CngKeyBlobFormat;
    readonly pkcs8PrivateBlob: CngKeyBlobFormat;
};


export interface __CngKeyBlobFormat$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CngKeyBlobFormat>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CngKeyBlobFormat): boolean;
}

export type CngKeyBlobFormat = CngKeyBlobFormat$instance & __CngKeyBlobFormat$views;


export interface CngKeyCreationParameters$instance {
    exportPolicy: Nullable_1<CngExportPolicies>;
    keyCreationOptions: CngKeyCreationOptions;
    keyUsage: Nullable_1<CngKeyUsages>;
    readonly parameters: CngPropertyCollection;
    parentWindowHandle: nint;
    provider: CngProvider;
    uiPolicy: CngUIPolicy;
}


export const CngKeyCreationParameters: {
    new(): CngKeyCreationParameters$instance;
};


export type CngKeyCreationParameters = CngKeyCreationParameters$instance;

export interface CngPropertyCollection$instance extends Collection_1<CngProperty> {
    add(item: CngProperty): void;
    add(value: unknown): int;
    clear(): void;
    contains(item: CngProperty): boolean;
    contains(value: unknown): boolean;
    copyTo(array: CngProperty[], index: int): void;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator_1<CngProperty>;
    getEnumerator(): IEnumerator;
    indexOf(item: CngProperty): int;
    insert(index: int, item: CngProperty): void;
    insert(index: int, value: unknown): void;
    remove(item: CngProperty): boolean;
    remove(value: unknown): void;
    removeAt(index: int): void;
}


export const CngPropertyCollection: {
    new(): CngPropertyCollection$instance;
};


export interface __CngPropertyCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<CngProperty>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<CngProperty>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<CngProperty>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<CngProperty>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type CngPropertyCollection = CngPropertyCollection$instance & __CngPropertyCollection$views;


export interface CngProvider$instance {
    readonly provider: string;
    equals(obj: unknown): boolean;
    equals(other: CngProvider): boolean;
    getHashCode(): int;
    toString(): string;
}


export const CngProvider: {
    new(provider: string): CngProvider$instance;
    readonly microsoftPlatformCryptoProvider: CngProvider;
    readonly microsoftSmartCardKeyStorageProvider: CngProvider;
    readonly microsoftSoftwareKeyStorageProvider: CngProvider;
};


export interface __CngProvider$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CngProvider>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CngProvider): boolean;
}

export type CngProvider = CngProvider$instance & __CngProvider$views;


export interface CngUIPolicy$instance {
    readonly creationTitle: string;
    readonly description: string;
    readonly friendlyName: string;
    readonly protectionLevel: CngUIProtectionLevels;
    readonly useContext: string;
}


export const CngUIPolicy: {
    new(protectionLevel: CngUIProtectionLevels): CngUIPolicy$instance;
    new(protectionLevel: CngUIProtectionLevels, friendlyName: string): CngUIPolicy$instance;
    new(protectionLevel: CngUIProtectionLevels, friendlyName: string, description: string): CngUIPolicy$instance;
    new(protectionLevel: CngUIProtectionLevels, friendlyName: string, description: string, useContext: string): CngUIPolicy$instance;
    new(protectionLevel: CngUIProtectionLevels, friendlyName: string, description: string, useContext: string, creationTitle: string): CngUIPolicy$instance;
};


export type CngUIPolicy = CngUIPolicy$instance;

export interface CompositeMLDsa$instance {
    readonly algorithm: CompositeMLDsaAlgorithm;
    dispose(): void;
    exportCompositeMLDsaPrivateKey(): byte[];
    exportCompositeMLDsaPrivateKey(destination: Span_1<CLROf<byte>>): int;
    exportCompositeMLDsaPublicKey(): byte[];
    exportCompositeMLDsaPublicKey(destination: Span_1<CLROf<byte>>): int;
    exportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKeyPem(password: string, pbeParameters: PbeParameters): string;
    exportEncryptedPkcs8PrivateKeyPem(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): string;
    exportEncryptedPkcs8PrivateKeyPem(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): string;
    exportPkcs8PrivateKey(): byte[];
    exportPkcs8PrivateKeyPem(): string;
    exportSubjectPublicKeyInfo(): byte[];
    exportSubjectPublicKeyInfoPem(): string;
    signData(data: byte[], context?: byte[]): byte[];
    signData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, context?: ReadOnlySpan_1<CLROf<byte>>): int;
    tryExportCompositeMLDsaPrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportCompositeMLDsaPublicKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    verifyData(data: byte[], signature: byte[], context?: byte[]): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, context?: ReadOnlySpan_1<CLROf<byte>>): boolean;
}


export const CompositeMLDsa: {
    readonly isSupported: boolean;
    generateKey(algorithm: CompositeMLDsaAlgorithm): CompositeMLDsa;
    importCompositeMLDsaPrivateKey(algorithm: CompositeMLDsaAlgorithm, source: byte[]): CompositeMLDsa;
    importCompositeMLDsaPrivateKey(algorithm: CompositeMLDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    importCompositeMLDsaPublicKey(algorithm: CompositeMLDsaAlgorithm, source: byte[]): CompositeMLDsa;
    importCompositeMLDsaPublicKey(algorithm: CompositeMLDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    importEncryptedPkcs8PrivateKey(password: string, source: byte[]): CompositeMLDsa;
    importFromEncryptedPem(source: ReadOnlySpan_1<CLROf<char>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    importFromEncryptedPem(source: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): CompositeMLDsa;
    importFromEncryptedPem(source: string, passwordBytes: byte[]): CompositeMLDsa;
    importFromEncryptedPem(source: string, password: string): CompositeMLDsa;
    importFromPem(source: ReadOnlySpan_1<CLROf<char>>): CompositeMLDsa;
    importFromPem(source: string): CompositeMLDsa;
    importPkcs8PrivateKey(source: byte[]): CompositeMLDsa;
    importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    importSubjectPublicKeyInfo(source: byte[]): CompositeMLDsa;
    importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    isAlgorithmSupported(algorithm: CompositeMLDsaAlgorithm): boolean;
};


export interface __CompositeMLDsa$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface CompositeMLDsa$instance extends System_Internal.IDisposable$instance {}

export type CompositeMLDsa = CompositeMLDsa$instance & __CompositeMLDsa$views;


export interface CompositeMLDsaAlgorithm$instance {
    readonly maxSignatureSizeInBytes: int;
    readonly name: string;
    equals(other: CompositeMLDsaAlgorithm): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const CompositeMLDsaAlgorithm: {
    new(): CompositeMLDsaAlgorithm$instance;
    readonly mlDsa44WithRSA2048Pss: CompositeMLDsaAlgorithm;
    readonly mlDsa44WithRSA2048Pkcs15: CompositeMLDsaAlgorithm;
    readonly mlDsa44WithEd25519: CompositeMLDsaAlgorithm;
    readonly mlDsa44WithECDsaP256: CompositeMLDsaAlgorithm;
    readonly mlDsa65WithRSA3072Pss: CompositeMLDsaAlgorithm;
    readonly mlDsa65WithRSA3072Pkcs15: CompositeMLDsaAlgorithm;
    readonly mlDsa65WithRSA4096Pss: CompositeMLDsaAlgorithm;
    readonly mlDsa65WithRSA4096Pkcs15: CompositeMLDsaAlgorithm;
    readonly mlDsa65WithECDsaP256: CompositeMLDsaAlgorithm;
    readonly mlDsa65WithECDsaP384: CompositeMLDsaAlgorithm;
    readonly mlDsa65WithECDsaBrainpoolP256r1: CompositeMLDsaAlgorithm;
    readonly mlDsa65WithEd25519: CompositeMLDsaAlgorithm;
    readonly mlDsa87WithECDsaP384: CompositeMLDsaAlgorithm;
    readonly mlDsa87WithECDsaBrainpoolP384r1: CompositeMLDsaAlgorithm;
    readonly mlDsa87WithEd448: CompositeMLDsaAlgorithm;
    readonly mlDsa87WithRSA3072Pss: CompositeMLDsaAlgorithm;
    readonly mlDsa87WithRSA4096Pss: CompositeMLDsaAlgorithm;
    readonly mlDsa87WithECDsaP521: CompositeMLDsaAlgorithm;
};


export interface __CompositeMLDsaAlgorithm$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CompositeMLDsaAlgorithm>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CompositeMLDsaAlgorithm): boolean;
}

export type CompositeMLDsaAlgorithm = CompositeMLDsaAlgorithm$instance & __CompositeMLDsaAlgorithm$views;


export interface CompositeMLDsaCng$instance extends CompositeMLDsa$instance {
    dispose(): void;
    getKey(): CngKey;
}


export const CompositeMLDsaCng: {
    new(key: CngKey): CompositeMLDsaCng$instance;
};


export interface __CompositeMLDsaCng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type CompositeMLDsaCng = CompositeMLDsaCng$instance & __CompositeMLDsaCng$views;


export interface CryptoConfig$instance {
}


export const CryptoConfig: {
    new(): CryptoConfig$instance;
    readonly allowOnlyFipsAlgorithms: boolean;
    addAlgorithm(algorithm: Type, names: string[]): void;
    addOID(oid: string, names: string[]): void;
    createFromName(name: string, args: unknown[]): unknown;
    createFromName(name: string): unknown;
    encodeOID(str: string): byte[];
    mapNameToOID(name: string): string;
};


export type CryptoConfig = CryptoConfig$instance;

export interface CryptographicException$instance extends SystemException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const CryptographicException: {
    new(): CryptographicException$instance;
    new(hr: int): CryptographicException$instance;
    new(message: string): CryptographicException$instance;
    new(message: string, inner: Exception): CryptographicException$instance;
    new(format: string, insert: string): CryptographicException$instance;
};


export interface __CryptographicException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type CryptographicException = CryptographicException$instance & __CryptographicException$views;


export interface CryptographicUnexpectedOperationException$instance extends CryptographicException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const CryptographicUnexpectedOperationException: {
    new(): CryptographicUnexpectedOperationException$instance;
    new(message: string): CryptographicUnexpectedOperationException$instance;
    new(message: string, inner: Exception): CryptographicUnexpectedOperationException$instance;
    new(format: string, insert: string): CryptographicUnexpectedOperationException$instance;
};


export interface __CryptographicUnexpectedOperationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type CryptographicUnexpectedOperationException = CryptographicUnexpectedOperationException$instance & __CryptographicUnexpectedOperationException$views;


export interface CryptoStream$instance extends Stream {
    readonly canRead: boolean;
    readonly canSeek: boolean;
    readonly canWrite: boolean;
    readonly hasFlushedFinalBlock: boolean;
    readonly length: long;
    position: long;
    beginRead(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginWrite(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    clear(): void;
    copyTo(destination: Stream, bufferSize: int): void;
    copyTo(destination: Stream): void;
    copyToAsync(destination: Stream, bufferSize: int, cancellationToken: CancellationToken): Task;
    copyToAsync(destination: Stream): Task;
    copyToAsync(destination: Stream, bufferSize: int): Task;
    copyToAsync(destination: Stream, cancellationToken: CancellationToken): Task;
    dispose(): void;
    disposeAsync(): ValueTask;
    endRead(asyncResult: IAsyncResult): int;
    endWrite(asyncResult: IAsyncResult): void;
    flush(): void;
    flushAsync(cancellationToken: CancellationToken): Task;
    flushAsync(): Task;
    flushFinalBlock(): void;
    flushFinalBlockAsync(cancellationToken?: CancellationToken): ValueTask;
    read(buffer: byte[], offset: int, count: int): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readByte(): int;
    seek(offset: long, origin: SeekOrigin): long;
    setLength(value: long): void;
    write(buffer: byte[], offset: int, count: int): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    writeAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeAsync(buffer: byte[], offset: int, count: int): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeByte(value: byte): void;
}


export const CryptoStream: {
    new(stream: Stream, transform: ICryptoTransform, mode: CryptoStreamMode): CryptoStream$instance;
    new(stream: Stream, transform: ICryptoTransform, mode: CryptoStreamMode, leaveOpen: boolean): CryptoStream$instance;
};


export interface __CryptoStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type CryptoStream = CryptoStream$instance & __CryptoStream$views;


export interface CspKeyContainerInfo$instance {
    readonly accessible: boolean;
    readonly exportable: boolean;
    readonly hardwareDevice: boolean;
    readonly keyContainerName: string;
    readonly keyNumber: KeyNumber;
    readonly machineKeyStore: boolean;
    readonly protected_: boolean;
    readonly providerName: string;
    readonly providerType: int;
    readonly randomlyGenerated: boolean;
    readonly removable: boolean;
    readonly uniqueKeyContainerName: string;
}


export const CspKeyContainerInfo: {
    new(parameters: CspParameters): CspKeyContainerInfo$instance;
};


export type CspKeyContainerInfo = CspKeyContainerInfo$instance;

export interface CspParameters$instance {
    providerType: int;
    providerName: string;
    keyContainerName: string;
    keyNumber: int;
    flags: CspProviderFlags;
    keyPassword: SecureString;
    parentWindowHandle: nint;
}


export const CspParameters: {
    new(): CspParameters$instance;
    new(dwTypeIn: int): CspParameters$instance;
    new(dwTypeIn: int, strProviderNameIn: string): CspParameters$instance;
    new(dwTypeIn: int, strProviderNameIn: string, strContainerNameIn: string): CspParameters$instance;
};


export type CspParameters = CspParameters$instance;

export interface DeriveBytes$instance {
    dispose(): void;
    getBytes(cb: int): byte[];
    reset(): void;
}


export const DeriveBytes: {
};


export interface __DeriveBytes$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DeriveBytes$instance extends System_Internal.IDisposable$instance {}

export type DeriveBytes = DeriveBytes$instance & __DeriveBytes$views;


export interface DES$instance extends SymmetricAlgorithm$instance {
    key: byte[];
    dispose(): void;
}


export const DES: {
    isSemiWeakKey(rgbKey: byte[]): boolean;
    isWeakKey(rgbKey: byte[]): boolean;
};


export interface __DES$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type DES = DES$instance & __DES$views;


export interface DESCryptoServiceProvider$instance extends DES$instance {
    blockSize: int;
    feedbackSize: int;
    IV: byte[];
    key: byte[];
    keySize: int;
    readonly legalBlockSizes: KeySizes[];
    readonly legalKeySizes: KeySizes[];
    mode: CipherMode;
    padding: PaddingMode;
    createDecryptor(): ICryptoTransform;
    createDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    createEncryptor(): ICryptoTransform;
    createEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    dispose(): void;
    generateIV(): void;
    generateKey(): void;
}


export const DESCryptoServiceProvider: {
    new(): DESCryptoServiceProvider$instance;
};


export interface __DESCryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type DESCryptoServiceProvider = DESCryptoServiceProvider$instance & __DESCryptoServiceProvider$views;


export interface DSA$instance extends AsymmetricAlgorithm$instance {
    createSignature(rgbHash: byte[]): byte[];
    createSignature(rgbHash: byte[], signatureFormat: DSASignatureFormat): byte[];
    dispose(): void;
    exportParameters(includePrivateParameters: boolean): DSAParameters;
    fromXmlString(xmlString: string): void;
    getMaxSignatureSize(signatureFormat: DSASignatureFormat): int;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): void;
    importFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): void;
    importFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): void;
    importFromPem(input: ReadOnlySpan_1<CLROf<char>>): void;
    importFromPem(input: ReadOnlySpan_1<CLROf<char>>): void;
    importParameters(parameters: DSAParameters): void;
    importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    signData(data: byte[], hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signData(data: Stream, hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: Stream, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    toXmlString(includePrivateParameters: boolean): string;
    tryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    trySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, bytesWritten: { value: ref<int> }): boolean;
    trySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    verifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
    verifySignature(rgbHash: byte[], rgbSignature: byte[], signatureFormat: DSASignatureFormat): boolean;
    verifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
}


export const DSA: {
    create(parameters: DSAParameters): DSA;
    create(algName: string): DSA;
};


export interface __DSA$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type DSA = DSA$instance & __DSA$views;


export interface DSACng$instance extends DSA$instance {
    readonly key: CngKey;
    createSignature(rgbHash: byte[]): byte[];
    createSignature(rgbHash: byte[], signatureFormat: DSASignatureFormat): byte[];
    dispose(): void;
    exportParameters(includePrivateParameters: boolean): DSAParameters;
    importParameters(parameters: DSAParameters): void;
    verifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
    verifySignature(rgbHash: byte[], rgbSignature: byte[], signatureFormat: DSASignatureFormat): boolean;
    verifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
}


export const DSACng: {
    new(): DSACng$instance;
    new(keySize: int): DSACng$instance;
    new(key: CngKey): DSACng$instance;
};


export interface __DSACng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type DSACng = DSACng$instance & __DSACng$views;


export interface DSACryptoServiceProvider$instance extends DSA$instance {
    readonly cspKeyContainerInfo: CspKeyContainerInfo;
    readonly keyExchangeAlgorithm: string;
    keySize: int;
    readonly legalKeySizes: KeySizes[];
    persistKeyInCsp: boolean;
    readonly publicOnly: boolean;
    readonly signatureAlgorithm: string;
    createSignature(rgbHash: byte[]): byte[];
    createSignature(rgbHash: byte[], signatureFormat: DSASignatureFormat): byte[];
    dispose(): void;
    exportCspBlob(includePrivateParameters: boolean): byte[];
    exportParameters(includePrivateParameters: boolean): DSAParameters;
    fromXmlString(xmlString: string): void;
    importCspBlob(keyBlob: byte[]): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importParameters(parameters: DSAParameters): void;
    signData(inputStream: Stream): byte[];
    signData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: Stream, hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: byte[], hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signData(data: Stream, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signHash(rgbHash: byte[], str: string): byte[];
    toXmlString(includePrivateParameters: boolean): string;
    tryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    trySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, bytesWritten: { value: ref<int> }): boolean;
    trySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, bytesWritten: { value: ref<int> }): boolean;
    trySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    verifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyHash(rgbHash: byte[], str: string, rgbSignature: byte[]): boolean;
    verifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
    verifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifySignature(rgbHash: byte[], rgbSignature: byte[], signatureFormat: DSASignatureFormat): boolean;
    verifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
}


export const DSACryptoServiceProvider: {
    new(): DSACryptoServiceProvider$instance;
    new(dwKeySize: int): DSACryptoServiceProvider$instance;
    new(dwKeySize: int, parameters: CspParameters): DSACryptoServiceProvider$instance;
    new(parameters: CspParameters): DSACryptoServiceProvider$instance;
    useMachineKeyStore: boolean;
};


export interface __DSACryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICspAsymmetricAlgorithm(): ICspAsymmetricAlgorithm$instance;
}

export interface DSACryptoServiceProvider$instance extends ICspAsymmetricAlgorithm$instance {}

export type DSACryptoServiceProvider = DSACryptoServiceProvider$instance & __DSACryptoServiceProvider$views;


export interface DSAOpenSsl$instance extends DSA$instance {
    keySize: int;
    readonly legalKeySizes: KeySizes[];
    createSignature(rgbHash: byte[]): byte[];
    createSignature(rgbHash: byte[], signatureFormat: DSASignatureFormat): byte[];
    dispose(): void;
    duplicateKeyHandle(): SafeEvpPKeyHandle;
    exportParameters(includePrivateParameters: boolean): DSAParameters;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importParameters(parameters: DSAParameters): void;
    tryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    verifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
    verifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifySignature(rgbHash: byte[], rgbSignature: byte[], signatureFormat: DSASignatureFormat): boolean;
    verifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
}


export const DSAOpenSsl: {
    new(): DSAOpenSsl$instance;
    new(keySize: int): DSAOpenSsl$instance;
    new(parameters: DSAParameters): DSAOpenSsl$instance;
    new(pkeyHandle: SafeEvpPKeyHandle): DSAOpenSsl$instance;
    new(handle: nint): DSAOpenSsl$instance;
};


export interface __DSAOpenSsl$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type DSAOpenSsl = DSAOpenSsl$instance & __DSAOpenSsl$views;


export interface DSASignatureDeformatter$instance extends AsymmetricSignatureDeformatter {
    setHashAlgorithm(strName: string): void;
    setKey(key: AsymmetricAlgorithm): void;
    verifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
    verifySignature(hash: HashAlgorithm, rgbSignature: byte[]): boolean;
}


export const DSASignatureDeformatter: {
    new(): DSASignatureDeformatter$instance;
    new(key: AsymmetricAlgorithm): DSASignatureDeformatter$instance;
};


export type DSASignatureDeformatter = DSASignatureDeformatter$instance;

export interface DSASignatureFormatter$instance extends AsymmetricSignatureFormatter {
    createSignature(rgbHash: byte[]): byte[];
    createSignature(hash: HashAlgorithm): byte[];
    setHashAlgorithm(strName: string): void;
    setKey(key: AsymmetricAlgorithm): void;
}


export const DSASignatureFormatter: {
    new(): DSASignatureFormatter$instance;
    new(key: AsymmetricAlgorithm): DSASignatureFormatter$instance;
};


export type DSASignatureFormatter = DSASignatureFormatter$instance;

export interface ECAlgorithm$instance extends AsymmetricAlgorithm$instance {
    dispose(): void;
    exportECPrivateKey(): byte[];
    exportECPrivateKeyPem(): string;
    exportExplicitParameters(includePrivateParameters: boolean): ECParameters;
    exportParameters(includePrivateParameters: boolean): ECParameters;
    generateKey(curve: ECCurve): void;
    importECPrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): void;
    importFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): void;
    importFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): void;
    importFromPem(input: ReadOnlySpan_1<CLROf<char>>): void;
    importFromPem(input: ReadOnlySpan_1<CLROf<char>>): void;
    importParameters(parameters: ECParameters): void;
    importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    tryExportECPrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportECPrivateKeyPem(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export const ECAlgorithm: {
};


export interface __ECAlgorithm$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ECAlgorithm = ECAlgorithm$instance & __ECAlgorithm$views;


export interface ECDiffieHellman$instance extends ECAlgorithm$instance {
    readonly keyExchangeAlgorithm: string;
    readonly publicKey: ECDiffieHellmanPublicKey;
    readonly signatureAlgorithm: string;
    deriveKeyFromHash(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName): byte[];
    deriveKeyFromHash(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, secretPrepend: byte[], secretAppend: byte[]): byte[];
    deriveKeyFromHmac(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, hmacKey: byte[]): byte[];
    deriveKeyFromHmac(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, hmacKey: byte[], secretPrepend: byte[], secretAppend: byte[]): byte[];
    deriveKeyMaterial(otherPartyPublicKey: ECDiffieHellmanPublicKey): byte[];
    deriveKeyTls(otherPartyPublicKey: ECDiffieHellmanPublicKey, prfLabel: byte[], prfSeed: byte[]): byte[];
    deriveRawSecretAgreement(otherPartyPublicKey: ECDiffieHellmanPublicKey): byte[];
    dispose(): void;
    fromXmlString(xmlString: string): void;
    toXmlString(includePrivateParameters: boolean): string;
}


export const ECDiffieHellman: {
    create(): ECDiffieHellman;
    create(curve: ECCurve): ECDiffieHellman;
    create(parameters: ECParameters): ECDiffieHellman;
    create(algorithm: string): ECDiffieHellman;
};


export interface __ECDiffieHellman$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ECDiffieHellman = ECDiffieHellman$instance & __ECDiffieHellman$views;


export interface ECDiffieHellmanCng$instance extends ECDiffieHellman$instance {
    hashAlgorithm: CngAlgorithm;
    hmacKey: byte[];
    readonly key: CngKey;
    keyDerivationFunction: ECDiffieHellmanKeyDerivationFunction;
    label: byte[];
    readonly publicKey: ECDiffieHellmanPublicKey;
    secretAppend: byte[];
    secretPrepend: byte[];
    seed: byte[];
    readonly useSecretAgreementAsHmacKey: boolean;
    deriveKeyMaterial(otherPartyPublicKey: ECDiffieHellmanPublicKey): byte[];
    deriveSecretAgreementHandle(otherPartyPublicKey: CngKey): SafeNCryptSecretHandle;
    deriveSecretAgreementHandle(otherPartyPublicKey: ECDiffieHellmanPublicKey): SafeNCryptSecretHandle;
    dispose(): void;
    fromXmlString(xmlString: string): void;
    toXmlString(includePrivateParameters: boolean): string;
}


export const ECDiffieHellmanCng: {
    new(): ECDiffieHellmanCng$instance;
    new(keySize: int): ECDiffieHellmanCng$instance;
    new(key: CngKey): ECDiffieHellmanCng$instance;
    new(curve: ECCurve): ECDiffieHellmanCng$instance;
};


export interface __ECDiffieHellmanCng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ECDiffieHellmanCng = ECDiffieHellmanCng$instance & __ECDiffieHellmanCng$views;


export interface ECDiffieHellmanCngPublicKey$instance extends ECDiffieHellmanPublicKey$instance {
    readonly blobFormat: CngKeyBlobFormat;
    dispose(): void;
    import_(): CngKey;
    toXmlString(): string;
}


export const ECDiffieHellmanCngPublicKey: {
    new(): ECDiffieHellmanCngPublicKey$instance;
    fromByteArray(publicKeyBlob: byte[], format: CngKeyBlobFormat): ECDiffieHellmanPublicKey;
    fromXmlString(xml: string): ECDiffieHellmanCngPublicKey;
};


export interface __ECDiffieHellmanCngPublicKey$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ECDiffieHellmanCngPublicKey = ECDiffieHellmanCngPublicKey$instance & __ECDiffieHellmanCngPublicKey$views;


export interface ECDiffieHellmanOpenSsl$instance extends ECDiffieHellman$instance {
    keySize: int;
    readonly legalKeySizes: KeySizes[];
    readonly publicKey: ECDiffieHellmanPublicKey;
    deriveKeyFromHash(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, secretPrepend: byte[], secretAppend: byte[]): byte[];
    deriveKeyFromHash(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName): byte[];
    deriveKeyFromHmac(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, hmacKey: byte[], secretPrepend: byte[], secretAppend: byte[]): byte[];
    deriveKeyFromHmac(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, hmacKey: byte[]): byte[];
    deriveKeyMaterial(otherPartyPublicKey: ECDiffieHellmanPublicKey): byte[];
    deriveKeyTls(otherPartyPublicKey: ECDiffieHellmanPublicKey, prfLabel: byte[], prfSeed: byte[]): byte[];
    deriveRawSecretAgreement(otherPartyPublicKey: ECDiffieHellmanPublicKey): byte[];
    dispose(): void;
    duplicateKeyHandle(): SafeEvpPKeyHandle;
    exportExplicitParameters(includePrivateParameters: boolean): ECParameters;
    exportParameters(includePrivateParameters: boolean): ECParameters;
    generateKey(curve: ECCurve): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importParameters(parameters: ECParameters): void;
}


export const ECDiffieHellmanOpenSsl: {
    new(curve: ECCurve): ECDiffieHellmanOpenSsl$instance;
    new(): ECDiffieHellmanOpenSsl$instance;
    new(keySize: int): ECDiffieHellmanOpenSsl$instance;
    new(pkeyHandle: SafeEvpPKeyHandle): ECDiffieHellmanOpenSsl$instance;
    new(handle: nint): ECDiffieHellmanOpenSsl$instance;
};


export interface __ECDiffieHellmanOpenSsl$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ECDiffieHellmanOpenSsl = ECDiffieHellmanOpenSsl$instance & __ECDiffieHellmanOpenSsl$views;


export interface ECDiffieHellmanPublicKey$instance {
    dispose(): void;
    exportExplicitParameters(): ECParameters;
    exportParameters(): ECParameters;
    exportSubjectPublicKeyInfo(): byte[];
    toByteArray(): byte[];
    toXmlString(): string;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export const ECDiffieHellmanPublicKey: {
};


export interface __ECDiffieHellmanPublicKey$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ECDiffieHellmanPublicKey$instance extends System_Internal.IDisposable$instance {}

export type ECDiffieHellmanPublicKey = ECDiffieHellmanPublicKey$instance & __ECDiffieHellmanPublicKey$views;


export interface ECDsa$instance extends ECAlgorithm$instance {
    readonly keyExchangeAlgorithm: string;
    readonly signatureAlgorithm: string;
    dispose(): void;
    fromXmlString(xmlString: string): void;
    getMaxSignatureSize(signatureFormat: DSASignatureFormat): int;
    signData(data: byte[], hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signData(data: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signData(data: Stream, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signData(data: Stream, hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): int;
    signData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): int;
    signHash(hash: byte[], signatureFormat: DSASignatureFormat): byte[];
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): byte[];
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>): byte[];
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): int;
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    signHash(hash: byte[]): byte[];
    toXmlString(includePrivateParameters: boolean): string;
    trySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, bytesWritten: { value: ref<int> }): boolean;
    trySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    trySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    trySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    verifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyHash(hash: byte[], signature: byte[]): boolean;
    verifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifyHash(hash: byte[], signature: byte[], signatureFormat: DSASignatureFormat): boolean;
    verifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
}


export const ECDsa: {
    create(): ECDsa;
    create(curve: ECCurve): ECDsa;
    create(parameters: ECParameters): ECDsa;
    create(algorithm: string): ECDsa;
};


export interface __ECDsa$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ECDsa = ECDsa$instance & __ECDsa$views;


export interface ECDsaCng$instance extends ECDsa$instance {
    hashAlgorithm: CngAlgorithm;
    readonly key: CngKey;
    dispose(): void;
    fromXmlString(xmlString: string): void;
    signData(data: Stream): byte[];
    signData(data: byte[], hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signData(data: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signData(data: Stream, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signData(data: Stream, hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): int;
    signData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): int;
    signHash(hash: byte[]): byte[];
    signHash(hash: byte[], signatureFormat: DSASignatureFormat): byte[];
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): byte[];
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>): byte[];
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): int;
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    toXmlString(includePrivateParameters: boolean): string;
    verifyData(data: Stream, signature: byte[]): boolean;
    verifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyHash(hash: byte[], signature: byte[]): boolean;
    verifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifyHash(hash: byte[], signature: byte[], signatureFormat: DSASignatureFormat): boolean;
    verifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
}


export const ECDsaCng: {
    new(): ECDsaCng$instance;
    new(keySize: int): ECDsaCng$instance;
    new(key: CngKey): ECDsaCng$instance;
    new(curve: ECCurve): ECDsaCng$instance;
};


export interface __ECDsaCng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ECDsaCng = ECDsaCng$instance & __ECDsaCng$views;


export interface ECDsaOpenSsl$instance extends ECDsa$instance {
    keySize: int;
    readonly legalKeySizes: KeySizes[];
    dispose(): void;
    duplicateKeyHandle(): SafeEvpPKeyHandle;
    exportExplicitParameters(includePrivateParameters: boolean): ECParameters;
    exportParameters(includePrivateParameters: boolean): ECParameters;
    generateKey(curve: ECCurve): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importParameters(parameters: ECParameters): void;
    signHash(hash: byte[]): byte[];
    signHash(hash: byte[], signatureFormat: DSASignatureFormat): byte[];
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): byte[];
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>): byte[];
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): int;
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    trySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    trySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    trySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    verifyHash(hash: byte[], signature: byte[]): boolean;
    verifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifyHash(hash: byte[], signature: byte[], signatureFormat: DSASignatureFormat): boolean;
    verifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
}


export const ECDsaOpenSsl: {
    new(curve: ECCurve): ECDsaOpenSsl$instance;
    new(): ECDsaOpenSsl$instance;
    new(keySize: int): ECDsaOpenSsl$instance;
    new(pkeyHandle: SafeEvpPKeyHandle): ECDsaOpenSsl$instance;
    new(handle: nint): ECDsaOpenSsl$instance;
};


export interface __ECDsaOpenSsl$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ECDsaOpenSsl = ECDsaOpenSsl$instance & __ECDsaOpenSsl$views;


export interface FromBase64Transform$instance {
    readonly canReuseTransform: boolean;
    readonly canTransformMultipleBlocks: boolean;
    readonly inputBlockSize: int;
    readonly outputBlockSize: int;
    clear(): void;
    dispose(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const FromBase64Transform: {
    new(): FromBase64Transform$instance;
    new(whitespaces: FromBase64TransformMode): FromBase64Transform$instance;
};


export interface __FromBase64Transform$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type FromBase64Transform = FromBase64Transform$instance & __FromBase64Transform$views;


export interface HashAlgorithm$instance {
    readonly canReuseTransform: boolean;
    readonly canTransformMultipleBlocks: boolean;
    readonly hash: byte[];
    readonly hashSize: int;
    readonly inputBlockSize: int;
    readonly outputBlockSize: int;
    clear(): void;
    computeHash(buffer: byte[]): byte[];
    computeHash(buffer: byte[], offset: int, count: int): byte[];
    computeHash(inputStream: Stream): byte[];
    computeHashAsync(inputStream: Stream, cancellationToken?: CancellationToken): Task_1<byte[]>;
    dispose(): void;
    initialize(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    tryComputeHash(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export const HashAlgorithm: {
    create(): HashAlgorithm;
    create(hashName: string): HashAlgorithm;
};


export interface __HashAlgorithm$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HashAlgorithm = HashAlgorithm$instance & __HashAlgorithm$views;


export interface HMAC$instance extends KeyedHashAlgorithm$instance {
    hashName: string;
    key: byte[];
    dispose(): void;
    initialize(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const HMAC: {
};


export interface __HMAC$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMAC = HMAC$instance & __HMAC$views;


export interface HMACMD5$instance extends HMAC$instance {
    key: byte[];
    dispose(): void;
    initialize(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const HMACMD5: {
    new(): HMACMD5$instance;
    new(key: byte[]): HMACMD5$instance;
    readonly hashSizeInBits: int;
    readonly hashSizeInBytes: int;
    hashData(key: byte[], source: byte[]): byte[];
    hashData(key: byte[], source: Stream): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    hashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    tryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __HMACMD5$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMACMD5 = HMACMD5$instance & __HMACMD5$views;


export interface HMACSHA1$instance extends HMAC$instance {
    key: byte[];
    dispose(): void;
    initialize(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const HMACSHA1: {
    new(): HMACSHA1$instance;
    new(key: byte[]): HMACSHA1$instance;
    new(key: byte[], useManagedSha1: boolean): HMACSHA1$instance;
    readonly hashSizeInBits: int;
    readonly hashSizeInBytes: int;
    hashData(key: byte[], source: byte[]): byte[];
    hashData(key: byte[], source: Stream): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    hashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    tryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __HMACSHA1$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMACSHA1 = HMACSHA1$instance & __HMACSHA1$views;


export interface HMACSHA256$instance extends HMAC$instance {
    key: byte[];
    dispose(): void;
    initialize(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const HMACSHA256: {
    new(): HMACSHA256$instance;
    new(key: byte[]): HMACSHA256$instance;
    readonly hashSizeInBits: int;
    readonly hashSizeInBytes: int;
    hashData(key: byte[], source: byte[]): byte[];
    hashData(key: byte[], source: Stream): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    hashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    tryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __HMACSHA256$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMACSHA256 = HMACSHA256$instance & __HMACSHA256$views;


export interface HMACSHA3_256$instance extends HMAC$instance {
    key: byte[];
    dispose(): void;
    initialize(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const HMACSHA3_256: {
    new(): HMACSHA3_256$instance;
    new(key: byte[]): HMACSHA3_256$instance;
    readonly hashSizeInBits: int;
    readonly hashSizeInBytes: int;
    readonly isSupported: boolean;
    hashData(key: byte[], source: byte[]): byte[];
    hashData(key: byte[], source: Stream): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    hashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    tryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __HMACSHA3_256$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMACSHA3_256 = HMACSHA3_256$instance & __HMACSHA3_256$views;


export interface HMACSHA3_384$instance extends HMAC$instance {
    key: byte[];
    dispose(): void;
    initialize(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const HMACSHA3_384: {
    new(): HMACSHA3_384$instance;
    new(key: byte[]): HMACSHA3_384$instance;
    readonly hashSizeInBits: int;
    readonly hashSizeInBytes: int;
    readonly isSupported: boolean;
    hashData(key: byte[], source: byte[]): byte[];
    hashData(key: byte[], source: Stream): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    hashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    tryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __HMACSHA3_384$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMACSHA3_384 = HMACSHA3_384$instance & __HMACSHA3_384$views;


export interface HMACSHA3_512$instance extends HMAC$instance {
    key: byte[];
    dispose(): void;
    initialize(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const HMACSHA3_512: {
    new(): HMACSHA3_512$instance;
    new(key: byte[]): HMACSHA3_512$instance;
    readonly hashSizeInBits: int;
    readonly hashSizeInBytes: int;
    readonly isSupported: boolean;
    hashData(key: byte[], source: byte[]): byte[];
    hashData(key: byte[], source: Stream): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    hashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    tryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __HMACSHA3_512$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMACSHA3_512 = HMACSHA3_512$instance & __HMACSHA3_512$views;


export interface HMACSHA384$instance extends HMAC$instance {
    key: byte[];
    produceLegacyHmacValues: boolean;
    dispose(): void;
    initialize(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const HMACSHA384: {
    new(): HMACSHA384$instance;
    new(key: byte[]): HMACSHA384$instance;
    readonly hashSizeInBits: int;
    readonly hashSizeInBytes: int;
    hashData(key: byte[], source: byte[]): byte[];
    hashData(key: byte[], source: Stream): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    hashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    tryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __HMACSHA384$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMACSHA384 = HMACSHA384$instance & __HMACSHA384$views;


export interface HMACSHA512$instance extends HMAC$instance {
    key: byte[];
    produceLegacyHmacValues: boolean;
    dispose(): void;
    initialize(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const HMACSHA512: {
    new(): HMACSHA512$instance;
    new(key: byte[]): HMACSHA512$instance;
    readonly hashSizeInBits: int;
    readonly hashSizeInBytes: int;
    hashData(key: byte[], source: byte[]): byte[];
    hashData(key: byte[], source: Stream): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    hashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    tryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __HMACSHA512$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMACSHA512 = HMACSHA512$instance & __HMACSHA512$views;


export interface IncrementalHash$instance {
    readonly algorithmName: HashAlgorithmName;
    readonly hashLengthInBytes: int;
    appendData(data: byte[]): void;
    appendData(data: byte[], offset: int, count: int): void;
    appendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    clone(): IncrementalHash;
    dispose(): void;
    getCurrentHash(): byte[];
    getCurrentHash(destination: Span_1<CLROf<byte>>): int;
    getHashAndReset(): byte[];
    getHashAndReset(destination: Span_1<CLROf<byte>>): int;
    tryGetCurrentHash(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryGetHashAndReset(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export const IncrementalHash: {
    new(): IncrementalHash$instance;
    createHash(hashAlgorithm: HashAlgorithmName): IncrementalHash;
    createHMAC(hashAlgorithm: HashAlgorithmName, key: byte[]): IncrementalHash;
    createHMAC(hashAlgorithm: HashAlgorithmName, key: ReadOnlySpan_1<CLROf<byte>>): IncrementalHash;
};


export interface __IncrementalHash$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface IncrementalHash$instance extends System_Internal.IDisposable$instance {}

export type IncrementalHash = IncrementalHash$instance & __IncrementalHash$views;


export interface KeyedHashAlgorithm$instance extends HashAlgorithm$instance {
    key: byte[];
    dispose(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const KeyedHashAlgorithm: {
};


export interface __KeyedHashAlgorithm$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type KeyedHashAlgorithm = KeyedHashAlgorithm$instance & __KeyedHashAlgorithm$views;


export interface KeySizes$instance {
    readonly maxSize: int;
    readonly minSize: int;
    readonly skipSize: int;
}


export const KeySizes: {
    new(minSize: int, maxSize: int, skipSize: int): KeySizes$instance;
};


export type KeySizes = KeySizes$instance;

export interface Kmac128$instance {
    appendData(data: byte[]): void;
    appendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    clone(): Kmac128;
    dispose(): void;
    getCurrentHash(outputLength: int): byte[];
    getCurrentHash(destination: Span_1<CLROf<byte>>): void;
    getHashAndReset(outputLength: int): byte[];
    getHashAndReset(destination: Span_1<CLROf<byte>>): void;
}


export const Kmac128: {
    new(key: byte[], customizationString: byte[]): Kmac128$instance;
    new(key: ReadOnlySpan_1<CLROf<byte>>, customizationString: ReadOnlySpan_1<CLROf<byte>>): Kmac128$instance;
    readonly isSupported: boolean;
    hashData(key: byte[], source: byte[], outputLength: int, customizationString?: byte[]): byte[];
    hashData(key: byte[], source: Stream, outputLength: int, customizationString?: byte[]): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    hashDataAsync(key: byte[], source: Stream, outputLength: int, customizationString?: byte[], cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
};


export interface __Kmac128$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Kmac128$instance extends System_Internal.IDisposable$instance {}

export type Kmac128 = Kmac128$instance & __Kmac128$views;


export interface Kmac256$instance {
    appendData(data: byte[]): void;
    appendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    clone(): Kmac256;
    dispose(): void;
    getCurrentHash(outputLength: int): byte[];
    getCurrentHash(destination: Span_1<CLROf<byte>>): void;
    getHashAndReset(outputLength: int): byte[];
    getHashAndReset(destination: Span_1<CLROf<byte>>): void;
}


export const Kmac256: {
    new(key: byte[], customizationString: byte[]): Kmac256$instance;
    new(key: ReadOnlySpan_1<CLROf<byte>>, customizationString: ReadOnlySpan_1<CLROf<byte>>): Kmac256$instance;
    readonly isSupported: boolean;
    hashData(key: byte[], source: byte[], outputLength: int, customizationString?: byte[]): byte[];
    hashData(key: byte[], source: Stream, outputLength: int, customizationString?: byte[]): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    hashDataAsync(key: byte[], source: Stream, outputLength: int, customizationString?: byte[], cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
};


export interface __Kmac256$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Kmac256$instance extends System_Internal.IDisposable$instance {}

export type Kmac256 = Kmac256$instance & __Kmac256$views;


export interface KmacXof128$instance {
    appendData(data: byte[]): void;
    appendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    clone(): KmacXof128;
    dispose(): void;
    getCurrentHash(outputLength: int): byte[];
    getCurrentHash(destination: Span_1<CLROf<byte>>): void;
    getHashAndReset(outputLength: int): byte[];
    getHashAndReset(destination: Span_1<CLROf<byte>>): void;
}


export const KmacXof128: {
    new(key: byte[], customizationString: byte[]): KmacXof128$instance;
    new(key: ReadOnlySpan_1<CLROf<byte>>, customizationString: ReadOnlySpan_1<CLROf<byte>>): KmacXof128$instance;
    readonly isSupported: boolean;
    hashData(key: byte[], source: byte[], outputLength: int, customizationString?: byte[]): byte[];
    hashData(key: byte[], source: Stream, outputLength: int, customizationString?: byte[]): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    hashDataAsync(key: byte[], source: Stream, outputLength: int, customizationString?: byte[], cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
};


export interface __KmacXof128$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface KmacXof128$instance extends System_Internal.IDisposable$instance {}

export type KmacXof128 = KmacXof128$instance & __KmacXof128$views;


export interface KmacXof256$instance {
    appendData(data: byte[]): void;
    appendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    clone(): KmacXof256;
    dispose(): void;
    getCurrentHash(outputLength: int): byte[];
    getCurrentHash(destination: Span_1<CLROf<byte>>): void;
    getHashAndReset(outputLength: int): byte[];
    getHashAndReset(destination: Span_1<CLROf<byte>>): void;
}


export const KmacXof256: {
    new(key: byte[], customizationString: byte[]): KmacXof256$instance;
    new(key: ReadOnlySpan_1<CLROf<byte>>, customizationString: ReadOnlySpan_1<CLROf<byte>>): KmacXof256$instance;
    readonly isSupported: boolean;
    hashData(key: byte[], source: byte[], outputLength: int, customizationString?: byte[]): byte[];
    hashData(key: byte[], source: Stream, outputLength: int, customizationString?: byte[]): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    hashDataAsync(key: byte[], source: Stream, outputLength: int, customizationString?: byte[], cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
};


export interface __KmacXof256$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface KmacXof256$instance extends System_Internal.IDisposable$instance {}

export type KmacXof256 = KmacXof256$instance & __KmacXof256$views;


export interface MaskGenerationMethod$instance {
    generateMask(rgbSeed: byte[], cbReturn: int): byte[];
}


export const MaskGenerationMethod: {
};


export type MaskGenerationMethod = MaskGenerationMethod$instance;

export interface MD5$instance extends HashAlgorithm$instance {
    dispose(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const MD5: {
    readonly hashSizeInBits: int;
    readonly hashSizeInBytes: int;
    hashData(source: byte[]): byte[];
    hashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    hashData(source: Stream): byte[];
    hashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    hashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    hashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    hashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    tryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __MD5$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type MD5 = MD5$instance & __MD5$views;


export interface MD5CryptoServiceProvider$instance extends MD5$instance {
    dispose(): void;
    initialize(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const MD5CryptoServiceProvider: {
    new(): MD5CryptoServiceProvider$instance;
};


export interface __MD5CryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type MD5CryptoServiceProvider = MD5CryptoServiceProvider$instance & __MD5CryptoServiceProvider$views;


export interface MLDsa$instance {
    readonly algorithm: MLDsaAlgorithm;
    dispose(): void;
    exportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKeyPem(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): string;
    exportEncryptedPkcs8PrivateKeyPem(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): string;
    exportEncryptedPkcs8PrivateKeyPem(password: string, pbeParameters: PbeParameters): string;
    exportMLDsaPrivateKey(): byte[];
    exportMLDsaPrivateKey(destination: Span_1<CLROf<byte>>): void;
    exportMLDsaPrivateSeed(): byte[];
    exportMLDsaPrivateSeed(destination: Span_1<CLROf<byte>>): void;
    exportMLDsaPublicKey(): byte[];
    exportMLDsaPublicKey(destination: Span_1<CLROf<byte>>): void;
    exportPkcs8PrivateKey(): byte[];
    exportPkcs8PrivateKeyPem(): string;
    exportSubjectPublicKeyInfo(): byte[];
    exportSubjectPublicKeyInfoPem(): string;
    signData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, context?: ReadOnlySpan_1<CLROf<byte>>): void;
    signData(data: byte[], context?: byte[]): byte[];
    signMu(externalMu: byte[]): byte[];
    signMu(externalMu: ReadOnlySpan_1<CLROf<byte>>): byte[];
    signMu(externalMu: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): void;
    signPreHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithmOid: string, context?: ReadOnlySpan_1<CLROf<byte>>): void;
    signPreHash(hash: byte[], hashAlgorithmOid: string, context?: byte[]): byte[];
    tryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, context?: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifyData(data: byte[], signature: byte[], context?: byte[]): boolean;
    verifyMu(externalMu: byte[], signature: byte[]): boolean;
    verifyMu(externalMu: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifyPreHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithmOid: string, context?: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifyPreHash(hash: byte[], signature: byte[], hashAlgorithmOid: string, context?: byte[]): boolean;
}


export const MLDsa: {
    readonly isSupported: boolean;
    generateKey(algorithm: MLDsaAlgorithm): MLDsa;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    importEncryptedPkcs8PrivateKey(password: string, source: byte[]): MLDsa;
    importFromEncryptedPem(source: ReadOnlySpan_1<CLROf<char>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    importFromEncryptedPem(source: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): MLDsa;
    importFromEncryptedPem(source: string, passwordBytes: byte[]): MLDsa;
    importFromEncryptedPem(source: string, password: string): MLDsa;
    importFromPem(source: ReadOnlySpan_1<CLROf<char>>): MLDsa;
    importFromPem(source: string): MLDsa;
    importMLDsaPrivateKey(algorithm: MLDsaAlgorithm, source: byte[]): MLDsa;
    importMLDsaPrivateKey(algorithm: MLDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    importMLDsaPrivateSeed(algorithm: MLDsaAlgorithm, source: byte[]): MLDsa;
    importMLDsaPrivateSeed(algorithm: MLDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    importMLDsaPublicKey(algorithm: MLDsaAlgorithm, source: byte[]): MLDsa;
    importMLDsaPublicKey(algorithm: MLDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    importPkcs8PrivateKey(source: byte[]): MLDsa;
    importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    importSubjectPublicKeyInfo(source: byte[]): MLDsa;
    importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
};


export interface __MLDsa$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MLDsa$instance extends System_Internal.IDisposable$instance {}

export type MLDsa = MLDsa$instance & __MLDsa$views;


export interface MLDsaAlgorithm$instance {
    readonly muSizeInBytes: int;
    readonly name: string;
    readonly privateKeySizeInBytes: int;
    readonly privateSeedSizeInBytes: int;
    readonly publicKeySizeInBytes: int;
    readonly signatureSizeInBytes: int;
    equals(other: MLDsaAlgorithm): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const MLDsaAlgorithm: {
    new(): MLDsaAlgorithm$instance;
    readonly mlDsa44: MLDsaAlgorithm;
    readonly mlDsa65: MLDsaAlgorithm;
    readonly mlDsa87: MLDsaAlgorithm;
};


export interface __MLDsaAlgorithm$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<MLDsaAlgorithm>;

    // Structural method bridges for numeric interface constraints
    Equals(other: MLDsaAlgorithm): boolean;
}

export type MLDsaAlgorithm = MLDsaAlgorithm$instance & __MLDsaAlgorithm$views;


export interface MLDsaCng$instance extends MLDsa$instance {
    dispose(): void;
    getKey(): CngKey;
}


export const MLDsaCng: {
    new(key: CngKey): MLDsaCng$instance;
};


export interface __MLDsaCng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type MLDsaCng = MLDsaCng$instance & __MLDsaCng$views;


export interface MLDsaOpenSsl$instance extends MLDsa$instance {
    dispose(): void;
    duplicateKeyHandle(): SafeEvpPKeyHandle;
}


export const MLDsaOpenSsl: {
    new(pkeyHandle: SafeEvpPKeyHandle): MLDsaOpenSsl$instance;
};


export interface __MLDsaOpenSsl$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type MLDsaOpenSsl = MLDsaOpenSsl$instance & __MLDsaOpenSsl$views;


export interface MLKem$instance {
    readonly algorithm: MLKemAlgorithm;
    decapsulate(ciphertext: ReadOnlySpan_1<CLROf<byte>>, sharedSecret: Span_1<CLROf<byte>>): void;
    decapsulate(ciphertext: byte[]): byte[];
    dispose(): void;
    encapsulate(ciphertext: Span_1<CLROf<byte>>, sharedSecret: Span_1<CLROf<byte>>): void;
    encapsulate(ciphertext: { value: ref<byte[]> }, sharedSecret: { value: ref<byte[]> }): void;
    exportDecapsulationKey(destination: Span_1<CLROf<byte>>): void;
    exportDecapsulationKey(): byte[];
    exportEncapsulationKey(destination: Span_1<CLROf<byte>>): void;
    exportEncapsulationKey(): byte[];
    exportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKeyPem(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): string;
    exportEncryptedPkcs8PrivateKeyPem(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): string;
    exportEncryptedPkcs8PrivateKeyPem(password: string, pbeParameters: PbeParameters): string;
    exportPkcs8PrivateKey(): byte[];
    exportPkcs8PrivateKeyPem(): string;
    exportPrivateSeed(destination: Span_1<CLROf<byte>>): void;
    exportPrivateSeed(): byte[];
    exportSubjectPublicKeyInfo(): byte[];
    exportSubjectPublicKeyInfoPem(): string;
    tryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export const MLKem: {
    readonly isSupported: boolean;
    generateKey(algorithm: MLKemAlgorithm): MLKem;
    importDecapsulationKey(algorithm: MLKemAlgorithm, source: byte[]): MLKem;
    importDecapsulationKey(algorithm: MLKemAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    importEncapsulationKey(algorithm: MLKemAlgorithm, source: byte[]): MLKem;
    importEncapsulationKey(algorithm: MLKemAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    importEncryptedPkcs8PrivateKey(password: string, source: byte[]): MLKem;
    importFromEncryptedPem(source: ReadOnlySpan_1<CLROf<char>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    importFromEncryptedPem(source: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): MLKem;
    importFromEncryptedPem(source: string, passwordBytes: byte[]): MLKem;
    importFromEncryptedPem(source: string, password: string): MLKem;
    importFromPem(source: ReadOnlySpan_1<CLROf<char>>): MLKem;
    importFromPem(source: string): MLKem;
    importPkcs8PrivateKey(source: byte[]): MLKem;
    importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    importPrivateSeed(algorithm: MLKemAlgorithm, source: byte[]): MLKem;
    importPrivateSeed(algorithm: MLKemAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    importSubjectPublicKeyInfo(source: byte[]): MLKem;
    importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
};


export interface __MLKem$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MLKem$instance extends System_Internal.IDisposable$instance {}

export type MLKem = MLKem$instance & __MLKem$views;


export interface MLKemAlgorithm$instance {
    readonly ciphertextSizeInBytes: int;
    readonly decapsulationKeySizeInBytes: int;
    readonly encapsulationKeySizeInBytes: int;
    readonly name: string;
    readonly privateSeedSizeInBytes: int;
    readonly sharedSecretSizeInBytes: int;
    equals(other: MLKemAlgorithm): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const MLKemAlgorithm: {
    new(): MLKemAlgorithm$instance;
    readonly mlKem512: MLKemAlgorithm;
    readonly mlKem768: MLKemAlgorithm;
    readonly mlKem1024: MLKemAlgorithm;
};


export interface __MLKemAlgorithm$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<MLKemAlgorithm>;

    // Structural method bridges for numeric interface constraints
    Equals(other: MLKemAlgorithm): boolean;
}

export type MLKemAlgorithm = MLKemAlgorithm$instance & __MLKemAlgorithm$views;


export interface MLKemCng$instance extends MLKem$instance {
    dispose(): void;
    getKey(): CngKey;
}


export const MLKemCng: {
    new(key: CngKey): MLKemCng$instance;
};


export interface __MLKemCng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type MLKemCng = MLKemCng$instance & __MLKemCng$views;


export interface MLKemOpenSsl$instance extends MLKem$instance {
    dispose(): void;
    duplicateKeyHandle(): SafeEvpPKeyHandle;
}


export const MLKemOpenSsl: {
    new(pkeyHandle: SafeEvpPKeyHandle): MLKemOpenSsl$instance;
};


export interface __MLKemOpenSsl$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type MLKemOpenSsl = MLKemOpenSsl$instance & __MLKemOpenSsl$views;


export interface Oid$instance {
    friendlyName: string;
    value: string;
}


export const Oid: {
    new(): Oid$instance;
    new(oid: string): Oid$instance;
    new(value: string, friendlyName: string): Oid$instance;
    new(oid: Oid): Oid$instance;
    fromFriendlyName(friendlyName: string, group: OidGroup): Oid;
    fromOidValue(oidValue: string, group: OidGroup): Oid;
};


export type Oid = Oid$instance;

export interface OidCollection$instance {
    readonly count: int;
    readonly isSynchronized: boolean;
    readonly syncRoot: unknown;
    add(oid: Oid): int;
    copyTo(array: Oid[], index: int): void;
    get_Item(index: int): Oid;
    get_Item(oid: string): Oid;
    getEnumerator(): OidEnumerator;
}


export const OidCollection: {
    new(): OidCollection$instance;
};


export interface __OidCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type OidCollection = OidCollection$instance & __OidCollection$views;


export interface OidEnumerator$instance {
    readonly current: Oid | unknown;
    moveNext(): boolean;
    reset(): void;
}


export const OidEnumerator: {
    new(): OidEnumerator$instance;
};


export interface __OidEnumerator$views {
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type OidEnumerator = OidEnumerator$instance & __OidEnumerator$views;


export interface PasswordDeriveBytes$instance extends DeriveBytes$instance {
    hashName: string;
    iterationCount: int;
    salt: byte[];
    cryptDeriveKey(algname: string, alghashname: string, keySize: int, rgbIV: byte[]): byte[];
    dispose(): void;
    getBytes(cb: int): byte[];
    reset(): void;
}


export const PasswordDeriveBytes: {
    new(strPassword: string, rgbSalt: byte[]): PasswordDeriveBytes$instance;
    new(password: byte[], salt: byte[]): PasswordDeriveBytes$instance;
    new(strPassword: string, rgbSalt: byte[], strHashName: string, iterations: int): PasswordDeriveBytes$instance;
    new(password: byte[], salt: byte[], hashName: string, iterations: int): PasswordDeriveBytes$instance;
    new(strPassword: string, rgbSalt: byte[], cspParams: CspParameters): PasswordDeriveBytes$instance;
    new(password: byte[], salt: byte[], cspParams: CspParameters): PasswordDeriveBytes$instance;
    new(strPassword: string, rgbSalt: byte[], strHashName: string, iterations: int, cspParams: CspParameters): PasswordDeriveBytes$instance;
    new(password: byte[], salt: byte[], hashName: string, iterations: int, cspParams: CspParameters): PasswordDeriveBytes$instance;
};


export interface __PasswordDeriveBytes$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type PasswordDeriveBytes = PasswordDeriveBytes$instance & __PasswordDeriveBytes$views;


export interface PbeParameters$instance {
    readonly encryptionAlgorithm: PbeEncryptionAlgorithm;
    readonly hashAlgorithm: HashAlgorithmName;
    readonly iterationCount: int;
}


export const PbeParameters: {
    new(encryptionAlgorithm: PbeEncryptionAlgorithm, hashAlgorithm: HashAlgorithmName, iterationCount: int): PbeParameters$instance;
};


export type PbeParameters = PbeParameters$instance;

export interface PKCS1MaskGenerationMethod$instance extends MaskGenerationMethod {
    hashName: string;
    generateMask(rgbSeed: byte[], cbReturn: int): byte[];
}


export const PKCS1MaskGenerationMethod: {
    new(): PKCS1MaskGenerationMethod$instance;
};


export type PKCS1MaskGenerationMethod = PKCS1MaskGenerationMethod$instance;

export interface RandomNumberGenerator$instance {
    dispose(): void;
    getBytes(data: byte[]): void;
    getBytes(data: byte[], offset: int, count: int): void;
    getBytes(data: Span_1<CLROf<byte>>): void;
    getNonZeroBytes(data: byte[]): void;
    getNonZeroBytes(data: Span_1<CLROf<byte>>): void;
}


export const RandomNumberGenerator: {
    create(): RandomNumberGenerator;
    create(rngName: string): RandomNumberGenerator;
    fill(data: Span_1<CLROf<byte>>): void;
    getBytes(count: int): byte[];
    getHexString(stringLength: int, lowercase?: boolean): string;
    getHexString(destination: Span_1<CLROf<char>>, lowercase?: boolean): void;
    getInt32(fromInclusive: int, toExclusive: int): int;
    getInt32(toExclusive: int): int;
    getItems<T>(choices: ReadOnlySpan_1<T>, destination: Span_1<T>): void;
    getItems<T>(choices: ReadOnlySpan_1<T>, length: int): T[];
    getString(choices: ReadOnlySpan_1<CLROf<char>>, length: int): string;
    shuffle<T>(values: Span_1<T>): void;
};


export interface __RandomNumberGenerator$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface RandomNumberGenerator$instance extends System_Internal.IDisposable$instance {}

export type RandomNumberGenerator = RandomNumberGenerator$instance & __RandomNumberGenerator$views;


export interface RC2$instance extends SymmetricAlgorithm$instance {
    effectiveKeySize: int;
    keySize: int;
    dispose(): void;
}


export const RC2: {
};


export interface __RC2$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type RC2 = RC2$instance & __RC2$views;


export interface RC2CryptoServiceProvider$instance extends RC2$instance {
    blockSize: int;
    effectiveKeySize: int;
    feedbackSize: int;
    IV: byte[];
    key: byte[];
    keySize: int;
    readonly legalBlockSizes: KeySizes[];
    readonly legalKeySizes: KeySizes[];
    mode: CipherMode;
    padding: PaddingMode;
    useSalt: boolean;
    createDecryptor(): ICryptoTransform;
    createDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    createEncryptor(): ICryptoTransform;
    createEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    dispose(): void;
    generateIV(): void;
    generateKey(): void;
}


export const RC2CryptoServiceProvider: {
    new(): RC2CryptoServiceProvider$instance;
};


export interface __RC2CryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type RC2CryptoServiceProvider = RC2CryptoServiceProvider$instance & __RC2CryptoServiceProvider$views;


export interface Rfc2898DeriveBytes$instance extends DeriveBytes$instance {
    readonly hashAlgorithm: HashAlgorithmName;
    iterationCount: int;
    salt: byte[];
    cryptDeriveKey(algname: string, alghashname: string, keySize: int, rgbIV: byte[]): byte[];
    dispose(): void;
    getBytes(cb: int): byte[];
    reset(): void;
}


export const Rfc2898DeriveBytes: {
    new(password: byte[], salt: byte[], iterations: int): Rfc2898DeriveBytes$instance;
    new(password: byte[], salt: byte[], iterations: int, hashAlgorithm: HashAlgorithmName): Rfc2898DeriveBytes$instance;
    new(password: string, salt: byte[]): Rfc2898DeriveBytes$instance;
    new(password: string, salt: byte[], iterations: int): Rfc2898DeriveBytes$instance;
    new(password: string, salt: byte[], iterations: int, hashAlgorithm: HashAlgorithmName): Rfc2898DeriveBytes$instance;
    new(password: string, saltSize: int): Rfc2898DeriveBytes$instance;
    new(password: string, saltSize: int, iterations: int): Rfc2898DeriveBytes$instance;
    new(password: string, saltSize: int, iterations: int, hashAlgorithm: HashAlgorithmName): Rfc2898DeriveBytes$instance;
    pbkdf2(password: byte[], salt: byte[], iterations: int, hashAlgorithm: HashAlgorithmName, outputLength: int): byte[];
    pbkdf2(password: ReadOnlySpan_1<CLROf<byte>>, salt: ReadOnlySpan_1<CLROf<byte>>, iterations: int, hashAlgorithm: HashAlgorithmName, outputLength: int): byte[];
    pbkdf2(password: ReadOnlySpan_1<CLROf<byte>>, salt: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, iterations: int, hashAlgorithm: HashAlgorithmName): void;
    pbkdf2(password: ReadOnlySpan_1<CLROf<char>>, salt: ReadOnlySpan_1<CLROf<byte>>, iterations: int, hashAlgorithm: HashAlgorithmName, outputLength: int): byte[];
    pbkdf2(password: ReadOnlySpan_1<CLROf<char>>, salt: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, iterations: int, hashAlgorithm: HashAlgorithmName): void;
    pbkdf2(password: string, salt: byte[], iterations: int, hashAlgorithm: HashAlgorithmName, outputLength: int): byte[];
};


export interface __Rfc2898DeriveBytes$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type Rfc2898DeriveBytes = Rfc2898DeriveBytes$instance & __Rfc2898DeriveBytes$views;


export interface Rijndael$instance extends SymmetricAlgorithm$instance {
    dispose(): void;
}


export const Rijndael: {
};


export interface __Rijndael$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type Rijndael = Rijndael$instance & __Rijndael$views;


export interface RijndaelManaged$instance extends Rijndael$instance {
    blockSize: int;
    feedbackSize: int;
    IV: byte[];
    key: byte[];
    keySize: int;
    readonly legalKeySizes: KeySizes[];
    mode: CipherMode;
    padding: PaddingMode;
    createDecryptor(): ICryptoTransform;
    createDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    createEncryptor(): ICryptoTransform;
    createEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    dispose(): void;
    generateIV(): void;
    generateKey(): void;
}


export const RijndaelManaged: {
    new(): RijndaelManaged$instance;
};


export interface __RijndaelManaged$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type RijndaelManaged = RijndaelManaged$instance & __RijndaelManaged$views;


export interface RNGCryptoServiceProvider$instance extends RandomNumberGenerator$instance {
    dispose(): void;
    getBytes(data: byte[]): void;
    getBytes(data: byte[], offset: int, count: int): void;
    getBytes(data: Span_1<CLROf<byte>>): void;
    getBytes(data: Span_1<CLROf<byte>>): void;
    getNonZeroBytes(data: byte[]): void;
    getNonZeroBytes(data: Span_1<CLROf<byte>>): void;
    getNonZeroBytes(data: Span_1<CLROf<byte>>): void;
}


export const RNGCryptoServiceProvider: {
    new(): RNGCryptoServiceProvider$instance;
    new(str: string): RNGCryptoServiceProvider$instance;
    new(rgb: byte[]): RNGCryptoServiceProvider$instance;
    new(cspParams: CspParameters): RNGCryptoServiceProvider$instance;
};


export interface __RNGCryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type RNGCryptoServiceProvider = RNGCryptoServiceProvider$instance & __RNGCryptoServiceProvider$views;


export interface RSA$instance extends AsymmetricAlgorithm$instance {
    readonly keyExchangeAlgorithm: string;
    readonly signatureAlgorithm: string;
    decrypt(data: byte[], padding: RSAEncryptionPadding): byte[];
    decrypt(data: ReadOnlySpan_1<CLROf<byte>>, padding: RSAEncryptionPadding): byte[];
    decrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding): int;
    decryptValue(rgb: byte[]): byte[];
    dispose(): void;
    encrypt(data: byte[], padding: RSAEncryptionPadding): byte[];
    encrypt(data: ReadOnlySpan_1<CLROf<byte>>, padding: RSAEncryptionPadding): byte[];
    encrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding): int;
    encryptValue(rgb: byte[]): byte[];
    exportParameters(includePrivateParameters: boolean): RSAParameters;
    exportRSAPrivateKey(): byte[];
    exportRSAPrivateKeyPem(): string;
    exportRSAPublicKey(): byte[];
    exportRSAPublicKeyPem(): string;
    fromXmlString(xmlString: string): void;
    getMaxOutputSize(): int;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): void;
    importFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): void;
    importFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): void;
    importFromPem(input: ReadOnlySpan_1<CLROf<char>>): void;
    importFromPem(input: ReadOnlySpan_1<CLROf<char>>): void;
    importParameters(parameters: RSAParameters): void;
    importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importRSAPrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importRSAPublicKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    signData(data: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signData(data: Stream, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signData(data: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): int;
    signHash(hash: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): int;
    toXmlString(includePrivateParameters: boolean): string;
    tryDecrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    tryEncrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportRSAPrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportRSAPrivateKeyPem(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    tryExportRSAPublicKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportRSAPublicKeyPem(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    trySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    trySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    verifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyHash(hash: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
}


export const RSA: {
    create(parameters: RSAParameters): RSA;
    create(algName: string): RSA;
};


export interface __RSA$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type RSA = RSA$instance & __RSA$views;


export interface RSACng$instance extends RSA$instance {
    readonly key: CngKey;
    dispose(): void;
    exportParameters(includePrivateParameters: boolean): RSAParameters;
    importParameters(parameters: RSAParameters): void;
}


export const RSACng: {
    new(): RSACng$instance;
    new(keySize: int): RSACng$instance;
    new(key: CngKey): RSACng$instance;
};


export interface __RSACng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type RSACng = RSACng$instance & __RSACng$views;


export interface RSACryptoServiceProvider$instance extends RSA$instance {
    readonly cspKeyContainerInfo: CspKeyContainerInfo;
    readonly keyExchangeAlgorithm: string;
    keySize: int;
    readonly legalKeySizes: KeySizes[];
    persistKeyInCsp: boolean;
    readonly publicOnly: boolean;
    readonly signatureAlgorithm: string;
    decrypt(data: byte[], padding: RSAEncryptionPadding): byte[];
    decrypt(data: ReadOnlySpan_1<CLROf<byte>>, padding: RSAEncryptionPadding): byte[];
    decrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding): int;
    dispose(): void;
    encrypt(data: byte[], padding: RSAEncryptionPadding): byte[];
    encrypt(data: ReadOnlySpan_1<CLROf<byte>>, padding: RSAEncryptionPadding): byte[];
    encrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding): int;
    exportCspBlob(includePrivateParameters: boolean): byte[];
    exportParameters(includePrivateParameters: boolean): RSAParameters;
    fromXmlString(xmlString: string): void;
    importCspBlob(keyBlob: byte[]): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importParameters(parameters: RSAParameters): void;
    signData(data: Stream, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signData(inputStream: Stream, halg: unknown): byte[];
    signData(data: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signData(data: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): int;
    signHash(hash: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): int;
    toXmlString(includePrivateParameters: boolean): string;
    tryDecrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    tryDecrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    tryEncrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    tryEncrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    trySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    trySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    trySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    trySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    verifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyHash(hash: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
}


export const RSACryptoServiceProvider: {
    new(): RSACryptoServiceProvider$instance;
    new(dwKeySize: int): RSACryptoServiceProvider$instance;
    new(dwKeySize: int, parameters: CspParameters): RSACryptoServiceProvider$instance;
    new(parameters: CspParameters): RSACryptoServiceProvider$instance;
    useMachineKeyStore: boolean;
};


export interface __RSACryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICspAsymmetricAlgorithm(): ICspAsymmetricAlgorithm$instance;
}

export interface RSACryptoServiceProvider$instance extends ICspAsymmetricAlgorithm$instance {}

export type RSACryptoServiceProvider = RSACryptoServiceProvider$instance & __RSACryptoServiceProvider$views;


export interface RSAEncryptionPadding$instance {
    readonly mode: RSAEncryptionPaddingMode;
    readonly oaepHashAlgorithm: HashAlgorithmName;
    equals(obj: unknown): boolean;
    equals(other: RSAEncryptionPadding): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RSAEncryptionPadding: {
    new(): RSAEncryptionPadding$instance;
    readonly pkcs1: RSAEncryptionPadding;
    readonly oaepSHA1: RSAEncryptionPadding;
    readonly oaepSHA256: RSAEncryptionPadding;
    readonly oaepSHA384: RSAEncryptionPadding;
    readonly oaepSHA512: RSAEncryptionPadding;
    readonly OaepSHA3_256: RSAEncryptionPadding;
    readonly OaepSHA3_384: RSAEncryptionPadding;
    readonly OaepSHA3_512: RSAEncryptionPadding;
    createOaep(hashAlgorithm: HashAlgorithmName): RSAEncryptionPadding;
};


export interface __RSAEncryptionPadding$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<RSAEncryptionPadding>;

    // Structural method bridges for numeric interface constraints
    Equals(other: RSAEncryptionPadding): boolean;
}

export type RSAEncryptionPadding = RSAEncryptionPadding$instance & __RSAEncryptionPadding$views;


export interface RSAOAEPKeyExchangeDeformatter$instance extends AsymmetricKeyExchangeDeformatter {
    parameters: string;
    decryptKeyExchange(rgbData: byte[]): byte[];
    setKey(key: AsymmetricAlgorithm): void;
}


export const RSAOAEPKeyExchangeDeformatter: {
    new(): RSAOAEPKeyExchangeDeformatter$instance;
    new(key: AsymmetricAlgorithm): RSAOAEPKeyExchangeDeformatter$instance;
};


export type RSAOAEPKeyExchangeDeformatter = RSAOAEPKeyExchangeDeformatter$instance;

export interface RSAOAEPKeyExchangeFormatter$instance extends AsymmetricKeyExchangeFormatter {
    parameter: byte[];
    readonly parameters: string;
    rng: RandomNumberGenerator;
    createKeyExchange(rgbData: byte[], symAlgType: Type): byte[];
    createKeyExchange(rgbData: byte[]): byte[];
    setKey(key: AsymmetricAlgorithm): void;
}


export const RSAOAEPKeyExchangeFormatter: {
    new(): RSAOAEPKeyExchangeFormatter$instance;
    new(key: AsymmetricAlgorithm): RSAOAEPKeyExchangeFormatter$instance;
};


export type RSAOAEPKeyExchangeFormatter = RSAOAEPKeyExchangeFormatter$instance;

export interface RSAOpenSsl$instance extends RSA$instance {
    keySize: int;
    readonly legalKeySizes: KeySizes[];
    decrypt(data: byte[], padding: RSAEncryptionPadding): byte[];
    decrypt(data: ReadOnlySpan_1<CLROf<byte>>, padding: RSAEncryptionPadding): byte[];
    decrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding): int;
    dispose(): void;
    duplicateKeyHandle(): SafeEvpPKeyHandle;
    encrypt(data: byte[], padding: RSAEncryptionPadding): byte[];
    encrypt(data: ReadOnlySpan_1<CLROf<byte>>, padding: RSAEncryptionPadding): byte[];
    encrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding): int;
    exportParameters(includePrivateParameters: boolean): RSAParameters;
    exportPkcs8PrivateKey(): byte[];
    exportRSAPrivateKey(): byte[];
    exportRSAPublicKey(): byte[];
    exportSubjectPublicKeyInfo(): byte[];
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importParameters(parameters: RSAParameters): void;
    importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importRSAPrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importRSAPrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importRSAPublicKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importRSAPublicKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    signHash(hash: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): int;
    tryDecrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    tryDecrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    tryEncrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    tryEncrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportRSAPrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportRSAPrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportRSAPublicKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportRSAPublicKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    trySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    trySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    verifyHash(hash: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
}


export const RSAOpenSsl: {
    new(): RSAOpenSsl$instance;
    new(keySize: int): RSAOpenSsl$instance;
    new(parameters: RSAParameters): RSAOpenSsl$instance;
    new(handle: nint): RSAOpenSsl$instance;
    new(pkeyHandle: SafeEvpPKeyHandle): RSAOpenSsl$instance;
};


export interface __RSAOpenSsl$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type RSAOpenSsl = RSAOpenSsl$instance & __RSAOpenSsl$views;


export interface RSAPKCS1KeyExchangeDeformatter$instance extends AsymmetricKeyExchangeDeformatter {
    parameters: string;
    RNG: RandomNumberGenerator;
    decryptKeyExchange(rgbIn: byte[]): byte[];
    setKey(key: AsymmetricAlgorithm): void;
}


export const RSAPKCS1KeyExchangeDeformatter: {
    new(): RSAPKCS1KeyExchangeDeformatter$instance;
    new(key: AsymmetricAlgorithm): RSAPKCS1KeyExchangeDeformatter$instance;
};


export type RSAPKCS1KeyExchangeDeformatter = RSAPKCS1KeyExchangeDeformatter$instance;

export interface RSAPKCS1KeyExchangeFormatter$instance extends AsymmetricKeyExchangeFormatter {
    readonly parameters: string;
    rng: RandomNumberGenerator;
    createKeyExchange(rgbData: byte[], symAlgType: Type): byte[];
    createKeyExchange(rgbData: byte[]): byte[];
    setKey(key: AsymmetricAlgorithm): void;
}


export const RSAPKCS1KeyExchangeFormatter: {
    new(): RSAPKCS1KeyExchangeFormatter$instance;
    new(key: AsymmetricAlgorithm): RSAPKCS1KeyExchangeFormatter$instance;
};


export type RSAPKCS1KeyExchangeFormatter = RSAPKCS1KeyExchangeFormatter$instance;

export interface RSAPKCS1SignatureDeformatter$instance extends AsymmetricSignatureDeformatter {
    setHashAlgorithm(strName: string): void;
    setKey(key: AsymmetricAlgorithm): void;
    verifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
    verifySignature(hash: HashAlgorithm, rgbSignature: byte[]): boolean;
}


export const RSAPKCS1SignatureDeformatter: {
    new(): RSAPKCS1SignatureDeformatter$instance;
    new(key: AsymmetricAlgorithm): RSAPKCS1SignatureDeformatter$instance;
};


export type RSAPKCS1SignatureDeformatter = RSAPKCS1SignatureDeformatter$instance;

export interface RSAPKCS1SignatureFormatter$instance extends AsymmetricSignatureFormatter {
    createSignature(rgbHash: byte[]): byte[];
    createSignature(hash: HashAlgorithm): byte[];
    setHashAlgorithm(strName: string): void;
    setKey(key: AsymmetricAlgorithm): void;
}


export const RSAPKCS1SignatureFormatter: {
    new(): RSAPKCS1SignatureFormatter$instance;
    new(key: AsymmetricAlgorithm): RSAPKCS1SignatureFormatter$instance;
};


export type RSAPKCS1SignatureFormatter = RSAPKCS1SignatureFormatter$instance;

export interface RSASignaturePadding$instance {
    readonly mode: RSASignaturePaddingMode;
    equals(obj: unknown): boolean;
    equals(other: RSASignaturePadding): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RSASignaturePadding: {
    new(): RSASignaturePadding$instance;
    readonly pkcs1: RSASignaturePadding;
    readonly pss: RSASignaturePadding;
};


export interface __RSASignaturePadding$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<RSASignaturePadding>;

    // Structural method bridges for numeric interface constraints
    Equals(other: RSASignaturePadding): boolean;
}

export type RSASignaturePadding = RSASignaturePadding$instance & __RSASignaturePadding$views;


export interface SafeEvpPKeyHandle$instance extends SafeHandle {
    readonly isInvalid: boolean;
    dispose(): void;
    duplicateHandle(): SafeEvpPKeyHandle;
}


export const SafeEvpPKeyHandle: {
    new(): SafeEvpPKeyHandle$instance;
    new(handle: nint, ownsHandle: boolean): SafeEvpPKeyHandle$instance;
    readonly openSslVersion: long;
    openKeyFromProvider(providerName: string, keyUri: string): SafeEvpPKeyHandle;
    openPrivateKeyFromEngine(engineName: string, keyId: string): SafeEvpPKeyHandle;
    openPublicKeyFromEngine(engineName: string, keyId: string): SafeEvpPKeyHandle;
};


export interface __SafeEvpPKeyHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type SafeEvpPKeyHandle = SafeEvpPKeyHandle$instance & __SafeEvpPKeyHandle$views;


export interface SHA1$instance extends HashAlgorithm$instance {
    dispose(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA1: {
    readonly hashSizeInBits: int;
    readonly hashSizeInBytes: int;
    hashData(source: byte[]): byte[];
    hashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    hashData(source: Stream): byte[];
    hashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    hashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    hashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    hashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    tryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __SHA1$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA1 = SHA1$instance & __SHA1$views;


export interface SHA1CryptoServiceProvider$instance extends SHA1$instance {
    dispose(): void;
    initialize(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA1CryptoServiceProvider: {
    new(): SHA1CryptoServiceProvider$instance;
};


export interface __SHA1CryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA1CryptoServiceProvider = SHA1CryptoServiceProvider$instance & __SHA1CryptoServiceProvider$views;


export interface SHA1Managed$instance extends SHA1$instance {
    dispose(): void;
    initialize(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA1Managed: {
    new(): SHA1Managed$instance;
};


export interface __SHA1Managed$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA1Managed = SHA1Managed$instance & __SHA1Managed$views;


export interface SHA256$instance extends HashAlgorithm$instance {
    dispose(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA256: {
    readonly hashSizeInBits: int;
    readonly hashSizeInBytes: int;
    hashData(source: byte[]): byte[];
    hashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    hashData(source: Stream): byte[];
    hashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    hashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    hashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    hashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    tryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __SHA256$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA256 = SHA256$instance & __SHA256$views;


export interface SHA256CryptoServiceProvider$instance extends SHA256$instance {
    dispose(): void;
    initialize(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA256CryptoServiceProvider: {
    new(): SHA256CryptoServiceProvider$instance;
};


export interface __SHA256CryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA256CryptoServiceProvider = SHA256CryptoServiceProvider$instance & __SHA256CryptoServiceProvider$views;


export interface SHA256Managed$instance extends SHA256$instance {
    dispose(): void;
    initialize(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA256Managed: {
    new(): SHA256Managed$instance;
};


export interface __SHA256Managed$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA256Managed = SHA256Managed$instance & __SHA256Managed$views;


export interface SHA3_256$instance extends HashAlgorithm$instance {
    dispose(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA3_256: {
    readonly hashSizeInBits: int;
    readonly hashSizeInBytes: int;
    readonly isSupported: boolean;
    hashData(source: byte[]): byte[];
    hashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    hashData(source: Stream): byte[];
    hashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    hashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    hashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    hashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    tryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __SHA3_256$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA3_256 = SHA3_256$instance & __SHA3_256$views;


export interface SHA3_384$instance extends HashAlgorithm$instance {
    dispose(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA3_384: {
    readonly hashSizeInBits: int;
    readonly hashSizeInBytes: int;
    readonly isSupported: boolean;
    hashData(source: byte[]): byte[];
    hashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    hashData(source: Stream): byte[];
    hashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    hashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    hashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    hashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    tryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __SHA3_384$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA3_384 = SHA3_384$instance & __SHA3_384$views;


export interface SHA3_512$instance extends HashAlgorithm$instance {
    dispose(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA3_512: {
    readonly hashSizeInBits: int;
    readonly hashSizeInBytes: int;
    readonly isSupported: boolean;
    hashData(source: byte[]): byte[];
    hashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    hashData(source: Stream): byte[];
    hashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    hashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    hashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    hashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    tryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __SHA3_512$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA3_512 = SHA3_512$instance & __SHA3_512$views;


export interface SHA384$instance extends HashAlgorithm$instance {
    dispose(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA384: {
    readonly hashSizeInBits: int;
    readonly hashSizeInBytes: int;
    hashData(source: byte[]): byte[];
    hashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    hashData(source: Stream): byte[];
    hashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    hashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    hashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    hashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    tryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __SHA384$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA384 = SHA384$instance & __SHA384$views;


export interface SHA384CryptoServiceProvider$instance extends SHA384$instance {
    dispose(): void;
    initialize(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA384CryptoServiceProvider: {
    new(): SHA384CryptoServiceProvider$instance;
};


export interface __SHA384CryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA384CryptoServiceProvider = SHA384CryptoServiceProvider$instance & __SHA384CryptoServiceProvider$views;


export interface SHA384Managed$instance extends SHA384$instance {
    dispose(): void;
    initialize(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA384Managed: {
    new(): SHA384Managed$instance;
};


export interface __SHA384Managed$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA384Managed = SHA384Managed$instance & __SHA384Managed$views;


export interface SHA512$instance extends HashAlgorithm$instance {
    dispose(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA512: {
    readonly hashSizeInBits: int;
    readonly hashSizeInBytes: int;
    hashData(source: byte[]): byte[];
    hashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    hashData(source: Stream): byte[];
    hashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    hashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    hashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    hashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    tryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __SHA512$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA512 = SHA512$instance & __SHA512$views;


export interface SHA512CryptoServiceProvider$instance extends SHA512$instance {
    dispose(): void;
    initialize(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA512CryptoServiceProvider: {
    new(): SHA512CryptoServiceProvider$instance;
};


export interface __SHA512CryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA512CryptoServiceProvider = SHA512CryptoServiceProvider$instance & __SHA512CryptoServiceProvider$views;


export interface SHA512Managed$instance extends SHA512$instance {
    dispose(): void;
    initialize(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA512Managed: {
    new(): SHA512Managed$instance;
};


export interface __SHA512Managed$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA512Managed = SHA512Managed$instance & __SHA512Managed$views;


export interface Shake128$instance {
    appendData(data: byte[]): void;
    appendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    clone(): Shake128;
    dispose(): void;
    getCurrentHash(outputLength: int): byte[];
    getCurrentHash(destination: Span_1<CLROf<byte>>): void;
    getHashAndReset(outputLength: int): byte[];
    getHashAndReset(destination: Span_1<CLROf<byte>>): void;
    read(outputLength: int): byte[];
    read(destination: Span_1<CLROf<byte>>): void;
    reset(): void;
}


export const Shake128: {
    new(): Shake128$instance;
    readonly isSupported: boolean;
    hashData(source: byte[], outputLength: int): byte[];
    hashData(source: Stream, outputLength: int): byte[];
    hashData(source: Stream, destination: Span_1<CLROf<byte>>): void;
    hashData(source: ReadOnlySpan_1<CLROf<byte>>, outputLength: int): byte[];
    hashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): void;
    hashDataAsync(source: Stream, outputLength: int, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    hashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
};


export interface __Shake128$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Shake128$instance extends System_Internal.IDisposable$instance {}

export type Shake128 = Shake128$instance & __Shake128$views;


export interface Shake256$instance {
    appendData(data: byte[]): void;
    appendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    clone(): Shake256;
    dispose(): void;
    getCurrentHash(outputLength: int): byte[];
    getCurrentHash(destination: Span_1<CLROf<byte>>): void;
    getHashAndReset(outputLength: int): byte[];
    getHashAndReset(destination: Span_1<CLROf<byte>>): void;
    read(outputLength: int): byte[];
    read(destination: Span_1<CLROf<byte>>): void;
    reset(): void;
}


export const Shake256: {
    new(): Shake256$instance;
    readonly isSupported: boolean;
    hashData(source: byte[], outputLength: int): byte[];
    hashData(source: Stream, outputLength: int): byte[];
    hashData(source: Stream, destination: Span_1<CLROf<byte>>): void;
    hashData(source: ReadOnlySpan_1<CLROf<byte>>, outputLength: int): byte[];
    hashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): void;
    hashDataAsync(source: Stream, outputLength: int, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    hashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
};


export interface __Shake256$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Shake256$instance extends System_Internal.IDisposable$instance {}

export type Shake256 = Shake256$instance & __Shake256$views;


export interface SignatureDescription$instance {
    deformatterAlgorithm: string;
    digestAlgorithm: string;
    formatterAlgorithm: string;
    keyAlgorithm: string;
    createDeformatter(key: AsymmetricAlgorithm): AsymmetricSignatureDeformatter;
    createDigest(): HashAlgorithm;
    createFormatter(key: AsymmetricAlgorithm): AsymmetricSignatureFormatter;
}


export const SignatureDescription: {
    new(): SignatureDescription$instance;
    new(el: SecurityElement): SignatureDescription$instance;
};


export type SignatureDescription = SignatureDescription$instance;

export interface SlhDsa$instance {
    readonly algorithm: SlhDsaAlgorithm;
    dispose(): void;
    exportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKeyPem(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): string;
    exportEncryptedPkcs8PrivateKeyPem(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): string;
    exportEncryptedPkcs8PrivateKeyPem(password: string, pbeParameters: PbeParameters): string;
    exportPkcs8PrivateKey(): byte[];
    exportPkcs8PrivateKeyPem(): string;
    exportSlhDsaPrivateKey(destination: Span_1<CLROf<byte>>): void;
    exportSlhDsaPrivateKey(): byte[];
    exportSlhDsaPublicKey(destination: Span_1<CLROf<byte>>): void;
    exportSlhDsaPublicKey(): byte[];
    exportSubjectPublicKeyInfo(): byte[];
    exportSubjectPublicKeyInfoPem(): string;
    signData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, context?: ReadOnlySpan_1<CLROf<byte>>): void;
    signData(data: byte[], context?: byte[]): byte[];
    signPreHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithmOid: string, context?: ReadOnlySpan_1<CLROf<byte>>): void;
    signPreHash(hash: byte[], hashAlgorithmOid: string, context?: byte[]): byte[];
    tryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, context?: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifyData(data: byte[], signature: byte[], context?: byte[]): boolean;
    verifyPreHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithmOid: string, context?: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifyPreHash(hash: byte[], signature: byte[], hashAlgorithmOid: string, context?: byte[]): boolean;
}


export const SlhDsa: {
    readonly isSupported: boolean;
    generateKey(algorithm: SlhDsaAlgorithm): SlhDsa;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
    importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
    importEncryptedPkcs8PrivateKey(password: string, source: byte[]): SlhDsa;
    importFromEncryptedPem(source: ReadOnlySpan_1<CLROf<char>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
    importFromEncryptedPem(source: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): SlhDsa;
    importFromEncryptedPem(source: string, passwordBytes: byte[]): SlhDsa;
    importFromEncryptedPem(source: string, password: string): SlhDsa;
    importFromPem(source: ReadOnlySpan_1<CLROf<char>>): SlhDsa;
    importFromPem(source: string): SlhDsa;
    importPkcs8PrivateKey(source: byte[]): SlhDsa;
    importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
    importSlhDsaPrivateKey(algorithm: SlhDsaAlgorithm, source: byte[]): SlhDsa;
    importSlhDsaPrivateKey(algorithm: SlhDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
    importSlhDsaPublicKey(algorithm: SlhDsaAlgorithm, source: byte[]): SlhDsa;
    importSlhDsaPublicKey(algorithm: SlhDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
    importSubjectPublicKeyInfo(source: byte[]): SlhDsa;
    importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
};


export interface __SlhDsa$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface SlhDsa$instance extends System_Internal.IDisposable$instance {}

export type SlhDsa = SlhDsa$instance & __SlhDsa$views;


export interface SlhDsaAlgorithm$instance {
    readonly name: string;
    readonly privateKeySizeInBytes: int;
    readonly publicKeySizeInBytes: int;
    readonly signatureSizeInBytes: int;
    equals(other: SlhDsaAlgorithm): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const SlhDsaAlgorithm: {
    new(): SlhDsaAlgorithm$instance;
    readonly SlhDsaSha2_128s: SlhDsaAlgorithm;
    readonly slhDsaShake128s: SlhDsaAlgorithm;
    readonly SlhDsaSha2_128f: SlhDsaAlgorithm;
    readonly slhDsaShake128f: SlhDsaAlgorithm;
    readonly SlhDsaSha2_192s: SlhDsaAlgorithm;
    readonly slhDsaShake192s: SlhDsaAlgorithm;
    readonly SlhDsaSha2_192f: SlhDsaAlgorithm;
    readonly slhDsaShake192f: SlhDsaAlgorithm;
    readonly SlhDsaSha2_256s: SlhDsaAlgorithm;
    readonly slhDsaShake256s: SlhDsaAlgorithm;
    readonly SlhDsaSha2_256f: SlhDsaAlgorithm;
    readonly slhDsaShake256f: SlhDsaAlgorithm;
};


export interface __SlhDsaAlgorithm$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SlhDsaAlgorithm>;

    // Structural method bridges for numeric interface constraints
    Equals(other: SlhDsaAlgorithm): boolean;
}

export type SlhDsaAlgorithm = SlhDsaAlgorithm$instance & __SlhDsaAlgorithm$views;


export interface SlhDsaCng$instance extends SlhDsa$instance {
    dispose(): void;
    getKey(): CngKey;
}


export const SlhDsaCng: {
    new(key: CngKey): SlhDsaCng$instance;
};


export interface __SlhDsaCng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type SlhDsaCng = SlhDsaCng$instance & __SlhDsaCng$views;


export interface SlhDsaOpenSsl$instance extends SlhDsa$instance {
    dispose(): void;
    duplicateKeyHandle(): SafeEvpPKeyHandle;
}


export const SlhDsaOpenSsl: {
    new(pkeyHandle: SafeEvpPKeyHandle): SlhDsaOpenSsl$instance;
};


export interface __SlhDsaOpenSsl$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type SlhDsaOpenSsl = SlhDsaOpenSsl$instance & __SlhDsaOpenSsl$views;


export interface SP800108HmacCounterKdf$instance {
    deriveKey(label: byte[], context: byte[], derivedKeyLengthInBytes: int): byte[];
    deriveKey(label: ReadOnlySpan_1<CLROf<byte>>, context: ReadOnlySpan_1<CLROf<byte>>, derivedKeyLengthInBytes: int): byte[];
    deriveKey(label: ReadOnlySpan_1<CLROf<byte>>, context: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): void;
    deriveKey(label: ReadOnlySpan_1<CLROf<char>>, context: ReadOnlySpan_1<CLROf<char>>, derivedKeyLengthInBytes: int): byte[];
    deriveKey(label: ReadOnlySpan_1<CLROf<char>>, context: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<byte>>): void;
    deriveKey(label: string, context: string, derivedKeyLengthInBytes: int): byte[];
    dispose(): void;
}


export const SP800108HmacCounterKdf: {
    new(key: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): SP800108HmacCounterKdf$instance;
    new(key: byte[], hashAlgorithm: HashAlgorithmName): SP800108HmacCounterKdf$instance;
    deriveBytes(key: byte[], hashAlgorithm: HashAlgorithmName, label: byte[], context: byte[], derivedKeyLengthInBytes: int): byte[];
    deriveBytes(key: byte[], hashAlgorithm: HashAlgorithmName, label: string, context: string, derivedKeyLengthInBytes: int): byte[];
    deriveBytes(key: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, label: ReadOnlySpan_1<CLROf<byte>>, context: ReadOnlySpan_1<CLROf<byte>>, derivedKeyLengthInBytes: int): byte[];
    deriveBytes(key: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, label: ReadOnlySpan_1<CLROf<byte>>, context: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): void;
    deriveBytes(key: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, label: ReadOnlySpan_1<CLROf<char>>, context: ReadOnlySpan_1<CLROf<char>>, derivedKeyLengthInBytes: int): byte[];
    deriveBytes(key: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, label: ReadOnlySpan_1<CLROf<char>>, context: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<byte>>): void;
};


export interface __SP800108HmacCounterKdf$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface SP800108HmacCounterKdf$instance extends System_Internal.IDisposable$instance {}

export type SP800108HmacCounterKdf = SP800108HmacCounterKdf$instance & __SP800108HmacCounterKdf$views;


export interface SymmetricAlgorithm$instance {
    blockSize: int;
    feedbackSize: int;
    IV: byte[];
    key: byte[];
    keySize: int;
    readonly legalBlockSizes: KeySizes[];
    readonly legalKeySizes: KeySizes[];
    mode: CipherMode;
    padding: PaddingMode;
    clear(): void;
    createDecryptor(): ICryptoTransform;
    createDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    createEncryptor(): ICryptoTransform;
    createEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    decryptCbc(ciphertext: byte[], iv: byte[], paddingMode?: PaddingMode): byte[];
    decryptCbc(ciphertext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, paddingMode?: PaddingMode): byte[];
    decryptCbc(ciphertext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode?: PaddingMode): int;
    decryptCfb(ciphertext: byte[], iv: byte[], paddingMode?: PaddingMode, feedbackSizeInBits?: int): byte[];
    decryptCfb(ciphertext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, paddingMode?: PaddingMode, feedbackSizeInBits?: int): byte[];
    decryptCfb(ciphertext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode?: PaddingMode, feedbackSizeInBits?: int): int;
    decryptEcb(ciphertext: byte[], paddingMode: PaddingMode): byte[];
    decryptEcb(ciphertext: ReadOnlySpan_1<CLROf<byte>>, paddingMode: PaddingMode): byte[];
    decryptEcb(ciphertext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode: PaddingMode): int;
    dispose(): void;
    encryptCbc(plaintext: byte[], iv: byte[], paddingMode?: PaddingMode): byte[];
    encryptCbc(plaintext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, paddingMode?: PaddingMode): byte[];
    encryptCbc(plaintext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode?: PaddingMode): int;
    encryptCfb(plaintext: byte[], iv: byte[], paddingMode?: PaddingMode, feedbackSizeInBits?: int): byte[];
    encryptCfb(plaintext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, paddingMode?: PaddingMode, feedbackSizeInBits?: int): byte[];
    encryptCfb(plaintext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode?: PaddingMode, feedbackSizeInBits?: int): int;
    encryptEcb(plaintext: byte[], paddingMode: PaddingMode): byte[];
    encryptEcb(plaintext: ReadOnlySpan_1<CLROf<byte>>, paddingMode: PaddingMode): byte[];
    encryptEcb(plaintext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode: PaddingMode): int;
    generateIV(): void;
    generateKey(): void;
    getCiphertextLengthCbc(plaintextLength: int, paddingMode?: PaddingMode): int;
    getCiphertextLengthCfb(plaintextLength: int, paddingMode?: PaddingMode, feedbackSizeInBits?: int): int;
    getCiphertextLengthEcb(plaintextLength: int, paddingMode: PaddingMode): int;
    setKey(key: ReadOnlySpan_1<CLROf<byte>>): void;
    tryDecryptCbc(ciphertext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, paddingMode?: PaddingMode): boolean;
    tryDecryptCfb(ciphertext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, paddingMode?: PaddingMode, feedbackSizeInBits?: int): boolean;
    tryDecryptEcb(ciphertext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode: PaddingMode, bytesWritten: { value: ref<int> }): boolean;
    tryEncryptCbc(plaintext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, paddingMode?: PaddingMode): boolean;
    tryEncryptCfb(plaintext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, paddingMode?: PaddingMode, feedbackSizeInBits?: int): boolean;
    tryEncryptEcb(plaintext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode: PaddingMode, bytesWritten: { value: ref<int> }): boolean;
    validKeySize(bitLength: int): boolean;
}


export const SymmetricAlgorithm: {
    create(): SymmetricAlgorithm;
    create(algName: string): SymmetricAlgorithm;
};


export interface __SymmetricAlgorithm$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface SymmetricAlgorithm$instance extends System_Internal.IDisposable$instance {}

export type SymmetricAlgorithm = SymmetricAlgorithm$instance & __SymmetricAlgorithm$views;


export interface ToBase64Transform$instance {
    readonly canReuseTransform: boolean;
    readonly canTransformMultipleBlocks: boolean;
    readonly inputBlockSize: int;
    readonly outputBlockSize: int;
    clear(): void;
    dispose(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const ToBase64Transform: {
    new(): ToBase64Transform$instance;
};


export interface __ToBase64Transform$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type ToBase64Transform = ToBase64Transform$instance & __ToBase64Transform$views;


export interface TripleDES$instance extends SymmetricAlgorithm$instance {
    key: byte[];
    dispose(): void;
}


export const TripleDES: {
    isWeakKey(rgbKey: byte[]): boolean;
};


export interface __TripleDES$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type TripleDES = TripleDES$instance & __TripleDES$views;


export interface TripleDESCng$instance extends TripleDES$instance {
    createDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    createDecryptor(): ICryptoTransform;
    createEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    createEncryptor(): ICryptoTransform;
    dispose(): void;
    generateIV(): void;
    generateKey(): void;
}


export const TripleDESCng: {
    new(): TripleDESCng$instance;
    new(keyName: string): TripleDESCng$instance;
    new(keyName: string, provider: CngProvider): TripleDESCng$instance;
    new(keyName: string, provider: CngProvider, openOptions: CngKeyOpenOptions): TripleDESCng$instance;
};


export interface __TripleDESCng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type TripleDESCng = TripleDESCng$instance & __TripleDESCng$views;


export interface TripleDESCryptoServiceProvider$instance extends TripleDES$instance {
    blockSize: int;
    feedbackSize: int;
    IV: byte[];
    key: byte[];
    keySize: int;
    readonly legalBlockSizes: KeySizes[];
    readonly legalKeySizes: KeySizes[];
    mode: CipherMode;
    padding: PaddingMode;
    createDecryptor(): ICryptoTransform;
    createDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    createEncryptor(): ICryptoTransform;
    createEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    dispose(): void;
    generateIV(): void;
    generateKey(): void;
}


export const TripleDESCryptoServiceProvider: {
    new(): TripleDESCryptoServiceProvider$instance;
};


export interface __TripleDESCryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type TripleDESCryptoServiceProvider = TripleDESCryptoServiceProvider$instance & __TripleDESCryptoServiceProvider$views;


export abstract class CryptographicOperations$instance {
    static fixedTimeEquals(left: ReadOnlySpan_1<CLROf<byte>>, right: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static hashData(hashAlgorithm: HashAlgorithmName, source: byte[]): byte[];
    static hashData(hashAlgorithm: HashAlgorithmName, source: Stream, destination: Span_1<CLROf<byte>>): int;
    static hashData(hashAlgorithm: HashAlgorithmName, source: Stream): byte[];
    static hashData(hashAlgorithm: HashAlgorithmName, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static hashData(hashAlgorithm: HashAlgorithmName, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashDataAsync(hashAlgorithm: HashAlgorithmName, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static hashDataAsync(hashAlgorithm: HashAlgorithmName, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static hmacData(hashAlgorithm: HashAlgorithmName, key: byte[], source: byte[]): byte[];
    static hmacData(hashAlgorithm: HashAlgorithmName, key: byte[], source: Stream): byte[];
    static hmacData(hashAlgorithm: HashAlgorithmName, key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    static hmacData(hashAlgorithm: HashAlgorithmName, key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    static hmacData(hashAlgorithm: HashAlgorithmName, key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static hmacData(hashAlgorithm: HashAlgorithmName, key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hmacDataAsync(hashAlgorithm: HashAlgorithmName, key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static hmacDataAsync(hashAlgorithm: HashAlgorithmName, key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static hmacDataAsync(hashAlgorithm: HashAlgorithmName, key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static tryHashData(hashAlgorithm: HashAlgorithmName, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static tryHmacData(hashAlgorithm: HashAlgorithmName, key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static zeroMemory(buffer: Span_1<CLROf<byte>>): void;
}


export type CryptographicOperations = CryptographicOperations$instance;

export abstract class ECCurve_NamedCurves$instance {
    static readonly brainpoolP160r1: ECCurve;
    static readonly brainpoolP160t1: ECCurve;
    static readonly brainpoolP192r1: ECCurve;
    static readonly brainpoolP192t1: ECCurve;
    static readonly brainpoolP224r1: ECCurve;
    static readonly brainpoolP224t1: ECCurve;
    static readonly brainpoolP256r1: ECCurve;
    static readonly brainpoolP256t1: ECCurve;
    static readonly brainpoolP320r1: ECCurve;
    static readonly brainpoolP320t1: ECCurve;
    static readonly brainpoolP384r1: ECCurve;
    static readonly brainpoolP384t1: ECCurve;
    static readonly brainpoolP512r1: ECCurve;
    static readonly brainpoolP512t1: ECCurve;
    static readonly nistP256: ECCurve;
    static readonly nistP384: ECCurve;
    static readonly nistP521: ECCurve;
}


export type ECCurve_NamedCurves = ECCurve_NamedCurves$instance;

export abstract class HKDF$instance {
    static deriveKey(hashAlgorithmName: HashAlgorithmName, ikm: byte[], outputLength: int, salt?: byte[], info?: byte[]): byte[];
    static deriveKey(hashAlgorithmName: HashAlgorithmName, ikm: ReadOnlySpan_1<CLROf<byte>>, output: Span_1<CLROf<byte>>, salt: ReadOnlySpan_1<CLROf<byte>>, info: ReadOnlySpan_1<CLROf<byte>>): void;
    static expand(hashAlgorithmName: HashAlgorithmName, prk: byte[], outputLength: int, info?: byte[]): byte[];
    static expand(hashAlgorithmName: HashAlgorithmName, prk: ReadOnlySpan_1<CLROf<byte>>, output: Span_1<CLROf<byte>>, info: ReadOnlySpan_1<CLROf<byte>>): void;
    static extract(hashAlgorithmName: HashAlgorithmName, ikm: byte[], salt?: byte[]): byte[];
    static extract(hashAlgorithmName: HashAlgorithmName, ikm: ReadOnlySpan_1<CLROf<byte>>, salt: ReadOnlySpan_1<CLROf<byte>>, prk: Span_1<CLROf<byte>>): int;
}


export type HKDF = HKDF$instance;

export abstract class PemEncoding$instance {
    static find(pemData: ReadOnlySpan_1<CLROf<char>>): PemFields;
    static findUtf8(pemData: ReadOnlySpan_1<CLROf<byte>>): PemFields;
    static getEncodedSize(labelLength: int, dataLength: int): int;
    static tryFind(pemData: ReadOnlySpan_1<CLROf<char>>, fields: { value: ref<PemFields> }): boolean;
    static tryFindUtf8(pemData: ReadOnlySpan_1<CLROf<byte>>, fields: { value: ref<PemFields> }): boolean;
    static tryWrite(label: ReadOnlySpan_1<CLROf<char>>, data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    static tryWriteUtf8(utf8Label: ReadOnlySpan_1<CLROf<byte>>, data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static write(label: ReadOnlySpan_1<CLROf<char>>, data: ReadOnlySpan_1<CLROf<byte>>): char[];
    static writeString(label: ReadOnlySpan_1<CLROf<char>>, data: ReadOnlySpan_1<CLROf<byte>>): string;
    static writeUtf8(utf8Label: ReadOnlySpan_1<CLROf<byte>>, data: ReadOnlySpan_1<CLROf<byte>>): byte[];
}


export type PemEncoding = PemEncoding$instance;

