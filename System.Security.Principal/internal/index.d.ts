// Generated by tsbindgen - Architecture
// Namespace: System.Security.Principal
// Assembly: System.Private.CoreLib, System.Security.Claims, System.Security.Principal.Windows

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { SafeAccessTokenHandle } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { BinaryWriter } from "../../System.IO/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Security_Claims_Internal from "../../System.Security.Claims/internal/index.js";
import type { Claim, ClaimsIdentity, ClaimsPrincipal } from "../../System.Security.Claims/internal/index.js";
import type { Task, Task_1 } from "../../System.Threading.Tasks/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action, Boolean as ClrBoolean, Byte, Enum, Exception, Func_1, IComparable, IComparable_1, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, Object as ClrObject, Predicate_1, String as ClrString, SystemException, Type, TypeCode, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum PrincipalPolicy {
    unauthenticatedPrincipal = 0,
    noPrincipal = 1,
    windowsPrincipal = 2
}


export enum TokenAccessLevels {
    assignPrimary = 1,
    duplicate = 2,
    impersonate = 4,
    query = 8,
    querySource = 16,
    adjustPrivileges = 32,
    adjustGroups = 64,
    adjustDefault = 128,
    adjustSessionId = 256,
    read = 131080,
    write = 131296,
    allAccess = 983551,
    maximumAllowed = 33554432
}


export enum TokenImpersonationLevel {
    none = 0,
    anonymous = 1,
    identification = 2,
    impersonation = 3,
    delegation = 4
}


export enum WellKnownSidType {
    nullSid = 0,
    worldSid = 1,
    localSid = 2,
    creatorOwnerSid = 3,
    creatorGroupSid = 4,
    creatorOwnerServerSid = 5,
    creatorGroupServerSid = 6,
    ntAuthoritySid = 7,
    dialupSid = 8,
    networkSid = 9,
    batchSid = 10,
    interactiveSid = 11,
    serviceSid = 12,
    anonymousSid = 13,
    proxySid = 14,
    enterpriseControllersSid = 15,
    selfSid = 16,
    authenticatedUserSid = 17,
    restrictedCodeSid = 18,
    terminalServerSid = 19,
    remoteLogonIdSid = 20,
    logonIdsSid = 21,
    localSystemSid = 22,
    localServiceSid = 23,
    networkServiceSid = 24,
    builtinDomainSid = 25,
    builtinAdministratorsSid = 26,
    builtinUsersSid = 27,
    builtinGuestsSid = 28,
    builtinPowerUsersSid = 29,
    builtinAccountOperatorsSid = 30,
    builtinSystemOperatorsSid = 31,
    builtinPrintOperatorsSid = 32,
    builtinBackupOperatorsSid = 33,
    builtinReplicatorSid = 34,
    builtinPreWindows2000CompatibleAccessSid = 35,
    builtinRemoteDesktopUsersSid = 36,
    builtinNetworkConfigurationOperatorsSid = 37,
    accountAdministratorSid = 38,
    accountGuestSid = 39,
    accountKrbtgtSid = 40,
    accountDomainAdminsSid = 41,
    accountDomainUsersSid = 42,
    accountDomainGuestsSid = 43,
    accountComputersSid = 44,
    accountControllersSid = 45,
    accountCertAdminsSid = 46,
    accountSchemaAdminsSid = 47,
    accountEnterpriseAdminsSid = 48,
    accountPolicyAdminsSid = 49,
    accountRasAndIasServersSid = 50,
    ntlmAuthenticationSid = 51,
    digestAuthenticationSid = 52,
    sChannelAuthenticationSid = 53,
    thisOrganizationSid = 54,
    otherOrganizationSid = 55,
    builtinIncomingForestTrustBuildersSid = 56,
    builtinPerformanceMonitoringUsersSid = 57,
    builtinPerformanceLoggingUsersSid = 58,
    builtinAuthorizationAccessSid = 59,
    maxDefined = 60,
    winBuiltinTerminalServerLicenseServersSid = 60,
    winBuiltinDCOMUsersSid = 61,
    winBuiltinIUsersSid = 62,
    winIUserSid = 63,
    winBuiltinCryptoOperatorsSid = 64,
    winUntrustedLabelSid = 65,
    winLowLabelSid = 66,
    winMediumLabelSid = 67,
    winHighLabelSid = 68,
    winSystemLabelSid = 69,
    winWriteRestrictedCodeSid = 70,
    winCreatorOwnerRightsSid = 71,
    winCacheablePrincipalsGroupSid = 72,
    winNonCacheablePrincipalsGroupSid = 73,
    winEnterpriseReadonlyControllersSid = 74,
    winAccountReadonlyControllersSid = 75,
    winBuiltinEventLogReadersGroup = 76,
    winNewEnterpriseReadonlyControllersSid = 77,
    winBuiltinCertSvcDComAccessGroup = 78,
    winMediumPlusLabelSid = 79,
    winLocalLogonSid = 80,
    winConsoleLogonSid = 81,
    winThisOrganizationCertificateSid = 82,
    winApplicationPackageAuthoritySid = 83,
    winBuiltinAnyPackageSid = 84,
    winCapabilityInternetClientSid = 85,
    winCapabilityInternetClientServerSid = 86,
    winCapabilityPrivateNetworkClientServerSid = 87,
    winCapabilityPicturesLibrarySid = 88,
    winCapabilityVideosLibrarySid = 89,
    winCapabilityMusicLibrarySid = 90,
    winCapabilityDocumentsLibrarySid = 91,
    winCapabilitySharedUserCertificatesSid = 92,
    winCapabilityEnterpriseAuthenticationSid = 93,
    winCapabilityRemovableStorageSid = 94
}


export enum WindowsAccountType {
    normal = 0,
    guest = 1,
    system = 2,
    anonymous = 3
}


export enum WindowsBuiltInRole {
    administrator = 544,
    user = 545,
    guest = 546,
    powerUser = 547,
    accountOperator = 548,
    systemOperator = 549,
    printOperator = 550,
    backupOperator = 551,
    replicator = 552
}


export interface IIdentity$instance {
    readonly name: string;
    readonly authenticationType: string;
    readonly isAuthenticated: boolean;
}


export type IIdentity = IIdentity$instance;

export interface IPrincipal$instance {
    readonly identity: IIdentity;
    isInRole(role: string): boolean;
}


export type IPrincipal = IPrincipal$instance;

export interface GenericIdentity$instance extends ClaimsIdentity {
    readonly authenticationType: string;
    readonly claims: IEnumerable_1<Claim>;
    readonly isAuthenticated: boolean;
    readonly name: string;
    clone(): ClaimsIdentity;
}


export const GenericIdentity: {
    new(name: string): GenericIdentity$instance;
    new(name: string, type_: string): GenericIdentity$instance;
};


export interface __GenericIdentity$views {
    As_IIdentity(): IIdentity$instance;
}

export interface GenericIdentity$instance extends IIdentity$instance {}

export type GenericIdentity = GenericIdentity$instance & __GenericIdentity$views;


export interface GenericPrincipal$instance extends ClaimsPrincipal {
    readonly identity: IIdentity;
    isInRole(role: string): boolean;
}


export const GenericPrincipal: {
    new(identity: IIdentity, roles: string[]): GenericPrincipal$instance;
};


export interface __GenericPrincipal$views {
    As_IPrincipal(): IPrincipal$instance;
}

export type GenericPrincipal = GenericPrincipal$instance & __GenericPrincipal$views;


export interface IdentityNotMappedException$instance extends SystemException {
    readonly unmappedIdentities: IdentityReferenceCollection;
    getObjectData(serializationInfo: SerializationInfo, streamingContext: StreamingContext): void;
}


export const IdentityNotMappedException: {
    new(): IdentityNotMappedException$instance;
    new(message: string): IdentityNotMappedException$instance;
    new(message: string, inner: Exception): IdentityNotMappedException$instance;
};


export interface __IdentityNotMappedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type IdentityNotMappedException = IdentityNotMappedException$instance & __IdentityNotMappedException$views;


export interface IdentityReference$instance {
    readonly value: string;
    equals(o: unknown): boolean;
    getHashCode(): int;
    isValidTargetType(targetType: Type): boolean;
    toString(): string;
    translate(targetType: Type): IdentityReference;
}


export const IdentityReference: {
};


export type IdentityReference = IdentityReference$instance;

export interface IdentityReferenceCollection$instance {
    readonly count: int;
    item: IdentityReference;
    add(identity: IdentityReference): void;
    clear(): void;
    contains(identity: IdentityReference): boolean;
    copyTo(array: IdentityReference[], offset: int): void;
    getEnumerator(): IEnumerator_1<IdentityReference>;
    remove(identity: IdentityReference): boolean;
    translate(targetType: Type): IdentityReferenceCollection;
    translate(targetType: Type, forceSuccess: boolean): IdentityReferenceCollection;
}


export const IdentityReferenceCollection: {
    new(): IdentityReferenceCollection$instance;
    new(capacity: int): IdentityReferenceCollection$instance;
};


export interface __IdentityReferenceCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<IdentityReference>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<IdentityReference>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type IdentityReferenceCollection = IdentityReferenceCollection$instance & __IdentityReferenceCollection$views;


export interface NTAccount$instance extends IdentityReference {
    readonly value: string;
    equals(o: unknown): boolean;
    getHashCode(): int;
    isValidTargetType(targetType: Type): boolean;
    toString(): string;
    translate(targetType: Type): IdentityReference;
}


export const NTAccount: {
    new(name: string): NTAccount$instance;
    new(domainName: string, accountName: string): NTAccount$instance;
};


export type NTAccount = NTAccount$instance;

export interface SecurityIdentifier$instance extends IdentityReference {
    readonly accountDomainSid: SecurityIdentifier;
    readonly binaryLength: int;
    readonly value: string;
    compareTo(sid: SecurityIdentifier): int;
    equals(o: unknown): boolean;
    equals(sid: SecurityIdentifier): boolean;
    getBinaryForm(binaryForm: byte[], offset: int): void;
    getHashCode(): int;
    isAccountSid(): boolean;
    isEqualDomainSid(sid: SecurityIdentifier): boolean;
    isValidTargetType(targetType: Type): boolean;
    isWellKnown(type_: WellKnownSidType): boolean;
    toString(): string;
    translate(targetType: Type): IdentityReference;
}


export const SecurityIdentifier: {
    new(binaryForm: byte[], offset: int): SecurityIdentifier$instance;
    new(binaryForm: nint): SecurityIdentifier$instance;
    new(sidType: WellKnownSidType, domainSid: SecurityIdentifier): SecurityIdentifier$instance;
    new(sddlForm: string): SecurityIdentifier$instance;
    readonly maxBinaryLength: int;
    readonly minBinaryLength: int;
};


export interface __SecurityIdentifier$views {
    As_IComparable_1(): System_Internal.IComparable_1$instance<SecurityIdentifier>;

    // Structural method bridges for numeric interface constraints
    CompareTo(obj: unknown): int;
}

export interface SecurityIdentifier$instance extends System_Internal.IComparable_1$instance<SecurityIdentifier> {}

export type SecurityIdentifier = SecurityIdentifier$instance & __SecurityIdentifier$views;


export interface WindowsIdentity$instance extends ClaimsIdentity {
    readonly accessToken: SafeAccessTokenHandle;
    readonly authenticationType: string;
    readonly claims: IEnumerable_1<Claim>;
    readonly deviceClaims: IEnumerable_1<Claim>;
    readonly groups: IdentityReferenceCollection;
    readonly impersonationLevel: TokenImpersonationLevel;
    readonly isAnonymous: boolean;
    readonly isAuthenticated: boolean;
    readonly isGuest: boolean;
    readonly isSystem: boolean;
    readonly name: string;
    readonly owner: SecurityIdentifier;
    readonly token: nint;
    readonly user: SecurityIdentifier;
    readonly userClaims: IEnumerable_1<Claim>;
    clone(): ClaimsIdentity;
    dispose(): void;
}


export const WindowsIdentity: {
    new(userToken: nint): WindowsIdentity$instance;
    new(userToken: nint, type_: string): WindowsIdentity$instance;
    new(userToken: nint, type_: string, acctType: WindowsAccountType): WindowsIdentity$instance;
    new(userToken: nint, type_: string, acctType: WindowsAccountType, isAuthenticated: boolean): WindowsIdentity$instance;
    new(info: SerializationInfo, context: StreamingContext): WindowsIdentity$instance;
    new(sUserPrincipalName: string): WindowsIdentity$instance;
    readonly defaultIssuer: string;
    getAnonymous(): WindowsIdentity;
    getCurrent(): WindowsIdentity;
    getCurrent(ifImpersonating: boolean): WindowsIdentity;
    getCurrent(desiredAccess: TokenAccessLevels): WindowsIdentity;
    runImpersonated<T>(safeAccessTokenHandle: SafeAccessTokenHandle, func: Func_1<T>): T;
    runImpersonated(safeAccessTokenHandle: SafeAccessTokenHandle, action: Action): void;
    runImpersonatedAsync<T>(safeAccessTokenHandle: SafeAccessTokenHandle, func: Func_1<Task_1<T>>): Task_1<T>;
    runImpersonatedAsync(safeAccessTokenHandle: SafeAccessTokenHandle, func: Func_1<Task>): Task;
};


export interface __WindowsIdentity$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
    As_IIdentity(): IIdentity$instance;
}

export interface WindowsIdentity$instance extends System_Internal.IDisposable$instance, System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance, IIdentity$instance {}

export type WindowsIdentity = WindowsIdentity$instance & __WindowsIdentity$views;


export interface WindowsPrincipal$instance extends ClaimsPrincipal {
    readonly deviceClaims: IEnumerable_1<Claim>;
    readonly identity: IIdentity;
    readonly userClaims: IEnumerable_1<Claim>;
    isInRole(sid: SecurityIdentifier): boolean;
    isInRole(role: WindowsBuiltInRole): boolean;
    isInRole(role: string): boolean;
}


export const WindowsPrincipal: {
    new(ntIdentity: WindowsIdentity): WindowsPrincipal$instance;
};


export interface __WindowsPrincipal$views {
    As_IPrincipal(): IPrincipal$instance;
}

export type WindowsPrincipal = WindowsPrincipal$instance & __WindowsPrincipal$views;


