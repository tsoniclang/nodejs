// Generated by tsbindgen - Architecture
// Namespace: System.Diagnostics.CodeAnalysis
// Assembly: System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import * as System_Internal from "../../System/internal/index.js";
import type { Attribute, Boolean as ClrBoolean, Enum, IComparable, IConvertible, IFormatProvider, IFormattable, Int32, ISpanFormattable, Object as ClrObject, String as ClrString, Type, TypeCode } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum DynamicallyAccessedMemberTypes {
    none = 0,
    publicParameterlessConstructor = 1,
    publicConstructors = 3,
    nonPublicConstructors = 4,
    publicMethods = 8,
    nonPublicMethods = 16,
    publicFields = 32,
    nonPublicFields = 64,
    publicNestedTypes = 128,
    nonPublicNestedTypes = 256,
    publicProperties = 512,
    nonPublicProperties = 1024,
    publicEvents = 2048,
    nonPublicEvents = 4096,
    interfaces = 8192,
    nonPublicConstructorsWithInherited = 16388,
    nonPublicMethodsWithInherited = 32784,
    nonPublicFieldsWithInherited = 65600,
    nonPublicNestedTypesWithInherited = 131328,
    nonPublicPropertiesWithInherited = 263168,
    nonPublicEventsWithInherited = 528384,
    publicConstructorsWithInherited = 1048579,
    publicNestedTypesWithInherited = 2097280,
    allConstructors = 1064967,
    allMethods = 32792,
    allFields = 65632,
    allNestedTypes = 2228608,
    allProperties = 263680,
    allEvents = 530432,
    all = -1
}


export interface AllowNullAttribute$instance extends Attribute {
}


export const AllowNullAttribute: {
    new(): AllowNullAttribute$instance;
};


export type AllowNullAttribute = AllowNullAttribute$instance;

export interface ConstantExpectedAttribute$instance extends Attribute {
    max: unknown;
    min: unknown;
}


export const ConstantExpectedAttribute: {
    new(): ConstantExpectedAttribute$instance;
};


export type ConstantExpectedAttribute = ConstantExpectedAttribute$instance;

export interface DisallowNullAttribute$instance extends Attribute {
}


export const DisallowNullAttribute: {
    new(): DisallowNullAttribute$instance;
};


export type DisallowNullAttribute = DisallowNullAttribute$instance;

export interface DoesNotReturnAttribute$instance extends Attribute {
}


export const DoesNotReturnAttribute: {
    new(): DoesNotReturnAttribute$instance;
};


export type DoesNotReturnAttribute = DoesNotReturnAttribute$instance;

export interface DoesNotReturnIfAttribute$instance extends Attribute {
    readonly parameterValue: boolean;
}


export const DoesNotReturnIfAttribute: {
    new(parameterValue: boolean): DoesNotReturnIfAttribute$instance;
};


export type DoesNotReturnIfAttribute = DoesNotReturnIfAttribute$instance;

export interface DynamicallyAccessedMembersAttribute$instance extends Attribute {
    readonly memberTypes: DynamicallyAccessedMemberTypes;
}


export const DynamicallyAccessedMembersAttribute: {
    new(memberTypes: DynamicallyAccessedMemberTypes): DynamicallyAccessedMembersAttribute$instance;
};


export type DynamicallyAccessedMembersAttribute = DynamicallyAccessedMembersAttribute$instance;

export interface DynamicDependencyAttribute$instance extends Attribute {
    readonly assemblyName: string;
    condition: string;
    readonly memberSignature: string;
    readonly memberTypes: DynamicallyAccessedMemberTypes;
    readonly type_: Type;
    readonly typeName: string;
}


export const DynamicDependencyAttribute: {
    new(memberSignature: string): DynamicDependencyAttribute$instance;
    new(memberSignature: string, type_: Type): DynamicDependencyAttribute$instance;
    new(memberSignature: string, typeName: string, assemblyName: string): DynamicDependencyAttribute$instance;
    new(memberTypes: DynamicallyAccessedMemberTypes, type_: Type): DynamicDependencyAttribute$instance;
    new(memberTypes: DynamicallyAccessedMemberTypes, typeName: string, assemblyName: string): DynamicDependencyAttribute$instance;
};


export type DynamicDependencyAttribute = DynamicDependencyAttribute$instance;

export interface ExcludeFromCodeCoverageAttribute$instance extends Attribute {
    justification: string;
}


export const ExcludeFromCodeCoverageAttribute: {
    new(): ExcludeFromCodeCoverageAttribute$instance;
};


export type ExcludeFromCodeCoverageAttribute = ExcludeFromCodeCoverageAttribute$instance;

export interface ExperimentalAttribute$instance extends Attribute {
    readonly diagnosticId: string;
    message: string;
    urlFormat: string;
}


export const ExperimentalAttribute: {
    new(diagnosticId: string): ExperimentalAttribute$instance;
};


export type ExperimentalAttribute = ExperimentalAttribute$instance;

export interface FeatureGuardAttribute$instance extends Attribute {
    readonly featureType: Type;
}


export const FeatureGuardAttribute: {
    new(featureType: Type): FeatureGuardAttribute$instance;
};


export type FeatureGuardAttribute = FeatureGuardAttribute$instance;

export interface FeatureSwitchDefinitionAttribute$instance extends Attribute {
    readonly switchName: string;
}


export const FeatureSwitchDefinitionAttribute: {
    new(switchName: string): FeatureSwitchDefinitionAttribute$instance;
};


export type FeatureSwitchDefinitionAttribute = FeatureSwitchDefinitionAttribute$instance;

export interface MaybeNullAttribute$instance extends Attribute {
}


export const MaybeNullAttribute: {
    new(): MaybeNullAttribute$instance;
};


export type MaybeNullAttribute = MaybeNullAttribute$instance;

export interface MaybeNullWhenAttribute$instance extends Attribute {
    readonly returnValue: boolean;
}


export const MaybeNullWhenAttribute: {
    new(returnValue: boolean): MaybeNullWhenAttribute$instance;
};


export type MaybeNullWhenAttribute = MaybeNullWhenAttribute$instance;

export interface MemberNotNullAttribute$instance extends Attribute {
    readonly members: string[];
}


export const MemberNotNullAttribute: {
    new(member: string): MemberNotNullAttribute$instance;
    new(members: string[]): MemberNotNullAttribute$instance;
};


export type MemberNotNullAttribute = MemberNotNullAttribute$instance;

export interface MemberNotNullWhenAttribute$instance extends Attribute {
    readonly members: string[];
    readonly returnValue: boolean;
}


export const MemberNotNullWhenAttribute: {
    new(returnValue: boolean, member: string): MemberNotNullWhenAttribute$instance;
    new(returnValue: boolean, members: string[]): MemberNotNullWhenAttribute$instance;
};


export type MemberNotNullWhenAttribute = MemberNotNullWhenAttribute$instance;

export interface NotNullAttribute$instance extends Attribute {
}


export const NotNullAttribute: {
    new(): NotNullAttribute$instance;
};


export type NotNullAttribute = NotNullAttribute$instance;

export interface NotNullIfNotNullAttribute$instance extends Attribute {
    readonly parameterName: string;
}


export const NotNullIfNotNullAttribute: {
    new(parameterName: string): NotNullIfNotNullAttribute$instance;
};


export type NotNullIfNotNullAttribute = NotNullIfNotNullAttribute$instance;

export interface NotNullWhenAttribute$instance extends Attribute {
    readonly returnValue: boolean;
}


export const NotNullWhenAttribute: {
    new(returnValue: boolean): NotNullWhenAttribute$instance;
};


export type NotNullWhenAttribute = NotNullWhenAttribute$instance;

export interface RequiresAssemblyFilesAttribute$instance extends Attribute {
    readonly message: string;
    url: string;
}


export const RequiresAssemblyFilesAttribute: {
    new(): RequiresAssemblyFilesAttribute$instance;
    new(message: string): RequiresAssemblyFilesAttribute$instance;
};


export type RequiresAssemblyFilesAttribute = RequiresAssemblyFilesAttribute$instance;

export interface RequiresDynamicCodeAttribute$instance extends Attribute {
    excludeStatics: boolean;
    readonly message: string;
    url: string;
}


export const RequiresDynamicCodeAttribute: {
    new(message: string): RequiresDynamicCodeAttribute$instance;
};


export type RequiresDynamicCodeAttribute = RequiresDynamicCodeAttribute$instance;

export interface RequiresUnreferencedCodeAttribute$instance extends Attribute {
    excludeStatics: boolean;
    readonly message: string;
    url: string;
}


export const RequiresUnreferencedCodeAttribute: {
    new(message: string): RequiresUnreferencedCodeAttribute$instance;
};


export type RequiresUnreferencedCodeAttribute = RequiresUnreferencedCodeAttribute$instance;

export interface SetsRequiredMembersAttribute$instance extends Attribute {
}


export const SetsRequiredMembersAttribute: {
    new(): SetsRequiredMembersAttribute$instance;
};


export type SetsRequiredMembersAttribute = SetsRequiredMembersAttribute$instance;

export interface StringSyntaxAttribute$instance extends Attribute {
    readonly arguments: unknown[];
    readonly syntax: string;
}


export const StringSyntaxAttribute: {
    new(syntax: string): StringSyntaxAttribute$instance;
    new(syntax: string, arguments: unknown[]): StringSyntaxAttribute$instance;
    readonly compositeFormat: string;
    readonly dateOnlyFormat: string;
    readonly dateTimeFormat: string;
    readonly enumFormat: string;
    readonly guidFormat: string;
    readonly json: string;
    readonly numericFormat: string;
    readonly regex: string;
    readonly timeOnlyFormat: string;
    readonly timeSpanFormat: string;
    readonly uri: string;
    readonly xml: string;
};


export type StringSyntaxAttribute = StringSyntaxAttribute$instance;

export interface SuppressMessageAttribute$instance extends Attribute {
    readonly category: string;
    readonly checkId: string;
    justification: string;
    messageId: string;
    scope: string;
    target: string;
}


export const SuppressMessageAttribute: {
    new(category: string, checkId: string): SuppressMessageAttribute$instance;
};


export type SuppressMessageAttribute = SuppressMessageAttribute$instance;

export interface UnconditionalSuppressMessageAttribute$instance extends Attribute {
    readonly category: string;
    readonly checkId: string;
    justification: string;
    messageId: string;
    scope: string;
    target: string;
}


export const UnconditionalSuppressMessageAttribute: {
    new(category: string, checkId: string): UnconditionalSuppressMessageAttribute$instance;
};


export type UnconditionalSuppressMessageAttribute = UnconditionalSuppressMessageAttribute$instance;

export interface UnscopedRefAttribute$instance extends Attribute {
}


export const UnscopedRefAttribute: {
    new(): UnscopedRefAttribute$instance;
};


export type UnscopedRefAttribute = UnscopedRefAttribute$instance;

