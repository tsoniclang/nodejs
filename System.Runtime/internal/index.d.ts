// Generated by tsbindgen - Architecture
// Namespace: System.Runtime
// Assembly: System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_ConstrainedExecution_Internal from "../../System.Runtime.ConstrainedExecution/internal/index.js";
import type { CriticalFinalizerObject } from "../../System.Runtime.ConstrainedExecution/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action, Attribute, Boolean as ClrBoolean, Enum, Exception, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, Int64, ISpanFormattable, Object as ClrObject, String as ClrString, TimeSpan, Type, TypeCode, ValueTuple_2, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum GCLargeObjectHeapCompactionMode {
    default_ = 1,
    compactOnce = 2
}


export enum GCLatencyMode {
    batch = 0,
    interactive = 1,
    lowLatency = 2,
    sustainedLowLatency = 3,
    noGCRegion = 4
}


export interface DependentHandle$instance {
    dependent: unknown;
    readonly isAllocated: boolean;
    target: unknown;
    readonly targetAndDependent: ValueTuple_2<unknown, unknown>;
    dispose(): void;
}


export const DependentHandle: {
    new(target: unknown, dependent: unknown): DependentHandle$instance;
};


export interface __DependentHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DependentHandle$instance extends System_Internal.IDisposable$instance {}

export type DependentHandle = DependentHandle$instance & __DependentHandle$views;


export interface AmbiguousImplementationException$instance extends Exception {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const AmbiguousImplementationException: {
    new(): AmbiguousImplementationException$instance;
    new(message: string): AmbiguousImplementationException$instance;
    new(message: string, innerException: Exception): AmbiguousImplementationException$instance;
};


export interface __AmbiguousImplementationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AmbiguousImplementationException = AmbiguousImplementationException$instance & __AmbiguousImplementationException$views;


export interface AssemblyTargetedPatchBandAttribute$instance extends Attribute {
    readonly targetedPatchBand: string;
}


export const AssemblyTargetedPatchBandAttribute: {
    new(targetedPatchBand: string): AssemblyTargetedPatchBandAttribute$instance;
};


export type AssemblyTargetedPatchBandAttribute = AssemblyTargetedPatchBandAttribute$instance;

export interface MemoryFailPoint$instance extends CriticalFinalizerObject {
    dispose(): void;
}


export const MemoryFailPoint: {
    new(sizeInMegabytes: int): MemoryFailPoint$instance;
};


export interface __MemoryFailPoint$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MemoryFailPoint$instance extends System_Internal.IDisposable$instance {}

export type MemoryFailPoint = MemoryFailPoint$instance & __MemoryFailPoint$views;


export interface TargetedPatchingOptOutAttribute$instance extends Attribute {
    readonly reason: string;
}


export const TargetedPatchingOptOutAttribute: {
    new(reason: string): TargetedPatchingOptOutAttribute$instance;
};


export type TargetedPatchingOptOutAttribute = TargetedPatchingOptOutAttribute$instance;

export abstract class ControlledExecution$instance {
    static run(action: Action, cancellationToken: CancellationToken): void;
}


export type ControlledExecution = ControlledExecution$instance;

export abstract class GCSettings$instance {
    static readonly isServerGC: boolean;
    static latencyMode: GCLatencyMode;
    static largeObjectHeapCompactionMode: GCLargeObjectHeapCompactionMode;
}


export type GCSettings = GCSettings$instance;

export abstract class JitInfo$instance {
    static getCompilationTime(currentThread?: boolean): TimeSpan;
    static getCompiledILBytes(currentThread?: boolean): long;
    static getCompiledMethodCount(currentThread?: boolean): long;
}


export type JitInfo = JitInfo$instance;

export abstract class ProfileOptimization$instance {
    static setProfileRoot(directoryPath: string): void;
    static startProfile(profile: string): void;
}


export type ProfileOptimization = ProfileOptimization$instance;

