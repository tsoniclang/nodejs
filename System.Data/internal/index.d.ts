// Generated by tsbindgen - Architecture
// Namespace: System.Data
// Assembly: System.Data.Common

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { IComparer_1, IEnumerable_1, IEnumerator_1, IEqualityComparer_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ReadOnlyCollection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { Hashtable, ICollection, IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { AttributeCollection, CollectionChangeEventHandler, DescriptionAttribute, EventDescriptor, EventDescriptorCollection, IBindingList, IBindingListView, IComponent, IContainer, ICustomTypeDescriptor, IDataErrorInfo, IEditableObject, IListSource, INotifyPropertyChanged, ISite, ISupportInitialize, ISupportInitializeNotification, ITypedList, ListChangedEventHandler, ListSortDescriptionCollection, ListSortDirection, MarshalByValueComponent, PropertyChangedEventHandler, PropertyDescriptor, PropertyDescriptorCollection, TypeConverter } from "../../System.ComponentModel/internal/index.js";
import * as System_Data_Common_Internal from "../../System.Data.Common/internal/index.js";
import type { DbColumn, DbDataReader } from "../../System.Data.Common/internal/index.js";
import type { CultureInfo } from "../../System.Globalization/internal/index.js";
import type { Stream, TextReader, TextWriter } from "../../System.IO/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { Task, Task_1, ValueTask } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import type { XmlSchema, XmlSchemaComplexType, XmlSchemaSet } from "../../System.Xml.Schema/internal/index.js";
import * as System_Xml_Serialization_Internal from "../../System.Xml.Serialization/internal/index.js";
import type { IXmlSerializable } from "../../System.Xml.Serialization/internal/index.js";
import type { XmlReader, XmlWriter } from "../../System.Xml/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Char, Converter_2, DateTime, Decimal, Delegate, Double, Enum, EventArgs, EventHandler, Exception, Func_2, Guid, IAsyncDisposable, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, IServiceProvider, ISpanFormattable, MulticastDelegate, Nullable_1, Object as ClrObject, Single, String as ClrString, SystemException, Type, TypeCode, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum AcceptRejectRule {
    none = 0,
    cascade = 1
}


export enum CommandBehavior {
    default_ = 0,
    singleResult = 1,
    schemaOnly = 2,
    keyInfo = 4,
    singleRow = 8,
    sequentialAccess = 16,
    closeConnection = 32
}


export enum CommandType {
    text = 1,
    storedProcedure = 4,
    tableDirect = 512
}


export enum ConflictOption {
    compareAllSearchableValues = 1,
    compareRowVersion = 2,
    overwriteChanges = 3
}


export enum ConnectionState {
    closed = 0,
    open = 1,
    connecting = 2,
    executing = 4,
    fetching = 8,
    broken = 16
}


export enum DataRowAction {
    nothing = 0,
    delete_ = 1,
    change = 2,
    rollback = 4,
    commit = 8,
    add = 16,
    changeOriginal = 32,
    changeCurrentAndOriginal = 64
}


export enum DataRowState {
    detached = 1,
    unchanged = 2,
    added = 4,
    deleted = 8,
    modified = 16
}


export enum DataRowVersion {
    original = 256,
    current = 512,
    proposed = 1024,
    default_ = 1536
}


export enum DataSetDateTime {
    local = 1,
    unspecified = 2,
    unspecifiedLocal = 3,
    utc = 4
}


export enum DataViewRowState {
    none = 0,
    unchanged = 2,
    added = 4,
    deleted = 8,
    modifiedCurrent = 16,
    modifiedOriginal = 32,
    originalRows = 42,
    currentRows = 22
}


export enum DbType {
    ansiString = 0,
    binary = 1,
    byte = 2,
    boolean_ = 3,
    currency = 4,
    date = 5,
    dateTime = 6,
    decimal = 7,
    double = 8,
    guid = 9,
    int16 = 10,
    int32 = 11,
    int64 = 12,
    object_ = 13,
    sByte = 14,
    single = 15,
    string_ = 16,
    time = 17,
    uInt16 = 18,
    uInt32 = 19,
    uInt64 = 20,
    varNumeric = 21,
    ansiStringFixedLength = 22,
    stringFixedLength = 23,
    xml = 25,
    dateTime2 = 26,
    dateTimeOffset = 27
}


export enum IsolationLevel {
    unspecified = -1,
    chaos = 16,
    readUncommitted = 256,
    readCommitted = 4096,
    repeatableRead = 65536,
    serializable = 1048576,
    snapshot = 16777216
}


export enum KeyRestrictionBehavior {
    allowOnly = 0,
    preventUsage = 1
}


export enum LoadOption {
    overwriteChanges = 1,
    preserveChanges = 2,
    upsert = 3
}


export enum MappingType {
    element = 1,
    attribute = 2,
    simpleContent = 3,
    hidden = 4
}


export enum MissingMappingAction {
    passthrough = 1,
    ignore = 2,
    error = 3
}


export enum MissingSchemaAction {
    add = 1,
    ignore = 2,
    error = 3,
    addWithKey = 4
}


export enum ParameterDirection {
    input = 1,
    output = 2,
    inputOutput = 3,
    returnValue = 6
}


export enum Rule {
    none = 0,
    cascade = 1,
    setNull = 2,
    setDefault = 3
}


export enum SchemaSerializationMode {
    includeSchema = 1,
    excludeSchema = 2
}


export enum SchemaType {
    source = 1,
    mapped = 2
}


export enum SerializationFormat {
    xml = 0,
    binary = 1
}


export enum SqlDbType {
    bigInt = 0,
    binary = 1,
    bit = 2,
    char = 3,
    dateTime = 4,
    decimal = 5,
    float = 6,
    image = 7,
    int = 8,
    money = 9,
    nChar = 10,
    nText = 11,
    nVarChar = 12,
    real = 13,
    uniqueIdentifier = 14,
    smallDateTime = 15,
    smallInt = 16,
    smallMoney = 17,
    text = 18,
    timestamp = 19,
    tinyInt = 20,
    varBinary = 21,
    varChar = 22,
    variant = 23,
    xml = 25,
    udt = 29,
    structured = 30,
    date = 31,
    time = 32,
    dateTime2 = 33,
    dateTimeOffset = 34,
    json = 35,
    vector = 36
}


export enum StatementType {
    select = 0,
    insert = 1,
    update = 2,
    delete_ = 3,
    batch = 4
}


export enum UpdateRowSource {
    none = 0,
    outputParameters = 1,
    firstReturnedRecord = 2,
    both = 3
}


export enum UpdateStatus {
    continue_ = 0,
    errorsOccurred = 1,
    skipCurrentRow = 2,
    skipAllRemainingRows = 3
}


export enum XmlReadMode {
    auto = 0,
    readSchema = 1,
    ignoreSchema = 2,
    inferSchema = 3,
    diffGram = 4,
    fragment = 5,
    inferTypedSchema = 6
}


export enum XmlWriteMode {
    writeSchema = 0,
    ignoreSchema = 1,
    diffGram = 2
}


export type DataColumnChangeEventHandler = (sender: unknown, e: DataColumnChangeEventArgs) => void;


export type DataRowChangeEventHandler = (sender: unknown, e: DataRowChangeEventArgs) => void;


export type DataTableClearEventHandler = (sender: unknown, e: DataTableClearEventArgs) => void;


export type DataTableNewRowEventHandler = (sender: unknown, e: DataTableNewRowEventArgs) => void;


export type FillErrorEventHandler = (sender: unknown, e: FillErrorEventArgs) => void;


export type MergeFailedEventHandler = (sender: unknown, e: MergeFailedEventArgs) => void;


export type StateChangeEventHandler = (sender: unknown, e: StateChangeEventArgs) => void;


export type StatementCompletedEventHandler = (sender: unknown, e: StatementCompletedEventArgs) => void;


export interface IColumnMapping$instance {
    dataSetColumn: string;
    sourceColumn: string;
}


export type IColumnMapping = IColumnMapping$instance;

export interface IColumnMappingCollection$instance extends IList, ICollection, IEnumerable {
    readonly isReadOnly: boolean;
    readonly isFixedSize: boolean;
    readonly count: int;
    readonly syncRoot: unknown;
    readonly isSynchronized: boolean;
    add(sourceColumnName: string, dataSetColumnName: string): IColumnMapping;
    add(value: unknown): int;
    clear(): void;
    contains(sourceColumnName: string): boolean;
    contains(value: unknown): boolean;
    copyTo(array: ClrArray, index: int): void;
    get_Item2(index: int): unknown;
    get_Item2(index: string): unknown;
    getByDataSetColumn(dataSetColumnName: string): IColumnMapping;
    getEnumerator(): IEnumerator;
    indexOf(sourceColumnName: string): int;
    insert(index: int, value: unknown): void;
    remove(value: unknown): void;
    removeAt(sourceColumnName: string): void;
    removeAt(index: int): void;
    set_Item2(index: int, value: unknown): void;
    set_Item2(index: string, value: unknown): void;
}


export type IColumnMappingCollection = IColumnMappingCollection$instance;

export interface IDataAdapter$instance {
    missingMappingAction: MissingMappingAction;
    missingSchemaAction: MissingSchemaAction;
    readonly tableMappings: ITableMappingCollection;
    fill(dataSet: DataSet): int;
    fillSchema(dataSet: DataSet, schemaType: SchemaType): DataTable[];
    getFillParameters(): IDataParameter[];
}


export type IDataAdapter = IDataAdapter$instance;

export interface IDataParameter$instance {
    dbType: DbType;
    direction: ParameterDirection;
    readonly isNullable: boolean;
    parameterName: string;
    sourceColumn: string;
    sourceVersion: DataRowVersion;
    value: unknown;
}


export type IDataParameter = IDataParameter$instance;

export interface IDataParameterCollection$instance extends IList, ICollection, IEnumerable {
    readonly isReadOnly: boolean;
    readonly isFixedSize: boolean;
    readonly count: int;
    readonly syncRoot: unknown;
    readonly isSynchronized: boolean;
    add(value: unknown): int;
    clear(): void;
    contains(parameterName: string): boolean;
    contains(value: unknown): boolean;
    copyTo(array: ClrArray, index: int): void;
    get_Item2(index: int): unknown;
    get_Item2(parameterName: string): unknown;
    getEnumerator(): IEnumerator;
    indexOf(parameterName: string): int;
    insert(index: int, value: unknown): void;
    remove(value: unknown): void;
    removeAt(parameterName: string): void;
    removeAt(index: int): void;
    set_Item2(index: int, value: unknown): void;
    set_Item2(parameterName: string, value: unknown): void;
}


export type IDataParameterCollection = IDataParameterCollection$instance;

export interface IDataReader$instance extends IDisposable, IDataRecord {
    readonly depth: int;
    readonly isClosed: boolean;
    readonly recordsAffected: int;
    readonly fieldCount: int;
    close(): void;
    get_Item(i: int): unknown;
    get_Item(name: string): unknown;
    getBoolean(i: int): boolean;
    getByte(i: int): byte;
    getBytes(i: int, fieldOffset: long, buffer: byte[], bufferoffset: int, length: int): long;
    getChar(i: int): char;
    getChars(i: int, fieldoffset: long, buffer: char[], bufferoffset: int, length: int): long;
    getData(i: int): IDataReader;
    getDateTime(i: int): DateTime;
    getDecimal(i: int): decimal;
    getDouble(i: int): double;
    getFieldType(i: int): Type;
    getFloat(i: int): float;
    getGuid(i: int): Guid;
    getInt16(i: int): short;
    getInt32(i: int): int;
    getInt64(i: int): long;
    getName(i: int): string;
    getOrdinal(name: string): int;
    getSchemaTable(): DataTable;
    getValue(i: int): unknown;
    getValues(values: unknown[]): int;
    nextResult(): boolean;
}


export interface IDataReader$instance extends IDataRecord$instance, System_Internal.IDisposable$instance {}

export type IDataReader = IDataReader$instance;

export interface IDataRecord$instance {
    readonly fieldCount: int;
    get_Item(i: int): unknown;
    get_Item(name: string): unknown;
    getBoolean(i: int): boolean;
    getByte(i: int): byte;
    getBytes(i: int, fieldOffset: long, buffer: byte[], bufferoffset: int, length: int): long;
    getChar(i: int): char;
    getChars(i: int, fieldoffset: long, buffer: char[], bufferoffset: int, length: int): long;
    getData(i: int): IDataReader;
    getDateTime(i: int): DateTime;
    getDecimal(i: int): decimal;
    getDouble(i: int): double;
    getFieldType(i: int): Type;
    getFloat(i: int): float;
    getGuid(i: int): Guid;
    getInt16(i: int): short;
    getInt32(i: int): int;
    getInt64(i: int): long;
    getName(i: int): string;
    getOrdinal(name: string): int;
    getValue(i: int): unknown;
    getValues(values: unknown[]): int;
}


export type IDataRecord = IDataRecord$instance;

export interface IDbCommand$instance extends IDisposable {
    connection: IDbConnection;
    transaction: IDbTransaction;
    commandText: string;
    commandTimeout: int;
    commandType: CommandType;
    readonly parameters: IDataParameterCollection;
    updatedRowSource: UpdateRowSource;
    createParameter(): IDbDataParameter;
    executeNonQuery(): int;
    executeReader(): IDataReader;
    executeReader(behavior: CommandBehavior): IDataReader;
    executeScalar(): unknown;
    prepare(): void;
}


export interface IDbCommand$instance extends System_Internal.IDisposable$instance {}

export type IDbCommand = IDbCommand$instance;

export interface IDbConnection$instance extends IDisposable {
    connectionString: string;
    readonly connectionTimeout: int;
    readonly database: string;
    readonly state: ConnectionState;
    beginTransaction(): IDbTransaction;
    beginTransaction(il: IsolationLevel): IDbTransaction;
    changeDatabase(databaseName: string): void;
    close(): void;
    createCommand(): IDbCommand;
}


export interface IDbConnection$instance extends System_Internal.IDisposable$instance {}

export type IDbConnection = IDbConnection$instance;

export interface IDbDataAdapter$instance extends IDataAdapter {
    selectCommand: IDbCommand;
    insertCommand: IDbCommand;
    updateCommand: IDbCommand;
    deleteCommand: IDbCommand;
    missingMappingAction: MissingMappingAction;
    missingSchemaAction: MissingSchemaAction;
    readonly tableMappings: ITableMappingCollection;
    fill(dataSet: DataSet): int;
    fillSchema(dataSet: DataSet, schemaType: SchemaType): DataTable[];
    getFillParameters(): IDataParameter[];
}


export interface IDbDataAdapter$instance extends IDataAdapter$instance {}

export type IDbDataAdapter = IDbDataAdapter$instance;

export interface IDbDataParameter$instance extends IDataParameter {
    precision: byte;
    scale: byte;
    size: int;
    dbType: DbType;
    direction: ParameterDirection;
    readonly isNullable: boolean;
    parameterName: string;
    sourceColumn: string;
    sourceVersion: DataRowVersion;
    value: unknown;
}


export interface IDbDataParameter$instance extends IDataParameter$instance {}

export type IDbDataParameter = IDbDataParameter$instance;

export interface IDbTransaction$instance extends IDisposable {
    readonly connection: IDbConnection;
    readonly isolationLevel: IsolationLevel;
    commit(): void;
}


export interface IDbTransaction$instance extends System_Internal.IDisposable$instance {}

export type IDbTransaction = IDbTransaction$instance;

export interface ITableMapping$instance {
    readonly columnMappings: IColumnMappingCollection;
    dataSetTable: string;
    sourceTable: string;
}


export type ITableMapping = ITableMapping$instance;

export interface ITableMappingCollection$instance extends IList, ICollection, IEnumerable {
    readonly isReadOnly: boolean;
    readonly isFixedSize: boolean;
    readonly count: int;
    readonly syncRoot: unknown;
    readonly isSynchronized: boolean;
    add(sourceTableName: string, dataSetTableName: string): ITableMapping;
    add(value: unknown): int;
    clear(): void;
    contains(sourceTableName: string): boolean;
    contains(value: unknown): boolean;
    copyTo(array: ClrArray, index: int): void;
    get_Item2(index: int): unknown;
    get_Item2(index: string): unknown;
    getByDataSetTable(dataSetTableName: string): ITableMapping;
    getEnumerator(): IEnumerator;
    indexOf(sourceTableName: string): int;
    insert(index: int, value: unknown): void;
    remove(value: unknown): void;
    removeAt(sourceTableName: string): void;
    removeAt(index: int): void;
    set_Item2(index: int, value: unknown): void;
    set_Item2(index: string, value: unknown): void;
}


export type ITableMappingCollection = ITableMappingCollection$instance;

export interface Constraint$instance {
    constraintName: string;
    readonly extendedProperties: PropertyCollection;
    readonly table: DataTable;
    toString(): string;
}


export const Constraint: {
};


export type Constraint = Constraint$instance;

export interface ConstraintCollection$instance extends InternalDataCollectionBase$instance {
    add(constraint: Constraint): void;
    add(name: string, columns: DataColumn[], primaryKey: boolean): Constraint;
    add(name: string, column: DataColumn, primaryKey: boolean): Constraint;
    add(name: string, primaryKeyColumn: DataColumn, foreignKeyColumn: DataColumn): Constraint;
    add(name: string, primaryKeyColumns: DataColumn[], foreignKeyColumns: DataColumn[]): Constraint;
    addRange(constraints: Constraint[]): void;
    canRemove(constraint: Constraint): boolean;
    clear(): void;
    contains(name: string): boolean;
    copyTo(ar: ClrArray, index: int): void;
    get_Item(index: int): Constraint;
    get_Item(name: string): Constraint;
    getEnumerator(): IEnumerator;
    indexOf(constraint: Constraint): int;
    indexOf(constraintName: string): int;
    remove(constraint: Constraint): void;
    remove(name: string): void;
    removeAt(index: int): void;
}


export const ConstraintCollection: {
    new(): ConstraintCollection$instance;
};


export interface __ConstraintCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ConstraintCollection = ConstraintCollection$instance & __ConstraintCollection$views;


export interface ConstraintException$instance extends DataException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const ConstraintException: {
    new(): ConstraintException$instance;
    new(s: string): ConstraintException$instance;
    new(message: string, innerException: Exception): ConstraintException$instance;
};


export interface __ConstraintException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ConstraintException = ConstraintException$instance & __ConstraintException$views;


export interface DataColumn$instance extends MarshalByValueComponent {
    allowDBNull: boolean;
    autoIncrement: boolean;
    autoIncrementSeed: long;
    autoIncrementStep: long;
    caption: string;
    columnMapping: MappingType;
    columnName: string;
    dataType: Type;
    dateTimeMode: DataSetDateTime;
    defaultValue: unknown;
    expression: string;
    readonly extendedProperties: PropertyCollection;
    maxLength: int;
    namespace_: string;
    readonly ordinal: int;
    prefix: string;
    readOnly: boolean;
    readonly table: DataTable;
    unique: boolean;
    dispose(): void;
    getService(service: Type): unknown;
    setOrdinal(ordinal: int): void;
    toString(): string;
}


export const DataColumn: {
    new(): DataColumn$instance;
    new(columnName: string): DataColumn$instance;
    new(columnName: string, dataType: Type): DataColumn$instance;
    new(columnName: string, dataType: Type, expr: string): DataColumn$instance;
    new(columnName: string, dataType: Type, expr: string, type_: MappingType): DataColumn$instance;
};


export interface __DataColumn$views {
    As_IServiceProvider(): System_Internal.IServiceProvider$instance;
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DataColumn$instance extends System_ComponentModel_Internal.IComponent$instance {}

export type DataColumn = DataColumn$instance & __DataColumn$views;


export interface DataColumnChangeEventArgs$instance extends EventArgs {
    readonly column: DataColumn;
    proposedValue: unknown;
    readonly row: DataRow;
}


export const DataColumnChangeEventArgs: {
    new(row: DataRow, column: DataColumn, value: unknown): DataColumnChangeEventArgs$instance;
};


export type DataColumnChangeEventArgs = DataColumnChangeEventArgs$instance;

export interface DataColumnCollection$instance extends InternalDataCollectionBase$instance {
    add(column: DataColumn): void;
    add(columnName: string, type_: Type, expression: string): DataColumn;
    add(columnName: string, type_: Type): DataColumn;
    add(columnName: string): DataColumn;
    add(): DataColumn;
    addRange(columns: DataColumn[]): void;
    canRemove(column: DataColumn): boolean;
    clear(): void;
    contains(name: string): boolean;
    copyTo(ar: ClrArray, index: int): void;
    get_Item(index: int): DataColumn;
    get_Item(name: string): DataColumn;
    getEnumerator(): IEnumerator;
    indexOf(column: DataColumn): int;
    indexOf(columnName: string): int;
    remove(column: DataColumn): void;
    remove(name: string): void;
    removeAt(index: int): void;
}


export const DataColumnCollection: {
    new(): DataColumnCollection$instance;
};


export interface __DataColumnCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type DataColumnCollection = DataColumnCollection$instance & __DataColumnCollection$views;


export interface DataException$instance extends SystemException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const DataException: {
    new(): DataException$instance;
    new(s: string): DataException$instance;
    new(s: string, innerException: Exception): DataException$instance;
};


export interface __DataException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DataException = DataException$instance & __DataException$views;


export interface DataRelation$instance {
    readonly childColumns: DataColumn[];
    readonly childKeyConstraint: ForeignKeyConstraint;
    readonly childTable: DataTable;
    readonly dataSet: DataSet;
    readonly extendedProperties: PropertyCollection;
    nested: boolean;
    readonly parentColumns: DataColumn[];
    readonly parentKeyConstraint: UniqueConstraint;
    readonly parentTable: DataTable;
    relationName: string;
    toString(): string;
}


export const DataRelation: {
    new(relationName: string, parentColumn: DataColumn, childColumn: DataColumn): DataRelation$instance;
    new(relationName: string, parentColumn: DataColumn, childColumn: DataColumn, createConstraints: boolean): DataRelation$instance;
    new(relationName: string, parentColumns: DataColumn[], childColumns: DataColumn[]): DataRelation$instance;
    new(relationName: string, parentColumns: DataColumn[], childColumns: DataColumn[], createConstraints: boolean): DataRelation$instance;
    new(relationName: string, parentTableName: string, childTableName: string, parentColumnNames: string[], childColumnNames: string[], nested: boolean): DataRelation$instance;
    new(relationName: string, parentTableName: string, parentTableNamespace: string, childTableName: string, childTableNamespace: string, parentColumnNames: string[], childColumnNames: string[], nested: boolean): DataRelation$instance;
};


export type DataRelation = DataRelation$instance;

export interface DataRelationCollection$instance extends InternalDataCollectionBase$instance {
    add(relation: DataRelation): void;
    add(name: string, parentColumns: DataColumn[], childColumns: DataColumn[]): DataRelation;
    add(name: string, parentColumns: DataColumn[], childColumns: DataColumn[], createConstraints: boolean): DataRelation;
    add(parentColumns: DataColumn[], childColumns: DataColumn[]): DataRelation;
    add(name: string, parentColumn: DataColumn, childColumn: DataColumn): DataRelation;
    add(name: string, parentColumn: DataColumn, childColumn: DataColumn, createConstraints: boolean): DataRelation;
    add(parentColumn: DataColumn, childColumn: DataColumn): DataRelation;
    addRange(relations: DataRelation[]): void;
    canRemove(relation: DataRelation): boolean;
    clear(): void;
    contains(name: string): boolean;
    copyTo(ar: ClrArray, index: int): void;
    get_Item(index: int): DataRelation;
    get_Item(name: string): DataRelation;
    getEnumerator(): IEnumerator;
    indexOf(relation: DataRelation): int;
    indexOf(relationName: string): int;
    remove(relation: DataRelation): void;
    remove(name: string): void;
    removeAt(index: int): void;
}


export const DataRelationCollection: {
};


export interface __DataRelationCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type DataRelationCollection = DataRelationCollection$instance & __DataRelationCollection$views;


export interface DataRow$instance {
    readonly hasErrors: boolean;
    itemArray: unknown[];
    rowError: string;
    readonly rowState: DataRowState;
    readonly table: DataTable;
    acceptChanges(): void;
    beginEdit(): void;
    cancelEdit(): void;
    clearErrors(): void;
    delete_(): void;
    endEdit(): void;
    get_Item(columnIndex: int): unknown;
    get_Item(columnName: string): unknown;
    get_Item(column: DataColumn): unknown;
    get_Item(columnIndex: int, version: DataRowVersion): unknown;
    get_Item(columnName: string, version: DataRowVersion): unknown;
    get_Item(column: DataColumn, version: DataRowVersion): unknown;
    getChildRows(relationName: string): DataRow[];
    getChildRows(relationName: string, version: DataRowVersion): DataRow[];
    getChildRows(relation: DataRelation): DataRow[];
    getChildRows(relation: DataRelation, version: DataRowVersion): DataRow[];
    getColumnError(columnIndex: int): string;
    getColumnError(columnName: string): string;
    getColumnError(column: DataColumn): string;
    getColumnsInError(): DataColumn[];
    getParentRow(relationName: string): DataRow;
    getParentRow(relationName: string, version: DataRowVersion): DataRow;
    getParentRow(relation: DataRelation): DataRow;
    getParentRow(relation: DataRelation, version: DataRowVersion): DataRow;
    getParentRows(relationName: string): DataRow[];
    getParentRows(relationName: string, version: DataRowVersion): DataRow[];
    getParentRows(relation: DataRelation): DataRow[];
    getParentRows(relation: DataRelation, version: DataRowVersion): DataRow[];
    hasVersion(version: DataRowVersion): boolean;
    isNull(columnIndex: int): boolean;
    isNull(columnName: string): boolean;
    isNull(column: DataColumn): boolean;
    isNull(column: DataColumn, version: DataRowVersion): boolean;
    rejectChanges(): void;
    set_Item(columnIndex: int, value: unknown): void;
    set_Item(columnName: string, value: unknown): void;
    set_Item(column: DataColumn, value: unknown): void;
    setAdded(): void;
    setColumnError(columnIndex: int, error: string): void;
    setColumnError(columnName: string, error: string): void;
    setColumnError(column: DataColumn, error: string): void;
    setModified(): void;
    setParentRow(parentRow: DataRow): void;
    setParentRow(parentRow: DataRow, relation: DataRelation): void;
}


export const DataRow: {
    new(): DataRow$instance;
};


export type DataRow = DataRow$instance;

export interface DataRowBuilder$instance {
}


export const DataRowBuilder: {
    new(): DataRowBuilder$instance;
};


export type DataRowBuilder = DataRowBuilder$instance;

export interface DataRowChangeEventArgs$instance extends EventArgs {
    readonly action: DataRowAction;
    readonly row: DataRow;
}


export const DataRowChangeEventArgs: {
    new(row: DataRow, action: DataRowAction): DataRowChangeEventArgs$instance;
};


export type DataRowChangeEventArgs = DataRowChangeEventArgs$instance;

export interface DataRowCollection$instance extends InternalDataCollectionBase$instance {
    readonly count: int;
    readonly item: DataRow;
    add(row: DataRow): void;
    add(values: unknown[]): DataRow;
    clear(): void;
    contains(key: unknown): boolean;
    contains(keys: unknown[]): boolean;
    copyTo(ar: ClrArray, index: int): void;
    copyTo(array: DataRow[], index: int): void;
    find(key: unknown): DataRow;
    find(keys: unknown[]): DataRow;
    getEnumerator(): IEnumerator;
    indexOf(row: DataRow): int;
    insertAt(row: DataRow, pos: int): void;
    remove(row: DataRow): void;
    removeAt(index: int): void;
}


export const DataRowCollection: {
    new(): DataRowCollection$instance;
};


export interface __DataRowCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type DataRowCollection = DataRowCollection$instance & __DataRowCollection$views;


export interface DataRowComparer_1$instance<TRow extends DataRow> {
    equals(leftRow: TRow, rightRow: TRow): boolean;
    getHashCode(row: TRow): int;
}


export const DataRowComparer_1: {
    new<TRow extends DataRow>(): DataRowComparer_1$instance<TRow>;
    readonly default_: unknown;
};


export interface __DataRowComparer_1$views<TRow extends DataRow> {
    As_IEqualityComparer_1(): System_Collections_Generic_Internal.IEqualityComparer_1$instance<TRow>;
}

export type DataRowComparer_1<TRow extends DataRow> = DataRowComparer_1$instance<TRow> & __DataRowComparer_1$views<TRow>;


export interface DataRowView$instance extends INotifyPropertyChanged {
    readonly dataView: DataView;
    readonly isEdit: boolean;
    readonly isNew: boolean;
    readonly row: DataRow;
    readonly rowVersion: DataRowVersion;
    beginEdit(): void;
    cancelEdit(): void;
    createChildView(relation: DataRelation, followParent: boolean): DataView;
    createChildView(relation: DataRelation): DataView;
    createChildView(relationName: string, followParent: boolean): DataView;
    createChildView(relationName: string): DataView;
    delete_(): void;
    endEdit(): void;
    equals(other: unknown): boolean;
    get_Item(ndx: int): unknown;
    get_Item(property: string): unknown;
    getHashCode(): int;
    set_Item(ndx: int, value: unknown): void;
    set_Item(property: string, value: unknown): void;
}


export const DataRowView: {
    new(): DataRowView$instance;
};


export interface __DataRowView$views {
    As_IEditableObject(): System_ComponentModel_Internal.IEditableObject$instance;
    As_ICustomTypeDescriptor(): System_ComponentModel_Internal.ICustomTypeDescriptor$instance;
    As_IDataErrorInfo(): System_ComponentModel_Internal.IDataErrorInfo$instance;
}

export interface DataRowView$instance extends System_ComponentModel_Internal.ICustomTypeDescriptor$instance, System_ComponentModel_Internal.IDataErrorInfo$instance, System_ComponentModel_Internal.IEditableObject$instance, System_ComponentModel_Internal.INotifyPropertyChanged$instance {}

export type DataRowView = DataRowView$instance & __DataRowView$views;


export interface DataSet$instance extends MarshalByValueComponent {
    caseSensitive: boolean;
    dataSetName: string;
    readonly defaultViewManager: DataViewManager;
    enforceConstraints: boolean;
    readonly extendedProperties: PropertyCollection;
    readonly hasErrors: boolean;
    readonly isInitialized: boolean;
    locale: CultureInfo;
    namespace_: string;
    prefix: string;
    readonly relations: DataRelationCollection;
    remotingFormat: SerializationFormat;
    schemaSerializationMode: SchemaSerializationMode;
    site: ISite;
    readonly tables: DataTableCollection;
    acceptChanges(): void;
    beginInit(): void;
    clear(): void;
    clone(): DataSet;
    copy(): DataSet;
    createDataReader(): DataTableReader;
    createDataReader(dataTables: DataTable[]): DataTableReader;
    dispose(): void;
    endInit(): void;
    getChanges(): DataSet;
    getChanges(rowStates: DataRowState): DataSet;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getService(service: Type): unknown;
    getXml(): string;
    getXmlSchema(): string;
    hasChanges(): boolean;
    hasChanges(rowStates: DataRowState): boolean;
    inferXmlSchema(reader: XmlReader, nsArray: string[]): void;
    inferXmlSchema(stream: Stream, nsArray: string[]): void;
    inferXmlSchema(reader: TextReader, nsArray: string[]): void;
    inferXmlSchema(fileName: string, nsArray: string[]): void;
    load(reader: IDataReader, loadOption: LoadOption, errorHandler: FillErrorEventHandler, tables: DataTable[]): void;
    load(reader: IDataReader, loadOption: LoadOption, tables: DataTable[]): void;
    load(reader: IDataReader, loadOption: LoadOption, tables: string[]): void;
    merge(dataSet: DataSet): void;
    merge(dataSet: DataSet, preserveChanges: boolean): void;
    merge(dataSet: DataSet, preserveChanges: boolean, missingSchemaAction: MissingSchemaAction): void;
    merge(table: DataTable): void;
    merge(table: DataTable, preserveChanges: boolean, missingSchemaAction: MissingSchemaAction): void;
    merge(rows: DataRow[]): void;
    merge(rows: DataRow[], preserveChanges: boolean, missingSchemaAction: MissingSchemaAction): void;
    readXml(reader: XmlReader): XmlReadMode;
    readXml(stream: Stream): XmlReadMode;
    readXml(reader: TextReader): XmlReadMode;
    readXml(fileName: string): XmlReadMode;
    readXml(reader: XmlReader, mode: XmlReadMode): XmlReadMode;
    readXml(stream: Stream, mode: XmlReadMode): XmlReadMode;
    readXml(reader: TextReader, mode: XmlReadMode): XmlReadMode;
    readXml(fileName: string, mode: XmlReadMode): XmlReadMode;
    readXmlSchema(reader: XmlReader): void;
    readXmlSchema(stream: Stream): void;
    readXmlSchema(reader: TextReader): void;
    readXmlSchema(fileName: string): void;
    rejectChanges(): void;
    reset(): void;
    writeXml(stream: Stream): void;
    writeXml(writer: TextWriter): void;
    writeXml(writer: XmlWriter): void;
    writeXml(fileName: string): void;
    writeXml(stream: Stream, mode: XmlWriteMode): void;
    writeXml(writer: TextWriter, mode: XmlWriteMode): void;
    writeXml(writer: XmlWriter, mode: XmlWriteMode): void;
    writeXml(fileName: string, mode: XmlWriteMode): void;
    writeXmlSchema(stream: Stream): void;
    writeXmlSchema(stream: Stream, multipleTargetConverter: Converter_2<Type, CLROf<string>>): void;
    writeXmlSchema(fileName: string): void;
    writeXmlSchema(fileName: string, multipleTargetConverter: Converter_2<Type, CLROf<string>>): void;
    writeXmlSchema(writer: TextWriter): void;
    writeXmlSchema(writer: TextWriter, multipleTargetConverter: Converter_2<Type, CLROf<string>>): void;
    writeXmlSchema(writer: XmlWriter): void;
    writeXmlSchema(writer: XmlWriter, multipleTargetConverter: Converter_2<Type, CLROf<string>>): void;
}


export const DataSet: {
    new(): DataSet$instance;
    new(dataSetName: string): DataSet$instance;
    getDataSetSchema(schemaSet: XmlSchemaSet): XmlSchemaComplexType;
};


export interface __DataSet$views {
    As_IServiceProvider(): System_Internal.IServiceProvider$instance;
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_ISupportInitialize(): System_ComponentModel_Internal.ISupportInitialize$instance;
    As_IListSource(): System_ComponentModel_Internal.IListSource$instance;
    As_ISupportInitializeNotification(): System_ComponentModel_Internal.ISupportInitializeNotification$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;
}

export interface DataSet$instance extends System_ComponentModel_Internal.IComponent$instance, System_ComponentModel_Internal.IListSource$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type DataSet = DataSet$instance & __DataSet$views;


export interface DataSysDescriptionAttribute$instance extends DescriptionAttribute {
    readonly description: string;
}


export const DataSysDescriptionAttribute: {
    new(description: string): DataSysDescriptionAttribute$instance;
};


export type DataSysDescriptionAttribute = DataSysDescriptionAttribute$instance;

export interface DataTable$instance extends MarshalByValueComponent {
    caseSensitive: boolean;
    readonly childRelations: DataRelationCollection;
    readonly columns: DataColumnCollection;
    readonly constraints: ConstraintCollection;
    readonly dataSet: DataSet;
    readonly defaultView: DataView;
    displayExpression: string;
    readonly extendedProperties: PropertyCollection;
    readonly hasErrors: boolean;
    readonly isInitialized: boolean;
    locale: CultureInfo;
    minimumCapacity: int;
    namespace_: string;
    readonly parentRelations: DataRelationCollection;
    prefix: string;
    primaryKey: DataColumn[];
    remotingFormat: SerializationFormat;
    readonly rows: DataRowCollection;
    site: ISite;
    tableName: string;
    acceptChanges(): void;
    beginInit(): void;
    beginLoadData(): void;
    clear(): void;
    clone(): DataTable;
    compute(expression: string, filter: string): unknown;
    copy(): DataTable;
    createDataReader(): DataTableReader;
    dispose(): void;
    endInit(): void;
    endLoadData(): void;
    getChanges(): DataTable;
    getChanges(rowStates: DataRowState): DataTable;
    getErrors(): DataRow[];
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getService(service: Type): unknown;
    importRow(row: DataRow): void;
    load(reader: IDataReader): void;
    load(reader: IDataReader, loadOption: LoadOption): void;
    load(reader: IDataReader, loadOption: LoadOption, errorHandler: FillErrorEventHandler): void;
    loadDataRow(values: unknown[], fAcceptChanges: boolean): DataRow;
    loadDataRow(values: unknown[], loadOption: LoadOption): DataRow;
    merge(table: DataTable): void;
    merge(table: DataTable, preserveChanges: boolean): void;
    merge(table: DataTable, preserveChanges: boolean, missingSchemaAction: MissingSchemaAction): void;
    newRow(): DataRow;
    readXml(stream: Stream): XmlReadMode;
    readXml(reader: TextReader): XmlReadMode;
    readXml(fileName: string): XmlReadMode;
    readXml(reader: XmlReader): XmlReadMode;
    readXmlSchema(stream: Stream): void;
    readXmlSchema(reader: TextReader): void;
    readXmlSchema(fileName: string): void;
    readXmlSchema(reader: XmlReader): void;
    rejectChanges(): void;
    reset(): void;
    select(): DataRow[];
    select(filterExpression: string): DataRow[];
    select(filterExpression: string, sort: string): DataRow[];
    select(filterExpression: string, sort: string, recordStates: DataViewRowState): DataRow[];
    toString(): string;
    writeXml(stream: Stream): void;
    writeXml(stream: Stream, writeHierarchy: boolean): void;
    writeXml(writer: TextWriter): void;
    writeXml(writer: TextWriter, writeHierarchy: boolean): void;
    writeXml(writer: XmlWriter): void;
    writeXml(writer: XmlWriter, writeHierarchy: boolean): void;
    writeXml(fileName: string): void;
    writeXml(fileName: string, writeHierarchy: boolean): void;
    writeXml(stream: Stream, mode: XmlWriteMode): void;
    writeXml(stream: Stream, mode: XmlWriteMode, writeHierarchy: boolean): void;
    writeXml(writer: TextWriter, mode: XmlWriteMode): void;
    writeXml(writer: TextWriter, mode: XmlWriteMode, writeHierarchy: boolean): void;
    writeXml(writer: XmlWriter, mode: XmlWriteMode): void;
    writeXml(writer: XmlWriter, mode: XmlWriteMode, writeHierarchy: boolean): void;
    writeXml(fileName: string, mode: XmlWriteMode): void;
    writeXml(fileName: string, mode: XmlWriteMode, writeHierarchy: boolean): void;
    writeXmlSchema(stream: Stream): void;
    writeXmlSchema(stream: Stream, writeHierarchy: boolean): void;
    writeXmlSchema(writer: TextWriter): void;
    writeXmlSchema(writer: TextWriter, writeHierarchy: boolean): void;
    writeXmlSchema(writer: XmlWriter): void;
    writeXmlSchema(writer: XmlWriter, writeHierarchy: boolean): void;
    writeXmlSchema(fileName: string): void;
    writeXmlSchema(fileName: string, writeHierarchy: boolean): void;
}


export const DataTable: {
    new(): DataTable$instance;
    new(tableName: string): DataTable$instance;
    new(tableName: string, tableNamespace: string): DataTable$instance;
    getDataTableSchema(schemaSet: XmlSchemaSet): XmlSchemaComplexType;
};


export interface __DataTable$views {
    As_IServiceProvider(): System_Internal.IServiceProvider$instance;
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_ISupportInitialize(): System_ComponentModel_Internal.ISupportInitialize$instance;
    As_IListSource(): System_ComponentModel_Internal.IListSource$instance;
    As_ISupportInitializeNotification(): System_ComponentModel_Internal.ISupportInitializeNotification$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;
}

export interface DataTable$instance extends System_ComponentModel_Internal.IComponent$instance, System_ComponentModel_Internal.IListSource$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type DataTable = DataTable$instance & __DataTable$views;


export interface DataTableClearEventArgs$instance extends EventArgs {
    readonly table: DataTable;
    readonly tableName: string;
    readonly tableNamespace: string;
}


export const DataTableClearEventArgs: {
    new(dataTable: DataTable): DataTableClearEventArgs$instance;
};


export type DataTableClearEventArgs = DataTableClearEventArgs$instance;

export interface DataTableCollection$instance extends InternalDataCollectionBase$instance {
    add(table: DataTable): void;
    add(name: string): DataTable;
    add(name: string, tableNamespace: string): DataTable;
    add(): DataTable;
    addRange(tables: DataTable[]): void;
    canRemove(table: DataTable): boolean;
    clear(): void;
    contains(name: string): boolean;
    contains(name: string, tableNamespace: string): boolean;
    copyTo(ar: ClrArray, index: int): void;
    get_Item(index: int): DataTable;
    get_Item(name: string): DataTable;
    get_Item(name: string, tableNamespace: string): DataTable;
    getEnumerator(): IEnumerator;
    indexOf(table: DataTable): int;
    indexOf(tableName: string): int;
    indexOf(tableName: string, tableNamespace: string): int;
    remove(table: DataTable): void;
    remove(name: string): void;
    remove(name: string, tableNamespace: string): void;
    removeAt(index: int): void;
}


export const DataTableCollection: {
    new(): DataTableCollection$instance;
};


export interface __DataTableCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type DataTableCollection = DataTableCollection$instance & __DataTableCollection$views;


export interface DataTableNewRowEventArgs$instance extends EventArgs {
    readonly row: DataRow;
}


export const DataTableNewRowEventArgs: {
    new(dataRow: DataRow): DataTableNewRowEventArgs$instance;
};


export type DataTableNewRowEventArgs = DataTableNewRowEventArgs$instance;

export interface DataTableReader$instance extends DbDataReader {
    readonly depth: int;
    readonly fieldCount: int;
    readonly hasRows: boolean;
    readonly isClosed: boolean;
    readonly recordsAffected: int;
    close(): void;
    dispose(): void;
    disposeAsync(): ValueTask;
    get_Item(ordinal: int): unknown;
    get_Item(name: string): unknown;
    getBoolean(ordinal: int): boolean;
    getByte(ordinal: int): byte;
    getBytes(ordinal: int, dataIndex: long, buffer: byte[], bufferIndex: int, length: int): long;
    getChar(ordinal: int): char;
    getChars(ordinal: int, dataIndex: long, buffer: char[], bufferIndex: int, length: int): long;
    getData(ordinal: int): DbDataReader;
    getData(i: int): IDataReader;
    getDataTypeName(ordinal: int): string;
    getDateTime(ordinal: int): DateTime;
    getDecimal(ordinal: int): decimal;
    getDouble(ordinal: int): double;
    getEnumerator(): IEnumerator;
    getFieldType(ordinal: int): Type;
    getFloat(ordinal: int): float;
    getGuid(ordinal: int): Guid;
    getInt16(ordinal: int): short;
    getInt32(ordinal: int): int;
    getInt64(ordinal: int): long;
    getName(ordinal: int): string;
    getOrdinal(name: string): int;
    getProviderSpecificFieldType(ordinal: int): Type;
    getProviderSpecificValue(ordinal: int): unknown;
    getProviderSpecificValues(values: unknown[]): int;
    getSchemaTable(): DataTable;
    getString(ordinal: int): string;
    getValue(ordinal: int): unknown;
    getValues(values: unknown[]): int;
    isDBNull(ordinal: int): boolean;
    nextResult(): boolean;
    read(): boolean;
}


export const DataTableReader: {
    new(dataTable: DataTable): DataTableReader$instance;
    new(dataTables: DataTable[]): DataTableReader$instance;
};


export interface __DataTableReader$views {
    As_IDataReader(): IDataReader$instance;
    As_IDataRecord(): IDataRecord$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type DataTableReader = DataTableReader$instance & __DataTableReader$views;


export interface DataView$instance extends MarshalByValueComponent {
    allowDelete: boolean;
    allowEdit: boolean;
    allowNew: boolean;
    applyDefaultSort: boolean;
    readonly count: int;
    readonly dataViewManager: DataViewManager;
    readonly isInitialized: boolean;
    readonly item: DataRowView;
    rowFilter: string;
    rowStateFilter: DataViewRowState;
    sort: string;
    table: DataTable;
    addNew(): DataRowView;
    beginInit(): void;
    copyTo(array: ClrArray, index: int): void;
    delete_(index: int): void;
    dispose(): void;
    endInit(): void;
    equals(view: DataView): boolean;
    equals(obj: unknown): boolean;
    find(key: unknown): int;
    find(key: unknown[]): int;
    findRows(key: unknown): DataRowView[];
    findRows(key: unknown[]): DataRowView[];
    getEnumerator(): IEnumerator;
    getService(service: Type): unknown;
    toTable(): DataTable;
    toTable(tableName: string): DataTable;
    toTable(distinct: boolean, columnNames: string[]): DataTable;
    toTable(tableName: string, distinct: boolean, columnNames: string[]): DataTable;
}


export const DataView: {
    new(): DataView$instance;
    new(table: DataTable): DataView$instance;
    new(table: DataTable, RowFilter: string, Sort: string, RowState: DataViewRowState): DataView$instance;
};


export interface __DataView$views {
    As_IServiceProvider(): System_Internal.IServiceProvider$instance;
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_ISupportInitialize(): System_ComponentModel_Internal.ISupportInitialize$instance;
    As_IBindingList(): System_ComponentModel_Internal.IBindingList$instance;
    As_IBindingListView(): System_ComponentModel_Internal.IBindingListView$instance;
    As_ISupportInitializeNotification(): System_ComponentModel_Internal.ISupportInitializeNotification$instance;
    As_ITypedList(): System_ComponentModel_Internal.ITypedList$instance;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DataView$instance extends System_ComponentModel_Internal.IComponent$instance, System_ComponentModel_Internal.ITypedList$instance {}

export type DataView = DataView$instance & __DataView$views;


export interface DataViewManager$instance extends MarshalByValueComponent {
    dataSet: DataSet;
    dataViewSettingCollectionString: string;
    readonly dataViewSettings: DataViewSettingCollection;
    createDataView(table: DataTable): DataView;
    dispose(): void;
    getService(service: Type): unknown;
}


export const DataViewManager: {
    new(): DataViewManager$instance;
    new(dataSet: DataSet): DataViewManager$instance;
};


export interface __DataViewManager$views {
    As_IServiceProvider(): System_Internal.IServiceProvider$instance;
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IBindingList(): System_ComponentModel_Internal.IBindingList$instance;
    As_ITypedList(): System_ComponentModel_Internal.ITypedList$instance;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DataViewManager$instance extends System_ComponentModel_Internal.IBindingList$instance, System_ComponentModel_Internal.IComponent$instance, System_ComponentModel_Internal.ITypedList$instance {}

export type DataViewManager = DataViewManager$instance & __DataViewManager$views;


export interface DataViewSetting$instance {
    applyDefaultSort: boolean;
    readonly dataViewManager: DataViewManager;
    rowFilter: string;
    rowStateFilter: DataViewRowState;
    sort: string;
    readonly table: DataTable;
}


export const DataViewSetting: {
    new(): DataViewSetting$instance;
};


export type DataViewSetting = DataViewSetting$instance;

export interface DataViewSettingCollection$instance {
    readonly count: int;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    readonly syncRoot: unknown;
    copyTo(ar: ClrArray, index: int): void;
    copyTo(ar: DataViewSetting[], index: int): void;
    get_Item(table: DataTable): DataViewSetting;
    get_Item(tableName: string): DataViewSetting;
    get_Item(index: int): DataViewSetting;
    getEnumerator(): IEnumerator;
    set_Item(table: DataTable, value: DataViewSetting): void;
    set_Item(index: int, value: DataViewSetting): void;
}


export const DataViewSettingCollection: {
    new(): DataViewSettingCollection$instance;
};


export interface __DataViewSettingCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type DataViewSettingCollection = DataViewSettingCollection$instance & __DataViewSettingCollection$views;


export interface DBConcurrencyException$instance extends SystemException {
    row: DataRow;
    readonly rowCount: int;
    copyToRows(array: DataRow[]): void;
    copyToRows(array: DataRow[], arrayIndex: int): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const DBConcurrencyException: {
    new(): DBConcurrencyException$instance;
    new(message: string): DBConcurrencyException$instance;
    new(message: string, inner: Exception): DBConcurrencyException$instance;
    new(message: string, inner: Exception, dataRows: DataRow[]): DBConcurrencyException$instance;
};


export interface __DBConcurrencyException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DBConcurrencyException = DBConcurrencyException$instance & __DBConcurrencyException$views;


export interface DeletedRowInaccessibleException$instance extends DataException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const DeletedRowInaccessibleException: {
    new(): DeletedRowInaccessibleException$instance;
    new(s: string): DeletedRowInaccessibleException$instance;
    new(message: string, innerException: Exception): DeletedRowInaccessibleException$instance;
};


export interface __DeletedRowInaccessibleException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DeletedRowInaccessibleException = DeletedRowInaccessibleException$instance & __DeletedRowInaccessibleException$views;


export interface DuplicateNameException$instance extends DataException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const DuplicateNameException: {
    new(): DuplicateNameException$instance;
    new(s: string): DuplicateNameException$instance;
    new(message: string, innerException: Exception): DuplicateNameException$instance;
};


export interface __DuplicateNameException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DuplicateNameException = DuplicateNameException$instance & __DuplicateNameException$views;


export interface EnumerableRowCollection$instance {
}


export const EnumerableRowCollection: {
};


export interface __EnumerableRowCollection$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export interface EnumerableRowCollection$instance extends System_Collections_Internal.IEnumerable$instance {}

export type EnumerableRowCollection = EnumerableRowCollection$instance & __EnumerableRowCollection$views;


export interface EnumerableRowCollection_1$instance<TRow> extends EnumerableRowCollection$instance {
    getEnumerator(): IEnumerator;
}


export const EnumerableRowCollection_1: {
    new<TRow>(): EnumerableRowCollection_1$instance<TRow>;
};


export interface __EnumerableRowCollection_1$views<TRow> {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<TRow>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type EnumerableRowCollection_1<TRow> = EnumerableRowCollection_1$instance<TRow> & __EnumerableRowCollection_1$views<TRow>;


export interface EvaluateException$instance extends InvalidExpressionException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const EvaluateException: {
    new(): EvaluateException$instance;
    new(s: string): EvaluateException$instance;
    new(message: string, innerException: Exception): EvaluateException$instance;
};


export interface __EvaluateException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type EvaluateException = EvaluateException$instance & __EvaluateException$views;


export interface FillErrorEventArgs$instance extends EventArgs {
    continue_: boolean;
    readonly dataTable: DataTable;
    errors: Exception;
    readonly values: unknown[];
}


export const FillErrorEventArgs: {
    new(dataTable: DataTable, values: unknown[]): FillErrorEventArgs$instance;
};


export type FillErrorEventArgs = FillErrorEventArgs$instance;

export interface ForeignKeyConstraint$instance extends Constraint {
    acceptRejectRule: AcceptRejectRule;
    readonly columns: DataColumn[];
    deleteRule: Rule;
    readonly relatedColumns: DataColumn[];
    readonly relatedTable: DataTable;
    readonly table: DataTable;
    updateRule: Rule;
    equals(key: unknown): boolean;
    getHashCode(): int;
}


export const ForeignKeyConstraint: {
    new(parentColumn: DataColumn, childColumn: DataColumn): ForeignKeyConstraint$instance;
    new(constraintName: string, parentColumn: DataColumn, childColumn: DataColumn): ForeignKeyConstraint$instance;
    new(parentColumns: DataColumn[], childColumns: DataColumn[]): ForeignKeyConstraint$instance;
    new(constraintName: string, parentColumns: DataColumn[], childColumns: DataColumn[]): ForeignKeyConstraint$instance;
    new(constraintName: string, parentTableName: string, parentColumnNames: string[], childColumnNames: string[], acceptRejectRule: AcceptRejectRule, deleteRule: Rule, updateRule: Rule): ForeignKeyConstraint$instance;
    new(constraintName: string, parentTableName: string, parentTableNamespace: string, parentColumnNames: string[], childColumnNames: string[], acceptRejectRule: AcceptRejectRule, deleteRule: Rule, updateRule: Rule): ForeignKeyConstraint$instance;
};


export type ForeignKeyConstraint = ForeignKeyConstraint$instance;

export interface InRowChangingEventException$instance extends DataException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const InRowChangingEventException: {
    new(): InRowChangingEventException$instance;
    new(s: string): InRowChangingEventException$instance;
    new(message: string, innerException: Exception): InRowChangingEventException$instance;
};


export interface __InRowChangingEventException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InRowChangingEventException = InRowChangingEventException$instance & __InRowChangingEventException$views;


export interface InternalDataCollectionBase$instance {
    readonly count: int;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    readonly syncRoot: unknown;
    copyTo(ar: ClrArray, index: int): void;
    getEnumerator(): IEnumerator;
}


export const InternalDataCollectionBase: {
    new(): InternalDataCollectionBase$instance;
};


export interface __InternalDataCollectionBase$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type InternalDataCollectionBase = InternalDataCollectionBase$instance & __InternalDataCollectionBase$views;


export interface InvalidConstraintException$instance extends DataException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const InvalidConstraintException: {
    new(): InvalidConstraintException$instance;
    new(s: string): InvalidConstraintException$instance;
    new(message: string, innerException: Exception): InvalidConstraintException$instance;
};


export interface __InvalidConstraintException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidConstraintException = InvalidConstraintException$instance & __InvalidConstraintException$views;


export interface InvalidExpressionException$instance extends DataException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const InvalidExpressionException: {
    new(): InvalidExpressionException$instance;
    new(s: string): InvalidExpressionException$instance;
    new(message: string, innerException: Exception): InvalidExpressionException$instance;
};


export interface __InvalidExpressionException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidExpressionException = InvalidExpressionException$instance & __InvalidExpressionException$views;


export interface MergeFailedEventArgs$instance extends EventArgs {
    readonly conflict: string;
    readonly table: DataTable;
}


export const MergeFailedEventArgs: {
    new(table: DataTable, conflict: string): MergeFailedEventArgs$instance;
};


export type MergeFailedEventArgs = MergeFailedEventArgs$instance;

export interface MissingPrimaryKeyException$instance extends DataException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const MissingPrimaryKeyException: {
    new(): MissingPrimaryKeyException$instance;
    new(s: string): MissingPrimaryKeyException$instance;
    new(message: string, innerException: Exception): MissingPrimaryKeyException$instance;
};


export interface __MissingPrimaryKeyException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MissingPrimaryKeyException = MissingPrimaryKeyException$instance & __MissingPrimaryKeyException$views;


export interface NoNullAllowedException$instance extends DataException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const NoNullAllowedException: {
    new(): NoNullAllowedException$instance;
    new(s: string): NoNullAllowedException$instance;
    new(message: string, innerException: Exception): NoNullAllowedException$instance;
};


export interface __NoNullAllowedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type NoNullAllowedException = NoNullAllowedException$instance & __NoNullAllowedException$views;


export interface OrderedEnumerableRowCollection_1$instance<TRow> extends EnumerableRowCollection_1$instance<TRow> {
    getEnumerator(): IEnumerator_1<TRow>;
    getEnumerator(): IEnumerator;
}


export const OrderedEnumerableRowCollection_1: {
    new<TRow>(): OrderedEnumerableRowCollection_1$instance<TRow>;
};


export interface __OrderedEnumerableRowCollection_1$views<TRow> {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<TRow>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type OrderedEnumerableRowCollection_1<TRow> = OrderedEnumerableRowCollection_1$instance<TRow> & __OrderedEnumerableRowCollection_1$views<TRow>;


export interface PropertyCollection$instance extends Hashtable {
    add(key: unknown, value: unknown): void;
    clear(): void;
    clone(): unknown;
    contains(key: unknown): boolean;
    copyTo(array: ClrArray, arrayIndex: int): void;
    getEnumerator(): IDictionaryEnumerator;
    getEnumerator(): IEnumerator;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    onDeserialization(sender: unknown): void;
    remove(key: unknown): void;
}


export const PropertyCollection: {
    new(): PropertyCollection$instance;
};


export interface __PropertyCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type PropertyCollection = PropertyCollection$instance & __PropertyCollection$views;


export interface ReadOnlyException$instance extends DataException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const ReadOnlyException: {
    new(): ReadOnlyException$instance;
    new(s: string): ReadOnlyException$instance;
    new(message: string, innerException: Exception): ReadOnlyException$instance;
};


export interface __ReadOnlyException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ReadOnlyException = ReadOnlyException$instance & __ReadOnlyException$views;


export interface RowNotInTableException$instance extends DataException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const RowNotInTableException: {
    new(): RowNotInTableException$instance;
    new(s: string): RowNotInTableException$instance;
    new(message: string, innerException: Exception): RowNotInTableException$instance;
};


export interface __RowNotInTableException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type RowNotInTableException = RowNotInTableException$instance & __RowNotInTableException$views;


export interface StateChangeEventArgs$instance extends EventArgs {
    readonly currentState: ConnectionState;
    readonly originalState: ConnectionState;
}


export const StateChangeEventArgs: {
    new(originalState: ConnectionState, currentState: ConnectionState): StateChangeEventArgs$instance;
};


export type StateChangeEventArgs = StateChangeEventArgs$instance;

export interface StatementCompletedEventArgs$instance extends EventArgs {
    readonly recordCount: int;
}


export const StatementCompletedEventArgs: {
    new(recordCount: int): StatementCompletedEventArgs$instance;
};


export type StatementCompletedEventArgs = StatementCompletedEventArgs$instance;

export interface StrongTypingException$instance extends DataException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const StrongTypingException: {
    new(): StrongTypingException$instance;
    new(message: string): StrongTypingException$instance;
    new(s: string, innerException: Exception): StrongTypingException$instance;
};


export interface __StrongTypingException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type StrongTypingException = StrongTypingException$instance & __StrongTypingException$views;


export interface SyntaxErrorException$instance extends InvalidExpressionException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SyntaxErrorException: {
    new(): SyntaxErrorException$instance;
    new(s: string): SyntaxErrorException$instance;
    new(message: string, innerException: Exception): SyntaxErrorException$instance;
};


export interface __SyntaxErrorException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SyntaxErrorException = SyntaxErrorException$instance & __SyntaxErrorException$views;


export interface TypedTableBase_1$instance<T extends DataRow> extends DataTable$instance {
    beginInit(): void;
    cast<TResult>(): EnumerableRowCollection_1<TResult>;
    dispose(): void;
    getEnumerator(): IEnumerator_1<T>;
    getList(): IList;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getSchema(): XmlSchema;
    getService(serviceType: Type): unknown;
    readXml(stream: Stream): XmlReadMode;
    readXml(reader: TextReader): XmlReadMode;
    readXml(fileName: string): XmlReadMode;
    readXml(reader: XmlReader): XmlReadMode;
    readXml(reader: XmlReader): void;
    writeXml(stream: Stream): void;
    writeXml(stream: Stream, writeHierarchy: boolean): void;
    writeXml(writer: TextWriter): void;
    writeXml(writer: TextWriter, writeHierarchy: boolean): void;
    writeXml(writer: XmlWriter): void;
    writeXml(writer: XmlWriter, writeHierarchy: boolean): void;
    writeXml(fileName: string): void;
    writeXml(fileName: string, writeHierarchy: boolean): void;
    writeXml(stream: Stream, mode: XmlWriteMode): void;
    writeXml(stream: Stream, mode: XmlWriteMode, writeHierarchy: boolean): void;
    writeXml(writer: TextWriter, mode: XmlWriteMode): void;
    writeXml(writer: TextWriter, mode: XmlWriteMode, writeHierarchy: boolean): void;
    writeXml(writer: XmlWriter, mode: XmlWriteMode): void;
    writeXml(writer: XmlWriter, mode: XmlWriteMode, writeHierarchy: boolean): void;
    writeXml(fileName: string, mode: XmlWriteMode): void;
    writeXml(fileName: string, mode: XmlWriteMode, writeHierarchy: boolean): void;
}


export const TypedTableBase_1: {
};


export interface __TypedTableBase_1$views<T extends DataRow> {
    As_IServiceProvider(): System_Internal.IServiceProvider$instance;
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_ISupportInitialize(): System_ComponentModel_Internal.ISupportInitialize$instance;
    As_IListSource(): System_ComponentModel_Internal.IListSource$instance;
    As_ISupportInitializeNotification(): System_ComponentModel_Internal.ISupportInitializeNotification$instance;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;
}

export interface TypedTableBase_1$instance<T extends DataRow> extends System_ComponentModel_Internal.IListSource$instance, System_ComponentModel_Internal.ISupportInitializeNotification$instance {}

export type TypedTableBase_1<T extends DataRow> = TypedTableBase_1$instance<T> & __TypedTableBase_1$views<T>;


export interface UniqueConstraint$instance extends Constraint {
    readonly columns: DataColumn[];
    readonly isPrimaryKey: boolean;
    readonly table: DataTable;
    equals(key2: unknown): boolean;
    getHashCode(): int;
}


export const UniqueConstraint: {
    new(name: string, column: DataColumn): UniqueConstraint$instance;
    new(column: DataColumn): UniqueConstraint$instance;
    new(name: string, columns: DataColumn[]): UniqueConstraint$instance;
    new(columns: DataColumn[]): UniqueConstraint$instance;
    new(name: string, columnNames: string[], isPrimaryKey: boolean): UniqueConstraint$instance;
    new(name: string, column: DataColumn, isPrimaryKey: boolean): UniqueConstraint$instance;
    new(column: DataColumn, isPrimaryKey: boolean): UniqueConstraint$instance;
    new(name: string, columns: DataColumn[], isPrimaryKey: boolean): UniqueConstraint$instance;
    new(columns: DataColumn[], isPrimaryKey: boolean): UniqueConstraint$instance;
};


export type UniqueConstraint = UniqueConstraint$instance;

export interface VersionNotFoundException$instance extends DataException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const VersionNotFoundException: {
    new(): VersionNotFoundException$instance;
    new(s: string): VersionNotFoundException$instance;
    new(message: string, innerException: Exception): VersionNotFoundException$instance;
};


export interface __VersionNotFoundException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type VersionNotFoundException = VersionNotFoundException$instance & __VersionNotFoundException$views;


export abstract class DataReaderExtensions$instance {
    static getBoolean(reader: DbDataReader, name: string): boolean;
    static getByte(reader: DbDataReader, name: string): byte;
    static getBytes(reader: DbDataReader, name: string, dataOffset: long, buffer: byte[], bufferOffset: int, length: int): long;
    static getChar(reader: DbDataReader, name: string): char;
    static getChars(reader: DbDataReader, name: string, dataOffset: long, buffer: char[], bufferOffset: int, length: int): long;
    static getData(reader: DbDataReader, name: string): DbDataReader;
    static getDataTypeName(reader: DbDataReader, name: string): string;
    static getDateTime(reader: DbDataReader, name: string): DateTime;
    static getDecimal(reader: DbDataReader, name: string): decimal;
    static getDouble(reader: DbDataReader, name: string): double;
    static getFieldType(reader: DbDataReader, name: string): Type;
    static getFieldValue<T>(reader: DbDataReader, name: string): T;
    static getFieldValueAsync<T>(reader: DbDataReader, name: string, cancellationToken?: CancellationToken): Task_1<T>;
    static getFloat(reader: DbDataReader, name: string): float;
    static getGuid(reader: DbDataReader, name: string): Guid;
    static getInt16(reader: DbDataReader, name: string): short;
    static getInt32(reader: DbDataReader, name: string): int;
    static getInt64(reader: DbDataReader, name: string): long;
    static getProviderSpecificFieldType(reader: DbDataReader, name: string): Type;
    static getProviderSpecificValue(reader: DbDataReader, name: string): unknown;
    static getStream(reader: DbDataReader, name: string): Stream;
    static getString(reader: DbDataReader, name: string): string;
    static getTextReader(reader: DbDataReader, name: string): TextReader;
    static getValue(reader: DbDataReader, name: string): unknown;
    static isDBNull(reader: DbDataReader, name: string): boolean;
    static isDBNullAsync(reader: DbDataReader, name: string, cancellationToken?: CancellationToken): Task_1<CLROf<boolean>>;
}


export type DataReaderExtensions = DataReaderExtensions$instance;

export abstract class DataRowComparer$instance {
    static readonly default_: DataRowComparer_1<DataRow>;
}


export type DataRowComparer = DataRowComparer$instance;

export abstract class DataRowExtensions$instance {
    static field<T>(row: DataRow, column: DataColumn, version: DataRowVersion): T;
    static field<T>(row: DataRow, column: DataColumn): T;
    static field<T>(row: DataRow, columnIndex: int, version: DataRowVersion): T;
    static field<T>(row: DataRow, columnIndex: int): T;
    static field<T>(row: DataRow, columnName: string, version: DataRowVersion): T;
    static field<T>(row: DataRow, columnName: string): T;
    static setField<T>(row: DataRow, column: DataColumn, value: T): void;
    static setField<T>(row: DataRow, columnIndex: int, value: T): void;
    static setField<T>(row: DataRow, columnName: string, value: T): void;
}


export type DataRowExtensions = DataRowExtensions$instance;

export abstract class DataTableExtensions$instance {
    static asDataView<T extends DataRow>(source: EnumerableRowCollection_1<T>): DataView;
    static asDataView(table: DataTable): DataView;
    static asEnumerable(source: DataTable): EnumerableRowCollection_1<DataRow>;
    static copyToDataTable<T extends DataRow>(source: IEnumerable_1<T>, table: DataTable, options: LoadOption, errorHandler: FillErrorEventHandler): void;
    static copyToDataTable<T extends DataRow>(source: IEnumerable_1<T>, table: DataTable, options: LoadOption): void;
    static copyToDataTable<T extends DataRow>(source: IEnumerable_1<T>): DataTable;
}


export type DataTableExtensions = DataTableExtensions$instance;

export abstract class EnumerableRowCollectionExtensions$instance {
    static cast<TResult>(source: EnumerableRowCollection): EnumerableRowCollection_1<TResult>;
    static orderBy<TRow, TKey>(source: EnumerableRowCollection_1<TRow>, keySelector: Func_2<TRow, TKey>, comparer: IComparer_1<TKey>): OrderedEnumerableRowCollection_1<TRow>;
    static orderBy<TRow, TKey>(source: EnumerableRowCollection_1<TRow>, keySelector: Func_2<TRow, TKey>): OrderedEnumerableRowCollection_1<TRow>;
    static orderByDescending<TRow, TKey>(source: EnumerableRowCollection_1<TRow>, keySelector: Func_2<TRow, TKey>, comparer: IComparer_1<TKey>): OrderedEnumerableRowCollection_1<TRow>;
    static orderByDescending<TRow, TKey>(source: EnumerableRowCollection_1<TRow>, keySelector: Func_2<TRow, TKey>): OrderedEnumerableRowCollection_1<TRow>;
    static select<TRow, S>(source: EnumerableRowCollection_1<TRow>, selector: Func_2<TRow, S>): EnumerableRowCollection_1<S>;
    static thenBy<TRow, TKey>(source: OrderedEnumerableRowCollection_1<TRow>, keySelector: Func_2<TRow, TKey>, comparer: IComparer_1<TKey>): OrderedEnumerableRowCollection_1<TRow>;
    static thenBy<TRow, TKey>(source: OrderedEnumerableRowCollection_1<TRow>, keySelector: Func_2<TRow, TKey>): OrderedEnumerableRowCollection_1<TRow>;
    static thenByDescending<TRow, TKey>(source: OrderedEnumerableRowCollection_1<TRow>, keySelector: Func_2<TRow, TKey>, comparer: IComparer_1<TKey>): OrderedEnumerableRowCollection_1<TRow>;
    static thenByDescending<TRow, TKey>(source: OrderedEnumerableRowCollection_1<TRow>, keySelector: Func_2<TRow, TKey>): OrderedEnumerableRowCollection_1<TRow>;
    static where<TRow>(source: EnumerableRowCollection_1<TRow>, predicate: Func_2<TRow, CLROf<boolean>>): EnumerableRowCollection_1<TRow>;
}


export type EnumerableRowCollectionExtensions = EnumerableRowCollectionExtensions$instance;

export abstract class TypedTableBaseExtensions$instance {
    static asEnumerable<TRow extends DataRow>(source: TypedTableBase_1<TRow>): EnumerableRowCollection_1<TRow>;
    static elementAtOrDefault<TRow extends DataRow>(source: TypedTableBase_1<TRow>, index: int): TRow;
    static orderBy<TRow extends DataRow, TKey>(source: TypedTableBase_1<TRow>, keySelector: Func_2<TRow, TKey>, comparer: IComparer_1<TKey>): OrderedEnumerableRowCollection_1<TRow>;
    static orderBy<TRow extends DataRow, TKey>(source: TypedTableBase_1<TRow>, keySelector: Func_2<TRow, TKey>): OrderedEnumerableRowCollection_1<TRow>;
    static orderByDescending<TRow extends DataRow, TKey>(source: TypedTableBase_1<TRow>, keySelector: Func_2<TRow, TKey>, comparer: IComparer_1<TKey>): OrderedEnumerableRowCollection_1<TRow>;
    static orderByDescending<TRow extends DataRow, TKey>(source: TypedTableBase_1<TRow>, keySelector: Func_2<TRow, TKey>): OrderedEnumerableRowCollection_1<TRow>;
    static select<TRow extends DataRow, S>(source: TypedTableBase_1<TRow>, selector: Func_2<TRow, S>): EnumerableRowCollection_1<S>;
    static where<TRow extends DataRow>(source: TypedTableBase_1<TRow>, predicate: Func_2<TRow, CLROf<boolean>>): EnumerableRowCollection_1<TRow>;
}


export type TypedTableBaseExtensions = TypedTableBaseExtensions$instance;

