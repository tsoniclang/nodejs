// Generated by tsbindgen - Architecture
// Namespace: System.Net.NetworkInformation
// Assembly: System.Net.NetworkInformation, System.Net.Ping, System.Net.Primitives

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { AsyncCompletedEventArgs, Component, IComponent, IContainer, ISite, Win32Exception } from "../../System.ComponentModel/internal/index.js";
import * as System_Net_Internal from "../../System.Net/internal/index.js";
import type { IPAddress, IPEndPoint } from "../../System.Net/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { Task_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { AsyncCallback, Boolean as ClrBoolean, Byte, Char, Delegate, Enum, EventArgs, Exception, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, Int64, IntPtr, InvalidOperationException, ISpanFormattable, MulticastDelegate, Object as ClrObject, ReadOnlySpan_1, String as ClrString, TimeSpan, Type, TypeCode, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum DuplicateAddressDetectionState {
    invalid = 0,
    tentative = 1,
    duplicate = 2,
    deprecated = 3,
    preferred = 4
}


export enum IPStatus {
    success = 0,
    destinationNetworkUnreachable = 11002,
    destinationHostUnreachable = 11003,
    destinationProtocolUnreachable = 11004,
    destinationPortUnreachable = 11005,
    destinationProhibited = 11004,
    noResources = 11006,
    badOption = 11007,
    hardwareError = 11008,
    packetTooBig = 11009,
    timedOut = 11010,
    badRoute = 11012,
    ttlExpired = 11013,
    ttlReassemblyTimeExceeded = 11014,
    parameterProblem = 11015,
    sourceQuench = 11016,
    badDestination = 11018,
    destinationUnreachable = 11040,
    timeExceeded = 11041,
    badHeader = 11042,
    unrecognizedNextHeader = 11043,
    icmpError = 11044,
    destinationScopeMismatch = 11045,
    unknown_ = -1
}


export enum NetBiosNodeType {
    unknown_ = 0,
    broadcast = 1,
    peer2Peer = 2,
    mixed = 4,
    hybrid = 8
}


export enum NetworkInterfaceComponent {
    iPv4 = 0,
    iPv6 = 1
}


export enum NetworkInterfaceType {
    unknown_ = 1,
    ethernet = 6,
    tokenRing = 9,
    fddi = 15,
    basicIsdn = 20,
    primaryIsdn = 21,
    ppp = 23,
    loopback = 24,
    ethernet3Megabit = 26,
    slip = 28,
    atm = 37,
    genericModem = 48,
    fastEthernetT = 62,
    isdn = 63,
    fastEthernetFx = 69,
    wireless80211 = 71,
    asymmetricDsl = 94,
    rateAdaptDsl = 95,
    symmetricDsl = 96,
    veryHighSpeedDsl = 97,
    ipOverAtm = 114,
    gigabitEthernet = 117,
    tunnel = 131,
    multiRateSymmetricDsl = 143,
    highPerformanceSerialBus = 144,
    wman = 237,
    wwanpp = 243,
    wwanpp2 = 244
}


export enum OperationalStatus {
    up = 1,
    down = 2,
    testing = 3,
    unknown_ = 4,
    dormant = 5,
    notPresent = 6,
    lowerLayerDown = 7
}


export enum PrefixOrigin {
    other = 0,
    manual = 1,
    wellKnown = 2,
    dhcp = 3,
    routerAdvertisement = 4
}


export enum ScopeLevel {
    none = 0,
    interface_ = 1,
    link = 2,
    subnet = 3,
    admin = 4,
    site = 5,
    organization = 8,
    global = 14
}


export enum SuffixOrigin {
    other = 0,
    manual = 1,
    wellKnown = 2,
    originDhcp = 3,
    linkLayerAddress = 4,
    random = 5
}


export enum TcpState {
    unknown_ = 0,
    closed = 1,
    listen = 2,
    synSent = 3,
    synReceived = 4,
    established = 5,
    finWait1 = 6,
    finWait2 = 7,
    closeWait = 8,
    closing = 9,
    lastAck = 10,
    timeWait = 11,
    deleteTcb = 12
}


export type NetworkAddressChangedEventHandler = (sender: unknown, e: EventArgs) => void;


export type NetworkAvailabilityChangedEventHandler = (sender: unknown, e: NetworkAvailabilityEventArgs) => void;


export type PingCompletedEventHandler = (sender: unknown, e: PingCompletedEventArgs) => void;


export interface GatewayIPAddressInformation$instance {
    readonly address: IPAddress;
}


export const GatewayIPAddressInformation: {
};


export type GatewayIPAddressInformation = GatewayIPAddressInformation$instance;

export interface GatewayIPAddressInformationCollection$instance {
    readonly count: int;
    readonly isReadOnly: boolean;
    readonly item: GatewayIPAddressInformation;
    add(address: GatewayIPAddressInformation): void;
    clear(): void;
    contains(address: GatewayIPAddressInformation): boolean;
    copyTo(array: GatewayIPAddressInformation[], offset: int): void;
    getEnumerator(): IEnumerator_1<GatewayIPAddressInformation>;
    remove(address: GatewayIPAddressInformation): boolean;
}


export const GatewayIPAddressInformationCollection: {
    new(): GatewayIPAddressInformationCollection$instance;
};


export interface __GatewayIPAddressInformationCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<GatewayIPAddressInformation>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<GatewayIPAddressInformation>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type GatewayIPAddressInformationCollection = GatewayIPAddressInformationCollection$instance & __GatewayIPAddressInformationCollection$views;


export interface IcmpV4Statistics$instance {
    readonly addressMaskRepliesReceived: long;
    readonly addressMaskRepliesSent: long;
    readonly addressMaskRequestsReceived: long;
    readonly addressMaskRequestsSent: long;
    readonly destinationUnreachableMessagesReceived: long;
    readonly destinationUnreachableMessagesSent: long;
    readonly echoRepliesReceived: long;
    readonly echoRepliesSent: long;
    readonly echoRequestsReceived: long;
    readonly echoRequestsSent: long;
    readonly errorsReceived: long;
    readonly errorsSent: long;
    readonly messagesReceived: long;
    readonly messagesSent: long;
    readonly parameterProblemsReceived: long;
    readonly parameterProblemsSent: long;
    readonly redirectsReceived: long;
    readonly redirectsSent: long;
    readonly sourceQuenchesReceived: long;
    readonly sourceQuenchesSent: long;
    readonly timeExceededMessagesReceived: long;
    readonly timeExceededMessagesSent: long;
    readonly timestampRepliesReceived: long;
    readonly timestampRepliesSent: long;
    readonly timestampRequestsReceived: long;
    readonly timestampRequestsSent: long;
}


export const IcmpV4Statistics: {
};


export type IcmpV4Statistics = IcmpV4Statistics$instance;

export interface IcmpV6Statistics$instance {
    readonly destinationUnreachableMessagesReceived: long;
    readonly destinationUnreachableMessagesSent: long;
    readonly echoRepliesReceived: long;
    readonly echoRepliesSent: long;
    readonly echoRequestsReceived: long;
    readonly echoRequestsSent: long;
    readonly errorsReceived: long;
    readonly errorsSent: long;
    readonly membershipQueriesReceived: long;
    readonly membershipQueriesSent: long;
    readonly membershipReductionsReceived: long;
    readonly membershipReductionsSent: long;
    readonly membershipReportsReceived: long;
    readonly membershipReportsSent: long;
    readonly messagesReceived: long;
    readonly messagesSent: long;
    readonly neighborAdvertisementsReceived: long;
    readonly neighborAdvertisementsSent: long;
    readonly neighborSolicitsReceived: long;
    readonly neighborSolicitsSent: long;
    readonly packetTooBigMessagesReceived: long;
    readonly packetTooBigMessagesSent: long;
    readonly parameterProblemsReceived: long;
    readonly parameterProblemsSent: long;
    readonly redirectsReceived: long;
    readonly redirectsSent: long;
    readonly routerAdvertisementsReceived: long;
    readonly routerAdvertisementsSent: long;
    readonly routerSolicitsReceived: long;
    readonly routerSolicitsSent: long;
    readonly timeExceededMessagesReceived: long;
    readonly timeExceededMessagesSent: long;
}


export const IcmpV6Statistics: {
};


export type IcmpV6Statistics = IcmpV6Statistics$instance;

export interface IPAddressCollection$instance {
    readonly count: int;
    readonly isReadOnly: boolean;
    readonly item: IPAddress;
    add(address: IPAddress): void;
    clear(): void;
    contains(address: IPAddress): boolean;
    copyTo(array: IPAddress[], offset: int): void;
    getEnumerator(): IEnumerator_1<IPAddress>;
    remove(address: IPAddress): boolean;
}


export const IPAddressCollection: {
    new(): IPAddressCollection$instance;
};


export interface __IPAddressCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<IPAddress>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<IPAddress>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type IPAddressCollection = IPAddressCollection$instance & __IPAddressCollection$views;


export interface IPAddressInformation$instance {
    readonly address: IPAddress;
    readonly isDnsEligible: boolean;
    readonly isTransient: boolean;
}


export const IPAddressInformation: {
};


export type IPAddressInformation = IPAddressInformation$instance;

export interface IPAddressInformationCollection$instance {
    readonly count: int;
    readonly isReadOnly: boolean;
    readonly item: IPAddressInformation;
    add(address: IPAddressInformation): void;
    clear(): void;
    contains(address: IPAddressInformation): boolean;
    copyTo(array: IPAddressInformation[], offset: int): void;
    getEnumerator(): IEnumerator_1<IPAddressInformation>;
    remove(address: IPAddressInformation): boolean;
}


export const IPAddressInformationCollection: {
    new(): IPAddressInformationCollection$instance;
};


export interface __IPAddressInformationCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<IPAddressInformation>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<IPAddressInformation>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type IPAddressInformationCollection = IPAddressInformationCollection$instance & __IPAddressInformationCollection$views;


export interface IPGlobalProperties$instance {
    readonly dhcpScopeName: string;
    readonly domainName: string;
    readonly hostName: string;
    readonly isWinsProxy: boolean;
    readonly nodeType: NetBiosNodeType;
    beginGetUnicastAddresses(callback: AsyncCallback, state: unknown): IAsyncResult;
    endGetUnicastAddresses(asyncResult: IAsyncResult): UnicastIPAddressInformationCollection;
    getActiveTcpConnections(): TcpConnectionInformation[];
    getActiveTcpListeners(): IPEndPoint[];
    getActiveUdpListeners(): IPEndPoint[];
    getIcmpV4Statistics(): IcmpV4Statistics;
    getIcmpV6Statistics(): IcmpV6Statistics;
    getIPv4GlobalStatistics(): IPGlobalStatistics;
    getIPv6GlobalStatistics(): IPGlobalStatistics;
    getTcpIPv4Statistics(): TcpStatistics;
    getTcpIPv6Statistics(): TcpStatistics;
    getUdpIPv4Statistics(): UdpStatistics;
    getUdpIPv6Statistics(): UdpStatistics;
    getUnicastAddresses(): UnicastIPAddressInformationCollection;
    getUnicastAddressesAsync(): Task_1<UnicastIPAddressInformationCollection>;
}


export const IPGlobalProperties: {
    getIPGlobalProperties(): IPGlobalProperties;
};


export type IPGlobalProperties = IPGlobalProperties$instance;

export interface IPGlobalStatistics$instance {
    readonly defaultTtl: int;
    readonly forwardingEnabled: boolean;
    readonly numberOfInterfaces: int;
    readonly numberOfIPAddresses: int;
    readonly numberOfRoutes: int;
    readonly outputPacketRequests: long;
    readonly outputPacketRoutingDiscards: long;
    readonly outputPacketsDiscarded: long;
    readonly outputPacketsWithNoRoute: long;
    readonly packetFragmentFailures: long;
    readonly packetReassembliesRequired: long;
    readonly packetReassemblyFailures: long;
    readonly packetReassemblyTimeout: long;
    readonly packetsFragmented: long;
    readonly packetsReassembled: long;
    readonly receivedPackets: long;
    readonly receivedPacketsDelivered: long;
    readonly receivedPacketsDiscarded: long;
    readonly receivedPacketsForwarded: long;
    readonly receivedPacketsWithAddressErrors: long;
    readonly receivedPacketsWithHeadersErrors: long;
    readonly receivedPacketsWithUnknownProtocol: long;
}


export const IPGlobalStatistics: {
};


export type IPGlobalStatistics = IPGlobalStatistics$instance;

export interface IPInterfaceProperties$instance {
    readonly anycastAddresses: IPAddressInformationCollection;
    readonly dhcpServerAddresses: IPAddressCollection;
    readonly dnsAddresses: IPAddressCollection;
    readonly dnsSuffix: string;
    readonly gatewayAddresses: GatewayIPAddressInformationCollection;
    readonly isDnsEnabled: boolean;
    readonly isDynamicDnsEnabled: boolean;
    readonly multicastAddresses: MulticastIPAddressInformationCollection;
    readonly unicastAddresses: UnicastIPAddressInformationCollection;
    readonly winsServersAddresses: IPAddressCollection;
    getIPv4Properties(): IPv4InterfaceProperties;
    getIPv6Properties(): IPv6InterfaceProperties;
}


export const IPInterfaceProperties: {
};


export type IPInterfaceProperties = IPInterfaceProperties$instance;

export interface IPInterfaceStatistics$instance {
    readonly bytesReceived: long;
    readonly bytesSent: long;
    readonly incomingPacketsDiscarded: long;
    readonly incomingPacketsWithErrors: long;
    readonly incomingUnknownProtocolPackets: long;
    readonly nonUnicastPacketsReceived: long;
    readonly nonUnicastPacketsSent: long;
    readonly outgoingPacketsDiscarded: long;
    readonly outgoingPacketsWithErrors: long;
    readonly outputQueueLength: long;
    readonly unicastPacketsReceived: long;
    readonly unicastPacketsSent: long;
}


export const IPInterfaceStatistics: {
};


export type IPInterfaceStatistics = IPInterfaceStatistics$instance;

export interface IPv4InterfaceProperties$instance {
    readonly index: int;
    readonly isAutomaticPrivateAddressingActive: boolean;
    readonly isAutomaticPrivateAddressingEnabled: boolean;
    readonly isDhcpEnabled: boolean;
    readonly isForwardingEnabled: boolean;
    readonly mtu: int;
    readonly usesWins: boolean;
}


export const IPv4InterfaceProperties: {
};


export type IPv4InterfaceProperties = IPv4InterfaceProperties$instance;

export interface IPv4InterfaceStatistics$instance {
    readonly bytesReceived: long;
    readonly bytesSent: long;
    readonly incomingPacketsDiscarded: long;
    readonly incomingPacketsWithErrors: long;
    readonly incomingUnknownProtocolPackets: long;
    readonly nonUnicastPacketsReceived: long;
    readonly nonUnicastPacketsSent: long;
    readonly outgoingPacketsDiscarded: long;
    readonly outgoingPacketsWithErrors: long;
    readonly outputQueueLength: long;
    readonly unicastPacketsReceived: long;
    readonly unicastPacketsSent: long;
}


export const IPv4InterfaceStatistics: {
};


export type IPv4InterfaceStatistics = IPv4InterfaceStatistics$instance;

export interface IPv6InterfaceProperties$instance {
    readonly index: int;
    readonly mtu: int;
    getScopeId(scopeLevel: ScopeLevel): long;
}


export const IPv6InterfaceProperties: {
};


export type IPv6InterfaceProperties = IPv6InterfaceProperties$instance;

export interface MulticastIPAddressInformation$instance extends IPAddressInformation {
    readonly addressPreferredLifetime: long;
    readonly addressValidLifetime: long;
    readonly dhcpLeaseLifetime: long;
    readonly duplicateAddressDetectionState: DuplicateAddressDetectionState;
    readonly prefixOrigin: PrefixOrigin;
    readonly suffixOrigin: SuffixOrigin;
}


export const MulticastIPAddressInformation: {
};


export type MulticastIPAddressInformation = MulticastIPAddressInformation$instance;

export interface MulticastIPAddressInformationCollection$instance {
    readonly count: int;
    readonly isReadOnly: boolean;
    readonly item: MulticastIPAddressInformation;
    add(address: MulticastIPAddressInformation): void;
    clear(): void;
    contains(address: MulticastIPAddressInformation): boolean;
    copyTo(array: MulticastIPAddressInformation[], offset: int): void;
    getEnumerator(): IEnumerator_1<MulticastIPAddressInformation>;
    remove(address: MulticastIPAddressInformation): boolean;
}


export const MulticastIPAddressInformationCollection: {
    new(): MulticastIPAddressInformationCollection$instance;
};


export interface __MulticastIPAddressInformationCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<MulticastIPAddressInformation>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<MulticastIPAddressInformation>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type MulticastIPAddressInformationCollection = MulticastIPAddressInformationCollection$instance & __MulticastIPAddressInformationCollection$views;


export interface NetworkAvailabilityEventArgs$instance extends EventArgs {
    readonly isAvailable: boolean;
}


export const NetworkAvailabilityEventArgs: {
    new(): NetworkAvailabilityEventArgs$instance;
};


export type NetworkAvailabilityEventArgs = NetworkAvailabilityEventArgs$instance;

export interface NetworkChange$instance {
}


export const NetworkChange: {
    new(): NetworkChange$instance;
    registerNetworkChange(nc: NetworkChange): void;
};


export type NetworkChange = NetworkChange$instance;

export interface NetworkInformationException$instance extends Win32Exception {
    readonly errorCode: int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const NetworkInformationException: {
    new(): NetworkInformationException$instance;
    new(errorCode: int): NetworkInformationException$instance;
};


export interface __NetworkInformationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type NetworkInformationException = NetworkInformationException$instance & __NetworkInformationException$views;


export interface NetworkInterface$instance {
    readonly description: string;
    readonly id: string;
    readonly isReceiveOnly: boolean;
    readonly name: string;
    readonly networkInterfaceType: NetworkInterfaceType;
    readonly operationalStatus: OperationalStatus;
    readonly speed: long;
    readonly supportsMulticast: boolean;
    getIPProperties(): IPInterfaceProperties;
    getIPStatistics(): IPInterfaceStatistics;
    getIPv4Statistics(): IPv4InterfaceStatistics;
    getPhysicalAddress(): PhysicalAddress;
    supports(networkInterfaceComponent: NetworkInterfaceComponent): boolean;
}


export const NetworkInterface: {
    readonly iPv6LoopbackInterfaceIndex: int;
    readonly loopbackInterfaceIndex: int;
    getAllNetworkInterfaces(): NetworkInterface[];
    getIsNetworkAvailable(): boolean;
};


export type NetworkInterface = NetworkInterface$instance;

export interface PhysicalAddress$instance {
    equals(comparand: unknown): boolean;
    getAddressBytes(): byte[];
    getHashCode(): int;
    toString(): string;
}


export const PhysicalAddress: {
    new(address: byte[]): PhysicalAddress$instance;
    readonly none: PhysicalAddress;
    parse(address: ReadOnlySpan_1<CLROf<char>>): PhysicalAddress;
    parse(address: string): PhysicalAddress;
    tryParse(address: ReadOnlySpan_1<CLROf<char>>, value: { value: ref<PhysicalAddress> }): boolean;
    tryParse(address: string, value: { value: ref<PhysicalAddress> }): boolean;
};


export type PhysicalAddress = PhysicalAddress$instance;

export interface Ping$instance extends Component {
    dispose(): void;
    send(hostNameOrAddress: string): PingReply;
    send(hostNameOrAddress: string, timeout: int): PingReply;
    send(address: IPAddress): PingReply;
    send(address: IPAddress, timeout: int): PingReply;
    send(hostNameOrAddress: string, timeout: int, buffer: byte[]): PingReply;
    send(address: IPAddress, timeout: int, buffer: byte[]): PingReply;
    send(hostNameOrAddress: string, timeout: int, buffer: byte[], options: PingOptions): PingReply;
    send(address: IPAddress, timeout: int, buffer: byte[], options: PingOptions): PingReply;
    send(address: IPAddress, timeout: TimeSpan, buffer?: byte[], options?: PingOptions): PingReply;
    send(hostNameOrAddress: string, timeout: TimeSpan, buffer?: byte[], options?: PingOptions): PingReply;
    sendAsync(hostNameOrAddress: string, userToken: unknown): void;
    sendAsync(hostNameOrAddress: string, timeout: int, userToken: unknown): void;
    sendAsync(address: IPAddress, userToken: unknown): void;
    sendAsync(address: IPAddress, timeout: int, userToken: unknown): void;
    sendAsync(hostNameOrAddress: string, timeout: int, buffer: byte[], userToken: unknown): void;
    sendAsync(address: IPAddress, timeout: int, buffer: byte[], userToken: unknown): void;
    sendAsync(hostNameOrAddress: string, timeout: int, buffer: byte[], options: PingOptions, userToken: unknown): void;
    sendAsync(address: IPAddress, timeout: int, buffer: byte[], options: PingOptions, userToken: unknown): void;
    sendAsyncCancel(): void;
    sendPingAsync(address: IPAddress): Task_1<PingReply>;
    sendPingAsync(hostNameOrAddress: string): Task_1<PingReply>;
    sendPingAsync(address: IPAddress, timeout: int): Task_1<PingReply>;
    sendPingAsync(hostNameOrAddress: string, timeout: int): Task_1<PingReply>;
    sendPingAsync(address: IPAddress, timeout: int, buffer: byte[]): Task_1<PingReply>;
    sendPingAsync(hostNameOrAddress: string, timeout: int, buffer: byte[]): Task_1<PingReply>;
    sendPingAsync(address: IPAddress, timeout: int, buffer: byte[], options: PingOptions): Task_1<PingReply>;
    sendPingAsync(address: IPAddress, timeout: TimeSpan, buffer?: byte[], options?: PingOptions, cancellationToken?: CancellationToken): Task_1<PingReply>;
    sendPingAsync(hostNameOrAddress: string, timeout: int, buffer: byte[], options: PingOptions): Task_1<PingReply>;
    sendPingAsync(hostNameOrAddress: string, timeout: TimeSpan, buffer?: byte[], options?: PingOptions, cancellationToken?: CancellationToken): Task_1<PingReply>;
}


export const Ping: {
    new(): Ping$instance;
};


export interface __Ping$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Ping$instance extends System_ComponentModel_Internal.IComponent$instance {}

export type Ping = Ping$instance & __Ping$views;


export interface PingCompletedEventArgs$instance extends AsyncCompletedEventArgs {
    readonly reply: PingReply;
}


export const PingCompletedEventArgs: {
    new(): PingCompletedEventArgs$instance;
};


export type PingCompletedEventArgs = PingCompletedEventArgs$instance;

export interface PingException$instance extends InvalidOperationException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const PingException: {
    new(message: string): PingException$instance;
    new(message: string, innerException: Exception): PingException$instance;
};


export interface __PingException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type PingException = PingException$instance & __PingException$views;


export interface PingOptions$instance {
    dontFragment: boolean;
    ttl: int;
}


export const PingOptions: {
    new(): PingOptions$instance;
    new(ttl: int, dontFragment: boolean): PingOptions$instance;
};


export type PingOptions = PingOptions$instance;

export interface PingReply$instance {
    readonly address: IPAddress;
    readonly buffer: byte[];
    readonly options: PingOptions;
    readonly roundtripTime: long;
    readonly status: IPStatus;
}


export const PingReply: {
    new(): PingReply$instance;
};


export type PingReply = PingReply$instance;

export interface TcpConnectionInformation$instance {
    readonly localEndPoint: IPEndPoint;
    readonly remoteEndPoint: IPEndPoint;
    readonly state: TcpState;
}


export const TcpConnectionInformation: {
};


export type TcpConnectionInformation = TcpConnectionInformation$instance;

export interface TcpStatistics$instance {
    readonly connectionsAccepted: long;
    readonly connectionsInitiated: long;
    readonly cumulativeConnections: long;
    readonly currentConnections: long;
    readonly errorsReceived: long;
    readonly failedConnectionAttempts: long;
    readonly maximumConnections: long;
    readonly maximumTransmissionTimeout: long;
    readonly minimumTransmissionTimeout: long;
    readonly resetConnections: long;
    readonly resetsSent: long;
    readonly segmentsReceived: long;
    readonly segmentsResent: long;
    readonly segmentsSent: long;
}


export const TcpStatistics: {
};


export type TcpStatistics = TcpStatistics$instance;

export interface UdpStatistics$instance {
    readonly datagramsReceived: long;
    readonly datagramsSent: long;
    readonly incomingDatagramsDiscarded: long;
    readonly incomingDatagramsWithErrors: long;
    readonly udpListeners: int;
}


export const UdpStatistics: {
};


export type UdpStatistics = UdpStatistics$instance;

export interface UnicastIPAddressInformation$instance extends IPAddressInformation {
    readonly addressPreferredLifetime: long;
    readonly addressValidLifetime: long;
    readonly dhcpLeaseLifetime: long;
    readonly duplicateAddressDetectionState: DuplicateAddressDetectionState;
    readonly iPv4Mask: IPAddress;
    readonly prefixLength: int;
    readonly prefixOrigin: PrefixOrigin;
    readonly suffixOrigin: SuffixOrigin;
}


export const UnicastIPAddressInformation: {
};


export type UnicastIPAddressInformation = UnicastIPAddressInformation$instance;

export interface UnicastIPAddressInformationCollection$instance {
    readonly count: int;
    readonly isReadOnly: boolean;
    readonly item: UnicastIPAddressInformation;
    add(address: UnicastIPAddressInformation): void;
    clear(): void;
    contains(address: UnicastIPAddressInformation): boolean;
    copyTo(array: UnicastIPAddressInformation[], offset: int): void;
    getEnumerator(): IEnumerator_1<UnicastIPAddressInformation>;
    remove(address: UnicastIPAddressInformation): boolean;
}


export const UnicastIPAddressInformationCollection: {
    new(): UnicastIPAddressInformationCollection$instance;
};


export interface __UnicastIPAddressInformationCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<UnicastIPAddressInformation>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<UnicastIPAddressInformation>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type UnicastIPAddressInformationCollection = UnicastIPAddressInformationCollection$instance & __UnicastIPAddressInformationCollection$views;


