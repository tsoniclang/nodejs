// Generated by tsbindgen - Architecture
// Namespace: System.Reflection.Metadata
// Assembly: System.Private.CoreLib, System.Reflection.Metadata

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { IComparer_1, IEnumerable_1, IEnumerator_1, IEqualityComparer_1, IReadOnlyCollection_1, IReadOnlyList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ImmutableArray_1 } from "../../System.Collections.Immutable/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { PEReader } from "../../System.Reflection.PortableExecutable/internal/index.js";
import type { Assembly, AssemblyFlags, AssemblyHashAlgorithm, AssemblyName, AssemblyNameFlags, DeclarativeSecurityAction, EventAttributes, FieldAttributes, GenericParameterAttributes, ManifestResourceAttributes, MethodAttributes, MethodBase, MethodImplAttributes, MethodImportAttributes, ParameterAttributes, PropertyAttributes, TypeAttributes } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { Encoding } from "../../System.Text/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ArraySegment_1, Attribute, Boolean as ClrBoolean, Byte, Char, DateTime, Decimal, Double, Enum, Exception, Func_2, Guid, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, ISpanFormattable, Object as ClrObject, ReadOnlySpan_1, SByte, Single, String as ClrString, Type, TypeCode, UInt16, UInt32, UInt64, ValueType, Version, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum ConstantTypeCode {
    invalid = 0,
    boolean_ = 2,
    char = 3,
    sByte = 4,
    byte = 5,
    int16 = 6,
    uInt16 = 7,
    int32 = 8,
    uInt32 = 9,
    int64 = 10,
    uInt64 = 11,
    single = 12,
    double = 13,
    string_ = 14,
    nullReference = 18
}


export enum CustomAttributeNamedArgumentKind {
    field = 83,
    property = 84
}


export enum ExceptionRegionKind {
    catch_ = 0,
    filter = 1,
    finally_ = 2,
    fault = 4
}


export enum HandleKind {
    moduleDefinition = 0,
    typeReference = 1,
    typeDefinition = 2,
    fieldDefinition = 4,
    methodDefinition = 6,
    parameter = 8,
    interfaceImplementation = 9,
    memberReference = 10,
    constant = 11,
    customAttribute = 12,
    declarativeSecurityAttribute = 14,
    standaloneSignature = 17,
    eventDefinition = 20,
    propertyDefinition = 23,
    methodImplementation = 25,
    moduleReference = 26,
    typeSpecification = 27,
    assemblyDefinition = 32,
    assemblyFile = 38,
    assemblyReference = 35,
    exportedType = 39,
    genericParameter = 42,
    methodSpecification = 43,
    genericParameterConstraint = 44,
    manifestResource = 40,
    document = 48,
    methodDebugInformation = 49,
    localScope = 50,
    localVariable = 51,
    localConstant = 52,
    importScope = 53,
    customDebugInformation = 55,
    namespaceDefinition = 124,
    userString = 112,
    string_ = 120,
    blob = 113,
    guid = 114
}


export enum ILOpCode {
    nop = 0,
    break_ = 1,
    Ldarg_0 = 2,
    Ldarg_1 = 3,
    Ldarg_2 = 4,
    Ldarg_3 = 5,
    Ldloc_0 = 6,
    Ldloc_1 = 7,
    Ldloc_2 = 8,
    Ldloc_3 = 9,
    Stloc_0 = 10,
    Stloc_1 = 11,
    Stloc_2 = 12,
    Stloc_3 = 13,
    Ldarg_s = 14,
    Ldarga_s = 15,
    Starg_s = 16,
    Ldloc_s = 17,
    Ldloca_s = 18,
    Stloc_s = 19,
    ldnull = 20,
    Ldc_i4_m1 = 21,
    Ldc_i4_0 = 22,
    Ldc_i4_1 = 23,
    Ldc_i4_2 = 24,
    Ldc_i4_3 = 25,
    Ldc_i4_4 = 26,
    Ldc_i4_5 = 27,
    Ldc_i4_6 = 28,
    Ldc_i4_7 = 29,
    Ldc_i4_8 = 30,
    Ldc_i4_s = 31,
    Ldc_i4 = 32,
    Ldc_i8 = 33,
    Ldc_r4 = 34,
    Ldc_r8 = 35,
    dup = 37,
    pop = 38,
    jmp = 39,
    call = 40,
    calli = 41,
    ret = 42,
    Br_s = 43,
    Brfalse_s = 44,
    Brtrue_s = 45,
    Beq_s = 46,
    Bge_s = 47,
    Bgt_s = 48,
    Ble_s = 49,
    Blt_s = 50,
    Bne_un_s = 51,
    Bge_un_s = 52,
    Bgt_un_s = 53,
    Ble_un_s = 54,
    Blt_un_s = 55,
    br = 56,
    brfalse = 57,
    brtrue = 58,
    beq = 59,
    bge = 60,
    bgt = 61,
    ble = 62,
    blt = 63,
    Bne_un = 64,
    Bge_un = 65,
    Bgt_un = 66,
    Ble_un = 67,
    Blt_un = 68,
    switch_ = 69,
    Ldind_i1 = 70,
    Ldind_u1 = 71,
    Ldind_i2 = 72,
    Ldind_u2 = 73,
    Ldind_i4 = 74,
    Ldind_u4 = 75,
    Ldind_i8 = 76,
    Ldind_i = 77,
    Ldind_r4 = 78,
    Ldind_r8 = 79,
    Ldind_ref = 80,
    Stind_ref = 81,
    Stind_i1 = 82,
    Stind_i2 = 83,
    Stind_i4 = 84,
    Stind_i8 = 85,
    Stind_r4 = 86,
    Stind_r8 = 87,
    add = 88,
    sub = 89,
    mul = 90,
    div = 91,
    Div_un = 92,
    rem = 93,
    Rem_un = 94,
    and = 95,
    or = 96,
    xor = 97,
    shl = 98,
    shr = 99,
    Shr_un = 100,
    neg = 101,
    not = 102,
    Conv_i1 = 103,
    Conv_i2 = 104,
    Conv_i4 = 105,
    Conv_i8 = 106,
    Conv_r4 = 107,
    Conv_r8 = 108,
    Conv_u4 = 109,
    Conv_u8 = 110,
    callvirt = 111,
    cpobj = 112,
    ldobj = 113,
    ldstr = 114,
    newobj = 115,
    castclass = 116,
    isinst = 117,
    Conv_r_un = 118,
    unbox = 121,
    throw_ = 122,
    ldfld = 123,
    ldflda = 124,
    stfld = 125,
    ldsfld = 126,
    ldsflda = 127,
    stsfld = 128,
    stobj = 129,
    Conv_ovf_i1_un = 130,
    Conv_ovf_i2_un = 131,
    Conv_ovf_i4_un = 132,
    Conv_ovf_i8_un = 133,
    Conv_ovf_u1_un = 134,
    Conv_ovf_u2_un = 135,
    Conv_ovf_u4_un = 136,
    Conv_ovf_u8_un = 137,
    Conv_ovf_i_un = 138,
    Conv_ovf_u_un = 139,
    box = 140,
    newarr = 141,
    ldlen = 142,
    ldelema = 143,
    Ldelem_i1 = 144,
    Ldelem_u1 = 145,
    Ldelem_i2 = 146,
    Ldelem_u2 = 147,
    Ldelem_i4 = 148,
    Ldelem_u4 = 149,
    Ldelem_i8 = 150,
    Ldelem_i = 151,
    Ldelem_r4 = 152,
    Ldelem_r8 = 153,
    Ldelem_ref = 154,
    Stelem_i = 155,
    Stelem_i1 = 156,
    Stelem_i2 = 157,
    Stelem_i4 = 158,
    Stelem_i8 = 159,
    Stelem_r4 = 160,
    Stelem_r8 = 161,
    Stelem_ref = 162,
    ldelem = 163,
    stelem = 164,
    Unbox_any = 165,
    Conv_ovf_i1 = 179,
    Conv_ovf_u1 = 180,
    Conv_ovf_i2 = 181,
    Conv_ovf_u2 = 182,
    Conv_ovf_i4 = 183,
    Conv_ovf_u4 = 184,
    Conv_ovf_i8 = 185,
    Conv_ovf_u8 = 186,
    refanyval = 194,
    ckfinite = 195,
    mkrefany = 198,
    ldtoken = 208,
    Conv_u2 = 209,
    Conv_u1 = 210,
    Conv_i = 211,
    Conv_ovf_i = 212,
    Conv_ovf_u = 213,
    Add_ovf = 214,
    Add_ovf_un = 215,
    Mul_ovf = 216,
    Mul_ovf_un = 217,
    Sub_ovf = 218,
    Sub_ovf_un = 219,
    endfinally = 220,
    leave = 221,
    Leave_s = 222,
    Stind_i = 223,
    Conv_u = 224,
    arglist = 65024,
    ceq = 65025,
    cgt = 65026,
    Cgt_un = 65027,
    clt = 65028,
    Clt_un = 65029,
    ldftn = 65030,
    ldvirtftn = 65031,
    ldarg = 65033,
    ldarga = 65034,
    starg = 65035,
    ldloc = 65036,
    ldloca = 65037,
    stloc = 65038,
    localloc = 65039,
    endfilter = 65041,
    unaligned = 65042,
    volatile = 65043,
    tail = 65044,
    initobj = 65045,
    constrained = 65046,
    cpblk = 65047,
    initblk = 65048,
    rethrow = 65050,
    sizeof = 65052,
    refanytype = 65053,
    readonly_ = 65054
}


export enum ImportDefinitionKind {
    importNamespace = 1,
    importAssemblyNamespace = 2,
    importType = 3,
    importXmlNamespace = 4,
    importAssemblyReferenceAlias = 5,
    aliasAssemblyReference = 6,
    aliasNamespace = 7,
    aliasAssemblyNamespace = 8,
    aliasType = 9
}


export enum LocalVariableAttributes {
    none = 0,
    debuggerHidden = 1
}


export enum MemberReferenceKind {
    method = 0,
    field = 1
}


export enum MetadataKind {
    ecma335 = 0,
    windowsMetadata = 1,
    managedWindowsMetadata = 2
}


export enum MetadataReaderOptions {
    none = 0,
    default_ = 1,
    applyWindowsRuntimeProjections = 1
}


export enum MetadataStreamOptions {
    default_ = 0,
    leaveOpen = 1,
    prefetchMetadata = 2
}


export enum PrimitiveSerializationTypeCode {
    boolean_ = 2,
    byte = 5,
    sByte = 4,
    char = 3,
    int16 = 6,
    uInt16 = 7,
    int32 = 8,
    uInt32 = 9,
    int64 = 10,
    uInt64 = 11,
    single = 12,
    double = 13,
    string_ = 14
}


export enum PrimitiveTypeCode {
    boolean_ = 2,
    byte = 5,
    sByte = 4,
    char = 3,
    int16 = 6,
    uInt16 = 7,
    int32 = 8,
    uInt32 = 9,
    int64 = 10,
    uInt64 = 11,
    single = 12,
    double = 13,
    intPtr = 24,
    uIntPtr = 25,
    object_ = 28,
    string_ = 14,
    typedReference = 22,
    void_ = 1
}


export enum SerializationTypeCode {
    invalid = 0,
    boolean_ = 2,
    char = 3,
    sByte = 4,
    byte = 5,
    int16 = 6,
    uInt16 = 7,
    int32 = 8,
    uInt32 = 9,
    int64 = 10,
    uInt64 = 11,
    single = 12,
    double = 13,
    string_ = 14,
    szArray = 29,
    type_ = 80,
    taggedObject = 81,
    enum_ = 85
}


export enum SignatureAttributes {
    none = 0,
    generic = 16,
    instance = 32,
    explicitThis = 64
}


export enum SignatureCallingConvention {
    default_ = 0,
    cDecl = 1,
    stdCall = 2,
    thisCall = 3,
    fastCall = 4,
    varArgs = 5,
    unmanaged = 9
}


export enum SignatureKind {
    method = 0,
    field = 6,
    localVariables = 7,
    property = 8,
    methodSpecification = 10
}


export enum SignatureTypeCode {
    invalid = 0,
    void_ = 1,
    boolean_ = 2,
    char = 3,
    sByte = 4,
    byte = 5,
    int16 = 6,
    uInt16 = 7,
    int32 = 8,
    uInt32 = 9,
    int64 = 10,
    uInt64 = 11,
    single = 12,
    double = 13,
    string_ = 14,
    pointer = 15,
    byReference = 16,
    genericTypeParameter = 19,
    array = 20,
    genericTypeInstance = 21,
    typedReference = 22,
    intPtr = 24,
    uIntPtr = 25,
    functionPointer = 27,
    object_ = 28,
    szArray = 29,
    genericMethodParameter = 30,
    requiredModifier = 31,
    optionalModifier = 32,
    typeHandle = 64,
    sentinel = 65,
    pinned = 69
}


export enum SignatureTypeKind {
    unknown_ = 0,
    class_ = 18,
    valueType = 17
}


export enum StandaloneSignatureKind {
    method = 0,
    localVariables = 1
}


export interface IConstructedTypeProvider_1$instance<TType> extends ISZArrayTypeProvider_1<TType> {
    getArrayType(elementType: TType, shape: ArrayShape): TType;
    getByReferenceType(elementType: TType): TType;
    getGenericInstantiation(genericType: TType, typeArguments: ImmutableArray_1<TType>): TType;
}


export interface IConstructedTypeProvider_1$instance<TType> extends ISZArrayTypeProvider_1$instance<TType> {}

export type IConstructedTypeProvider_1<TType> = IConstructedTypeProvider_1$instance<TType>;

export interface ICustomAttributeTypeProvider_1$instance<TType> extends ISimpleTypeProvider_1<TType>, ISZArrayTypeProvider_1<TType> {
    getPrimitiveType(typeCode: PrimitiveTypeCode): TType;
    getSystemType(): TType;
    getSZArrayType(elementType: TType): TType;
    getTypeFromDefinition(reader: MetadataReader, handle: TypeDefinitionHandle, rawTypeKind: byte): TType;
    getTypeFromReference(reader: MetadataReader, handle: TypeReferenceHandle, rawTypeKind: byte): TType;
    getTypeFromSerializedName(name: string): TType;
    getUnderlyingEnumType(type_: TType): PrimitiveTypeCode;
    isSystemType(type_: TType): boolean;
}


export interface ICustomAttributeTypeProvider_1$instance<TType> extends ISimpleTypeProvider_1$instance<TType>, ISZArrayTypeProvider_1$instance<TType> {}

export type ICustomAttributeTypeProvider_1<TType> = ICustomAttributeTypeProvider_1$instance<TType>;

export interface ISignatureTypeProvider_2$instance<TType, TGenericContext> extends ISimpleTypeProvider_1<TType>, IConstructedTypeProvider_1<TType>, ISZArrayTypeProvider_1<TType> {
    getArrayType(elementType: TType, shape: ArrayShape): TType;
    getFunctionPointerType(signature: MethodSignature_1<TType>): TType;
    getGenericInstantiation(genericType: TType, typeArguments: ImmutableArray_1<TType>): TType;
    getGenericMethodParameter(genericContext: TGenericContext, index: int): TType;
    getModifiedType(modifier: TType, unmodifiedType: TType, isRequired: boolean): TType;
    getPinnedType(elementType: TType): TType;
    getPrimitiveType(typeCode: PrimitiveTypeCode): TType;
    getTypeFromDefinition(reader: MetadataReader, handle: TypeDefinitionHandle, rawTypeKind: byte): TType;
    getTypeFromReference(reader: MetadataReader, handle: TypeReferenceHandle, rawTypeKind: byte): TType;
    getTypeFromSpecification(reader: MetadataReader, genericContext: TGenericContext, handle: TypeSpecificationHandle, rawTypeKind: byte): TType;
}


export interface ISignatureTypeProvider_2$instance<TType, TGenericContext> extends IConstructedTypeProvider_1$instance<TType>, ISimpleTypeProvider_1$instance<TType> {}

export type ISignatureTypeProvider_2<TType, TGenericContext> = ISignatureTypeProvider_2$instance<TType, TGenericContext>;

export interface ISimpleTypeProvider_1$instance<TType> {
    getPrimitiveType(typeCode: PrimitiveTypeCode): TType;
    getTypeFromDefinition(reader: MetadataReader, handle: TypeDefinitionHandle, rawTypeKind: byte): TType;
    getTypeFromReference(reader: MetadataReader, handle: TypeReferenceHandle, rawTypeKind: byte): TType;
}


export type ISimpleTypeProvider_1<TType> = ISimpleTypeProvider_1$instance<TType>;

export interface ISZArrayTypeProvider_1$instance<TType> {
    getSZArrayType(elementType: TType): TType;
}


export type ISZArrayTypeProvider_1<TType> = ISZArrayTypeProvider_1$instance<TType>;

export interface ArrayShape$instance {
    readonly lowerBounds: ImmutableArray_1<CLROf<int>>;
    readonly rank: int;
    readonly sizes: ImmutableArray_1<CLROf<int>>;
}


export const ArrayShape: {
    new(rank: int, sizes: ImmutableArray_1<CLROf<int>>, lowerBounds: ImmutableArray_1<CLROf<int>>): ArrayShape$instance;
};


export type ArrayShape = ArrayShape$instance;

export interface AssemblyDefinition$instance {
    readonly culture: StringHandle;
    readonly flags: AssemblyFlags;
    readonly hashAlgorithm: AssemblyHashAlgorithm;
    readonly name: StringHandle;
    readonly publicKey: BlobHandle;
    readonly version: Version;
    getAssemblyName(): AssemblyName;
    getAssemblyNameInfo(): AssemblyNameInfo;
    getCustomAttributes(): CustomAttributeHandleCollection;
    getDeclarativeSecurityAttributes(): DeclarativeSecurityAttributeHandleCollection;
}


export const AssemblyDefinition: {
    new(): AssemblyDefinition$instance;
};


export type AssemblyDefinition = AssemblyDefinition$instance;

export interface AssemblyDefinitionHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: AssemblyDefinitionHandle): boolean;
    getHashCode(): int;
}


export const AssemblyDefinitionHandle: {
    new(): AssemblyDefinitionHandle$instance;
};


export interface __AssemblyDefinitionHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<AssemblyDefinitionHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: AssemblyDefinitionHandle): boolean;
}

export type AssemblyDefinitionHandle = AssemblyDefinitionHandle$instance & __AssemblyDefinitionHandle$views;


export interface AssemblyFile$instance {
    readonly containsMetadata: boolean;
    readonly hashValue: BlobHandle;
    readonly name: StringHandle;
    getCustomAttributes(): CustomAttributeHandleCollection;
}


export const AssemblyFile: {
    new(): AssemblyFile$instance;
};


export type AssemblyFile = AssemblyFile$instance;

export interface AssemblyFileHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: AssemblyFileHandle): boolean;
    getHashCode(): int;
}


export const AssemblyFileHandle: {
    new(): AssemblyFileHandle$instance;
};


export interface __AssemblyFileHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<AssemblyFileHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: AssemblyFileHandle): boolean;
}

export type AssemblyFileHandle = AssemblyFileHandle$instance & __AssemblyFileHandle$views;


export interface AssemblyFileHandleCollection$instance {
    readonly count: int;
    getEnumerator(): AssemblyFileHandleCollection_Enumerator;
}


export const AssemblyFileHandleCollection: {
    new(): AssemblyFileHandleCollection$instance;
};


export interface __AssemblyFileHandleCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<AssemblyFileHandle>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<AssemblyFileHandle>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type AssemblyFileHandleCollection = AssemblyFileHandleCollection$instance & __AssemblyFileHandleCollection$views;


export interface AssemblyFileHandleCollection_Enumerator$instance {
    readonly current: AssemblyFileHandle;
    moveNext(): boolean;
    reset(): void;
}


export const AssemblyFileHandleCollection_Enumerator: {
    new(): AssemblyFileHandleCollection_Enumerator$instance;
};


export interface __AssemblyFileHandleCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<AssemblyFileHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type AssemblyFileHandleCollection_Enumerator = AssemblyFileHandleCollection_Enumerator$instance & __AssemblyFileHandleCollection_Enumerator$views;


export interface AssemblyReference$instance {
    readonly culture: StringHandle;
    readonly flags: AssemblyFlags;
    readonly hashValue: BlobHandle;
    readonly name: StringHandle;
    readonly publicKeyOrToken: BlobHandle;
    readonly version: Version;
    getAssemblyName(): AssemblyName;
    getAssemblyNameInfo(): AssemblyNameInfo;
    getCustomAttributes(): CustomAttributeHandleCollection;
}


export const AssemblyReference: {
    new(): AssemblyReference$instance;
};


export type AssemblyReference = AssemblyReference$instance;

export interface AssemblyReferenceHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: AssemblyReferenceHandle): boolean;
    getHashCode(): int;
}


export const AssemblyReferenceHandle: {
    new(): AssemblyReferenceHandle$instance;
};


export interface __AssemblyReferenceHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<AssemblyReferenceHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: AssemblyReferenceHandle): boolean;
}

export type AssemblyReferenceHandle = AssemblyReferenceHandle$instance & __AssemblyReferenceHandle$views;


export interface AssemblyReferenceHandleCollection$instance {
    readonly count: int;
    getEnumerator(): AssemblyReferenceHandleCollection_Enumerator;
}


export const AssemblyReferenceHandleCollection: {
    new(): AssemblyReferenceHandleCollection$instance;
};


export interface __AssemblyReferenceHandleCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<AssemblyReferenceHandle>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<AssemblyReferenceHandle>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type AssemblyReferenceHandleCollection = AssemblyReferenceHandleCollection$instance & __AssemblyReferenceHandleCollection$views;


export interface AssemblyReferenceHandleCollection_Enumerator$instance {
    readonly current: AssemblyReferenceHandle;
    moveNext(): boolean;
    reset(): void;
}


export const AssemblyReferenceHandleCollection_Enumerator: {
    new(): AssemblyReferenceHandleCollection_Enumerator$instance;
};


export interface __AssemblyReferenceHandleCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<AssemblyReferenceHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type AssemblyReferenceHandleCollection_Enumerator = AssemblyReferenceHandleCollection_Enumerator$instance & __AssemblyReferenceHandleCollection_Enumerator$views;


export interface Blob$instance {
    readonly isDefault: boolean;
    readonly length: int;
    getBytes(): ArraySegment_1<CLROf<byte>>;
}


export const Blob: {
    new(): Blob$instance;
};


export type Blob = Blob$instance;

export interface BlobBuilder_Blobs$instance {
    readonly current: Blob;
    getEnumerator(): BlobBuilder_Blobs;
    moveNext(): boolean;
    reset(): void;
}


export const BlobBuilder_Blobs: {
    new(): BlobBuilder_Blobs$instance;
};


export interface __BlobBuilder_Blobs$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<Blob>;
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<Blob>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type BlobBuilder_Blobs = BlobBuilder_Blobs$instance & __BlobBuilder_Blobs$views;


export interface BlobContentId$instance {
    readonly guid: Guid;
    readonly isDefault: boolean;
    readonly stamp: uint;
    equals(other: BlobContentId): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const BlobContentId: {
    new(guid: Guid, stamp: uint): BlobContentId$instance;
    new(id: ImmutableArray_1<CLROf<byte>>): BlobContentId$instance;
    new(id: byte[]): BlobContentId$instance;
    fromHash(hashCode: byte[]): BlobContentId;
    fromHash(hashCode: ImmutableArray_1<CLROf<byte>>): BlobContentId;
    getTimeBasedProvider(): Func_2<IEnumerable_1<Blob>, BlobContentId>;
};


export interface __BlobContentId$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<BlobContentId>;

    // Structural method bridges for numeric interface constraints
    Equals(other: BlobContentId): boolean;
}

export type BlobContentId = BlobContentId$instance & __BlobContentId$views;


export interface BlobHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: BlobHandle): boolean;
    getHashCode(): int;
}


export const BlobHandle: {
    new(): BlobHandle$instance;
};


export interface __BlobHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<BlobHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: BlobHandle): boolean;
}

export type BlobHandle = BlobHandle$instance & __BlobHandle$views;


export interface BlobReader$instance {
    readonly currentPointer: ptr<byte>;
    readonly length: int;
    offset: int;
    readonly remainingBytes: int;
    readonly startPointer: ptr<byte>;
    align(alignment: byte): void;
    indexOf(value: byte): int;
    readBlobHandle(): BlobHandle;
    readBoolean(): boolean;
    readByte(): byte;
    readBytes(byteCount: int): byte[];
    readBytes(byteCount: int, buffer: byte[], bufferOffset: int): void;
    readChar(): char;
    readCompressedInteger(): int;
    readCompressedSignedInteger(): int;
    readConstant(typeCode: ConstantTypeCode): unknown;
    readDateTime(): DateTime;
    readDecimal(): decimal;
    readDouble(): double;
    readGuid(): Guid;
    readInt16(): short;
    readInt32(): int;
    readInt64(): long;
    readSByte(): sbyte;
    readSerializationTypeCode(): SerializationTypeCode;
    readSerializedString(): string;
    readSignatureHeader(): SignatureHeader;
    readSignatureTypeCode(): SignatureTypeCode;
    readSingle(): float;
    readTypeHandle(): EntityHandle;
    readUInt16(): ushort;
    readUInt32(): uint;
    readUInt64(): ulong;
    readUTF16(byteCount: int): string;
    readUTF8(byteCount: int): string;
    reset(): void;
    tryReadCompressedInteger(value: { value: ref<int> }): boolean;
    tryReadCompressedSignedInteger(value: { value: ref<int> }): boolean;
}


export const BlobReader: {
    new(buffer: ptr<byte>, length: int): BlobReader$instance;
};


export type BlobReader = BlobReader$instance;

export interface BlobWriter$instance {
    readonly blob: Blob;
    readonly length: int;
    offset: int;
    readonly remainingBytes: int;
    align(alignment: int): void;
    clear(): void;
    contentEquals(other: BlobWriter): boolean;
    padTo(offset: int): void;
    toArray(): byte[];
    toArray(start: int, byteCount: int): byte[];
    toImmutableArray(): ImmutableArray_1<CLROf<byte>>;
    toImmutableArray(start: int, byteCount: int): ImmutableArray_1<CLROf<byte>>;
    writeBoolean(value: boolean): void;
    writeByte(value: byte): void;
    writeBytes(value: byte, byteCount: int): void;
    writeBytes(buffer: ptr<byte>, byteCount: int): void;
    writeBytes(source: BlobBuilder): void;
    writeBytes(source: Stream, byteCount: int): int;
    writeBytes(buffer: ImmutableArray_1<CLROf<byte>>): void;
    writeBytes(buffer: ImmutableArray_1<CLROf<byte>>, start: int, byteCount: int): void;
    writeBytes(buffer: byte[]): void;
    writeBytes(buffer: byte[], start: int, byteCount: int): void;
    writeCompressedInteger(value: int): void;
    writeCompressedSignedInteger(value: int): void;
    writeConstant(value: unknown): void;
    writeDateTime(value: DateTime): void;
    writeDecimal(value: decimal): void;
    writeDouble(value: double): void;
    writeGuid(value: Guid): void;
    writeInt16(value: short): void;
    writeInt16BE(value: short): void;
    writeInt32(value: int): void;
    writeInt32BE(value: int): void;
    writeInt64(value: long): void;
    writeReference(reference: int, isSmall: boolean): void;
    writeSByte(value: sbyte): void;
    writeSerializedString(str: string): void;
    writeSingle(value: float): void;
    writeUInt16(value: ushort): void;
    writeUInt16BE(value: ushort): void;
    writeUInt32(value: uint): void;
    writeUInt32BE(value: uint): void;
    writeUInt64(value: ulong): void;
    writeUserString(value: string): void;
    writeUTF16(value: char[]): void;
    writeUTF16(value: string): void;
    writeUTF8(value: string, allowUnpairedSurrogates: boolean): void;
}


export const BlobWriter: {
    new(size: int): BlobWriter$instance;
    new(buffer: byte[]): BlobWriter$instance;
    new(blob: Blob): BlobWriter$instance;
    new(buffer: byte[], start: int, count: int): BlobWriter$instance;
};


export type BlobWriter = BlobWriter$instance;

export interface Constant$instance {
    readonly parent: EntityHandle;
    readonly typeCode: ConstantTypeCode;
    readonly value: BlobHandle;
}


export const Constant: {
    new(): Constant$instance;
};


export type Constant = Constant$instance;

export interface ConstantHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: ConstantHandle): boolean;
    getHashCode(): int;
}


export const ConstantHandle: {
    new(): ConstantHandle$instance;
};


export interface __ConstantHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<ConstantHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ConstantHandle): boolean;
}

export type ConstantHandle = ConstantHandle$instance & __ConstantHandle$views;


export interface CustomAttribute$instance {
    readonly constructor_: EntityHandle;
    readonly parent: EntityHandle;
    readonly value: BlobHandle;
    decodeValue<TType>(provider: ICustomAttributeTypeProvider_1<TType>): CustomAttributeValue_1<TType>;
}


export const CustomAttribute: {
    new(): CustomAttribute$instance;
};


export type CustomAttribute = CustomAttribute$instance;

export interface CustomAttributeHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: CustomAttributeHandle): boolean;
    getHashCode(): int;
}


export const CustomAttributeHandle: {
    new(): CustomAttributeHandle$instance;
};


export interface __CustomAttributeHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CustomAttributeHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CustomAttributeHandle): boolean;
}

export type CustomAttributeHandle = CustomAttributeHandle$instance & __CustomAttributeHandle$views;


export interface CustomAttributeHandleCollection$instance {
    readonly count: int;
    getEnumerator(): CustomAttributeHandleCollection_Enumerator;
}


export const CustomAttributeHandleCollection: {
    new(): CustomAttributeHandleCollection$instance;
};


export interface __CustomAttributeHandleCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<CustomAttributeHandle>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<CustomAttributeHandle>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type CustomAttributeHandleCollection = CustomAttributeHandleCollection$instance & __CustomAttributeHandleCollection$views;


export interface CustomAttributeHandleCollection_Enumerator$instance {
    readonly current: CustomAttributeHandle;
    moveNext(): boolean;
    reset(): void;
}


export const CustomAttributeHandleCollection_Enumerator: {
    new(): CustomAttributeHandleCollection_Enumerator$instance;
};


export interface __CustomAttributeHandleCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<CustomAttributeHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type CustomAttributeHandleCollection_Enumerator = CustomAttributeHandleCollection_Enumerator$instance & __CustomAttributeHandleCollection_Enumerator$views;


export interface CustomAttributeNamedArgument_1$instance<TType> {
    readonly kind: CustomAttributeNamedArgumentKind;
    readonly name: string;
    readonly type_: TType;
    readonly value: unknown;
}


export const CustomAttributeNamedArgument_1: {
    new<TType>(name: string, kind: CustomAttributeNamedArgumentKind, type_: TType, value: unknown): CustomAttributeNamedArgument_1$instance<TType>;
};


export type CustomAttributeNamedArgument_1<TType> = CustomAttributeNamedArgument_1$instance<TType>;

export interface CustomAttributeTypedArgument_1$instance<TType> {
    readonly type_: TType;
    readonly value: unknown;
}


export const CustomAttributeTypedArgument_1: {
    new<TType>(type_: TType, value: unknown): CustomAttributeTypedArgument_1$instance<TType>;
};


export type CustomAttributeTypedArgument_1<TType> = CustomAttributeTypedArgument_1$instance<TType>;

export interface CustomAttributeValue_1$instance<TType> {
    readonly fixedArguments: ImmutableArray_1<CustomAttributeTypedArgument_1<TType>>;
    readonly namedArguments: ImmutableArray_1<CustomAttributeNamedArgument_1<TType>>;
}


export const CustomAttributeValue_1: {
    new<TType>(fixedArguments: ImmutableArray_1<CustomAttributeTypedArgument_1<TType>>, namedArguments: ImmutableArray_1<CustomAttributeNamedArgument_1<TType>>): CustomAttributeValue_1$instance<TType>;
};


export type CustomAttributeValue_1<TType> = CustomAttributeValue_1$instance<TType>;

export interface CustomDebugInformation$instance {
    readonly kind: GuidHandle;
    readonly parent: EntityHandle;
    readonly value: BlobHandle;
}


export const CustomDebugInformation: {
    new(): CustomDebugInformation$instance;
};


export type CustomDebugInformation = CustomDebugInformation$instance;

export interface CustomDebugInformationHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: CustomDebugInformationHandle): boolean;
    getHashCode(): int;
}


export const CustomDebugInformationHandle: {
    new(): CustomDebugInformationHandle$instance;
};


export interface __CustomDebugInformationHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CustomDebugInformationHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CustomDebugInformationHandle): boolean;
}

export type CustomDebugInformationHandle = CustomDebugInformationHandle$instance & __CustomDebugInformationHandle$views;


export interface CustomDebugInformationHandleCollection$instance {
    readonly count: int;
    getEnumerator(): CustomDebugInformationHandleCollection_Enumerator;
}


export const CustomDebugInformationHandleCollection: {
    new(): CustomDebugInformationHandleCollection$instance;
};


export interface __CustomDebugInformationHandleCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<CustomDebugInformationHandle>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<CustomDebugInformationHandle>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type CustomDebugInformationHandleCollection = CustomDebugInformationHandleCollection$instance & __CustomDebugInformationHandleCollection$views;


export interface CustomDebugInformationHandleCollection_Enumerator$instance {
    readonly current: CustomDebugInformationHandle;
    moveNext(): boolean;
    reset(): void;
}


export const CustomDebugInformationHandleCollection_Enumerator: {
    new(): CustomDebugInformationHandleCollection_Enumerator$instance;
};


export interface __CustomDebugInformationHandleCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<CustomDebugInformationHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type CustomDebugInformationHandleCollection_Enumerator = CustomDebugInformationHandleCollection_Enumerator$instance & __CustomDebugInformationHandleCollection_Enumerator$views;


export interface DeclarativeSecurityAttribute$instance {
    readonly action: DeclarativeSecurityAction;
    readonly parent: EntityHandle;
    readonly permissionSet: BlobHandle;
}


export const DeclarativeSecurityAttribute: {
    new(): DeclarativeSecurityAttribute$instance;
};


export type DeclarativeSecurityAttribute = DeclarativeSecurityAttribute$instance;

export interface DeclarativeSecurityAttributeHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: DeclarativeSecurityAttributeHandle): boolean;
    getHashCode(): int;
}


export const DeclarativeSecurityAttributeHandle: {
    new(): DeclarativeSecurityAttributeHandle$instance;
};


export interface __DeclarativeSecurityAttributeHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<DeclarativeSecurityAttributeHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: DeclarativeSecurityAttributeHandle): boolean;
}

export type DeclarativeSecurityAttributeHandle = DeclarativeSecurityAttributeHandle$instance & __DeclarativeSecurityAttributeHandle$views;


export interface DeclarativeSecurityAttributeHandleCollection$instance {
    readonly count: int;
    getEnumerator(): DeclarativeSecurityAttributeHandleCollection_Enumerator;
}


export const DeclarativeSecurityAttributeHandleCollection: {
    new(): DeclarativeSecurityAttributeHandleCollection$instance;
};


export interface __DeclarativeSecurityAttributeHandleCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<DeclarativeSecurityAttributeHandle>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<DeclarativeSecurityAttributeHandle>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type DeclarativeSecurityAttributeHandleCollection = DeclarativeSecurityAttributeHandleCollection$instance & __DeclarativeSecurityAttributeHandleCollection$views;


export interface DeclarativeSecurityAttributeHandleCollection_Enumerator$instance {
    readonly current: DeclarativeSecurityAttributeHandle;
    moveNext(): boolean;
    reset(): void;
}


export const DeclarativeSecurityAttributeHandleCollection_Enumerator: {
    new(): DeclarativeSecurityAttributeHandleCollection_Enumerator$instance;
};


export interface __DeclarativeSecurityAttributeHandleCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<DeclarativeSecurityAttributeHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type DeclarativeSecurityAttributeHandleCollection_Enumerator = DeclarativeSecurityAttributeHandleCollection_Enumerator$instance & __DeclarativeSecurityAttributeHandleCollection_Enumerator$views;


export interface Document$instance {
    readonly hash: BlobHandle;
    readonly hashAlgorithm: GuidHandle;
    readonly language: GuidHandle;
    readonly name: DocumentNameBlobHandle;
}


export const Document: {
    new(): Document$instance;
};


export type Document = Document$instance;

export interface DocumentHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: DocumentHandle): boolean;
    getHashCode(): int;
}


export const DocumentHandle: {
    new(): DocumentHandle$instance;
};


export interface __DocumentHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<DocumentHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: DocumentHandle): boolean;
}

export type DocumentHandle = DocumentHandle$instance & __DocumentHandle$views;


export interface DocumentHandleCollection$instance {
    readonly count: int;
    getEnumerator(): DocumentHandleCollection_Enumerator;
}


export const DocumentHandleCollection: {
    new(): DocumentHandleCollection$instance;
};


export interface __DocumentHandleCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<DocumentHandle>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<DocumentHandle>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type DocumentHandleCollection = DocumentHandleCollection$instance & __DocumentHandleCollection$views;


export interface DocumentHandleCollection_Enumerator$instance {
    readonly current: DocumentHandle;
    moveNext(): boolean;
    reset(): void;
}


export const DocumentHandleCollection_Enumerator: {
    new(): DocumentHandleCollection_Enumerator$instance;
};


export interface __DocumentHandleCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<DocumentHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type DocumentHandleCollection_Enumerator = DocumentHandleCollection_Enumerator$instance & __DocumentHandleCollection_Enumerator$views;


export interface DocumentNameBlobHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: DocumentNameBlobHandle): boolean;
    getHashCode(): int;
}


export const DocumentNameBlobHandle: {
    new(): DocumentNameBlobHandle$instance;
};


export interface __DocumentNameBlobHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<DocumentNameBlobHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: DocumentNameBlobHandle): boolean;
}

export type DocumentNameBlobHandle = DocumentNameBlobHandle$instance & __DocumentNameBlobHandle$views;


export interface EntityHandle$instance {
    readonly isNil: boolean;
    readonly kind: HandleKind;
    equals(obj: unknown): boolean;
    equals(other: EntityHandle): boolean;
    getHashCode(): int;
}


export const EntityHandle: {
    new(): EntityHandle$instance;
    readonly moduleDefinition: ModuleDefinitionHandle;
    readonly assemblyDefinition: AssemblyDefinitionHandle;
};


export interface __EntityHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<EntityHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: EntityHandle): boolean;
}

export type EntityHandle = EntityHandle$instance & __EntityHandle$views;


export interface EventAccessors$instance {
    readonly adder: MethodDefinitionHandle;
    readonly others: ImmutableArray_1<MethodDefinitionHandle>;
    readonly raiser: MethodDefinitionHandle;
    readonly remover: MethodDefinitionHandle;
}


export const EventAccessors: {
    new(): EventAccessors$instance;
};


export type EventAccessors = EventAccessors$instance;

export interface EventDefinition$instance {
    readonly attributes: EventAttributes;
    readonly name: StringHandle;
    readonly type_: EntityHandle;
    getAccessors(): EventAccessors;
    getCustomAttributes(): CustomAttributeHandleCollection;
    getDeclaringType(): TypeDefinitionHandle;
}


export const EventDefinition: {
    new(): EventDefinition$instance;
};


export type EventDefinition = EventDefinition$instance;

export interface EventDefinitionHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: EventDefinitionHandle): boolean;
    getHashCode(): int;
}


export const EventDefinitionHandle: {
    new(): EventDefinitionHandle$instance;
};


export interface __EventDefinitionHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<EventDefinitionHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: EventDefinitionHandle): boolean;
}

export type EventDefinitionHandle = EventDefinitionHandle$instance & __EventDefinitionHandle$views;


export interface EventDefinitionHandleCollection$instance {
    readonly count: int;
    getEnumerator(): EventDefinitionHandleCollection_Enumerator;
}


export const EventDefinitionHandleCollection: {
    new(): EventDefinitionHandleCollection$instance;
};


export interface __EventDefinitionHandleCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<EventDefinitionHandle>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<EventDefinitionHandle>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type EventDefinitionHandleCollection = EventDefinitionHandleCollection$instance & __EventDefinitionHandleCollection$views;


export interface EventDefinitionHandleCollection_Enumerator$instance {
    readonly current: EventDefinitionHandle;
    moveNext(): boolean;
    reset(): void;
}


export const EventDefinitionHandleCollection_Enumerator: {
    new(): EventDefinitionHandleCollection_Enumerator$instance;
};


export interface __EventDefinitionHandleCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<EventDefinitionHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type EventDefinitionHandleCollection_Enumerator = EventDefinitionHandleCollection_Enumerator$instance & __EventDefinitionHandleCollection_Enumerator$views;


export interface ExceptionRegion$instance {
    readonly catchType: EntityHandle;
    readonly filterOffset: int;
    readonly handlerLength: int;
    readonly handlerOffset: int;
    readonly kind: ExceptionRegionKind;
    readonly tryLength: int;
    readonly tryOffset: int;
}


export const ExceptionRegion: {
    new(): ExceptionRegion$instance;
};


export type ExceptionRegion = ExceptionRegion$instance;

export interface ExportedType$instance {
    readonly attributes: TypeAttributes;
    readonly implementation: EntityHandle;
    readonly isForwarder: boolean;
    readonly name: StringHandle;
    readonly namespace_: StringHandle;
    readonly namespaceDefinition: NamespaceDefinitionHandle;
    getCustomAttributes(): CustomAttributeHandleCollection;
}


export const ExportedType: {
    new(): ExportedType$instance;
};


export type ExportedType = ExportedType$instance;

export interface ExportedTypeHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: ExportedTypeHandle): boolean;
    getHashCode(): int;
}


export const ExportedTypeHandle: {
    new(): ExportedTypeHandle$instance;
};


export interface __ExportedTypeHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<ExportedTypeHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ExportedTypeHandle): boolean;
}

export type ExportedTypeHandle = ExportedTypeHandle$instance & __ExportedTypeHandle$views;


export interface ExportedTypeHandleCollection$instance {
    readonly count: int;
    getEnumerator(): ExportedTypeHandleCollection_Enumerator;
}


export const ExportedTypeHandleCollection: {
    new(): ExportedTypeHandleCollection$instance;
};


export interface __ExportedTypeHandleCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<ExportedTypeHandle>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<ExportedTypeHandle>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ExportedTypeHandleCollection = ExportedTypeHandleCollection$instance & __ExportedTypeHandleCollection$views;


export interface ExportedTypeHandleCollection_Enumerator$instance {
    readonly current: ExportedTypeHandle;
    moveNext(): boolean;
    reset(): void;
}


export const ExportedTypeHandleCollection_Enumerator: {
    new(): ExportedTypeHandleCollection_Enumerator$instance;
};


export interface __ExportedTypeHandleCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<ExportedTypeHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type ExportedTypeHandleCollection_Enumerator = ExportedTypeHandleCollection_Enumerator$instance & __ExportedTypeHandleCollection_Enumerator$views;


export interface FieldDefinition$instance {
    readonly attributes: FieldAttributes;
    readonly name: StringHandle;
    readonly signature: BlobHandle;
    decodeSignature<TType, TGenericContext>(provider: ISignatureTypeProvider_2<TType, TGenericContext>, genericContext: TGenericContext): TType;
    getCustomAttributes(): CustomAttributeHandleCollection;
    getDeclaringType(): TypeDefinitionHandle;
    getDefaultValue(): ConstantHandle;
    getMarshallingDescriptor(): BlobHandle;
    getOffset(): int;
    getRelativeVirtualAddress(): int;
}


export const FieldDefinition: {
    new(): FieldDefinition$instance;
};


export type FieldDefinition = FieldDefinition$instance;

export interface FieldDefinitionHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: FieldDefinitionHandle): boolean;
    getHashCode(): int;
}


export const FieldDefinitionHandle: {
    new(): FieldDefinitionHandle$instance;
};


export interface __FieldDefinitionHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<FieldDefinitionHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: FieldDefinitionHandle): boolean;
}

export type FieldDefinitionHandle = FieldDefinitionHandle$instance & __FieldDefinitionHandle$views;


export interface FieldDefinitionHandleCollection$instance {
    readonly count: int;
    getEnumerator(): FieldDefinitionHandleCollection_Enumerator;
}


export const FieldDefinitionHandleCollection: {
    new(): FieldDefinitionHandleCollection$instance;
};


export interface __FieldDefinitionHandleCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<FieldDefinitionHandle>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<FieldDefinitionHandle>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type FieldDefinitionHandleCollection = FieldDefinitionHandleCollection$instance & __FieldDefinitionHandleCollection$views;


export interface FieldDefinitionHandleCollection_Enumerator$instance {
    readonly current: FieldDefinitionHandle;
    moveNext(): boolean;
    reset(): void;
}


export const FieldDefinitionHandleCollection_Enumerator: {
    new(): FieldDefinitionHandleCollection_Enumerator$instance;
};


export interface __FieldDefinitionHandleCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<FieldDefinitionHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type FieldDefinitionHandleCollection_Enumerator = FieldDefinitionHandleCollection_Enumerator$instance & __FieldDefinitionHandleCollection_Enumerator$views;


export interface GenericParameter$instance {
    readonly attributes: GenericParameterAttributes;
    readonly index: int;
    readonly name: StringHandle;
    readonly parent: EntityHandle;
    getConstraints(): GenericParameterConstraintHandleCollection;
    getCustomAttributes(): CustomAttributeHandleCollection;
}


export const GenericParameter: {
    new(): GenericParameter$instance;
};


export type GenericParameter = GenericParameter$instance;

export interface GenericParameterConstraint$instance {
    readonly parameter: GenericParameterHandle;
    readonly type_: EntityHandle;
    getCustomAttributes(): CustomAttributeHandleCollection;
}


export const GenericParameterConstraint: {
    new(): GenericParameterConstraint$instance;
};


export type GenericParameterConstraint = GenericParameterConstraint$instance;

export interface GenericParameterConstraintHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: GenericParameterConstraintHandle): boolean;
    getHashCode(): int;
}


export const GenericParameterConstraintHandle: {
    new(): GenericParameterConstraintHandle$instance;
};


export interface __GenericParameterConstraintHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<GenericParameterConstraintHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: GenericParameterConstraintHandle): boolean;
}

export type GenericParameterConstraintHandle = GenericParameterConstraintHandle$instance & __GenericParameterConstraintHandle$views;


export interface GenericParameterConstraintHandleCollection$instance {
    readonly count: int;
    readonly item: GenericParameterConstraintHandle;
    getEnumerator(): GenericParameterConstraintHandleCollection_Enumerator;
}


export const GenericParameterConstraintHandleCollection: {
    new(): GenericParameterConstraintHandleCollection$instance;
};


export interface __GenericParameterConstraintHandleCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<GenericParameterConstraintHandle>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<GenericParameterConstraintHandle>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type GenericParameterConstraintHandleCollection = GenericParameterConstraintHandleCollection$instance & __GenericParameterConstraintHandleCollection$views;


export interface GenericParameterConstraintHandleCollection_Enumerator$instance {
    readonly current: GenericParameterConstraintHandle;
    moveNext(): boolean;
    reset(): void;
}


export const GenericParameterConstraintHandleCollection_Enumerator: {
    new(): GenericParameterConstraintHandleCollection_Enumerator$instance;
};


export interface __GenericParameterConstraintHandleCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<GenericParameterConstraintHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type GenericParameterConstraintHandleCollection_Enumerator = GenericParameterConstraintHandleCollection_Enumerator$instance & __GenericParameterConstraintHandleCollection_Enumerator$views;


export interface GenericParameterHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: GenericParameterHandle): boolean;
    getHashCode(): int;
}


export const GenericParameterHandle: {
    new(): GenericParameterHandle$instance;
};


export interface __GenericParameterHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<GenericParameterHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: GenericParameterHandle): boolean;
}

export type GenericParameterHandle = GenericParameterHandle$instance & __GenericParameterHandle$views;


export interface GenericParameterHandleCollection$instance {
    readonly count: int;
    readonly item: GenericParameterHandle;
    getEnumerator(): GenericParameterHandleCollection_Enumerator;
}


export const GenericParameterHandleCollection: {
    new(): GenericParameterHandleCollection$instance;
};


export interface __GenericParameterHandleCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<GenericParameterHandle>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<GenericParameterHandle>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type GenericParameterHandleCollection = GenericParameterHandleCollection$instance & __GenericParameterHandleCollection$views;


export interface GenericParameterHandleCollection_Enumerator$instance {
    readonly current: GenericParameterHandle;
    moveNext(): boolean;
    reset(): void;
}


export const GenericParameterHandleCollection_Enumerator: {
    new(): GenericParameterHandleCollection_Enumerator$instance;
};


export interface __GenericParameterHandleCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<GenericParameterHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type GenericParameterHandleCollection_Enumerator = GenericParameterHandleCollection_Enumerator$instance & __GenericParameterHandleCollection_Enumerator$views;


export interface GuidHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: GuidHandle): boolean;
    getHashCode(): int;
}


export const GuidHandle: {
    new(): GuidHandle$instance;
};


export interface __GuidHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<GuidHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: GuidHandle): boolean;
}

export type GuidHandle = GuidHandle$instance & __GuidHandle$views;


export interface Handle$instance {
    readonly isNil: boolean;
    readonly kind: HandleKind;
    equals(obj: unknown): boolean;
    equals(other: Handle): boolean;
    getHashCode(): int;
}


export const Handle: {
    new(): Handle$instance;
    readonly moduleDefinition: ModuleDefinitionHandle;
    readonly assemblyDefinition: AssemblyDefinitionHandle;
};


export interface __Handle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Handle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Handle): boolean;
}

export type Handle = Handle$instance & __Handle$views;


export interface ImportDefinition$instance {
    readonly alias: BlobHandle;
    readonly kind: ImportDefinitionKind;
    readonly targetAssembly: AssemblyReferenceHandle;
    readonly targetNamespace: BlobHandle;
    readonly targetType: EntityHandle;
}


export const ImportDefinition: {
    new(): ImportDefinition$instance;
};


export type ImportDefinition = ImportDefinition$instance;

export interface ImportDefinitionCollection$instance {
    getEnumerator(): ImportDefinitionCollection_Enumerator;
}


export const ImportDefinitionCollection: {
    new(): ImportDefinitionCollection$instance;
};


export interface __ImportDefinitionCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<ImportDefinition>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ImportDefinitionCollection = ImportDefinitionCollection$instance & __ImportDefinitionCollection$views;


export interface ImportDefinitionCollection_Enumerator$instance {
    readonly current: ImportDefinition;
    moveNext(): boolean;
    reset(): void;
}


export const ImportDefinitionCollection_Enumerator: {
    new(): ImportDefinitionCollection_Enumerator$instance;
};


export interface __ImportDefinitionCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<ImportDefinition>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ImportDefinitionCollection_Enumerator = ImportDefinitionCollection_Enumerator$instance & __ImportDefinitionCollection_Enumerator$views;


export interface ImportScope$instance {
    readonly importsBlob: BlobHandle;
    readonly parent: ImportScopeHandle;
    getImports(): ImportDefinitionCollection;
}


export const ImportScope: {
    new(): ImportScope$instance;
};


export type ImportScope = ImportScope$instance;

export interface ImportScopeCollection$instance {
    readonly count: int;
    getEnumerator(): ImportScopeCollection_Enumerator;
}


export const ImportScopeCollection: {
    new(): ImportScopeCollection$instance;
};


export interface __ImportScopeCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<ImportScopeHandle>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<ImportScopeHandle>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ImportScopeCollection = ImportScopeCollection$instance & __ImportScopeCollection$views;


export interface ImportScopeCollection_Enumerator$instance {
    readonly current: ImportScopeHandle;
    moveNext(): boolean;
    reset(): void;
}


export const ImportScopeCollection_Enumerator: {
    new(): ImportScopeCollection_Enumerator$instance;
};


export interface __ImportScopeCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<ImportScopeHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type ImportScopeCollection_Enumerator = ImportScopeCollection_Enumerator$instance & __ImportScopeCollection_Enumerator$views;


export interface ImportScopeHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: ImportScopeHandle): boolean;
    getHashCode(): int;
}


export const ImportScopeHandle: {
    new(): ImportScopeHandle$instance;
};


export interface __ImportScopeHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<ImportScopeHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ImportScopeHandle): boolean;
}

export type ImportScopeHandle = ImportScopeHandle$instance & __ImportScopeHandle$views;


export interface InterfaceImplementation$instance {
    readonly interface_: EntityHandle;
    getCustomAttributes(): CustomAttributeHandleCollection;
}


export const InterfaceImplementation: {
    new(): InterfaceImplementation$instance;
};


export type InterfaceImplementation = InterfaceImplementation$instance;

export interface InterfaceImplementationHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: InterfaceImplementationHandle): boolean;
    getHashCode(): int;
}


export const InterfaceImplementationHandle: {
    new(): InterfaceImplementationHandle$instance;
};


export interface __InterfaceImplementationHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<InterfaceImplementationHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: InterfaceImplementationHandle): boolean;
}

export type InterfaceImplementationHandle = InterfaceImplementationHandle$instance & __InterfaceImplementationHandle$views;


export interface InterfaceImplementationHandleCollection$instance {
    readonly count: int;
    getEnumerator(): InterfaceImplementationHandleCollection_Enumerator;
}


export const InterfaceImplementationHandleCollection: {
    new(): InterfaceImplementationHandleCollection$instance;
};


export interface __InterfaceImplementationHandleCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<InterfaceImplementationHandle>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<InterfaceImplementationHandle>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type InterfaceImplementationHandleCollection = InterfaceImplementationHandleCollection$instance & __InterfaceImplementationHandleCollection$views;


export interface InterfaceImplementationHandleCollection_Enumerator$instance {
    readonly current: InterfaceImplementationHandle;
    moveNext(): boolean;
    reset(): void;
}


export const InterfaceImplementationHandleCollection_Enumerator: {
    new(): InterfaceImplementationHandleCollection_Enumerator$instance;
};


export interface __InterfaceImplementationHandleCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<InterfaceImplementationHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type InterfaceImplementationHandleCollection_Enumerator = InterfaceImplementationHandleCollection_Enumerator$instance & __InterfaceImplementationHandleCollection_Enumerator$views;


export interface LocalConstant$instance {
    readonly name: StringHandle;
    readonly signature: BlobHandle;
}


export const LocalConstant: {
    new(): LocalConstant$instance;
};


export type LocalConstant = LocalConstant$instance;

export interface LocalConstantHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: LocalConstantHandle): boolean;
    getHashCode(): int;
}


export const LocalConstantHandle: {
    new(): LocalConstantHandle$instance;
};


export interface __LocalConstantHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<LocalConstantHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: LocalConstantHandle): boolean;
}

export type LocalConstantHandle = LocalConstantHandle$instance & __LocalConstantHandle$views;


export interface LocalConstantHandleCollection$instance {
    readonly count: int;
    getEnumerator(): LocalConstantHandleCollection_Enumerator;
}


export const LocalConstantHandleCollection: {
    new(): LocalConstantHandleCollection$instance;
};


export interface __LocalConstantHandleCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<LocalConstantHandle>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<LocalConstantHandle>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type LocalConstantHandleCollection = LocalConstantHandleCollection$instance & __LocalConstantHandleCollection$views;


export interface LocalConstantHandleCollection_Enumerator$instance {
    readonly current: LocalConstantHandle;
    moveNext(): boolean;
    reset(): void;
}


export const LocalConstantHandleCollection_Enumerator: {
    new(): LocalConstantHandleCollection_Enumerator$instance;
};


export interface __LocalConstantHandleCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<LocalConstantHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type LocalConstantHandleCollection_Enumerator = LocalConstantHandleCollection_Enumerator$instance & __LocalConstantHandleCollection_Enumerator$views;


export interface LocalScope$instance {
    readonly endOffset: int;
    readonly importScope: ImportScopeHandle;
    readonly length: int;
    readonly method: MethodDefinitionHandle;
    readonly startOffset: int;
    getChildren(): LocalScopeHandleCollection_ChildrenEnumerator;
    getLocalConstants(): LocalConstantHandleCollection;
    getLocalVariables(): LocalVariableHandleCollection;
}


export const LocalScope: {
    new(): LocalScope$instance;
};


export type LocalScope = LocalScope$instance;

export interface LocalScopeHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: LocalScopeHandle): boolean;
    getHashCode(): int;
}


export const LocalScopeHandle: {
    new(): LocalScopeHandle$instance;
};


export interface __LocalScopeHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<LocalScopeHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: LocalScopeHandle): boolean;
}

export type LocalScopeHandle = LocalScopeHandle$instance & __LocalScopeHandle$views;


export interface LocalScopeHandleCollection$instance {
    readonly count: int;
    getEnumerator(): LocalScopeHandleCollection_Enumerator;
}


export const LocalScopeHandleCollection: {
    new(): LocalScopeHandleCollection$instance;
};


export interface __LocalScopeHandleCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<LocalScopeHandle>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<LocalScopeHandle>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type LocalScopeHandleCollection = LocalScopeHandleCollection$instance & __LocalScopeHandleCollection$views;


export interface LocalScopeHandleCollection_ChildrenEnumerator$instance {
    readonly current: LocalScopeHandle;
    moveNext(): boolean;
    reset(): void;
}


export const LocalScopeHandleCollection_ChildrenEnumerator: {
    new(): LocalScopeHandleCollection_ChildrenEnumerator$instance;
};


export interface __LocalScopeHandleCollection_ChildrenEnumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<LocalScopeHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type LocalScopeHandleCollection_ChildrenEnumerator = LocalScopeHandleCollection_ChildrenEnumerator$instance & __LocalScopeHandleCollection_ChildrenEnumerator$views;


export interface LocalScopeHandleCollection_Enumerator$instance {
    readonly current: LocalScopeHandle;
    moveNext(): boolean;
    reset(): void;
}


export const LocalScopeHandleCollection_Enumerator: {
    new(): LocalScopeHandleCollection_Enumerator$instance;
};


export interface __LocalScopeHandleCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<LocalScopeHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type LocalScopeHandleCollection_Enumerator = LocalScopeHandleCollection_Enumerator$instance & __LocalScopeHandleCollection_Enumerator$views;


export interface LocalVariable$instance {
    readonly attributes: LocalVariableAttributes;
    readonly index: int;
    readonly name: StringHandle;
}


export const LocalVariable: {
    new(): LocalVariable$instance;
};


export type LocalVariable = LocalVariable$instance;

export interface LocalVariableHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: LocalVariableHandle): boolean;
    getHashCode(): int;
}


export const LocalVariableHandle: {
    new(): LocalVariableHandle$instance;
};


export interface __LocalVariableHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<LocalVariableHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: LocalVariableHandle): boolean;
}

export type LocalVariableHandle = LocalVariableHandle$instance & __LocalVariableHandle$views;


export interface LocalVariableHandleCollection$instance {
    readonly count: int;
    getEnumerator(): LocalVariableHandleCollection_Enumerator;
}


export const LocalVariableHandleCollection: {
    new(): LocalVariableHandleCollection$instance;
};


export interface __LocalVariableHandleCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<LocalVariableHandle>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<LocalVariableHandle>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type LocalVariableHandleCollection = LocalVariableHandleCollection$instance & __LocalVariableHandleCollection$views;


export interface LocalVariableHandleCollection_Enumerator$instance {
    readonly current: LocalVariableHandle;
    moveNext(): boolean;
    reset(): void;
}


export const LocalVariableHandleCollection_Enumerator: {
    new(): LocalVariableHandleCollection_Enumerator$instance;
};


export interface __LocalVariableHandleCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<LocalVariableHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type LocalVariableHandleCollection_Enumerator = LocalVariableHandleCollection_Enumerator$instance & __LocalVariableHandleCollection_Enumerator$views;


export interface ManifestResource$instance {
    readonly attributes: ManifestResourceAttributes;
    readonly implementation: EntityHandle;
    readonly name: StringHandle;
    readonly offset: long;
    getCustomAttributes(): CustomAttributeHandleCollection;
}


export const ManifestResource: {
    new(): ManifestResource$instance;
};


export type ManifestResource = ManifestResource$instance;

export interface ManifestResourceHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: ManifestResourceHandle): boolean;
    getHashCode(): int;
}


export const ManifestResourceHandle: {
    new(): ManifestResourceHandle$instance;
};


export interface __ManifestResourceHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<ManifestResourceHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ManifestResourceHandle): boolean;
}

export type ManifestResourceHandle = ManifestResourceHandle$instance & __ManifestResourceHandle$views;


export interface ManifestResourceHandleCollection$instance {
    readonly count: int;
    getEnumerator(): ManifestResourceHandleCollection_Enumerator;
}


export const ManifestResourceHandleCollection: {
    new(): ManifestResourceHandleCollection$instance;
};


export interface __ManifestResourceHandleCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<ManifestResourceHandle>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<ManifestResourceHandle>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ManifestResourceHandleCollection = ManifestResourceHandleCollection$instance & __ManifestResourceHandleCollection$views;


export interface ManifestResourceHandleCollection_Enumerator$instance {
    readonly current: ManifestResourceHandle;
    moveNext(): boolean;
    reset(): void;
}


export const ManifestResourceHandleCollection_Enumerator: {
    new(): ManifestResourceHandleCollection_Enumerator$instance;
};


export interface __ManifestResourceHandleCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<ManifestResourceHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type ManifestResourceHandleCollection_Enumerator = ManifestResourceHandleCollection_Enumerator$instance & __ManifestResourceHandleCollection_Enumerator$views;


export interface MemberReference$instance {
    readonly name: StringHandle;
    readonly parent: EntityHandle;
    readonly signature: BlobHandle;
    decodeFieldSignature<TType, TGenericContext>(provider: ISignatureTypeProvider_2<TType, TGenericContext>, genericContext: TGenericContext): TType;
    decodeMethodSignature<TType, TGenericContext>(provider: ISignatureTypeProvider_2<TType, TGenericContext>, genericContext: TGenericContext): MethodSignature_1<TType>;
    getCustomAttributes(): CustomAttributeHandleCollection;
    getKind(): MemberReferenceKind;
}


export const MemberReference: {
    new(): MemberReference$instance;
};


export type MemberReference = MemberReference$instance;

export interface MemberReferenceHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: MemberReferenceHandle): boolean;
    getHashCode(): int;
}


export const MemberReferenceHandle: {
    new(): MemberReferenceHandle$instance;
};


export interface __MemberReferenceHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<MemberReferenceHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: MemberReferenceHandle): boolean;
}

export type MemberReferenceHandle = MemberReferenceHandle$instance & __MemberReferenceHandle$views;


export interface MemberReferenceHandleCollection$instance {
    readonly count: int;
    getEnumerator(): MemberReferenceHandleCollection_Enumerator;
}


export const MemberReferenceHandleCollection: {
    new(): MemberReferenceHandleCollection$instance;
};


export interface __MemberReferenceHandleCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<MemberReferenceHandle>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<MemberReferenceHandle>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type MemberReferenceHandleCollection = MemberReferenceHandleCollection$instance & __MemberReferenceHandleCollection$views;


export interface MemberReferenceHandleCollection_Enumerator$instance {
    readonly current: MemberReferenceHandle;
    moveNext(): boolean;
    reset(): void;
}


export const MemberReferenceHandleCollection_Enumerator: {
    new(): MemberReferenceHandleCollection_Enumerator$instance;
};


export interface __MemberReferenceHandleCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<MemberReferenceHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type MemberReferenceHandleCollection_Enumerator = MemberReferenceHandleCollection_Enumerator$instance & __MemberReferenceHandleCollection_Enumerator$views;


export interface MetadataStringComparer$instance {
    equals(handle: StringHandle, value: string): boolean;
    equals(handle: StringHandle, value: string, ignoreCase: boolean): boolean;
    equals(handle: NamespaceDefinitionHandle, value: string): boolean;
    equals(handle: NamespaceDefinitionHandle, value: string, ignoreCase: boolean): boolean;
    equals(handle: DocumentNameBlobHandle, value: string): boolean;
    equals(handle: DocumentNameBlobHandle, value: string, ignoreCase: boolean): boolean;
    startsWith(handle: StringHandle, value: string): boolean;
    startsWith(handle: StringHandle, value: string, ignoreCase: boolean): boolean;
}


export const MetadataStringComparer: {
    new(): MetadataStringComparer$instance;
};


export type MetadataStringComparer = MetadataStringComparer$instance;

export interface MethodDebugInformation$instance {
    readonly document: DocumentHandle;
    readonly localSignature: StandaloneSignatureHandle;
    readonly sequencePointsBlob: BlobHandle;
    getSequencePoints(): SequencePointCollection;
    getStateMachineKickoffMethod(): MethodDefinitionHandle;
}


export const MethodDebugInformation: {
    new(): MethodDebugInformation$instance;
};


export type MethodDebugInformation = MethodDebugInformation$instance;

export interface MethodDebugInformationHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: MethodDebugInformationHandle): boolean;
    getHashCode(): int;
    toDefinitionHandle(): MethodDefinitionHandle;
}


export const MethodDebugInformationHandle: {
    new(): MethodDebugInformationHandle$instance;
};


export interface __MethodDebugInformationHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<MethodDebugInformationHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: MethodDebugInformationHandle): boolean;
}

export type MethodDebugInformationHandle = MethodDebugInformationHandle$instance & __MethodDebugInformationHandle$views;


export interface MethodDebugInformationHandleCollection$instance {
    readonly count: int;
    getEnumerator(): MethodDebugInformationHandleCollection_Enumerator;
}


export const MethodDebugInformationHandleCollection: {
    new(): MethodDebugInformationHandleCollection$instance;
};


export interface __MethodDebugInformationHandleCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<MethodDebugInformationHandle>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<MethodDebugInformationHandle>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type MethodDebugInformationHandleCollection = MethodDebugInformationHandleCollection$instance & __MethodDebugInformationHandleCollection$views;


export interface MethodDebugInformationHandleCollection_Enumerator$instance {
    readonly current: MethodDebugInformationHandle;
    moveNext(): boolean;
    reset(): void;
}


export const MethodDebugInformationHandleCollection_Enumerator: {
    new(): MethodDebugInformationHandleCollection_Enumerator$instance;
};


export interface __MethodDebugInformationHandleCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<MethodDebugInformationHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type MethodDebugInformationHandleCollection_Enumerator = MethodDebugInformationHandleCollection_Enumerator$instance & __MethodDebugInformationHandleCollection_Enumerator$views;


export interface MethodDefinition$instance {
    readonly attributes: MethodAttributes;
    readonly implAttributes: MethodImplAttributes;
    readonly name: StringHandle;
    readonly relativeVirtualAddress: int;
    readonly signature: BlobHandle;
    decodeSignature<TType, TGenericContext>(provider: ISignatureTypeProvider_2<TType, TGenericContext>, genericContext: TGenericContext): MethodSignature_1<TType>;
    getCustomAttributes(): CustomAttributeHandleCollection;
    getDeclarativeSecurityAttributes(): DeclarativeSecurityAttributeHandleCollection;
    getDeclaringType(): TypeDefinitionHandle;
    getGenericParameters(): GenericParameterHandleCollection;
    getImport(): MethodImport;
    getParameters(): ParameterHandleCollection;
}


export const MethodDefinition: {
    new(): MethodDefinition$instance;
};


export type MethodDefinition = MethodDefinition$instance;

export interface MethodDefinitionHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: MethodDefinitionHandle): boolean;
    getHashCode(): int;
    toDebugInformationHandle(): MethodDebugInformationHandle;
}


export const MethodDefinitionHandle: {
    new(): MethodDefinitionHandle$instance;
};


export interface __MethodDefinitionHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<MethodDefinitionHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: MethodDefinitionHandle): boolean;
}

export type MethodDefinitionHandle = MethodDefinitionHandle$instance & __MethodDefinitionHandle$views;


export interface MethodDefinitionHandleCollection$instance {
    readonly count: int;
    getEnumerator(): MethodDefinitionHandleCollection_Enumerator;
}


export const MethodDefinitionHandleCollection: {
    new(): MethodDefinitionHandleCollection$instance;
};


export interface __MethodDefinitionHandleCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<MethodDefinitionHandle>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<MethodDefinitionHandle>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type MethodDefinitionHandleCollection = MethodDefinitionHandleCollection$instance & __MethodDefinitionHandleCollection$views;


export interface MethodDefinitionHandleCollection_Enumerator$instance {
    readonly current: MethodDefinitionHandle;
    moveNext(): boolean;
    reset(): void;
}


export const MethodDefinitionHandleCollection_Enumerator: {
    new(): MethodDefinitionHandleCollection_Enumerator$instance;
};


export interface __MethodDefinitionHandleCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<MethodDefinitionHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type MethodDefinitionHandleCollection_Enumerator = MethodDefinitionHandleCollection_Enumerator$instance & __MethodDefinitionHandleCollection_Enumerator$views;


export interface MethodImplementation$instance {
    readonly methodBody: EntityHandle;
    readonly methodDeclaration: EntityHandle;
    readonly type_: TypeDefinitionHandle;
    getCustomAttributes(): CustomAttributeHandleCollection;
}


export const MethodImplementation: {
    new(): MethodImplementation$instance;
};


export type MethodImplementation = MethodImplementation$instance;

export interface MethodImplementationHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: MethodImplementationHandle): boolean;
    getHashCode(): int;
}


export const MethodImplementationHandle: {
    new(): MethodImplementationHandle$instance;
};


export interface __MethodImplementationHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<MethodImplementationHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: MethodImplementationHandle): boolean;
}

export type MethodImplementationHandle = MethodImplementationHandle$instance & __MethodImplementationHandle$views;


export interface MethodImplementationHandleCollection$instance {
    readonly count: int;
    getEnumerator(): MethodImplementationHandleCollection_Enumerator;
}


export const MethodImplementationHandleCollection: {
    new(): MethodImplementationHandleCollection$instance;
};


export interface __MethodImplementationHandleCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<MethodImplementationHandle>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<MethodImplementationHandle>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type MethodImplementationHandleCollection = MethodImplementationHandleCollection$instance & __MethodImplementationHandleCollection$views;


export interface MethodImplementationHandleCollection_Enumerator$instance {
    readonly current: MethodImplementationHandle;
    moveNext(): boolean;
    reset(): void;
}


export const MethodImplementationHandleCollection_Enumerator: {
    new(): MethodImplementationHandleCollection_Enumerator$instance;
};


export interface __MethodImplementationHandleCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<MethodImplementationHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type MethodImplementationHandleCollection_Enumerator = MethodImplementationHandleCollection_Enumerator$instance & __MethodImplementationHandleCollection_Enumerator$views;


export interface MethodImport$instance {
    readonly attributes: MethodImportAttributes;
    readonly module_: ModuleReferenceHandle;
    readonly name: StringHandle;
}


export const MethodImport: {
    new(): MethodImport$instance;
};


export type MethodImport = MethodImport$instance;

export interface MethodSignature_1$instance<TType> {
    readonly genericParameterCount: int;
    readonly header: SignatureHeader;
    readonly parameterTypes: ImmutableArray_1<TType>;
    readonly requiredParameterCount: int;
    readonly returnType: TType;
}


export const MethodSignature_1: {
    new<TType>(header: SignatureHeader, returnType: TType, requiredParameterCount: int, genericParameterCount: int, parameterTypes: ImmutableArray_1<TType>): MethodSignature_1$instance<TType>;
};


export type MethodSignature_1<TType> = MethodSignature_1$instance<TType>;

export interface MethodSpecification$instance {
    readonly method: EntityHandle;
    readonly signature: BlobHandle;
    decodeSignature<TType, TGenericContext>(provider: ISignatureTypeProvider_2<TType, TGenericContext>, genericContext: TGenericContext): ImmutableArray_1<TType>;
    getCustomAttributes(): CustomAttributeHandleCollection;
}


export const MethodSpecification: {
    new(): MethodSpecification$instance;
};


export type MethodSpecification = MethodSpecification$instance;

export interface MethodSpecificationHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: MethodSpecificationHandle): boolean;
    getHashCode(): int;
}


export const MethodSpecificationHandle: {
    new(): MethodSpecificationHandle$instance;
};


export interface __MethodSpecificationHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<MethodSpecificationHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: MethodSpecificationHandle): boolean;
}

export type MethodSpecificationHandle = MethodSpecificationHandle$instance & __MethodSpecificationHandle$views;


export interface ModuleDefinition$instance {
    readonly baseGenerationId: GuidHandle;
    readonly generation: int;
    readonly generationId: GuidHandle;
    readonly mvid: GuidHandle;
    readonly name: StringHandle;
    getCustomAttributes(): CustomAttributeHandleCollection;
}


export const ModuleDefinition: {
    new(): ModuleDefinition$instance;
};


export type ModuleDefinition = ModuleDefinition$instance;

export interface ModuleDefinitionHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: ModuleDefinitionHandle): boolean;
    getHashCode(): int;
}


export const ModuleDefinitionHandle: {
    new(): ModuleDefinitionHandle$instance;
};


export interface __ModuleDefinitionHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<ModuleDefinitionHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ModuleDefinitionHandle): boolean;
}

export type ModuleDefinitionHandle = ModuleDefinitionHandle$instance & __ModuleDefinitionHandle$views;


export interface ModuleReference$instance {
    readonly name: StringHandle;
    getCustomAttributes(): CustomAttributeHandleCollection;
}


export const ModuleReference: {
    new(): ModuleReference$instance;
};


export type ModuleReference = ModuleReference$instance;

export interface ModuleReferenceHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: ModuleReferenceHandle): boolean;
    getHashCode(): int;
}


export const ModuleReferenceHandle: {
    new(): ModuleReferenceHandle$instance;
};


export interface __ModuleReferenceHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<ModuleReferenceHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ModuleReferenceHandle): boolean;
}

export type ModuleReferenceHandle = ModuleReferenceHandle$instance & __ModuleReferenceHandle$views;


export interface NamespaceDefinition$instance {
    readonly exportedTypes: ImmutableArray_1<ExportedTypeHandle>;
    readonly name: StringHandle;
    readonly namespaceDefinitions: ImmutableArray_1<NamespaceDefinitionHandle>;
    readonly parent: NamespaceDefinitionHandle;
    readonly typeDefinitions: ImmutableArray_1<TypeDefinitionHandle>;
}


export const NamespaceDefinition: {
    new(): NamespaceDefinition$instance;
};


export type NamespaceDefinition = NamespaceDefinition$instance;

export interface NamespaceDefinitionHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: NamespaceDefinitionHandle): boolean;
    getHashCode(): int;
}


export const NamespaceDefinitionHandle: {
    new(): NamespaceDefinitionHandle$instance;
};


export interface __NamespaceDefinitionHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<NamespaceDefinitionHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: NamespaceDefinitionHandle): boolean;
}

export type NamespaceDefinitionHandle = NamespaceDefinitionHandle$instance & __NamespaceDefinitionHandle$views;


export interface Parameter$instance {
    readonly attributes: ParameterAttributes;
    readonly name: StringHandle;
    readonly sequenceNumber: int;
    getCustomAttributes(): CustomAttributeHandleCollection;
    getDefaultValue(): ConstantHandle;
    getMarshallingDescriptor(): BlobHandle;
}


export const Parameter: {
    new(): Parameter$instance;
};


export type Parameter = Parameter$instance;

export interface ParameterHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: ParameterHandle): boolean;
    getHashCode(): int;
}


export const ParameterHandle: {
    new(): ParameterHandle$instance;
};


export interface __ParameterHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<ParameterHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ParameterHandle): boolean;
}

export type ParameterHandle = ParameterHandle$instance & __ParameterHandle$views;


export interface ParameterHandleCollection$instance {
    readonly count: int;
    getEnumerator(): ParameterHandleCollection_Enumerator;
}


export const ParameterHandleCollection: {
    new(): ParameterHandleCollection$instance;
};


export interface __ParameterHandleCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<ParameterHandle>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<ParameterHandle>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ParameterHandleCollection = ParameterHandleCollection$instance & __ParameterHandleCollection$views;


export interface ParameterHandleCollection_Enumerator$instance {
    readonly current: ParameterHandle;
    moveNext(): boolean;
    reset(): void;
}


export const ParameterHandleCollection_Enumerator: {
    new(): ParameterHandleCollection_Enumerator$instance;
};


export interface __ParameterHandleCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<ParameterHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type ParameterHandleCollection_Enumerator = ParameterHandleCollection_Enumerator$instance & __ParameterHandleCollection_Enumerator$views;


export interface PropertyAccessors$instance {
    readonly getter: MethodDefinitionHandle;
    readonly others: ImmutableArray_1<MethodDefinitionHandle>;
    readonly setter: MethodDefinitionHandle;
}


export const PropertyAccessors: {
    new(): PropertyAccessors$instance;
};


export type PropertyAccessors = PropertyAccessors$instance;

export interface PropertyDefinition$instance {
    readonly attributes: PropertyAttributes;
    readonly name: StringHandle;
    readonly signature: BlobHandle;
    decodeSignature<TType, TGenericContext>(provider: ISignatureTypeProvider_2<TType, TGenericContext>, genericContext: TGenericContext): MethodSignature_1<TType>;
    getAccessors(): PropertyAccessors;
    getCustomAttributes(): CustomAttributeHandleCollection;
    getDeclaringType(): TypeDefinitionHandle;
    getDefaultValue(): ConstantHandle;
}


export const PropertyDefinition: {
    new(): PropertyDefinition$instance;
};


export type PropertyDefinition = PropertyDefinition$instance;

export interface PropertyDefinitionHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: PropertyDefinitionHandle): boolean;
    getHashCode(): int;
}


export const PropertyDefinitionHandle: {
    new(): PropertyDefinitionHandle$instance;
};


export interface __PropertyDefinitionHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<PropertyDefinitionHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: PropertyDefinitionHandle): boolean;
}

export type PropertyDefinitionHandle = PropertyDefinitionHandle$instance & __PropertyDefinitionHandle$views;


export interface PropertyDefinitionHandleCollection$instance {
    readonly count: int;
    getEnumerator(): PropertyDefinitionHandleCollection_Enumerator;
}


export const PropertyDefinitionHandleCollection: {
    new(): PropertyDefinitionHandleCollection$instance;
};


export interface __PropertyDefinitionHandleCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<PropertyDefinitionHandle>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<PropertyDefinitionHandle>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type PropertyDefinitionHandleCollection = PropertyDefinitionHandleCollection$instance & __PropertyDefinitionHandleCollection$views;


export interface PropertyDefinitionHandleCollection_Enumerator$instance {
    readonly current: PropertyDefinitionHandle;
    moveNext(): boolean;
    reset(): void;
}


export const PropertyDefinitionHandleCollection_Enumerator: {
    new(): PropertyDefinitionHandleCollection_Enumerator$instance;
};


export interface __PropertyDefinitionHandleCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<PropertyDefinitionHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type PropertyDefinitionHandleCollection_Enumerator = PropertyDefinitionHandleCollection_Enumerator$instance & __PropertyDefinitionHandleCollection_Enumerator$views;


export interface ReservedBlob_1$instance<THandle extends unknown> {
    readonly content: Blob;
    readonly handle: THandle;
    createWriter(): BlobWriter;
}


export const ReservedBlob_1: {
    new<THandle extends unknown>(): ReservedBlob_1$instance<THandle>;
};


export type ReservedBlob_1<THandle> = ReservedBlob_1$instance<THandle>;

export interface SequencePoint$instance {
    readonly document: DocumentHandle;
    readonly endColumn: int;
    readonly endLine: int;
    readonly isHidden: boolean;
    readonly offset: int;
    readonly startColumn: int;
    readonly startLine: int;
    equals(obj: unknown): boolean;
    equals(other: SequencePoint): boolean;
    getHashCode(): int;
}


export const SequencePoint: {
    new(): SequencePoint$instance;
    readonly hiddenLine: int;
};


export interface __SequencePoint$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SequencePoint>;

    // Structural method bridges for numeric interface constraints
    Equals(other: SequencePoint): boolean;
}

export type SequencePoint = SequencePoint$instance & __SequencePoint$views;


export interface SequencePointCollection$instance {
    getEnumerator(): SequencePointCollection_Enumerator;
}


export const SequencePointCollection: {
    new(): SequencePointCollection$instance;
};


export interface __SequencePointCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<SequencePoint>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type SequencePointCollection = SequencePointCollection$instance & __SequencePointCollection$views;


export interface SequencePointCollection_Enumerator$instance {
    readonly current: SequencePoint;
    moveNext(): boolean;
    reset(): void;
}


export const SequencePointCollection_Enumerator: {
    new(): SequencePointCollection_Enumerator$instance;
};


export interface __SequencePointCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<SequencePoint>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type SequencePointCollection_Enumerator = SequencePointCollection_Enumerator$instance & __SequencePointCollection_Enumerator$views;


export interface SignatureHeader$instance {
    readonly attributes: SignatureAttributes;
    readonly callingConvention: SignatureCallingConvention;
    readonly hasExplicitThis: boolean;
    readonly isGeneric: boolean;
    readonly isInstance: boolean;
    readonly kind: SignatureKind;
    readonly rawValue: byte;
    equals(obj: unknown): boolean;
    equals(other: SignatureHeader): boolean;
    getHashCode(): int;
    toString(): string;
}


export const SignatureHeader: {
    new(rawValue: byte): SignatureHeader$instance;
    new(kind: SignatureKind, convention: SignatureCallingConvention, attributes: SignatureAttributes): SignatureHeader$instance;
    readonly callingConventionOrKindMask: byte;
};


export interface __SignatureHeader$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SignatureHeader>;

    // Structural method bridges for numeric interface constraints
    Equals(other: SignatureHeader): boolean;
}

export type SignatureHeader = SignatureHeader$instance & __SignatureHeader$views;


export interface StandaloneSignature$instance {
    readonly signature: BlobHandle;
    decodeLocalSignature<TType, TGenericContext>(provider: ISignatureTypeProvider_2<TType, TGenericContext>, genericContext: TGenericContext): ImmutableArray_1<TType>;
    decodeMethodSignature<TType, TGenericContext>(provider: ISignatureTypeProvider_2<TType, TGenericContext>, genericContext: TGenericContext): MethodSignature_1<TType>;
    getCustomAttributes(): CustomAttributeHandleCollection;
    getKind(): StandaloneSignatureKind;
}


export const StandaloneSignature: {
    new(): StandaloneSignature$instance;
};


export type StandaloneSignature = StandaloneSignature$instance;

export interface StandaloneSignatureHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: StandaloneSignatureHandle): boolean;
    getHashCode(): int;
}


export const StandaloneSignatureHandle: {
    new(): StandaloneSignatureHandle$instance;
};


export interface __StandaloneSignatureHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<StandaloneSignatureHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: StandaloneSignatureHandle): boolean;
}

export type StandaloneSignatureHandle = StandaloneSignatureHandle$instance & __StandaloneSignatureHandle$views;


export interface StringHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: StringHandle): boolean;
    getHashCode(): int;
}


export const StringHandle: {
    new(): StringHandle$instance;
};


export interface __StringHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<StringHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: StringHandle): boolean;
}

export type StringHandle = StringHandle$instance & __StringHandle$views;


export interface TypeDefinition$instance {
    readonly attributes: TypeAttributes;
    readonly baseType: EntityHandle;
    readonly isNested: boolean;
    readonly name: StringHandle;
    readonly namespace_: StringHandle;
    readonly namespaceDefinition: NamespaceDefinitionHandle;
    getCustomAttributes(): CustomAttributeHandleCollection;
    getDeclarativeSecurityAttributes(): DeclarativeSecurityAttributeHandleCollection;
    getDeclaringType(): TypeDefinitionHandle;
    getEvents(): EventDefinitionHandleCollection;
    getFields(): FieldDefinitionHandleCollection;
    getGenericParameters(): GenericParameterHandleCollection;
    getInterfaceImplementations(): InterfaceImplementationHandleCollection;
    getLayout(): TypeLayout;
    getMethodImplementations(): MethodImplementationHandleCollection;
    getMethods(): MethodDefinitionHandleCollection;
    getNestedTypes(): ImmutableArray_1<TypeDefinitionHandle>;
    getProperties(): PropertyDefinitionHandleCollection;
}


export const TypeDefinition: {
    new(): TypeDefinition$instance;
};


export type TypeDefinition = TypeDefinition$instance;

export interface TypeDefinitionHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: TypeDefinitionHandle): boolean;
    getHashCode(): int;
}


export const TypeDefinitionHandle: {
    new(): TypeDefinitionHandle$instance;
};


export interface __TypeDefinitionHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<TypeDefinitionHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: TypeDefinitionHandle): boolean;
}

export type TypeDefinitionHandle = TypeDefinitionHandle$instance & __TypeDefinitionHandle$views;


export interface TypeDefinitionHandleCollection$instance {
    readonly count: int;
    getEnumerator(): TypeDefinitionHandleCollection_Enumerator;
}


export const TypeDefinitionHandleCollection: {
    new(): TypeDefinitionHandleCollection$instance;
};


export interface __TypeDefinitionHandleCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<TypeDefinitionHandle>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<TypeDefinitionHandle>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type TypeDefinitionHandleCollection = TypeDefinitionHandleCollection$instance & __TypeDefinitionHandleCollection$views;


export interface TypeDefinitionHandleCollection_Enumerator$instance {
    readonly current: TypeDefinitionHandle;
    moveNext(): boolean;
    reset(): void;
}


export const TypeDefinitionHandleCollection_Enumerator: {
    new(): TypeDefinitionHandleCollection_Enumerator$instance;
};


export interface __TypeDefinitionHandleCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<TypeDefinitionHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type TypeDefinitionHandleCollection_Enumerator = TypeDefinitionHandleCollection_Enumerator$instance & __TypeDefinitionHandleCollection_Enumerator$views;


export interface TypeLayout$instance {
    readonly isDefault: boolean;
    readonly packingSize: int;
    readonly size: int;
}


export const TypeLayout: {
    new(size: int, packingSize: int): TypeLayout$instance;
};


export type TypeLayout = TypeLayout$instance;

export interface TypeReference$instance {
    readonly name: StringHandle;
    readonly namespace_: StringHandle;
    readonly resolutionScope: EntityHandle;
}


export const TypeReference: {
    new(): TypeReference$instance;
};


export type TypeReference = TypeReference$instance;

export interface TypeReferenceHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: TypeReferenceHandle): boolean;
    getHashCode(): int;
}


export const TypeReferenceHandle: {
    new(): TypeReferenceHandle$instance;
};


export interface __TypeReferenceHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<TypeReferenceHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: TypeReferenceHandle): boolean;
}

export type TypeReferenceHandle = TypeReferenceHandle$instance & __TypeReferenceHandle$views;


export interface TypeReferenceHandleCollection$instance {
    readonly count: int;
    getEnumerator(): TypeReferenceHandleCollection_Enumerator;
}


export const TypeReferenceHandleCollection: {
    new(): TypeReferenceHandleCollection$instance;
};


export interface __TypeReferenceHandleCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<TypeReferenceHandle>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<TypeReferenceHandle>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type TypeReferenceHandleCollection = TypeReferenceHandleCollection$instance & __TypeReferenceHandleCollection$views;


export interface TypeReferenceHandleCollection_Enumerator$instance {
    readonly current: TypeReferenceHandle;
    moveNext(): boolean;
    reset(): void;
}


export const TypeReferenceHandleCollection_Enumerator: {
    new(): TypeReferenceHandleCollection_Enumerator$instance;
};


export interface __TypeReferenceHandleCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<TypeReferenceHandle>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type TypeReferenceHandleCollection_Enumerator = TypeReferenceHandleCollection_Enumerator$instance & __TypeReferenceHandleCollection_Enumerator$views;


export interface TypeSpecification$instance {
    readonly signature: BlobHandle;
    decodeSignature<TType, TGenericContext>(provider: ISignatureTypeProvider_2<TType, TGenericContext>, genericContext: TGenericContext): TType;
    getCustomAttributes(): CustomAttributeHandleCollection;
}


export const TypeSpecification: {
    new(): TypeSpecification$instance;
};


export type TypeSpecification = TypeSpecification$instance;

export interface TypeSpecificationHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: TypeSpecificationHandle): boolean;
    getHashCode(): int;
}


export const TypeSpecificationHandle: {
    new(): TypeSpecificationHandle$instance;
};


export interface __TypeSpecificationHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<TypeSpecificationHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: TypeSpecificationHandle): boolean;
}

export type TypeSpecificationHandle = TypeSpecificationHandle$instance & __TypeSpecificationHandle$views;


export interface UserStringHandle$instance {
    readonly isNil: boolean;
    equals(obj: unknown): boolean;
    equals(other: UserStringHandle): boolean;
    getHashCode(): int;
}


export const UserStringHandle: {
    new(): UserStringHandle$instance;
};


export interface __UserStringHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<UserStringHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: UserStringHandle): boolean;
}

export type UserStringHandle = UserStringHandle$instance & __UserStringHandle$views;


export interface AssemblyNameInfo$instance {
    readonly cultureName: string;
    readonly flags: AssemblyNameFlags;
    readonly fullName: string;
    readonly name: string;
    readonly publicKeyOrToken: ImmutableArray_1<CLROf<byte>>;
    readonly version: Version;
    toAssemblyName(): AssemblyName;
}


export const AssemblyNameInfo: {
    new(name: string, version: Version, cultureName: string, flags: AssemblyNameFlags, publicKeyOrToken: ImmutableArray_1<CLROf<byte>>): AssemblyNameInfo$instance;
    parse(assemblyName: ReadOnlySpan_1<CLROf<char>>): AssemblyNameInfo;
    tryParse(assemblyName: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<AssemblyNameInfo> }): boolean;
};


export type AssemblyNameInfo = AssemblyNameInfo$instance;

export interface BlobBuilder$instance {
    readonly count: int;
    align(alignment: int): void;
    clear(): void;
    contentEquals(other: BlobBuilder): boolean;
    getBlobs(): BlobBuilder_Blobs;
    linkPrefix(prefix: BlobBuilder): void;
    linkSuffix(suffix: BlobBuilder): void;
    padTo(position: int): void;
    reserveBytes(byteCount: int): Blob;
    toArray(): byte[];
    toArray(start: int, byteCount: int): byte[];
    toImmutableArray(): ImmutableArray_1<CLROf<byte>>;
    toImmutableArray(start: int, byteCount: int): ImmutableArray_1<CLROf<byte>>;
    tryWriteBytes(source: Stream, byteCount: int): int;
    writeBoolean(value: boolean): void;
    writeByte(value: byte): void;
    writeBytes(value: byte, byteCount: int): void;
    writeBytes(buffer: ptr<byte>, byteCount: int): void;
    writeBytes(buffer: ImmutableArray_1<CLROf<byte>>): void;
    writeBytes(buffer: ImmutableArray_1<CLROf<byte>>, start: int, byteCount: int): void;
    writeBytes(buffer: byte[]): void;
    writeBytes(buffer: byte[], start: int, byteCount: int): void;
    writeCompressedInteger(value: int): void;
    writeCompressedSignedInteger(value: int): void;
    writeConstant(value: unknown): void;
    writeContentTo(destination: Stream): void;
    writeContentTo(destination: { value: ref<BlobWriter> }): void;
    writeContentTo(destination: BlobBuilder): void;
    writeDateTime(value: DateTime): void;
    writeDecimal(value: decimal): void;
    writeDouble(value: double): void;
    writeGuid(value: Guid): void;
    writeInt16(value: short): void;
    writeInt16BE(value: short): void;
    writeInt32(value: int): void;
    writeInt32BE(value: int): void;
    writeInt64(value: long): void;
    writeReference(reference: int, isSmall: boolean): void;
    writeSByte(value: sbyte): void;
    writeSerializedString(value: string): void;
    writeSingle(value: float): void;
    writeUInt16(value: ushort): void;
    writeUInt16BE(value: ushort): void;
    writeUInt32(value: uint): void;
    writeUInt32BE(value: uint): void;
    writeUInt64(value: ulong): void;
    writeUserString(value: string): void;
    writeUTF16(value: char[]): void;
    writeUTF16(value: string): void;
    writeUTF8(value: string, allowUnpairedSurrogates?: boolean): void;
}


export const BlobBuilder: {
    new(capacity: int): BlobBuilder$instance;
};


export type BlobBuilder = BlobBuilder$instance;

export interface DebugMetadataHeader$instance {
    readonly entryPoint: MethodDefinitionHandle;
    readonly id: ImmutableArray_1<CLROf<byte>>;
    readonly idStartOffset: int;
}


export const DebugMetadataHeader: {
    new(): DebugMetadataHeader$instance;
};


export type DebugMetadataHeader = DebugMetadataHeader$instance;

export interface HandleComparer$instance {
    compare(x: Handle, y: Handle): int;
    compare(x: EntityHandle, y: EntityHandle): int;
    equals(x: Handle, y: Handle): boolean;
    equals(x: EntityHandle, y: EntityHandle): boolean;
    getHashCode(obj: Handle): int;
    getHashCode(obj: EntityHandle): int;
}


export const HandleComparer: {
    new(): HandleComparer$instance;
    readonly default_: HandleComparer;
};


export interface __HandleComparer$views {
    As_IComparer_1(): System_Collections_Generic_Internal.IComparer_1$instance<Handle>;
    As_IEqualityComparer_1(): System_Collections_Generic_Internal.IEqualityComparer_1$instance<Handle>;
}

export interface HandleComparer$instance extends System_Collections_Generic_Internal.IComparer_1$instance<EntityHandle> {}

export type HandleComparer = HandleComparer$instance & __HandleComparer$views;


export interface ImageFormatLimitationException$instance extends Exception {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const ImageFormatLimitationException: {
    new(): ImageFormatLimitationException$instance;
    new(message: string): ImageFormatLimitationException$instance;
    new(message: string, innerException: Exception): ImageFormatLimitationException$instance;
};


export interface __ImageFormatLimitationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ImageFormatLimitationException = ImageFormatLimitationException$instance & __ImageFormatLimitationException$views;


export interface MetadataReader$instance {
    readonly assemblyFiles: AssemblyFileHandleCollection;
    readonly assemblyReferences: AssemblyReferenceHandleCollection;
    readonly customAttributes: CustomAttributeHandleCollection;
    readonly customDebugInformation: CustomDebugInformationHandleCollection;
    readonly debugMetadataHeader: DebugMetadataHeader;
    readonly declarativeSecurityAttributes: DeclarativeSecurityAttributeHandleCollection;
    readonly documents: DocumentHandleCollection;
    readonly eventDefinitions: EventDefinitionHandleCollection;
    readonly exportedTypes: ExportedTypeHandleCollection;
    readonly fieldDefinitions: FieldDefinitionHandleCollection;
    readonly importScopes: ImportScopeCollection;
    readonly isAssembly: boolean;
    readonly localConstants: LocalConstantHandleCollection;
    readonly localScopes: LocalScopeHandleCollection;
    readonly localVariables: LocalVariableHandleCollection;
    readonly manifestResources: ManifestResourceHandleCollection;
    readonly memberReferences: MemberReferenceHandleCollection;
    readonly metadataKind: MetadataKind;
    readonly metadataLength: int;
    readonly metadataPointer: ptr<byte>;
    readonly metadataVersion: string;
    readonly methodDebugInformation: MethodDebugInformationHandleCollection;
    readonly methodDefinitions: MethodDefinitionHandleCollection;
    readonly options: MetadataReaderOptions;
    readonly propertyDefinitions: PropertyDefinitionHandleCollection;
    readonly stringComparer: MetadataStringComparer;
    readonly typeDefinitions: TypeDefinitionHandleCollection;
    readonly typeReferences: TypeReferenceHandleCollection;
    readonly utF8Decoder: MetadataStringDecoder;
    getAssemblyDefinition(): AssemblyDefinition;
    getAssemblyFile(handle: AssemblyFileHandle): AssemblyFile;
    getAssemblyReference(handle: AssemblyReferenceHandle): AssemblyReference;
    getBlobBytes(handle: BlobHandle): byte[];
    getBlobContent(handle: BlobHandle): ImmutableArray_1<CLROf<byte>>;
    getBlobReader(handle: BlobHandle): BlobReader;
    getBlobReader(handle: StringHandle): BlobReader;
    getConstant(handle: ConstantHandle): Constant;
    getCustomAttribute(handle: CustomAttributeHandle): CustomAttribute;
    getCustomAttributes(handle: EntityHandle): CustomAttributeHandleCollection;
    getCustomDebugInformation(handle: CustomDebugInformationHandle): CustomDebugInformation;
    getCustomDebugInformation(handle: EntityHandle): CustomDebugInformationHandleCollection;
    getDeclarativeSecurityAttribute(handle: DeclarativeSecurityAttributeHandle): DeclarativeSecurityAttribute;
    getDocument(handle: DocumentHandle): Document;
    getEventDefinition(handle: EventDefinitionHandle): EventDefinition;
    getExportedType(handle: ExportedTypeHandle): ExportedType;
    getFieldDefinition(handle: FieldDefinitionHandle): FieldDefinition;
    getGenericParameter(handle: GenericParameterHandle): GenericParameter;
    getGenericParameterConstraint(handle: GenericParameterConstraintHandle): GenericParameterConstraint;
    getGuid(handle: GuidHandle): Guid;
    getImportScope(handle: ImportScopeHandle): ImportScope;
    getInterfaceImplementation(handle: InterfaceImplementationHandle): InterfaceImplementation;
    getLocalConstant(handle: LocalConstantHandle): LocalConstant;
    getLocalScope(handle: LocalScopeHandle): LocalScope;
    getLocalScopes(handle: MethodDefinitionHandle): LocalScopeHandleCollection;
    getLocalScopes(handle: MethodDebugInformationHandle): LocalScopeHandleCollection;
    getLocalVariable(handle: LocalVariableHandle): LocalVariable;
    getManifestResource(handle: ManifestResourceHandle): ManifestResource;
    getMemberReference(handle: MemberReferenceHandle): MemberReference;
    getMethodDebugInformation(handle: MethodDebugInformationHandle): MethodDebugInformation;
    getMethodDebugInformation(handle: MethodDefinitionHandle): MethodDebugInformation;
    getMethodDefinition(handle: MethodDefinitionHandle): MethodDefinition;
    getMethodImplementation(handle: MethodImplementationHandle): MethodImplementation;
    getMethodSpecification(handle: MethodSpecificationHandle): MethodSpecification;
    getModuleDefinition(): ModuleDefinition;
    getModuleReference(handle: ModuleReferenceHandle): ModuleReference;
    getNamespaceDefinition(handle: NamespaceDefinitionHandle): NamespaceDefinition;
    getNamespaceDefinitionRoot(): NamespaceDefinition;
    getParameter(handle: ParameterHandle): Parameter;
    getPropertyDefinition(handle: PropertyDefinitionHandle): PropertyDefinition;
    getStandaloneSignature(handle: StandaloneSignatureHandle): StandaloneSignature;
    getString(handle: StringHandle): string;
    getString(handle: NamespaceDefinitionHandle): string;
    getString(handle: DocumentNameBlobHandle): string;
    getTypeDefinition(handle: TypeDefinitionHandle): TypeDefinition;
    getTypeReference(handle: TypeReferenceHandle): TypeReference;
    getTypeSpecification(handle: TypeSpecificationHandle): TypeSpecification;
    getUserString(handle: UserStringHandle): string;
}


export const MetadataReader: {
    new(metadata: ptr<byte>, length: int): MetadataReader$instance;
    new(metadata: ptr<byte>, length: int, options: MetadataReaderOptions): MetadataReader$instance;
    new(metadata: ptr<byte>, length: int, options: MetadataReaderOptions, utf8Decoder: MetadataStringDecoder): MetadataReader$instance;
    getAssemblyName(assemblyFile: string): AssemblyName;
};


export type MetadataReader = MetadataReader$instance;

export interface MetadataReaderProvider$instance {
    dispose(): void;
    getMetadataReader(options?: MetadataReaderOptions, utf8Decoder?: MetadataStringDecoder): MetadataReader;
}


export const MetadataReaderProvider: {
    new(): MetadataReaderProvider$instance;
    fromMetadataImage(start: ptr<byte>, size: int): MetadataReaderProvider;
    fromMetadataImage(image: ImmutableArray_1<CLROf<byte>>): MetadataReaderProvider;
    fromMetadataStream(stream: Stream, options?: MetadataStreamOptions, size?: int): MetadataReaderProvider;
    fromPortablePdbImage(start: ptr<byte>, size: int): MetadataReaderProvider;
    fromPortablePdbImage(image: ImmutableArray_1<CLROf<byte>>): MetadataReaderProvider;
    fromPortablePdbStream(stream: Stream, options?: MetadataStreamOptions, size?: int): MetadataReaderProvider;
};


export interface __MetadataReaderProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MetadataReaderProvider$instance extends System_Internal.IDisposable$instance {}

export type MetadataReaderProvider = MetadataReaderProvider$instance & __MetadataReaderProvider$views;


export interface MetadataStringDecoder$instance {
    readonly encoding: Encoding;
    getString(bytes: ptr<byte>, byteCount: int): string;
}


export const MetadataStringDecoder: {
    new(encoding: Encoding): MetadataStringDecoder$instance;
    readonly defaultUTF8: MetadataStringDecoder;
};


export type MetadataStringDecoder = MetadataStringDecoder$instance;

export interface MetadataUpdateHandlerAttribute$instance extends Attribute {
    readonly handlerType: Type;
}


export const MetadataUpdateHandlerAttribute: {
    new(handlerType: Type): MetadataUpdateHandlerAttribute$instance;
};


export type MetadataUpdateHandlerAttribute = MetadataUpdateHandlerAttribute$instance;

export interface MethodBodyBlock$instance {
    readonly exceptionRegions: ImmutableArray_1<ExceptionRegion>;
    readonly localSignature: StandaloneSignatureHandle;
    readonly localVariablesInitialized: boolean;
    readonly maxStack: int;
    readonly size: int;
    getILBytes(): byte[];
    getILContent(): ImmutableArray_1<CLROf<byte>>;
    getILReader(): BlobReader;
}


export const MethodBodyBlock: {
    new(): MethodBodyBlock$instance;
    create(reader: BlobReader): MethodBodyBlock;
};


export type MethodBodyBlock = MethodBodyBlock$instance;

export interface TypeName$instance {
    readonly assemblyName: AssemblyNameInfo;
    readonly assemblyQualifiedName: string;
    readonly declaringType: TypeName;
    readonly fullName: string;
    readonly isArray: boolean;
    readonly isByRef: boolean;
    readonly isConstructedGenericType: boolean;
    readonly isNested: boolean;
    readonly isPointer: boolean;
    readonly isSimple: boolean;
    readonly isSZArray: boolean;
    readonly isVariableBoundArrayType: boolean;
    readonly name: string;
    readonly namespace_: string;
    getArrayRank(): int;
    getElementType(): TypeName;
    getGenericArguments(): ImmutableArray_1<TypeName>;
    getGenericTypeDefinition(): TypeName;
    getNodeCount(): int;
    makeArrayTypeName(rank: int): TypeName;
    makeByRefTypeName(): TypeName;
    makeGenericTypeName(typeArguments: ImmutableArray_1<TypeName>): TypeName;
    makePointerTypeName(): TypeName;
    makeSZArrayTypeName(): TypeName;
    withAssemblyName(assemblyName: AssemblyNameInfo): TypeName;
}


export const TypeName: {
    new(): TypeName$instance;
    parse(typeName: ReadOnlySpan_1<CLROf<char>>, options?: TypeNameParseOptions): TypeName;
    tryParse(typeName: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<TypeName> }, options?: TypeNameParseOptions): boolean;
    unescape(name: string): string;
};


export type TypeName = TypeName$instance;

export interface TypeNameParseOptions$instance {
    maxNodes: int;
}


export const TypeNameParseOptions: {
    new(): TypeNameParseOptions$instance;
};


export type TypeNameParseOptions = TypeNameParseOptions$instance;

export abstract class AssemblyExtensions$instance {
    static tryGetRawMetadata(assembly: Assembly, blob: { value: ref<ptr<byte>> }, length: { value: ref<int> }): boolean;
}


export type AssemblyExtensions = AssemblyExtensions$instance;

export abstract class ILOpCodeExtensions$instance {
    static getBranchOperandSize(opCode: ILOpCode): int;
    static getLongBranch(opCode: ILOpCode): ILOpCode;
    static getShortBranch(opCode: ILOpCode): ILOpCode;
    static isBranch(opCode: ILOpCode): boolean;
}


export type ILOpCodeExtensions = ILOpCodeExtensions$instance;

export abstract class MetadataUpdater$instance {
    static readonly isSupported: boolean;
    static applyUpdate(assembly: Assembly, metadataDelta: ReadOnlySpan_1<CLROf<byte>>, ilDelta: ReadOnlySpan_1<CLROf<byte>>, pdbDelta: ReadOnlySpan_1<CLROf<byte>>): void;
}


export type MetadataUpdater = MetadataUpdater$instance;

export abstract class PEReaderExtensions$instance {
    static getMetadataReader(peReader: PEReader, options: MetadataReaderOptions, utf8Decoder: MetadataStringDecoder): MetadataReader;
    static getMetadataReader(peReader: PEReader, options: MetadataReaderOptions): MetadataReader;
    static getMetadataReader(peReader: PEReader): MetadataReader;
    static getMethodBody(peReader: PEReader, relativeVirtualAddress: int): MethodBodyBlock;
}


export type PEReaderExtensions = PEReaderExtensions$instance;

