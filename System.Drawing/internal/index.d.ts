// Generated by tsbindgen - Architecture
// Namespace: System.Drawing
// Assembly: System.ComponentModel.TypeConverter, System.Drawing.Primitives

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { ICollection, IDictionary } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { ITypeDescriptorContext, PropertyDescriptorCollection, TypeConverter, TypeConverter_StandardValuesCollection } from "../../System.ComponentModel/internal/index.js";
import type { CultureInfo } from "../../System.Globalization/internal/index.js";
import type { Vector2, Vector4 } from "../../System.Numerics/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Attribute, Boolean as ClrBoolean, Byte, Enum, IComparable, IConvertible, IEquatable_1, IFormatProvider, IFormattable, Int32, ISpanFormattable, Object as ClrObject, Single, String as ClrString, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum KnownColor {
    activeBorder = 1,
    activeCaption = 2,
    activeCaptionText = 3,
    appWorkspace = 4,
    control = 5,
    controlDark = 6,
    controlDarkDark = 7,
    controlLight = 8,
    controlLightLight = 9,
    controlText = 10,
    desktop = 11,
    grayText = 12,
    highlight = 13,
    highlightText = 14,
    hotTrack = 15,
    inactiveBorder = 16,
    inactiveCaption = 17,
    inactiveCaptionText = 18,
    info = 19,
    infoText = 20,
    menu = 21,
    menuText = 22,
    scrollBar = 23,
    window = 24,
    windowFrame = 25,
    windowText = 26,
    transparent = 27,
    aliceBlue = 28,
    antiqueWhite = 29,
    aqua = 30,
    aquamarine = 31,
    azure = 32,
    beige = 33,
    bisque = 34,
    black = 35,
    blanchedAlmond = 36,
    blue = 37,
    blueViolet = 38,
    brown = 39,
    burlyWood = 40,
    cadetBlue = 41,
    chartreuse = 42,
    chocolate = 43,
    coral = 44,
    cornflowerBlue = 45,
    cornsilk = 46,
    crimson = 47,
    cyan = 48,
    darkBlue = 49,
    darkCyan = 50,
    darkGoldenrod = 51,
    darkGray = 52,
    darkGreen = 53,
    darkKhaki = 54,
    darkMagenta = 55,
    darkOliveGreen = 56,
    darkOrange = 57,
    darkOrchid = 58,
    darkRed = 59,
    darkSalmon = 60,
    darkSeaGreen = 61,
    darkSlateBlue = 62,
    darkSlateGray = 63,
    darkTurquoise = 64,
    darkViolet = 65,
    deepPink = 66,
    deepSkyBlue = 67,
    dimGray = 68,
    dodgerBlue = 69,
    firebrick = 70,
    floralWhite = 71,
    forestGreen = 72,
    fuchsia = 73,
    gainsboro = 74,
    ghostWhite = 75,
    gold = 76,
    goldenrod = 77,
    gray = 78,
    green = 79,
    greenYellow = 80,
    honeydew = 81,
    hotPink = 82,
    indianRed = 83,
    indigo = 84,
    ivory = 85,
    khaki = 86,
    lavender = 87,
    lavenderBlush = 88,
    lawnGreen = 89,
    lemonChiffon = 90,
    lightBlue = 91,
    lightCoral = 92,
    lightCyan = 93,
    lightGoldenrodYellow = 94,
    lightGray = 95,
    lightGreen = 96,
    lightPink = 97,
    lightSalmon = 98,
    lightSeaGreen = 99,
    lightSkyBlue = 100,
    lightSlateGray = 101,
    lightSteelBlue = 102,
    lightYellow = 103,
    lime = 104,
    limeGreen = 105,
    linen = 106,
    magenta = 107,
    maroon = 108,
    mediumAquamarine = 109,
    mediumBlue = 110,
    mediumOrchid = 111,
    mediumPurple = 112,
    mediumSeaGreen = 113,
    mediumSlateBlue = 114,
    mediumSpringGreen = 115,
    mediumTurquoise = 116,
    mediumVioletRed = 117,
    midnightBlue = 118,
    mintCream = 119,
    mistyRose = 120,
    moccasin = 121,
    navajoWhite = 122,
    navy = 123,
    oldLace = 124,
    olive = 125,
    oliveDrab = 126,
    orange = 127,
    orangeRed = 128,
    orchid = 129,
    paleGoldenrod = 130,
    paleGreen = 131,
    paleTurquoise = 132,
    paleVioletRed = 133,
    papayaWhip = 134,
    peachPuff = 135,
    peru = 136,
    pink = 137,
    plum = 138,
    powderBlue = 139,
    purple = 140,
    red = 141,
    rosyBrown = 142,
    royalBlue = 143,
    saddleBrown = 144,
    salmon = 145,
    sandyBrown = 146,
    seaGreen = 147,
    seaShell = 148,
    sienna = 149,
    silver = 150,
    skyBlue = 151,
    slateBlue = 152,
    slateGray = 153,
    snow = 154,
    springGreen = 155,
    steelBlue = 156,
    tan = 157,
    teal = 158,
    thistle = 159,
    tomato = 160,
    turquoise = 161,
    violet = 162,
    wheat = 163,
    white = 164,
    whiteSmoke = 165,
    yellow = 166,
    yellowGreen = 167,
    buttonFace = 168,
    buttonHighlight = 169,
    buttonShadow = 170,
    gradientActiveCaption = 171,
    gradientInactiveCaption = 172,
    menuBar = 173,
    menuHighlight = 174,
    rebeccaPurple = 175
}


export interface Color$instance {
    readonly A: byte;
    readonly B: byte;
    readonly G: byte;
    readonly isEmpty: boolean;
    readonly isKnownColor: boolean;
    readonly isNamedColor: boolean;
    readonly isSystemColor: boolean;
    readonly name: string;
    readonly R: byte;
    equals(obj: unknown): boolean;
    equals(other: Color): boolean;
    getBrightness(): float;
    getHashCode(): int;
    getHue(): float;
    getSaturation(): float;
    toArgb(): int;
    toKnownColor(): KnownColor;
    toString(): string;
}


export const Color: {
    new(): Color$instance;
    readonly empty: Color;
    readonly transparent: Color;
    readonly aliceBlue: Color;
    readonly antiqueWhite: Color;
    readonly aqua: Color;
    readonly aquamarine: Color;
    readonly azure: Color;
    readonly beige: Color;
    readonly bisque: Color;
    readonly black: Color;
    readonly blanchedAlmond: Color;
    readonly blue: Color;
    readonly blueViolet: Color;
    readonly brown: Color;
    readonly burlyWood: Color;
    readonly cadetBlue: Color;
    readonly chartreuse: Color;
    readonly chocolate: Color;
    readonly coral: Color;
    readonly cornflowerBlue: Color;
    readonly cornsilk: Color;
    readonly crimson: Color;
    readonly cyan: Color;
    readonly darkBlue: Color;
    readonly darkCyan: Color;
    readonly darkGoldenrod: Color;
    readonly darkGray: Color;
    readonly darkGreen: Color;
    readonly darkKhaki: Color;
    readonly darkMagenta: Color;
    readonly darkOliveGreen: Color;
    readonly darkOrange: Color;
    readonly darkOrchid: Color;
    readonly darkRed: Color;
    readonly darkSalmon: Color;
    readonly darkSeaGreen: Color;
    readonly darkSlateBlue: Color;
    readonly darkSlateGray: Color;
    readonly darkTurquoise: Color;
    readonly darkViolet: Color;
    readonly deepPink: Color;
    readonly deepSkyBlue: Color;
    readonly dimGray: Color;
    readonly dodgerBlue: Color;
    readonly firebrick: Color;
    readonly floralWhite: Color;
    readonly forestGreen: Color;
    readonly fuchsia: Color;
    readonly gainsboro: Color;
    readonly ghostWhite: Color;
    readonly gold: Color;
    readonly goldenrod: Color;
    readonly gray: Color;
    readonly green: Color;
    readonly greenYellow: Color;
    readonly honeydew: Color;
    readonly hotPink: Color;
    readonly indianRed: Color;
    readonly indigo: Color;
    readonly ivory: Color;
    readonly khaki: Color;
    readonly lavender: Color;
    readonly lavenderBlush: Color;
    readonly lawnGreen: Color;
    readonly lemonChiffon: Color;
    readonly lightBlue: Color;
    readonly lightCoral: Color;
    readonly lightCyan: Color;
    readonly lightGoldenrodYellow: Color;
    readonly lightGreen: Color;
    readonly lightGray: Color;
    readonly lightPink: Color;
    readonly lightSalmon: Color;
    readonly lightSeaGreen: Color;
    readonly lightSkyBlue: Color;
    readonly lightSlateGray: Color;
    readonly lightSteelBlue: Color;
    readonly lightYellow: Color;
    readonly lime: Color;
    readonly limeGreen: Color;
    readonly linen: Color;
    readonly magenta: Color;
    readonly maroon: Color;
    readonly mediumAquamarine: Color;
    readonly mediumBlue: Color;
    readonly mediumOrchid: Color;
    readonly mediumPurple: Color;
    readonly mediumSeaGreen: Color;
    readonly mediumSlateBlue: Color;
    readonly mediumSpringGreen: Color;
    readonly mediumTurquoise: Color;
    readonly mediumVioletRed: Color;
    readonly midnightBlue: Color;
    readonly mintCream: Color;
    readonly mistyRose: Color;
    readonly moccasin: Color;
    readonly navajoWhite: Color;
    readonly navy: Color;
    readonly oldLace: Color;
    readonly olive: Color;
    readonly oliveDrab: Color;
    readonly orange: Color;
    readonly orangeRed: Color;
    readonly orchid: Color;
    readonly paleGoldenrod: Color;
    readonly paleGreen: Color;
    readonly paleTurquoise: Color;
    readonly paleVioletRed: Color;
    readonly papayaWhip: Color;
    readonly peachPuff: Color;
    readonly peru: Color;
    readonly pink: Color;
    readonly plum: Color;
    readonly powderBlue: Color;
    readonly purple: Color;
    readonly rebeccaPurple: Color;
    readonly red: Color;
    readonly rosyBrown: Color;
    readonly royalBlue: Color;
    readonly saddleBrown: Color;
    readonly salmon: Color;
    readonly sandyBrown: Color;
    readonly seaGreen: Color;
    readonly seaShell: Color;
    readonly sienna: Color;
    readonly silver: Color;
    readonly skyBlue: Color;
    readonly slateBlue: Color;
    readonly slateGray: Color;
    readonly snow: Color;
    readonly springGreen: Color;
    readonly steelBlue: Color;
    readonly tan: Color;
    readonly teal: Color;
    readonly thistle: Color;
    readonly tomato: Color;
    readonly turquoise: Color;
    readonly violet: Color;
    readonly wheat: Color;
    readonly white: Color;
    readonly whiteSmoke: Color;
    readonly yellow: Color;
    readonly yellowGreen: Color;
    fromArgb(alpha: int, baseColor: Color): Color;
    fromArgb(alpha: int, red: int, green: int, blue: int): Color;
    fromArgb(red: int, green: int, blue: int): Color;
    fromArgb(argb: int): Color;
    fromKnownColor(color: KnownColor): Color;
    fromName(name: string): Color;
};


export interface __Color$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Color>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Color): boolean;
}

export type Color = Color$instance & __Color$views;


export interface Point$instance {
    readonly isEmpty: boolean;
    X: int;
    Y: int;
    equals(obj: unknown): boolean;
    equals(other: Point): boolean;
    getHashCode(): int;
    offset(dx: int, dy: int): void;
    offset(p: Point): void;
    toString(): string;
}


export const Point: {
    new(x: int, y: int): Point$instance;
    new(sz: Size): Point$instance;
    new(dw: int): Point$instance;
    readonly empty: Point;
    add(pt: Point, sz: Size): Point;
    ceiling(value: PointF): Point;
    round(value: PointF): Point;
    subtract(pt: Point, sz: Size): Point;
    truncate(value: PointF): Point;
};


export interface __Point$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Point>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Point): boolean;
}

export type Point = Point$instance & __Point$views;


export interface PointF$instance {
    readonly isEmpty: boolean;
    X: float;
    Y: float;
    equals(obj: unknown): boolean;
    equals(other: PointF): boolean;
    getHashCode(): int;
    toString(): string;
    toVector2(): Vector2;
}


export const PointF: {
    new(x: float, y: float): PointF$instance;
    new(vector: Vector2): PointF$instance;
    readonly empty: PointF;
    add(pt: PointF, sz: Size): PointF;
    add(pt: PointF, sz: SizeF): PointF;
    subtract(pt: PointF, sz: Size): PointF;
    subtract(pt: PointF, sz: SizeF): PointF;
};


export interface __PointF$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<PointF>;

    // Structural method bridges for numeric interface constraints
    Equals(other: PointF): boolean;
}

export type PointF = PointF$instance & __PointF$views;


export interface Rectangle$instance {
    readonly bottom: int;
    height: int;
    readonly isEmpty: boolean;
    readonly left: int;
    location: Point;
    readonly right: int;
    size: Size;
    readonly top: int;
    width: int;
    X: int;
    Y: int;
    contains(x: int, y: int): boolean;
    contains(pt: Point): boolean;
    contains(rect: Rectangle): boolean;
    equals(obj: unknown): boolean;
    equals(other: Rectangle): boolean;
    getHashCode(): int;
    inflate(width: int, height: int): void;
    inflate(size: Size): void;
    intersect(rect: Rectangle): void;
    intersectsWith(rect: Rectangle): boolean;
    offset(pos: Point): void;
    offset(x: int, y: int): void;
    toString(): string;
}


export const Rectangle: {
    new(x: int, y: int, width: int, height: int): Rectangle$instance;
    new(location: Point, size: Size): Rectangle$instance;
    readonly empty: Rectangle;
    ceiling(value: RectangleF): Rectangle;
    fromLTRB(left: int, top: int, right: int, bottom: int): Rectangle;
    inflate(rect: Rectangle, x: int, y: int): Rectangle;
    intersect(a: Rectangle, b: Rectangle): Rectangle;
    round(value: RectangleF): Rectangle;
    truncate(value: RectangleF): Rectangle;
    union(a: Rectangle, b: Rectangle): Rectangle;
};


export interface __Rectangle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Rectangle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Rectangle): boolean;
}

export type Rectangle = Rectangle$instance & __Rectangle$views;


export interface RectangleF$instance {
    readonly bottom: float;
    height: float;
    readonly isEmpty: boolean;
    readonly left: float;
    location: PointF;
    readonly right: float;
    size: SizeF;
    readonly top: float;
    width: float;
    X: float;
    Y: float;
    contains(x: float, y: float): boolean;
    contains(pt: PointF): boolean;
    contains(rect: RectangleF): boolean;
    equals(obj: unknown): boolean;
    equals(other: RectangleF): boolean;
    getHashCode(): int;
    inflate(x: float, y: float): void;
    inflate(size: SizeF): void;
    intersect(rect: RectangleF): void;
    intersectsWith(rect: RectangleF): boolean;
    offset(pos: PointF): void;
    offset(x: float, y: float): void;
    toString(): string;
    toVector4(): Vector4;
}


export const RectangleF: {
    new(x: float, y: float, width: float, height: float): RectangleF$instance;
    new(location: PointF, size: SizeF): RectangleF$instance;
    new(vector: Vector4): RectangleF$instance;
    readonly empty: RectangleF;
    fromLTRB(left: float, top: float, right: float, bottom: float): RectangleF;
    inflate(rect: RectangleF, x: float, y: float): RectangleF;
    intersect(a: RectangleF, b: RectangleF): RectangleF;
    union(a: RectangleF, b: RectangleF): RectangleF;
};


export interface __RectangleF$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<RectangleF>;

    // Structural method bridges for numeric interface constraints
    Equals(other: RectangleF): boolean;
}

export type RectangleF = RectangleF$instance & __RectangleF$views;


export interface Size$instance {
    height: int;
    readonly isEmpty: boolean;
    width: int;
    equals(obj: unknown): boolean;
    equals(other: Size): boolean;
    getHashCode(): int;
    toString(): string;
}


export const Size: {
    new(pt: Point): Size$instance;
    new(width: int, height: int): Size$instance;
    readonly empty: Size;
    add(sz1: Size, sz2: Size): Size;
    ceiling(value: SizeF): Size;
    round(value: SizeF): Size;
    subtract(sz1: Size, sz2: Size): Size;
    truncate(value: SizeF): Size;
};


export interface __Size$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Size>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Size): boolean;
}

export type Size = Size$instance & __Size$views;


export interface SizeF$instance {
    height: float;
    readonly isEmpty: boolean;
    width: float;
    equals(obj: unknown): boolean;
    equals(other: SizeF): boolean;
    getHashCode(): int;
    toPointF(): PointF;
    toSize(): Size;
    toString(): string;
    toVector2(): Vector2;
}


export const SizeF: {
    new(size: SizeF): SizeF$instance;
    new(pt: PointF): SizeF$instance;
    new(vector: Vector2): SizeF$instance;
    new(width: float, height: float): SizeF$instance;
    readonly empty: SizeF;
    add(sz1: SizeF, sz2: SizeF): SizeF;
    subtract(sz1: SizeF, sz2: SizeF): SizeF;
};


export interface __SizeF$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SizeF>;

    // Structural method bridges for numeric interface constraints
    Equals(other: SizeF): boolean;
}

export type SizeF = SizeF$instance & __SizeF$views;


export interface ColorConverter$instance extends TypeConverter {
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    getStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    getStandardValues(): ICollection;
    getStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    getStandardValuesSupported(): boolean;
}


export const ColorConverter: {
    new(): ColorConverter$instance;
};


export type ColorConverter = ColorConverter$instance;

export interface PointConverter$instance extends TypeConverter {
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    createInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): unknown;
    createInstance(propertyValues: IDictionary): unknown;
    getCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    getCreateInstanceSupported(): boolean;
    getProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(value: unknown): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    getPropertiesSupported(context: ITypeDescriptorContext): boolean;
    getPropertiesSupported(): boolean;
}


export const PointConverter: {
    new(): PointConverter$instance;
};


export type PointConverter = PointConverter$instance;

export interface RectangleConverter$instance extends TypeConverter {
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    createInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): unknown;
    createInstance(propertyValues: IDictionary): unknown;
    getCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    getCreateInstanceSupported(): boolean;
    getProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(value: unknown): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    getPropertiesSupported(context: ITypeDescriptorContext): boolean;
    getPropertiesSupported(): boolean;
}


export const RectangleConverter: {
    new(): RectangleConverter$instance;
};


export type RectangleConverter = RectangleConverter$instance;

export interface SizeConverter$instance extends TypeConverter {
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    createInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): unknown;
    createInstance(propertyValues: IDictionary): unknown;
    getCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    getCreateInstanceSupported(): boolean;
    getProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(value: unknown): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    getPropertiesSupported(context: ITypeDescriptorContext): boolean;
    getPropertiesSupported(): boolean;
}


export const SizeConverter: {
    new(): SizeConverter$instance;
};


export type SizeConverter = SizeConverter$instance;

export interface SizeFConverter$instance extends TypeConverter {
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    createInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): unknown;
    createInstance(propertyValues: IDictionary): unknown;
    getCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    getCreateInstanceSupported(): boolean;
    getProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(value: unknown): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    getPropertiesSupported(context: ITypeDescriptorContext): boolean;
    getPropertiesSupported(): boolean;
}


export const SizeFConverter: {
    new(): SizeFConverter$instance;
};


export type SizeFConverter = SizeFConverter$instance;

export abstract class ColorTranslator$instance {
    static fromHtml(htmlColor: string): Color;
    static fromOle(oleColor: int): Color;
    static fromWin32(win32Color: int): Color;
    static toHtml(c: Color): string;
    static toOle(c: Color): int;
    static toWin32(c: Color): int;
}


export type ColorTranslator = ColorTranslator$instance;

export abstract class SystemColors$instance {
    static readonly activeBorder: Color;
    static readonly activeCaption: Color;
    static readonly activeCaptionText: Color;
    static readonly appWorkspace: Color;
    static readonly buttonFace: Color;
    static readonly buttonHighlight: Color;
    static readonly buttonShadow: Color;
    static readonly control: Color;
    static readonly controlDark: Color;
    static readonly controlDarkDark: Color;
    static readonly controlLight: Color;
    static readonly controlLightLight: Color;
    static readonly controlText: Color;
    static readonly desktop: Color;
    static readonly gradientActiveCaption: Color;
    static readonly gradientInactiveCaption: Color;
    static readonly grayText: Color;
    static readonly highlight: Color;
    static readonly highlightText: Color;
    static readonly hotTrack: Color;
    static readonly inactiveBorder: Color;
    static readonly inactiveCaption: Color;
    static readonly inactiveCaptionText: Color;
    static readonly info: Color;
    static readonly infoText: Color;
    static readonly menu: Color;
    static readonly menuBar: Color;
    static readonly menuHighlight: Color;
    static readonly menuText: Color;
    static readonly scrollBar: Color;
    static readonly window: Color;
    static readonly windowFrame: Color;
    static readonly windowText: Color;
    static useAlternativeColorSet: boolean;
}


export type SystemColors = SystemColors$instance;

