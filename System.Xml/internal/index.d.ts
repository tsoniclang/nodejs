// Generated by tsbindgen - Architecture
// Namespace: System.Xml
// Assembly: System.Data.Common, System.Private.DataContractSerialization, System.Private.Xml

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { IDictionary_2 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { DataRow, DataSet } from "../../System.Data/internal/index.js";
import type { Stream, TextReader, TextWriter } from "../../System.IO/internal/index.js";
import type { RequestCachePolicy } from "../../System.Net.Cache/internal/index.js";
import type { ICredentials, IWebProxy } from "../../System.Net/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { Encoding, StringBuilder } from "../../System.Text/internal/index.js";
import type { Task, Task_1, ValueTask } from "../../System.Threading.Tasks/internal/index.js";
import type { IXmlSchemaInfo, ValidationEventHandler, XmlSchemaCollection, XmlSchemaSet, XmlSchemaValidationFlags } from "../../System.Xml.Schema/internal/index.js";
import * as System_Xml_XPath_Internal from "../../System.Xml.XPath/internal/index.js";
import type { IXPathNavigable, XPathNavigator } from "../../System.Xml.XPath/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, AsyncCallback, Boolean as ClrBoolean, Byte, Char, DateTime, DateTimeOffset, Decimal, Delegate, Double, Enum, EventArgs, Exception, Guid, IAsyncDisposable, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, MulticastDelegate, Object as ClrObject, SByte, Single, String as ClrString, SystemException, TimeSpan, Type, TypeCode, UInt16, UInt32, UInt64, Uri, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum ConformanceLevel {
    auto = 0,
    fragment = 1,
    document = 2
}


export enum DtdProcessing {
    prohibit = 0,
    ignore = 1,
    parse = 2
}


export enum EntityHandling {
    expandEntities = 1,
    expandCharEntities = 2
}


export enum Formatting {
    none = 0,
    indented = 1
}


export enum NamespaceHandling {
    default_ = 0,
    omitDuplicates = 1
}


export enum NewLineHandling {
    replace = 0,
    entitize = 1,
    none = 2
}


export enum ReadState {
    initial = 0,
    interactive = 1,
    error = 2,
    endOfFile = 3,
    closed = 4
}


export enum ValidationType {
    none = 0,
    auto = 1,
    DTD = 2,
    XDR = 3,
    schema = 4
}


export enum WhitespaceHandling {
    all = 0,
    significant = 1,
    none = 2
}


export enum WriteState {
    start = 0,
    prolog = 1,
    element = 2,
    attribute = 3,
    content = 4,
    closed = 5,
    error = 6
}


export enum XmlDateTimeSerializationMode {
    local = 0,
    utc = 1,
    unspecified = 2,
    roundtripKind = 3
}


export enum XmlDictionaryReaderQuotaTypes {
    maxDepth = 1,
    maxStringContentLength = 2,
    maxArrayLength = 4,
    maxBytesPerRead = 8,
    maxNameTableCharCount = 16
}


export enum XmlNamespaceScope {
    all = 0,
    excludeXml = 1,
    local = 2
}


export enum XmlNodeChangedAction {
    insert = 0,
    remove = 1,
    change = 2
}


export enum XmlNodeOrder {
    before = 0,
    after = 1,
    same = 2,
    unknown_ = 3
}


export enum XmlNodeType {
    none = 0,
    element = 1,
    attribute = 2,
    text = 3,
    CDATA = 4,
    entityReference = 5,
    entity = 6,
    processingInstruction = 7,
    comment = 8,
    document = 9,
    documentType = 10,
    documentFragment = 11,
    notation = 12,
    whitespace = 13,
    significantWhitespace = 14,
    endElement = 15,
    endEntity = 16,
    xmlDeclaration = 17
}


export enum XmlOutputMethod {
    xml = 0,
    html = 1,
    text = 2,
    autoDetect = 3
}


export enum XmlSpace {
    none = 0,
    default_ = 1,
    preserve = 2
}


export enum XmlTokenizedType {
    CDATA = 0,
    ID = 1,
    IDREF = 2,
    IDREFS = 3,
    ENTITY = 4,
    ENTITIES = 5,
    NMTOKEN = 6,
    NMTOKENS = 7,
    NOTATION = 8,
    ENUMERATION = 9,
    qName = 10,
    ncName = 11,
    none = 12
}


export type OnXmlDictionaryReaderClose = (reader: XmlDictionaryReader) => void;


export type XmlNodeChangedEventHandler = (sender: unknown, e: XmlNodeChangedEventArgs) => void;


export interface IApplicationResourceStreamResolver$instance {
    getApplicationResourceStream(relativeUri: Uri): Stream;
}


export type IApplicationResourceStreamResolver = IApplicationResourceStreamResolver$instance;

export interface IFragmentCapableXmlDictionaryWriter$instance {
    readonly canFragment: boolean;
    endFragment(): void;
    startFragment(stream: Stream, generateSelfContainedTextFragment: boolean): void;
    writeFragment(buffer: byte[], offset: int, count: int): void;
}


export type IFragmentCapableXmlDictionaryWriter = IFragmentCapableXmlDictionaryWriter$instance;

export interface IHasXmlNode$instance {
    getNode(): XmlNode;
}


export type IHasXmlNode = IHasXmlNode$instance;

export interface IStreamProvider$instance {
    getStream(): Stream;
    releaseStream(stream: Stream): void;
}


export type IStreamProvider = IStreamProvider$instance;

export interface IXmlBinaryReaderInitializer$instance {
    setInput(buffer: byte[], offset: int, count: int, dictionary: IXmlDictionary, quotas: XmlDictionaryReaderQuotas, session: XmlBinaryReaderSession, onClose: OnXmlDictionaryReaderClose): void;
    setInput(stream: Stream, dictionary: IXmlDictionary, quotas: XmlDictionaryReaderQuotas, session: XmlBinaryReaderSession, onClose: OnXmlDictionaryReaderClose): void;
}


export type IXmlBinaryReaderInitializer = IXmlBinaryReaderInitializer$instance;

export interface IXmlBinaryWriterInitializer$instance {
    setOutput(stream: Stream, dictionary: IXmlDictionary, session: XmlBinaryWriterSession, ownsStream: boolean): void;
}


export type IXmlBinaryWriterInitializer = IXmlBinaryWriterInitializer$instance;

export interface IXmlDictionary$instance {
    tryLookup(key: int, result: { value: ref<XmlDictionaryString> }): boolean;
    tryLookup(value: string, result: { value: ref<XmlDictionaryString> }): boolean;
    tryLookup(value: XmlDictionaryString, result: { value: ref<XmlDictionaryString> }): boolean;
}


export type IXmlDictionary = IXmlDictionary$instance;

export interface IXmlLineInfo$instance {
    readonly lineNumber: int;
    readonly linePosition: int;
    hasLineInfo(): boolean;
}


export type IXmlLineInfo = IXmlLineInfo$instance;

export interface IXmlNamespaceResolver$instance {
    getNamespacesInScope(scope: XmlNamespaceScope): IDictionary_2<CLROf<string>, CLROf<string>>;
    lookupNamespace(prefix: string): string;
}


export type IXmlNamespaceResolver = IXmlNamespaceResolver$instance;

export interface IXmlTextReaderInitializer$instance {
    setInput(buffer: byte[], offset: int, count: int, encoding: Encoding, quotas: XmlDictionaryReaderQuotas, onClose: OnXmlDictionaryReaderClose): void;
    setInput(stream: Stream, encoding: Encoding, quotas: XmlDictionaryReaderQuotas, onClose: OnXmlDictionaryReaderClose): void;
}


export type IXmlTextReaderInitializer = IXmlTextReaderInitializer$instance;

export interface IXmlTextWriterInitializer$instance {
    setOutput(stream: Stream, encoding: Encoding, ownsStream: boolean): void;
}


export type IXmlTextWriterInitializer = IXmlTextWriterInitializer$instance;

export interface NameTable$instance extends XmlNameTable {
    add(key: string): string;
    add(key: char[], start: int, len: int): string;
    get_(value: string): string;
    get_(key: char[], start: int, len: int): string;
}


export const NameTable: {
    new(): NameTable$instance;
};


export type NameTable = NameTable$instance;

export interface UniqueId$instance {
    readonly charArrayLength: int;
    readonly isGuid: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toCharArray(chars: char[], offset: int): int;
    toString(): string;
    tryGetGuid(guid: { value: ref<Guid> }): boolean;
    tryGetGuid(buffer: byte[], offset: int): boolean;
}


export const UniqueId: {
    new(): UniqueId$instance;
    new(guid: Guid): UniqueId$instance;
    new(guid: byte[]): UniqueId$instance;
    new(guid: byte[], offset: int): UniqueId$instance;
    new(value: string): UniqueId$instance;
    new(chars: char[], offset: int, count: int): UniqueId$instance;
};


export type UniqueId = UniqueId$instance;

export interface XmlAttribute$instance extends XmlNode$instance {
    readonly baseURI: string;
    innerText: string;
    innerXml: string;
    readonly localName: string;
    readonly name: string;
    readonly namespaceURI: string;
    readonly nodeType: XmlNodeType;
    readonly ownerDocument: XmlDocument;
    readonly ownerElement: XmlElement;
    readonly parentNode: XmlNode;
    prefix: string;
    readonly schemaInfo: IXmlSchemaInfo;
    readonly specified: boolean;
    value: string;
    appendChild(newChild: XmlNode): XmlNode;
    clone(): XmlNode;
    clone(): unknown;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    insertAfter(newChild: XmlNode, refChild: XmlNode): XmlNode;
    insertBefore(newChild: XmlNode, refChild: XmlNode): XmlNode;
    prependChild(newChild: XmlNode): XmlNode;
    removeChild(oldChild: XmlNode): XmlNode;
    replaceChild(newChild: XmlNode, oldChild: XmlNode): XmlNode;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export const XmlAttribute: {
    new(): XmlAttribute$instance;
};


export interface __XmlAttribute$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlAttribute = XmlAttribute$instance & __XmlAttribute$views;


export interface XmlAttributeCollection$instance extends XmlNamedNodeMap$instance {
    append(node: XmlAttribute): XmlAttribute;
    copyTo(array: XmlAttribute[], index: int): void;
    get_Item(i: int): XmlAttribute;
    get_Item(name: string): XmlAttribute;
    get_Item(localName: string, namespaceURI: string): XmlAttribute;
    getEnumerator(): IEnumerator;
    insertAfter(newNode: XmlAttribute, refNode: XmlAttribute): XmlAttribute;
    insertBefore(newNode: XmlAttribute, refNode: XmlAttribute): XmlAttribute;
    prepend(node: XmlAttribute): XmlAttribute;
    remove(node: XmlAttribute): XmlAttribute;
    removeAll(): void;
    removeAt(i: int): XmlAttribute;
    setNamedItem(node: XmlNode): XmlNode;
}


export const XmlAttributeCollection: {
    new(): XmlAttributeCollection$instance;
};


export interface __XmlAttributeCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type XmlAttributeCollection = XmlAttributeCollection$instance & __XmlAttributeCollection$views;


export interface XmlBinaryReaderSession$instance {
    add(id: int, value: string): XmlDictionaryString;
    clear(): void;
    tryLookup(key: int, result: { value: ref<XmlDictionaryString> }): boolean;
    tryLookup(value: string, result: { value: ref<XmlDictionaryString> }): boolean;
    tryLookup(value: XmlDictionaryString, result: { value: ref<XmlDictionaryString> }): boolean;
}


export const XmlBinaryReaderSession: {
    new(): XmlBinaryReaderSession$instance;
};


export interface __XmlBinaryReaderSession$views {
    As_IXmlDictionary(): IXmlDictionary$instance;
}

export type XmlBinaryReaderSession = XmlBinaryReaderSession$instance & __XmlBinaryReaderSession$views;


export interface XmlBinaryWriterSession$instance {
    reset(): void;
    tryAdd(value: XmlDictionaryString, key: { value: ref<int> }): boolean;
}


export const XmlBinaryWriterSession: {
    new(): XmlBinaryWriterSession$instance;
};


export type XmlBinaryWriterSession = XmlBinaryWriterSession$instance;

export interface XmlCDataSection$instance extends XmlCharacterData$instance {
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly parentNode: XmlNode;
    readonly previousText: XmlNode;
    clone(): unknown;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export const XmlCDataSection: {
    new(): XmlCDataSection$instance;
};


export interface __XmlCDataSection$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlCDataSection = XmlCDataSection$instance & __XmlCDataSection$views;


export interface XmlCharacterData$instance extends XmlLinkedNode$instance {
    data: string;
    innerText: string;
    readonly length: int;
    value: string;
    appendData(strData: string): void;
    clone(): unknown;
    clone(): XmlNode;
    createNavigator(): XPathNavigator;
    deleteData(offset: int, count: int): void;
    getEnumerator(): IEnumerator;
    insertData(offset: int, strData: string): void;
    replaceData(offset: int, count: int, strData: string): void;
    substring(offset: int, count: int): string;
}


export const XmlCharacterData: {
};


export interface __XmlCharacterData$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlCharacterData = XmlCharacterData$instance & __XmlCharacterData$views;


export interface XmlComment$instance extends XmlCharacterData$instance {
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    clone(): unknown;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export const XmlComment: {
    new(): XmlComment$instance;
};


export interface __XmlComment$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlComment = XmlComment$instance & __XmlComment$views;


export interface XmlConvert$instance {
}


export const XmlConvert: {
    new(): XmlConvert$instance;
    decodeName(name: string): string;
    encodeLocalName(name: string): string;
    encodeName(name: string): string;
    encodeNmToken(name: string): string;
    isNCNameChar(ch: char): boolean;
    isPublicIdChar(ch: char): boolean;
    isStartNCNameChar(ch: char): boolean;
    isWhitespaceChar(ch: char): boolean;
    isXmlChar(ch: char): boolean;
    isXmlSurrogatePair(lowChar: char, highChar: char): boolean;
    toBoolean(s: string): boolean;
    toByte(s: string): byte;
    toChar(s: string): char;
    toDateTime(s: string, format: string): DateTime;
    toDateTime(s: string, formats: string[]): DateTime;
    toDateTime(s: string, dateTimeOption: XmlDateTimeSerializationMode): DateTime;
    toDateTime(s: string): DateTime;
    toDateTimeOffset(s: string, format: string): DateTimeOffset;
    toDateTimeOffset(s: string, formats: string[]): DateTimeOffset;
    toDateTimeOffset(s: string): DateTimeOffset;
    toDecimal(s: string): decimal;
    toDouble(s: string): double;
    toGuid(s: string): Guid;
    toInt16(s: string): short;
    toInt32(s: string): int;
    toInt64(s: string): long;
    toSByte(s: string): sbyte;
    toSingle(s: string): float;
    toString(value: boolean): string;
    toString(value: byte): string;
    toString(value: char): string;
    toString(value: DateTime, format: string): string;
    toString(value: DateTime, dateTimeOption: XmlDateTimeSerializationMode): string;
    toString(value: DateTime): string;
    toString(value: DateTimeOffset, format: string): string;
    toString(value: DateTimeOffset): string;
    toString(value: decimal): string;
    toString(value: double): string;
    toString(value: Guid): string;
    toString(value: short): string;
    toString(value: int): string;
    toString(value: long): string;
    toString(value: sbyte): string;
    toString(value: float): string;
    toString(value: TimeSpan): string;
    toString(value: ushort): string;
    toString(value: uint): string;
    toString(value: ulong): string;
    toTimeSpan(s: string): TimeSpan;
    toUInt16(s: string): ushort;
    toUInt32(s: string): uint;
    toUInt64(s: string): ulong;
    verifyName(name: string): string;
    verifyNCName(name: string): string;
    verifyNMTOKEN(name: string): string;
    verifyPublicId(publicId: string): string;
    verifyTOKEN(token: string): string;
    verifyWhitespace(content: string): string;
    verifyXmlChars(content: string): string;
};


export type XmlConvert = XmlConvert$instance;

export interface XmlDataDocument$instance extends XmlDocument$instance {
    readonly dataSet: DataSet;
    clone(): unknown;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createElement(prefix: string, localName: string, namespaceURI: string): XmlElement;
    createElement(name: string): XmlElement;
    createElement(qualifiedName: string, namespaceURI: string): XmlElement;
    createEntityReference(name: string): XmlEntityReference;
    createNavigator(): XPathNavigator;
    getElementById(elemId: string): XmlElement;
    getElementFromRow(r: DataRow): XmlElement;
    getElementsByTagName(name: string): XmlNodeList;
    getElementsByTagName(localName: string, namespaceURI: string): XmlNodeList;
    getEnumerator(): IEnumerator;
    getRowFromElement(e: XmlElement): DataRow;
    load(filename: string): void;
    load(inStream: Stream): void;
    load(txtReader: TextReader): void;
    load(reader: XmlReader): void;
}


export const XmlDataDocument: {
    new(): XmlDataDocument$instance;
    new(dataset: DataSet): XmlDataDocument$instance;
};


export interface __XmlDataDocument$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlDataDocument = XmlDataDocument$instance & __XmlDataDocument$views;


export interface XmlDeclaration$instance extends XmlLinkedNode$instance {
    encoding: string;
    innerText: string;
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    standalone: string;
    value: string;
    readonly version: string;
    clone(): unknown;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export const XmlDeclaration: {
    new(): XmlDeclaration$instance;
};


export interface __XmlDeclaration$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlDeclaration = XmlDeclaration$instance & __XmlDeclaration$views;


export interface XmlDictionary$instance {
    add(value: string): XmlDictionaryString;
    tryLookup(value: string, result: { value: ref<XmlDictionaryString> }): boolean;
    tryLookup(key: int, result: { value: ref<XmlDictionaryString> }): boolean;
    tryLookup(value: XmlDictionaryString, result: { value: ref<XmlDictionaryString> }): boolean;
}


export const XmlDictionary: {
    new(): XmlDictionary$instance;
    new(capacity: int): XmlDictionary$instance;
    readonly empty: IXmlDictionary;
};


export interface __XmlDictionary$views {
    As_IXmlDictionary(): IXmlDictionary$instance;
}

export type XmlDictionary = XmlDictionary$instance & __XmlDictionary$views;


export interface XmlDictionaryReader$instance extends XmlReader$instance {
    readonly canCanonicalize: boolean;
    readonly quotas: XmlDictionaryReaderQuotas;
    dispose(): void;
    endCanonicalization(): void;
    getAttribute(name: string): string;
    getAttribute(name: string, namespaceURI: string): string;
    getAttribute(i: int): string;
    getNonAtomizedNames(localName: { value: ref<string> }, namespaceUri: { value: ref<string> }): void;
    indexOfLocalName(localNames: string[], namespaceUri: string): int;
    indexOfLocalName(localNames: XmlDictionaryString[], namespaceUri: XmlDictionaryString): int;
    isLocalName(localName: string): boolean;
    isLocalName(localName: XmlDictionaryString): boolean;
    isNamespaceUri(namespaceUri: string): boolean;
    isNamespaceUri(namespaceUri: XmlDictionaryString): boolean;
    isStartArray(type_: { value: ref<Type> }): boolean;
    isStartElement(): boolean;
    isStartElement(name: string): boolean;
    isStartElement(localname: string, ns: string): boolean;
    moveToStartElement(): void;
    moveToStartElement(name: string): void;
    moveToStartElement(localName: string, namespaceUri: string): void;
    moveToStartElement(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): void;
    readArray(localName: string, namespaceUri: string, array: boolean[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: boolean[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: short[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: short[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: int[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: int[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: long[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: long[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: float[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: float[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: double[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: double[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: decimal[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: decimal[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: DateTime[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: DateTime[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: Guid[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: Guid[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: TimeSpan[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: TimeSpan[], offset: int, count: int): int;
    readBooleanArray(localName: string, namespaceUri: string): boolean[];
    readBooleanArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): boolean[];
    readContentAs(type_: Type, namespaceResolver: IXmlNamespaceResolver): unknown;
    readContentAsBase642(buffer: byte[], index: int, count: int): int;
    readContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readContentAsChars(chars: char[], offset: int, count: int): int;
    readContentAsDecimal(): decimal;
    readContentAsFloat(): float;
    readContentAsGuid(): Guid;
    readContentAsQualifiedName(localName: { value: ref<string> }, namespaceUri: { value: ref<string> }): void;
    readContentAsString(): string;
    readContentAsString(strings: XmlDictionaryString[], index: { value: ref<int> }): string;
    readContentAsTimeSpan(): TimeSpan;
    readContentAsUniqueId(): UniqueId;
    readDateTimeArray(localName: string, namespaceUri: string): DateTime[];
    readDateTimeArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): DateTime[];
    readDecimalArray(localName: string, namespaceUri: string): decimal[];
    readDecimalArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): decimal[];
    readDoubleArray(localName: string, namespaceUri: string): double[];
    readDoubleArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): double[];
    readElementContentAsBase642(buffer: byte[], index: int, count: int): int;
    readElementContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readElementContentAsBoolean(): boolean;
    readElementContentAsBoolean(localName: string, namespaceURI: string): boolean;
    readElementContentAsDateTime(): DateTime;
    readElementContentAsDateTime(localName: string, namespaceURI: string): DateTime;
    readElementContentAsDecimal(): decimal;
    readElementContentAsDecimal(localName: string, namespaceURI: string): decimal;
    readElementContentAsDouble(): double;
    readElementContentAsDouble(localName: string, namespaceURI: string): double;
    readElementContentAsFloat(): float;
    readElementContentAsFloat(localName: string, namespaceURI: string): float;
    readElementContentAsGuid(): Guid;
    readElementContentAsInt(): int;
    readElementContentAsInt(localName: string, namespaceURI: string): int;
    readElementContentAsLong(): long;
    readElementContentAsLong(localName: string, namespaceURI: string): long;
    readElementContentAsString(): string;
    readElementContentAsString(localName: string, namespaceURI: string): string;
    readElementContentAsTimeSpan(): TimeSpan;
    readElementContentAsUniqueId(): UniqueId;
    readFullStartElement(): void;
    readFullStartElement(name: string): void;
    readFullStartElement(localName: string, namespaceUri: string): void;
    readFullStartElement(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): void;
    readGuidArray(localName: string, namespaceUri: string): Guid[];
    readGuidArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): Guid[];
    readInt16Array(localName: string, namespaceUri: string): short[];
    readInt16Array(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): short[];
    readInt32Array(localName: string, namespaceUri: string): int[];
    readInt32Array(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): int[];
    readInt64Array(localName: string, namespaceUri: string): long[];
    readInt64Array(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): long[];
    readSingleArray(localName: string, namespaceUri: string): float[];
    readSingleArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): float[];
    readStartElement(): void;
    readStartElement(name: string): void;
    readStartElement(localname: string, ns: string): void;
    readString(): string;
    readTimeSpanArray(localName: string, namespaceUri: string): TimeSpan[];
    readTimeSpanArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): TimeSpan[];
    readValueAsBase64(buffer: byte[], offset: int, count: int): int;
    startCanonicalization(stream: Stream, includeComments: boolean, inclusivePrefixes: string[]): void;
    tryGetArrayLength(count: { value: ref<int> }): boolean;
    tryGetBase64ContentLength(length: { value: ref<int> }): boolean;
    tryGetLocalNameAsDictionaryString(localName: { value: ref<XmlDictionaryString> }): boolean;
    tryGetNamespaceUriAsDictionaryString(namespaceUri: { value: ref<XmlDictionaryString> }): boolean;
    tryGetValueAsDictionaryString(value: { value: ref<XmlDictionaryString> }): boolean;
}


export const XmlDictionaryReader: {
    createBinaryReader(buffer: byte[], offset: int, count: int, dictionary: IXmlDictionary, quotas: XmlDictionaryReaderQuotas, session: XmlBinaryReaderSession, onClose: OnXmlDictionaryReaderClose): XmlDictionaryReader;
    createBinaryReader(buffer: byte[], offset: int, count: int, dictionary: IXmlDictionary, quotas: XmlDictionaryReaderQuotas, session: XmlBinaryReaderSession): XmlDictionaryReader;
    createBinaryReader(buffer: byte[], offset: int, count: int, dictionary: IXmlDictionary, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    createBinaryReader(buffer: byte[], offset: int, count: int, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    createBinaryReader(buffer: byte[], quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    createBinaryReader(stream: Stream, dictionary: IXmlDictionary, quotas: XmlDictionaryReaderQuotas, session: XmlBinaryReaderSession, onClose: OnXmlDictionaryReaderClose): XmlDictionaryReader;
    createBinaryReader(stream: Stream, dictionary: IXmlDictionary, quotas: XmlDictionaryReaderQuotas, session: XmlBinaryReaderSession): XmlDictionaryReader;
    createBinaryReader(stream: Stream, dictionary: IXmlDictionary, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    createBinaryReader(stream: Stream, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    createDictionaryReader(reader: XmlReader): XmlDictionaryReader;
    createMtomReader(buffer: byte[], offset: int, count: int, encoding: Encoding, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    createMtomReader(buffer: byte[], offset: int, count: int, encodings: Encoding[], contentType: string, quotas: XmlDictionaryReaderQuotas, maxBufferSize: int, onClose: OnXmlDictionaryReaderClose): XmlDictionaryReader;
    createMtomReader(buffer: byte[], offset: int, count: int, encodings: Encoding[], contentType: string, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    createMtomReader(buffer: byte[], offset: int, count: int, encodings: Encoding[], quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    createMtomReader(stream: Stream, encoding: Encoding, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    createMtomReader(stream: Stream, encodings: Encoding[], contentType: string, quotas: XmlDictionaryReaderQuotas, maxBufferSize: int, onClose: OnXmlDictionaryReaderClose): XmlDictionaryReader;
    createMtomReader(stream: Stream, encodings: Encoding[], contentType: string, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    createMtomReader(stream: Stream, encodings: Encoding[], quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    createTextReader(buffer: byte[], offset: int, count: int, encoding: Encoding, quotas: XmlDictionaryReaderQuotas, onClose: OnXmlDictionaryReaderClose): XmlDictionaryReader;
    createTextReader(buffer: byte[], offset: int, count: int, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    createTextReader(buffer: byte[], quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    createTextReader(stream: Stream, encoding: Encoding, quotas: XmlDictionaryReaderQuotas, onClose: OnXmlDictionaryReaderClose): XmlDictionaryReader;
    createTextReader(stream: Stream, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
};


export interface __XmlDictionaryReader$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type XmlDictionaryReader = XmlDictionaryReader$instance & __XmlDictionaryReader$views;


export interface XmlDictionaryReaderQuotas$instance {
    maxArrayLength: int;
    maxBytesPerRead: int;
    maxDepth: int;
    maxNameTableCharCount: int;
    maxStringContentLength: int;
    readonly modifiedQuotas: XmlDictionaryReaderQuotaTypes;
    copyTo(quotas: XmlDictionaryReaderQuotas): void;
}


export const XmlDictionaryReaderQuotas: {
    new(): XmlDictionaryReaderQuotas$instance;
    readonly max: XmlDictionaryReaderQuotas;
};


export type XmlDictionaryReaderQuotas = XmlDictionaryReaderQuotas$instance;

export interface XmlDictionaryString$instance {
    readonly dictionary: IXmlDictionary;
    readonly key: int;
    readonly value: string;
    toString(): string;
}


export const XmlDictionaryString: {
    new(dictionary: IXmlDictionary, value: string, key: int): XmlDictionaryString$instance;
    readonly empty: XmlDictionaryString;
};


export type XmlDictionaryString = XmlDictionaryString$instance;

export interface XmlDictionaryWriter$instance extends XmlWriter$instance {
    readonly canCanonicalize: boolean;
    close(): void;
    dispose(): void;
    disposeAsync(): ValueTask;
    endCanonicalization(): void;
    startCanonicalization(stream: Stream, includeComments: boolean, inclusivePrefixes: string[]): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: boolean[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: boolean[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: short[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: short[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: int[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: int[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: long[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: long[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: float[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: float[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: double[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: double[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: decimal[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: decimal[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: DateTime[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: DateTime[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: Guid[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: Guid[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: TimeSpan[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: TimeSpan[], offset: int, count: int): void;
    writeAttributeString(localName: string, ns: string, value: string): void;
    writeAttributeString(localName: string, value: string): void;
    writeAttributeString(prefix: string, localName: string, ns: string, value: string): void;
    writeBase64Async(buffer: byte[], index: int, count: int): Task;
    writeElementString(localName: string, value: string): void;
    writeElementString(localName: string, ns: string, value: string): void;
    writeElementString(prefix: string, localName: string, ns: string, value: string): void;
    writeNode(reader: XmlReader, defattr: boolean): void;
    writeNode(navigator: XPathNavigator, defattr: boolean): void;
    writeQualifiedName(localName: string, ns: string): void;
    writeStartAttribute(localName: string, ns: string): void;
    writeStartAttribute(prefix: string, localName: string, ns: string): void;
    writeStartAttribute(localName: string): void;
    writeStartElement(localName: string, ns: string): void;
    writeStartElement(prefix: string, localName: string, ns: string): void;
    writeStartElement(localName: string): void;
    writeString(text: string): void;
    writeValue(value: XmlDictionaryString): void;
    writeValue(value: UniqueId): void;
    writeValue(value: TimeSpan): void;
    writeValue(value: IStreamProvider): void;
    writeValue(value: unknown): void;
    writeValue(value: string): void;
    writeValue(value: boolean): void;
    writeValue(value: DateTime): void;
    writeValue(value: DateTimeOffset): void;
    writeValue(value: double): void;
    writeValue(value: float): void;
    writeValue(value: decimal): void;
    writeValue(value: int): void;
    writeValue(value: long): void;
    writeValueAsync(value: IStreamProvider): Task;
    writeXmlAttribute(localName: string, value: string): void;
    writeXmlAttribute(localName: XmlDictionaryString, value: XmlDictionaryString): void;
    writeXmlnsAttribute(prefix: string, namespaceUri: string): void;
    writeXmlnsAttribute(prefix: string, namespaceUri: XmlDictionaryString): void;
}


export const XmlDictionaryWriter: {
    createBinaryWriter(stream: Stream, dictionary: IXmlDictionary, session: XmlBinaryWriterSession, ownsStream: boolean): XmlDictionaryWriter;
    createBinaryWriter(stream: Stream, dictionary: IXmlDictionary, session: XmlBinaryWriterSession): XmlDictionaryWriter;
    createBinaryWriter(stream: Stream, dictionary: IXmlDictionary): XmlDictionaryWriter;
    createBinaryWriter(stream: Stream): XmlDictionaryWriter;
    createDictionaryWriter(writer: XmlWriter): XmlDictionaryWriter;
    createMtomWriter(stream: Stream, encoding: Encoding, maxSizeInBytes: int, startInfo: string, boundary: string, startUri: string, writeMessageHeaders: boolean, ownsStream: boolean): XmlDictionaryWriter;
    createMtomWriter(stream: Stream, encoding: Encoding, maxSizeInBytes: int, startInfo: string): XmlDictionaryWriter;
    createTextWriter(stream: Stream, encoding: Encoding, ownsStream: boolean): XmlDictionaryWriter;
    createTextWriter(stream: Stream, encoding: Encoding): XmlDictionaryWriter;
    createTextWriter(stream: Stream): XmlDictionaryWriter;
};


export interface __XmlDictionaryWriter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type XmlDictionaryWriter = XmlDictionaryWriter$instance & __XmlDictionaryWriter$views;


export interface XmlDocument$instance extends XmlNode$instance {
    readonly baseURI: string;
    readonly documentElement: XmlElement;
    readonly documentType: XmlDocumentType;
    readonly implementation: XmlImplementation;
    innerText: string;
    innerXml: string;
    readonly isReadOnly: boolean;
    readonly localName: string;
    readonly name: string;
    readonly nameTable: XmlNameTable;
    readonly nodeType: XmlNodeType;
    readonly ownerDocument: XmlDocument;
    readonly parentNode: XmlNode;
    preserveWhitespace: boolean;
    readonly schemaInfo: IXmlSchemaInfo;
    schemas: XmlSchemaSet;
    xmlResolver: XmlResolver;
    clone(): XmlNode;
    clone(): unknown;
    cloneNode(deep: boolean): XmlNode;
    createAttribute(name: string): XmlAttribute;
    createAttribute(qualifiedName: string, namespaceURI: string): XmlAttribute;
    createAttribute(prefix: string, localName: string, namespaceURI: string): XmlAttribute;
    createCDataSection(data: string): XmlCDataSection;
    createComment(data: string): XmlComment;
    createDocumentFragment(): XmlDocumentFragment;
    createDocumentType(name: string, publicId: string, systemId: string, internalSubset: string): XmlDocumentType;
    createElement(name: string): XmlElement;
    createElement(qualifiedName: string, namespaceURI: string): XmlElement;
    createElement(prefix: string, localName: string, namespaceURI: string): XmlElement;
    createEntityReference(name: string): XmlEntityReference;
    createNavigator(): XPathNavigator;
    createNode(type_: XmlNodeType, prefix: string, name: string, namespaceURI: string): XmlNode;
    createNode(nodeTypeString: string, name: string, namespaceURI: string): XmlNode;
    createNode(type_: XmlNodeType, name: string, namespaceURI: string): XmlNode;
    createProcessingInstruction(target: string, data: string): XmlProcessingInstruction;
    createSignificantWhitespace(text: string): XmlSignificantWhitespace;
    createTextNode(text: string): XmlText;
    createWhitespace(text: string): XmlWhitespace;
    createXmlDeclaration(version: string, encoding: string, standalone: string): XmlDeclaration;
    getElementById(elementId: string): XmlElement;
    getElementsByTagName(name: string): XmlNodeList;
    getElementsByTagName(localName: string, namespaceURI: string): XmlNodeList;
    getEnumerator(): IEnumerator;
    importNode(node: XmlNode, deep: boolean): XmlNode;
    load(filename: string): void;
    load(inStream: Stream): void;
    load(txtReader: TextReader): void;
    load(reader: XmlReader): void;
    loadXml(xml: string): void;
    readNode(reader: XmlReader): XmlNode;
    save(filename: string): void;
    save(outStream: Stream): void;
    save(writer: TextWriter): void;
    save(w: XmlWriter): void;
    validate(validationEventHandler: ValidationEventHandler): void;
    validate(validationEventHandler: ValidationEventHandler, nodeToValidate: XmlNode): void;
    writeContentTo(xw: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export const XmlDocument: {
    new(): XmlDocument$instance;
    new(nt: XmlNameTable): XmlDocument$instance;
};


export interface __XmlDocument$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlDocument = XmlDocument$instance & __XmlDocument$views;


export interface XmlDocumentFragment$instance extends XmlNode$instance {
    innerXml: string;
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly ownerDocument: XmlDocument;
    readonly parentNode: XmlNode;
    clone(): XmlNode;
    clone(): unknown;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export const XmlDocumentFragment: {
    new(): XmlDocumentFragment$instance;
};


export interface __XmlDocumentFragment$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlDocumentFragment = XmlDocumentFragment$instance & __XmlDocumentFragment$views;


export interface XmlDocumentType$instance extends XmlLinkedNode$instance {
    readonly entities: XmlNamedNodeMap;
    readonly internalSubset: string;
    readonly isReadOnly: boolean;
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly notations: XmlNamedNodeMap;
    readonly publicId: string;
    readonly systemId: string;
    clone(): unknown;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export const XmlDocumentType: {
    new(): XmlDocumentType$instance;
};


export interface __XmlDocumentType$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlDocumentType = XmlDocumentType$instance & __XmlDocumentType$views;


export interface XmlElement$instance extends XmlLinkedNode$instance {
    readonly attributes: XmlAttributeCollection;
    readonly hasAttributes: boolean;
    innerText: string;
    innerXml: string;
    isEmpty: boolean;
    readonly localName: string;
    readonly name: string;
    readonly namespaceURI: string;
    readonly nextSibling: XmlNode;
    readonly nodeType: XmlNodeType;
    readonly ownerDocument: XmlDocument;
    readonly parentNode: XmlNode;
    prefix: string;
    readonly schemaInfo: IXmlSchemaInfo;
    clone(): unknown;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getAttribute(name: string): string;
    getAttribute(localName: string, namespaceURI: string): string;
    getAttributeNode(name: string): XmlAttribute;
    getAttributeNode(localName: string, namespaceURI: string): XmlAttribute;
    getElementsByTagName(name: string): XmlNodeList;
    getElementsByTagName(localName: string, namespaceURI: string): XmlNodeList;
    getEnumerator(): IEnumerator;
    hasAttribute(name: string): boolean;
    hasAttribute(localName: string, namespaceURI: string): boolean;
    removeAll(): void;
    removeAllAttributes(): void;
    removeAttribute(name: string): void;
    removeAttribute(localName: string, namespaceURI: string): void;
    removeAttributeAt(i: int): XmlNode;
    removeAttributeNode(oldAttr: XmlAttribute): XmlAttribute;
    removeAttributeNode(localName: string, namespaceURI: string): XmlAttribute;
    setAttribute(name: string, value: string): void;
    setAttribute(localName: string, namespaceURI: string, value: string): string;
    setAttributeNode(newAttr: XmlAttribute): XmlAttribute;
    setAttributeNode(localName: string, namespaceURI: string): XmlAttribute;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export const XmlElement: {
    new(): XmlElement$instance;
};


export interface __XmlElement$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlElement = XmlElement$instance & __XmlElement$views;


export interface XmlEntity$instance extends XmlNode$instance {
    readonly baseURI: string;
    innerText: string;
    innerXml: string;
    readonly isReadOnly: boolean;
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly notationName: string;
    readonly outerXml: string;
    readonly publicId: string;
    readonly systemId: string;
    clone(): XmlNode;
    clone(): unknown;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export const XmlEntity: {
    new(): XmlEntity$instance;
};


export interface __XmlEntity$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlEntity = XmlEntity$instance & __XmlEntity$views;


export interface XmlEntityReference$instance extends XmlLinkedNode$instance {
    readonly baseURI: string;
    readonly isReadOnly: boolean;
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    value: string;
    clone(): unknown;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export const XmlEntityReference: {
    new(): XmlEntityReference$instance;
};


export interface __XmlEntityReference$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlEntityReference = XmlEntityReference$instance & __XmlEntityReference$views;


export interface XmlException$instance extends SystemException {
    readonly lineNumber: int;
    readonly linePosition: int;
    readonly message: string;
    readonly sourceUri: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const XmlException: {
    new(): XmlException$instance;
    new(message: string): XmlException$instance;
    new(message: string, innerException: Exception): XmlException$instance;
    new(message: string, innerException: Exception, lineNumber: int, linePosition: int): XmlException$instance;
};


export interface __XmlException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XmlException = XmlException$instance & __XmlException$views;


export interface XmlImplementation$instance {
    createDocument(): XmlDocument;
    hasFeature(strFeature: string, strVersion: string): boolean;
}


export const XmlImplementation: {
    new(): XmlImplementation$instance;
    new(nt: XmlNameTable): XmlImplementation$instance;
};


export type XmlImplementation = XmlImplementation$instance;

export interface XmlLinkedNode$instance extends XmlNode$instance {
    readonly nextSibling: XmlNode;
    readonly previousSibling: XmlNode;
    clone(): XmlNode;
    clone(): unknown;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
}


export const XmlLinkedNode: {
};


export interface __XmlLinkedNode$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlLinkedNode = XmlLinkedNode$instance & __XmlLinkedNode$views;


export interface XmlNamedNodeMap$instance {
    readonly count: int;
    getEnumerator(): IEnumerator;
    getNamedItem(name: string): XmlNode;
    getNamedItem(localName: string, namespaceURI: string): XmlNode;
    item(index: int): XmlNode;
    removeNamedItem(name: string): XmlNode;
    removeNamedItem(localName: string, namespaceURI: string): XmlNode;
    setNamedItem(node: XmlNode): XmlNode;
}


export const XmlNamedNodeMap: {
    new(): XmlNamedNodeMap$instance;
};


export interface __XmlNamedNodeMap$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export interface XmlNamedNodeMap$instance extends System_Collections_Internal.IEnumerable$instance {}

export type XmlNamedNodeMap = XmlNamedNodeMap$instance & __XmlNamedNodeMap$views;


export interface XmlNamespaceManager$instance {
    readonly defaultNamespace: string;
    readonly nameTable: XmlNameTable;
    addNamespace(prefix: string, uri: string): void;
    getEnumerator(): IEnumerator;
    getNamespacesInScope(scope: XmlNamespaceScope): IDictionary_2<CLROf<string>, CLROf<string>>;
    hasNamespace(prefix: string): boolean;
    lookupNamespace(prefix: string): string;
    lookupPrefix(uri: string): string;
    popScope(): boolean;
    pushScope(): void;
    removeNamespace(prefix: string, uri: string): void;
}


export const XmlNamespaceManager: {
    new(nameTable: XmlNameTable): XmlNamespaceManager$instance;
};


export interface __XmlNamespaceManager$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IXmlNamespaceResolver(): IXmlNamespaceResolver$instance;
}

export interface XmlNamespaceManager$instance extends System_Collections_Internal.IEnumerable$instance, IXmlNamespaceResolver$instance {}

export type XmlNamespaceManager = XmlNamespaceManager$instance & __XmlNamespaceManager$views;


export interface XmlNameTable$instance {
    add(array: char[], offset: int, length: int): string;
    add(array: string): string;
    get_(array: char[], offset: int, length: int): string;
    get_(array: string): string;
}


export const XmlNameTable: {
};


export type XmlNameTable = XmlNameTable$instance;

export interface XmlNode$instance {
    readonly attributes: XmlAttributeCollection;
    readonly baseURI: string;
    readonly childNodes: XmlNodeList;
    readonly firstChild: XmlNode;
    readonly hasChildNodes: boolean;
    innerText: string;
    innerXml: string;
    readonly isReadOnly: boolean;
    readonly lastChild: XmlNode;
    readonly localName: string;
    readonly name: string;
    readonly namespaceURI: string;
    readonly nextSibling: XmlNode;
    readonly nodeType: XmlNodeType;
    readonly outerXml: string;
    readonly ownerDocument: XmlDocument;
    readonly parentNode: XmlNode;
    prefix: string;
    readonly previousSibling: XmlNode;
    readonly previousText: XmlNode;
    readonly schemaInfo: IXmlSchemaInfo;
    value: string;
    appendChild(newChild: XmlNode): XmlNode;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    get_Item(name: string): XmlElement;
    get_Item(localname: string, ns: string): XmlElement;
    getEnumerator(): IEnumerator;
    getNamespaceOfPrefix(prefix: string): string;
    getPrefixOfNamespace(namespaceURI: string): string;
    insertAfter(newChild: XmlNode, refChild: XmlNode): XmlNode;
    insertBefore(newChild: XmlNode, refChild: XmlNode): XmlNode;
    normalize(): void;
    prependChild(newChild: XmlNode): XmlNode;
    removeAll(): void;
    removeChild(oldChild: XmlNode): XmlNode;
    replaceChild(newChild: XmlNode, oldChild: XmlNode): XmlNode;
    selectNodes(xpath: string): XmlNodeList;
    selectNodes(xpath: string, nsmgr: XmlNamespaceManager): XmlNodeList;
    selectSingleNode(xpath: string): XmlNode;
    selectSingleNode(xpath: string, nsmgr: XmlNamespaceManager): XmlNode;
    supports(feature: string, version: string): boolean;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export const XmlNode: {
};


export interface __XmlNode$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export interface XmlNode$instance extends System_Collections_Internal.IEnumerable$instance, System_Xml_XPath_Internal.IXPathNavigable$instance {}

export type XmlNode = XmlNode$instance & __XmlNode$views;


export interface XmlNodeChangedEventArgs$instance extends EventArgs {
    readonly action: XmlNodeChangedAction;
    readonly newParent: XmlNode;
    readonly newValue: string;
    readonly node: XmlNode;
    readonly oldParent: XmlNode;
    readonly oldValue: string;
}


export const XmlNodeChangedEventArgs: {
    new(node: XmlNode, oldParent: XmlNode, newParent: XmlNode, oldValue: string, newValue: string, action: XmlNodeChangedAction): XmlNodeChangedEventArgs$instance;
};


export type XmlNodeChangedEventArgs = XmlNodeChangedEventArgs$instance;

export interface XmlNodeList$instance {
    readonly count: int;
    readonly itemOf: XmlNode;
    getEnumerator(): IEnumerator;
    item(index: int): XmlNode;
}


export const XmlNodeList: {
};


export interface __XmlNodeList$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface XmlNodeList$instance extends System_Collections_Internal.IEnumerable$instance, System_Internal.IDisposable$instance {}

export type XmlNodeList = XmlNodeList$instance & __XmlNodeList$views;


export interface XmlNodeReader$instance extends XmlReader$instance {
    readonly attributeCount: int;
    readonly baseURI: string;
    readonly canReadBinaryContent: boolean;
    readonly canResolveEntity: boolean;
    readonly depth: int;
    readonly EOF: boolean;
    readonly hasAttributes: boolean;
    readonly hasValue: boolean;
    readonly isDefault: boolean;
    readonly isEmptyElement: boolean;
    readonly localName: string;
    readonly name: string;
    readonly namespaceURI: string;
    readonly nameTable: XmlNameTable;
    readonly nodeType: XmlNodeType;
    readonly prefix: string;
    readonly readState: ReadState;
    readonly schemaInfo: IXmlSchemaInfo;
    readonly value: string;
    readonly xmlLang: string;
    readonly xmlSpace: XmlSpace;
    close(): void;
    dispose(): void;
    getAttribute(name: string): string;
    getAttribute(name: string, namespaceURI: string): string;
    getAttribute(attributeIndex: int): string;
    lookupNamespace(prefix: string): string;
    moveToAttribute(name: string): boolean;
    moveToAttribute(name: string, namespaceURI: string): boolean;
    moveToAttribute(attributeIndex: int): void;
    moveToElement(): boolean;
    moveToFirstAttribute(): boolean;
    moveToNextAttribute(): boolean;
    read(): boolean;
    readAttributeValue(): boolean;
    readContentAsBase64(buffer: byte[], index: int, count: int): int;
    readContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readElementContentAsBase64(buffer: byte[], index: int, count: int): int;
    readElementContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readString(): string;
    resolveEntity(): void;
    skip(): void;
}


export const XmlNodeReader: {
    new(node: XmlNode): XmlNodeReader$instance;
};


export interface __XmlNodeReader$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IXmlNamespaceResolver(): IXmlNamespaceResolver$instance;
}

export type XmlNodeReader = XmlNodeReader$instance & __XmlNodeReader$views;


export interface XmlNotation$instance extends XmlNode$instance {
    innerXml: string;
    readonly isReadOnly: boolean;
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly outerXml: string;
    readonly publicId: string;
    readonly systemId: string;
    clone(): XmlNode;
    clone(): unknown;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export const XmlNotation: {
    new(): XmlNotation$instance;
};


export interface __XmlNotation$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlNotation = XmlNotation$instance & __XmlNotation$views;


export interface XmlParserContext$instance {
    baseURI: string;
    docTypeName: string;
    encoding: Encoding;
    internalSubset: string;
    namespaceManager: XmlNamespaceManager;
    nameTable: XmlNameTable;
    publicId: string;
    systemId: string;
    xmlLang: string;
    xmlSpace: XmlSpace;
}


export const XmlParserContext: {
    new(nt: XmlNameTable, nsMgr: XmlNamespaceManager, xmlLang: string, xmlSpace: XmlSpace): XmlParserContext$instance;
    new(nt: XmlNameTable, nsMgr: XmlNamespaceManager, xmlLang: string, xmlSpace: XmlSpace, enc: Encoding): XmlParserContext$instance;
    new(nt: XmlNameTable, nsMgr: XmlNamespaceManager, docTypeName: string, pubId: string, sysId: string, internalSubset: string, baseURI: string, xmlLang: string, xmlSpace: XmlSpace): XmlParserContext$instance;
    new(nt: XmlNameTable, nsMgr: XmlNamespaceManager, docTypeName: string, pubId: string, sysId: string, internalSubset: string, baseURI: string, xmlLang: string, xmlSpace: XmlSpace, enc: Encoding): XmlParserContext$instance;
};


export type XmlParserContext = XmlParserContext$instance;

export interface XmlProcessingInstruction$instance extends XmlLinkedNode$instance {
    data: string;
    innerText: string;
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly target: string;
    value: string;
    clone(): unknown;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export const XmlProcessingInstruction: {
    new(): XmlProcessingInstruction$instance;
};


export interface __XmlProcessingInstruction$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlProcessingInstruction = XmlProcessingInstruction$instance & __XmlProcessingInstruction$views;


export interface XmlQualifiedName$instance {
    readonly isEmpty: boolean;
    readonly name: string;
    readonly namespace_: string;
    equals(other: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const XmlQualifiedName: {
    new(): XmlQualifiedName$instance;
    new(name: string): XmlQualifiedName$instance;
    new(name: string, ns: string): XmlQualifiedName$instance;
    readonly empty: XmlQualifiedName;
    toString(name: string, ns: string): string;
};


export type XmlQualifiedName = XmlQualifiedName$instance;

export interface XmlReader$instance {
    readonly attributeCount: int;
    readonly baseURI: string;
    readonly canReadBinaryContent: boolean;
    readonly canReadValueChunk: boolean;
    readonly canResolveEntity: boolean;
    readonly depth: int;
    readonly EOF: boolean;
    readonly hasAttributes: boolean;
    readonly hasValue: boolean;
    readonly isDefault: boolean;
    readonly isEmptyElement: boolean;
    readonly localName: string;
    readonly name: string;
    readonly namespaceURI: string;
    readonly nameTable: XmlNameTable;
    readonly nodeType: XmlNodeType;
    readonly prefix: string;
    readonly quoteChar: char;
    readonly readState: ReadState;
    readonly schemaInfo: IXmlSchemaInfo;
    readonly settings: XmlReaderSettings;
    readonly value: string;
    readonly valueType: Type;
    readonly xmlLang: string;
    readonly xmlSpace: XmlSpace;
    close(): void;
    dispose(): void;
    get_Item(i: int): string;
    get_Item(name: string): string;
    get_Item(name: string, namespaceURI: string): string;
    getAttribute(name: string): string;
    getAttribute(name: string, namespaceURI: string): string;
    getAttribute(i: int): string;
    getValueAsync(): Task_1<CLROf<string>>;
    isStartElement(): boolean;
    isStartElement(name: string): boolean;
    isStartElement(localname: string, ns: string): boolean;
    lookupNamespace(prefix: string): string;
    moveToAttribute(name: string): boolean;
    moveToAttribute(name: string, ns: string): boolean;
    moveToAttribute(i: int): void;
    moveToContent(): XmlNodeType;
    moveToContentAsync(): Task_1<XmlNodeType>;
    moveToElement(): boolean;
    moveToFirstAttribute(): boolean;
    moveToNextAttribute(): boolean;
    read(): boolean;
    readAsync(): Task_1<CLROf<boolean>>;
    readAttributeValue(): boolean;
    readContentAs(returnType: Type, namespaceResolver: IXmlNamespaceResolver): unknown;
    readContentAsAsync(returnType: Type, namespaceResolver: IXmlNamespaceResolver): Task_1<unknown>;
    readContentAsBase64(buffer: byte[], index: int, count: int): int;
    readContentAsBase64Async(buffer: byte[], index: int, count: int): Task_1<CLROf<int>>;
    readContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readContentAsBinHexAsync(buffer: byte[], index: int, count: int): Task_1<CLROf<int>>;
    readContentAsBoolean(): boolean;
    readContentAsDateTime(): DateTime;
    readContentAsDateTimeOffset(): DateTimeOffset;
    readContentAsDecimal(): decimal;
    readContentAsDouble(): double;
    readContentAsFloat(): float;
    readContentAsInt(): int;
    readContentAsLong(): long;
    readContentAsObject(): unknown;
    readContentAsObjectAsync(): Task_1<unknown>;
    readContentAsString(): string;
    readContentAsStringAsync(): Task_1<CLROf<string>>;
    readElementContentAs(returnType: Type, namespaceResolver: IXmlNamespaceResolver): unknown;
    readElementContentAs(returnType: Type, namespaceResolver: IXmlNamespaceResolver, localName: string, namespaceURI: string): unknown;
    readElementContentAsAsync(returnType: Type, namespaceResolver: IXmlNamespaceResolver): Task_1<unknown>;
    readElementContentAsBase64(buffer: byte[], index: int, count: int): int;
    readElementContentAsBase64Async(buffer: byte[], index: int, count: int): Task_1<CLROf<int>>;
    readElementContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readElementContentAsBinHexAsync(buffer: byte[], index: int, count: int): Task_1<CLROf<int>>;
    readElementContentAsBoolean(): boolean;
    readElementContentAsBoolean(localName: string, namespaceURI: string): boolean;
    readElementContentAsDateTime(): DateTime;
    readElementContentAsDateTime(localName: string, namespaceURI: string): DateTime;
    readElementContentAsDecimal(): decimal;
    readElementContentAsDecimal(localName: string, namespaceURI: string): decimal;
    readElementContentAsDouble(): double;
    readElementContentAsDouble(localName: string, namespaceURI: string): double;
    readElementContentAsFloat(): float;
    readElementContentAsFloat(localName: string, namespaceURI: string): float;
    readElementContentAsInt(): int;
    readElementContentAsInt(localName: string, namespaceURI: string): int;
    readElementContentAsLong(): long;
    readElementContentAsLong(localName: string, namespaceURI: string): long;
    readElementContentAsObject(): unknown;
    readElementContentAsObject(localName: string, namespaceURI: string): unknown;
    readElementContentAsObjectAsync(): Task_1<unknown>;
    readElementContentAsString(): string;
    readElementContentAsString(localName: string, namespaceURI: string): string;
    readElementContentAsStringAsync(): Task_1<CLROf<string>>;
    readElementString(): string;
    readElementString(name: string): string;
    readElementString(localname: string, ns: string): string;
    readEndElement(): void;
    readInnerXml(): string;
    readInnerXmlAsync(): Task_1<CLROf<string>>;
    readOuterXml(): string;
    readOuterXmlAsync(): Task_1<CLROf<string>>;
    readStartElement(): void;
    readStartElement(name: string): void;
    readStartElement(localname: string, ns: string): void;
    readString(): string;
    readSubtree(): XmlReader;
    readToDescendant(name: string): boolean;
    readToDescendant(localName: string, namespaceURI: string): boolean;
    readToFollowing(name: string): boolean;
    readToFollowing(localName: string, namespaceURI: string): boolean;
    readToNextSibling(name: string): boolean;
    readToNextSibling(localName: string, namespaceURI: string): boolean;
    readValueChunk(buffer: char[], index: int, count: int): int;
    readValueChunkAsync(buffer: char[], index: int, count: int): Task_1<CLROf<int>>;
    resolveEntity(): void;
    skip(): void;
    skipAsync(): Task;
}


export const XmlReader: {
    create(input: Stream, settings: XmlReaderSettings, baseUri: string): XmlReader;
    create(input: Stream, settings: XmlReaderSettings, inputContext: XmlParserContext): XmlReader;
    create(input: Stream, settings: XmlReaderSettings): XmlReader;
    create(input: Stream): XmlReader;
    create(input: TextReader, settings: XmlReaderSettings, baseUri: string): XmlReader;
    create(input: TextReader, settings: XmlReaderSettings, inputContext: XmlParserContext): XmlReader;
    create(input: TextReader, settings: XmlReaderSettings): XmlReader;
    create(input: TextReader): XmlReader;
    create(inputUri: string, settings: XmlReaderSettings, inputContext: XmlParserContext): XmlReader;
    create(inputUri: string, settings: XmlReaderSettings): XmlReader;
    create(inputUri: string): XmlReader;
    create(reader: XmlReader, settings: XmlReaderSettings): XmlReader;
    isName(str: string): boolean;
    isNameToken(str: string): boolean;
};


export interface __XmlReader$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface XmlReader$instance extends System_Internal.IDisposable$instance {}

export type XmlReader = XmlReader$instance & __XmlReader$views;


export interface XmlReaderSettings$instance {
    async_: boolean;
    checkCharacters: boolean;
    closeInput: boolean;
    conformanceLevel: ConformanceLevel;
    dtdProcessing: DtdProcessing;
    ignoreComments: boolean;
    ignoreProcessingInstructions: boolean;
    ignoreWhitespace: boolean;
    lineNumberOffset: int;
    linePositionOffset: int;
    maxCharactersFromEntities: long;
    maxCharactersInDocument: long;
    nameTable: XmlNameTable;
    prohibitDtd: boolean;
    schemas: XmlSchemaSet;
    validationFlags: XmlSchemaValidationFlags;
    validationType: ValidationType;
    xmlResolver: XmlResolver;
    clone(): XmlReaderSettings;
    reset(): void;
}


export const XmlReaderSettings: {
    new(): XmlReaderSettings$instance;
};


export type XmlReaderSettings = XmlReaderSettings$instance;

export interface XmlResolver$instance {
    credentials: ICredentials;
    getEntity(absoluteUri: Uri, role: string, ofObjectToReturn: Type): unknown;
    getEntityAsync(absoluteUri: Uri, role: string, ofObjectToReturn: Type): Task_1<unknown>;
    resolveUri(baseUri: Uri, relativeUri: string): Uri;
    supportsType(absoluteUri: Uri, type_: Type): boolean;
}


export const XmlResolver: {
    readonly fileSystemResolver: XmlResolver;
    readonly throwingResolver: XmlResolver;
};


export type XmlResolver = XmlResolver$instance;

export interface XmlSecureResolver$instance extends XmlResolver {
    credentials: ICredentials;
    getEntity(absoluteUri: Uri, role: string, ofObjectToReturn: Type): unknown;
    getEntityAsync(absoluteUri: Uri, role: string, ofObjectToReturn: Type): Task_1<unknown>;
    getEntityAsync(absoluteUri: Uri, role: string, ofObjectToReturn: Type): Task_1<unknown>;
    resolveUri(baseUri: Uri, relativeUri: string): Uri;
}


export const XmlSecureResolver: {
    new(resolver: XmlResolver, securityUrl: string): XmlSecureResolver$instance;
};


export type XmlSecureResolver = XmlSecureResolver$instance;

export interface XmlSignificantWhitespace$instance extends XmlCharacterData$instance {
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly parentNode: XmlNode;
    readonly previousText: XmlNode;
    value: string;
    clone(): unknown;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export const XmlSignificantWhitespace: {
    new(): XmlSignificantWhitespace$instance;
};


export interface __XmlSignificantWhitespace$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlSignificantWhitespace = XmlSignificantWhitespace$instance & __XmlSignificantWhitespace$views;


export interface XmlText$instance extends XmlCharacterData$instance {
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly parentNode: XmlNode;
    readonly previousText: XmlNode;
    value: string;
    clone(): unknown;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    splitText(offset: int): XmlText;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export const XmlText: {
    new(): XmlText$instance;
};


export interface __XmlText$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlText = XmlText$instance & __XmlText$views;


export interface XmlTextReader$instance extends XmlReader$instance {
    readonly attributeCount: int;
    readonly baseURI: string;
    readonly canReadBinaryContent: boolean;
    readonly canReadValueChunk: boolean;
    readonly canResolveEntity: boolean;
    readonly depth: int;
    dtdProcessing: DtdProcessing;
    readonly encoding: Encoding;
    entityHandling: EntityHandling;
    readonly EOF: boolean;
    readonly hasValue: boolean;
    readonly isDefault: boolean;
    readonly isEmptyElement: boolean;
    readonly lineNumber: int;
    readonly linePosition: int;
    readonly localName: string;
    readonly name: string;
    namespaces: boolean;
    readonly namespaceURI: string;
    readonly nameTable: XmlNameTable;
    readonly nodeType: XmlNodeType;
    normalization: boolean;
    readonly prefix: string;
    prohibitDtd: boolean;
    readonly quoteChar: char;
    readonly readState: ReadState;
    readonly value: string;
    whitespaceHandling: WhitespaceHandling;
    readonly xmlLang: string;
    xmlResolver: XmlResolver;
    readonly xmlSpace: XmlSpace;
    close(): void;
    dispose(): void;
    getAttribute(name: string): string;
    getAttribute(localName: string, namespaceURI: string): string;
    getAttribute(i: int): string;
    getNamespacesInScope(scope: XmlNamespaceScope): IDictionary_2<CLROf<string>, CLROf<string>>;
    getRemainder(): TextReader;
    hasLineInfo(): boolean;
    lookupNamespace(prefix: string): string;
    moveToAttribute(name: string): boolean;
    moveToAttribute(localName: string, namespaceURI: string): boolean;
    moveToAttribute(i: int): void;
    moveToElement(): boolean;
    moveToFirstAttribute(): boolean;
    moveToNextAttribute(): boolean;
    read(): boolean;
    readAttributeValue(): boolean;
    readBase64(array: byte[], offset: int, len: int): int;
    readBinHex(array: byte[], offset: int, len: int): int;
    readChars(buffer: char[], index: int, count: int): int;
    readContentAsBase64(buffer: byte[], index: int, count: int): int;
    readContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readElementContentAsBase64(buffer: byte[], index: int, count: int): int;
    readElementContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readString(): string;
    resetState(): void;
    resolveEntity(): void;
    skip(): void;
}


export const XmlTextReader: {
    new(input: Stream): XmlTextReader$instance;
    new(url: string, input: Stream): XmlTextReader$instance;
    new(input: Stream, nt: XmlNameTable): XmlTextReader$instance;
    new(url: string, input: Stream, nt: XmlNameTable): XmlTextReader$instance;
    new(input: TextReader): XmlTextReader$instance;
    new(url: string, input: TextReader): XmlTextReader$instance;
    new(input: TextReader, nt: XmlNameTable): XmlTextReader$instance;
    new(url: string, input: TextReader, nt: XmlNameTable): XmlTextReader$instance;
    new(xmlFragment: Stream, fragType: XmlNodeType, context: XmlParserContext): XmlTextReader$instance;
    new(xmlFragment: string, fragType: XmlNodeType, context: XmlParserContext): XmlTextReader$instance;
    new(url: string): XmlTextReader$instance;
    new(url: string, nt: XmlNameTable): XmlTextReader$instance;
};


export interface __XmlTextReader$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IXmlLineInfo(): IXmlLineInfo$instance;
    As_IXmlNamespaceResolver(): IXmlNamespaceResolver$instance;
}

export interface XmlTextReader$instance extends IXmlLineInfo$instance {}

export type XmlTextReader = XmlTextReader$instance & __XmlTextReader$views;


export interface XmlTextWriter$instance extends XmlWriter$instance {
    readonly baseStream: Stream;
    formatting: Formatting;
    indentation: int;
    indentChar: char;
    namespaces: boolean;
    quoteChar: char;
    readonly writeState: WriteState;
    readonly xmlLang: string;
    readonly xmlSpace: XmlSpace;
    close(): void;
    dispose(): void;
    disposeAsync(): ValueTask;
    flush(): void;
    lookupPrefix(ns: string): string;
    writeBase64(buffer: byte[], index: int, count: int): void;
    writeBinHex(buffer: byte[], index: int, count: int): void;
    writeCData(text: string): void;
    writeCharEntity(ch: char): void;
    writeChars(buffer: char[], index: int, count: int): void;
    writeComment(text: string): void;
    writeDocType(name: string, pubid: string, sysid: string, subset: string): void;
    writeEndAttribute(): void;
    writeEndDocument(): void;
    writeEndElement(): void;
    writeEntityRef(name: string): void;
    writeFullEndElement(): void;
    writeName(name: string): void;
    writeNmToken(name: string): void;
    writeProcessingInstruction(name: string, text: string): void;
    writeQualifiedName(localName: string, ns: string): void;
    writeRaw(buffer: char[], index: int, count: int): void;
    writeRaw(data: string): void;
    writeStartAttribute(prefix: string, localName: string, ns: string): void;
    writeStartAttribute(localName: string, ns: string): void;
    writeStartAttribute(localName: string): void;
    writeStartDocument(): void;
    writeStartDocument(standalone: boolean): void;
    writeStartElement(prefix: string, localName: string, ns: string): void;
    writeStartElement(localName: string, ns: string): void;
    writeStartElement(localName: string): void;
    writeString(text: string): void;
    writeSurrogateCharEntity(lowChar: char, highChar: char): void;
    writeWhitespace(ws: string): void;
}


export const XmlTextWriter: {
    new(w: Stream, encoding: Encoding): XmlTextWriter$instance;
    new(filename: string, encoding: Encoding): XmlTextWriter$instance;
    new(w: TextWriter): XmlTextWriter$instance;
};


export interface __XmlTextWriter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type XmlTextWriter = XmlTextWriter$instance & __XmlTextWriter$views;


export interface XmlUrlResolver$instance extends XmlResolver {
    cachePolicy: RequestCachePolicy;
    credentials: ICredentials;
    proxy: IWebProxy;
    getEntity(absoluteUri: Uri, role: string, ofObjectToReturn: Type): unknown;
    getEntityAsync(absoluteUri: Uri, role: string, ofObjectToReturn: Type): Task_1<unknown>;
    getEntityAsync(absoluteUri: Uri, role: string, ofObjectToReturn: Type): Task_1<unknown>;
    resolveUri(baseUri: Uri, relativeUri: string): Uri;
}


export const XmlUrlResolver: {
    new(): XmlUrlResolver$instance;
};


export type XmlUrlResolver = XmlUrlResolver$instance;

export interface XmlValidatingReader$instance extends XmlReader$instance {
    readonly attributeCount: int;
    readonly baseURI: string;
    readonly canReadBinaryContent: boolean;
    readonly canResolveEntity: boolean;
    readonly depth: int;
    readonly encoding: Encoding;
    entityHandling: EntityHandling;
    readonly EOF: boolean;
    readonly hasValue: boolean;
    readonly isDefault: boolean;
    readonly isEmptyElement: boolean;
    readonly lineNumber: int;
    readonly linePosition: int;
    readonly localName: string;
    readonly name: string;
    namespaces: boolean;
    readonly namespaceURI: string;
    readonly nameTable: XmlNameTable;
    readonly nodeType: XmlNodeType;
    readonly prefix: string;
    readonly quoteChar: char;
    readonly reader: XmlReader;
    readonly readState: ReadState;
    readonly schemas: XmlSchemaCollection;
    readonly schemaType: unknown;
    validationType: ValidationType;
    readonly value: string;
    readonly xmlLang: string;
    xmlResolver: XmlResolver;
    readonly xmlSpace: XmlSpace;
    close(): void;
    dispose(): void;
    getAttribute(name: string): string;
    getAttribute(localName: string, namespaceURI: string): string;
    getAttribute(i: int): string;
    hasLineInfo(): boolean;
    lookupNamespace(prefix: string): string;
    moveToAttribute(name: string): boolean;
    moveToAttribute(localName: string, namespaceURI: string): boolean;
    moveToAttribute(i: int): void;
    moveToElement(): boolean;
    moveToFirstAttribute(): boolean;
    moveToNextAttribute(): boolean;
    read(): boolean;
    readAttributeValue(): boolean;
    readContentAsBase64(buffer: byte[], index: int, count: int): int;
    readContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readElementContentAsBase64(buffer: byte[], index: int, count: int): int;
    readElementContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readString(): string;
    readTypedValue(): unknown;
    resolveEntity(): void;
}


export const XmlValidatingReader: {
    new(reader: XmlReader): XmlValidatingReader$instance;
    new(xmlFragment: string, fragType: XmlNodeType, context: XmlParserContext): XmlValidatingReader$instance;
    new(xmlFragment: Stream, fragType: XmlNodeType, context: XmlParserContext): XmlValidatingReader$instance;
};


export interface __XmlValidatingReader$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IXmlLineInfo(): IXmlLineInfo$instance;
    As_IXmlNamespaceResolver(): IXmlNamespaceResolver$instance;
}

export interface XmlValidatingReader$instance extends IXmlLineInfo$instance {}

export type XmlValidatingReader = XmlValidatingReader$instance & __XmlValidatingReader$views;


export interface XmlWhitespace$instance extends XmlCharacterData$instance {
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly parentNode: XmlNode;
    readonly previousText: XmlNode;
    value: string;
    clone(): unknown;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export const XmlWhitespace: {
    new(): XmlWhitespace$instance;
};


export interface __XmlWhitespace$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlWhitespace = XmlWhitespace$instance & __XmlWhitespace$views;


export interface XmlWriter$instance {
    readonly settings: XmlWriterSettings;
    readonly writeState: WriteState;
    readonly xmlLang: string;
    readonly xmlSpace: XmlSpace;
    close(): void;
    dispose(): void;
    disposeAsync(): ValueTask;
    flush(): void;
    flushAsync(): Task;
    lookupPrefix(ns: string): string;
    writeAttributes(reader: XmlReader, defattr: boolean): void;
    writeAttributesAsync(reader: XmlReader, defattr: boolean): Task;
    writeAttributeString(localName: string, ns: string, value: string): void;
    writeAttributeString(localName: string, value: string): void;
    writeAttributeString(prefix: string, localName: string, ns: string, value: string): void;
    writeAttributeStringAsync(prefix: string, localName: string, ns: string, value: string): Task;
    writeBase64(buffer: byte[], index: int, count: int): void;
    writeBase64Async(buffer: byte[], index: int, count: int): Task;
    writeBinHex(buffer: byte[], index: int, count: int): void;
    writeBinHexAsync(buffer: byte[], index: int, count: int): Task;
    writeCData(text: string): void;
    writeCDataAsync(text: string): Task;
    writeCharEntity(ch: char): void;
    writeCharEntityAsync(ch: char): Task;
    writeChars(buffer: char[], index: int, count: int): void;
    writeCharsAsync(buffer: char[], index: int, count: int): Task;
    writeComment(text: string): void;
    writeCommentAsync(text: string): Task;
    writeDocType(name: string, pubid: string, sysid: string, subset: string): void;
    writeDocTypeAsync(name: string, pubid: string, sysid: string, subset: string): Task;
    writeElementString(localName: string, value: string): void;
    writeElementString(localName: string, ns: string, value: string): void;
    writeElementString(prefix: string, localName: string, ns: string, value: string): void;
    writeElementStringAsync(prefix: string, localName: string, ns: string, value: string): Task;
    writeEndAttribute(): void;
    writeEndDocument(): void;
    writeEndDocumentAsync(): Task;
    writeEndElement(): void;
    writeEndElementAsync(): Task;
    writeEntityRef(name: string): void;
    writeEntityRefAsync(name: string): Task;
    writeFullEndElement(): void;
    writeFullEndElementAsync(): Task;
    writeName(name: string): void;
    writeNameAsync(name: string): Task;
    writeNmToken(name: string): void;
    writeNmTokenAsync(name: string): Task;
    writeNode(reader: XmlReader, defattr: boolean): void;
    writeNode(navigator: XPathNavigator, defattr: boolean): void;
    writeNodeAsync(reader: XmlReader, defattr: boolean): Task;
    writeNodeAsync(navigator: XPathNavigator, defattr: boolean): Task;
    writeProcessingInstruction(name: string, text: string): void;
    writeProcessingInstructionAsync(name: string, text: string): Task;
    writeQualifiedName(localName: string, ns: string): void;
    writeQualifiedNameAsync(localName: string, ns: string): Task;
    writeRaw(buffer: char[], index: int, count: int): void;
    writeRaw(data: string): void;
    writeRawAsync(buffer: char[], index: int, count: int): Task;
    writeRawAsync(data: string): Task;
    writeStartAttribute(localName: string, ns: string): void;
    writeStartAttribute(prefix: string, localName: string, ns: string): void;
    writeStartAttribute(localName: string): void;
    writeStartDocument(): void;
    writeStartDocument(standalone: boolean): void;
    writeStartDocumentAsync(): Task;
    writeStartDocumentAsync(standalone: boolean): Task;
    writeStartElement(localName: string, ns: string): void;
    writeStartElement(prefix: string, localName: string, ns: string): void;
    writeStartElement(localName: string): void;
    writeStartElementAsync(prefix: string, localName: string, ns: string): Task;
    writeString(text: string): void;
    writeStringAsync(text: string): Task;
    writeSurrogateCharEntity(lowChar: char, highChar: char): void;
    writeSurrogateCharEntityAsync(lowChar: char, highChar: char): Task;
    writeValue(value: unknown): void;
    writeValue(value: string): void;
    writeValue(value: boolean): void;
    writeValue(value: DateTime): void;
    writeValue(value: DateTimeOffset): void;
    writeValue(value: double): void;
    writeValue(value: float): void;
    writeValue(value: decimal): void;
    writeValue(value: int): void;
    writeValue(value: long): void;
    writeWhitespace(ws: string): void;
    writeWhitespaceAsync(ws: string): Task;
}


export const XmlWriter: {
    create(output: Stream, settings: XmlWriterSettings): XmlWriter;
    create(output: Stream): XmlWriter;
    create(output: TextWriter, settings: XmlWriterSettings): XmlWriter;
    create(output: TextWriter): XmlWriter;
    create(outputFileName: string, settings: XmlWriterSettings): XmlWriter;
    create(outputFileName: string): XmlWriter;
    create(output: StringBuilder, settings: XmlWriterSettings): XmlWriter;
    create(output: StringBuilder): XmlWriter;
    create(output: XmlWriter, settings: XmlWriterSettings): XmlWriter;
    create(output: XmlWriter): XmlWriter;
};


export interface __XmlWriter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface XmlWriter$instance extends System_Internal.IAsyncDisposable$instance, System_Internal.IDisposable$instance {}

export type XmlWriter = XmlWriter$instance & __XmlWriter$views;


export interface XmlWriterSettings$instance {
    async_: boolean;
    checkCharacters: boolean;
    closeOutput: boolean;
    conformanceLevel: ConformanceLevel;
    doNotEscapeUriAttributes: boolean;
    encoding: Encoding;
    indent: boolean;
    indentChars: string;
    namespaceHandling: NamespaceHandling;
    newLineChars: string;
    newLineHandling: NewLineHandling;
    newLineOnAttributes: boolean;
    omitXmlDeclaration: boolean;
    readonly outputMethod: XmlOutputMethod;
    writeEndDocumentOnClose: boolean;
    clone(): XmlWriterSettings;
    reset(): void;
}


export const XmlWriterSettings: {
    new(): XmlWriterSettings$instance;
};


export type XmlWriterSettings = XmlWriterSettings$instance;

