// Generated by tsbindgen - Architecture
// Namespace: System.Collections.Immutable
// Assembly: System.Collections.Immutable

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IComparer_1, IDictionary_2, IEnumerable_1, IEnumerator_1, IEqualityComparer_1, IList_1, IReadOnlyCollection_1, IReadOnlyDictionary_2, IReadOnlyList_1, IReadOnlySet_1, ISet_1, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IComparer, IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator, IEqualityComparer, IList, IStructuralComparable, IStructuralEquatable } from "../../System.Collections/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Array as ClrArray, Boolean as ClrBoolean, Comparison_1, Func_2, Func_3, IDisposable, IEquatable_1, Int32, Object as ClrObject, Predicate_1, Range, ReadOnlyMemory_1, ReadOnlySpan_1, Span_1, String as ClrString, Type, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface IImmutableDictionary_2$instance<TKey, TValue> extends IReadOnlyDictionary_2<TKey, TValue>, IEnumerable_1<KeyValuePair_2<TKey, TValue>>, IEnumerable, IReadOnlyCollection_1<KeyValuePair_2<TKey, TValue>> {
    readonly item: TValue;
    readonly keys: IEnumerable_1<TKey>;
    readonly values: IEnumerable_1<TValue>;
    readonly count: int;
    add(key: TKey, value: TValue): IImmutableDictionary_2<TKey, TValue>;
    addRange(pairs: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): IImmutableDictionary_2<TKey, TValue>;
    clear(): IImmutableDictionary_2<TKey, TValue>;
    contains(pair: KeyValuePair_2<TKey, TValue>): boolean;
    containsKey(key: TKey): boolean;
    getEnumerator(): IEnumerator_1<KeyValuePair_2<TKey, TValue>>;
    getEnumerator(): IEnumerator;
    remove(key: TKey): IImmutableDictionary_2<TKey, TValue>;
    tryGetKey(equalKey: TKey, actualKey: { value: ref<TKey> }): boolean;
    tryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
}


export type IImmutableDictionary_2<TKey, TValue> = IImmutableDictionary_2$instance<TKey, TValue>;

export interface IImmutableList_1$instance<T> extends IReadOnlyList_1<T>, IEnumerable_1<T>, IEnumerable, IReadOnlyCollection_1<T> {
    readonly item: T;
    readonly count: int;
    add(value: T): IImmutableList_1<T>;
    addRange(items: IEnumerable_1<T>): IImmutableList_1<T>;
    clear(): IImmutableList_1<T>;
    getEnumerator(): IEnumerator_1<T>;
    getEnumerator(): IEnumerator;
    indexOf(item: T, index: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    insert(index: int, element: T): IImmutableList_1<T>;
    insertRange(index: int, items: IEnumerable_1<T>): IImmutableList_1<T>;
    remove(value: T, equalityComparer: IEqualityComparer_1<T>): IImmutableList_1<T>;
    removeAll(match: Predicate_1<T>): IImmutableList_1<T>;
    removeAt(index: int): IImmutableList_1<T>;
    removeRange(items: IEnumerable_1<T>, equalityComparer: IEqualityComparer_1<T>): IImmutableList_1<T>;
    removeRange(index: int, count: int): IImmutableList_1<T>;
    replace(oldValue: T, newValue: T, equalityComparer: IEqualityComparer_1<T>): IImmutableList_1<T>;
}


export type IImmutableList_1<T> = IImmutableList_1$instance<T>;

export interface IImmutableQueue_1$instance<T> extends IEnumerable_1<T>, IEnumerable {
    readonly isEmpty: boolean;
    clear(): IImmutableQueue_1<T>;
    enqueue(value: T): IImmutableQueue_1<T>;
    getEnumerator(): IEnumerator_1<T>;
    getEnumerator(): IEnumerator;
    peek(): T;
}


export type IImmutableQueue_1<T> = IImmutableQueue_1$instance<T>;

export interface IImmutableSet_1$instance<T> extends IReadOnlyCollection_1<T>, IEnumerable_1<T>, IEnumerable {
    readonly count: int;
    add(value: T): IImmutableSet_1<T>;
    clear(): IImmutableSet_1<T>;
    contains(value: T): boolean;
    getEnumerator(): IEnumerator_1<T>;
    getEnumerator(): IEnumerator;
    intersect(other: IEnumerable_1<T>): IImmutableSet_1<T>;
    setEquals(other: IEnumerable_1<T>): boolean;
    tryGetValue(equalValue: T, actualValue: { value: ref<T> }): boolean;
}


export type IImmutableSet_1<T> = IImmutableSet_1$instance<T>;

export interface IImmutableStack_1$instance<T> extends IEnumerable_1<T>, IEnumerable {
    readonly isEmpty: boolean;
    clear(): IImmutableStack_1<T>;
    getEnumerator(): IEnumerator_1<T>;
    getEnumerator(): IEnumerator;
    peek(): T;
    push(value: T): IImmutableStack_1<T>;
}


export type IImmutableStack_1<T> = IImmutableStack_1$instance<T>;

export interface ImmutableArray_1$instance<T> {
    readonly isDefault: boolean;
    readonly isDefaultOrEmpty: boolean;
    readonly isEmpty: boolean;
    readonly item: T;
    readonly length: int;
    add(item: T): ImmutableArray_1<T>;
    addRange(items: IEnumerable_1<T>): ImmutableArray_1<T>;
    addRange(items: T[], length: int): ImmutableArray_1<T>;
    addRange<TDerived extends T>(items: TDerived[]): ImmutableArray_1<T>;
    addRange(items: ImmutableArray_1<T>, length: int): ImmutableArray_1<T>;
    addRange<TDerived extends T>(items: ImmutableArray_1<TDerived>): ImmutableArray_1<T>;
    addRange(items: ReadOnlySpan_1<T>): ImmutableArray_1<T>;
    addRange(items: T[]): ImmutableArray_1<T>;
    as_<TOther>(): ImmutableArray_1<TOther>;
    asMemory(): ReadOnlyMemory_1<T>;
    asSpan(): ReadOnlySpan_1<T>;
    asSpan(start: int, length: int): ReadOnlySpan_1<T>;
    asSpan(range: Range): ReadOnlySpan_1<T>;
    castArray<TOther>(): ImmutableArray_1<TOther>;
    clear(): ImmutableArray_1<T>;
    contains(item: T): boolean;
    contains(item: T, equalityComparer: IEqualityComparer_1<T>): boolean;
    copyTo(destination: Span_1<T>): void;
    copyTo(destination: T[]): void;
    copyTo(destination: T[], destinationIndex: int): void;
    copyTo(sourceIndex: int, destination: T[], destinationIndex: int, length: int): void;
    equals(obj: unknown): boolean;
    equals(other: ImmutableArray_1<T>): boolean;
    getEnumerator(): ImmutableArray_1_Enumerator<T>;
    getHashCode(): int;
    indexOf(item: T): int;
    indexOf(item: T, startIndex: int, equalityComparer: IEqualityComparer_1<T>): int;
    indexOf(item: T, startIndex: int): int;
    indexOf(item: T, startIndex: int, count: int): int;
    indexOf(item: T, startIndex: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    insert(index: int, item: T): ImmutableArray_1<T>;
    insertRange(index: int, items: IEnumerable_1<T>): ImmutableArray_1<T>;
    insertRange(index: int, items: ImmutableArray_1<T>): ImmutableArray_1<T>;
    insertRange(index: int, items: T[]): ImmutableArray_1<T>;
    insertRange(index: int, items: ReadOnlySpan_1<T>): ImmutableArray_1<T>;
    itemRef(index: int): ref<T>;
    lastIndexOf(item: T): int;
    lastIndexOf(item: T, startIndex: int): int;
    lastIndexOf(item: T, startIndex: int, count: int): int;
    lastIndexOf(item: T, startIndex: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    ofType<TResult>(): IEnumerable_1<TResult>;
    remove(item: T): ImmutableArray_1<T>;
    remove(item: T, equalityComparer: IEqualityComparer_1<T>): ImmutableArray_1<T>;
    removeAll(match: Predicate_1<T>): ImmutableArray_1<T>;
    removeAt(index: int): ImmutableArray_1<T>;
    removeRange(index: int, length: int): ImmutableArray_1<T>;
    removeRange(items: IEnumerable_1<T>): ImmutableArray_1<T>;
    removeRange(items: IEnumerable_1<T>, equalityComparer: IEqualityComparer_1<T>): ImmutableArray_1<T>;
    removeRange(items: ImmutableArray_1<T>): ImmutableArray_1<T>;
    removeRange(items: ImmutableArray_1<T>, equalityComparer: IEqualityComparer_1<T>): ImmutableArray_1<T>;
    removeRange(items: ReadOnlySpan_1<T>, equalityComparer?: IEqualityComparer_1<T>): ImmutableArray_1<T>;
    removeRange(items: T[], equalityComparer?: IEqualityComparer_1<T>): ImmutableArray_1<T>;
    replace(oldValue: T, newValue: T): ImmutableArray_1<T>;
    replace(oldValue: T, newValue: T, equalityComparer: IEqualityComparer_1<T>): ImmutableArray_1<T>;
    setItem(index: int, item: T): ImmutableArray_1<T>;
    slice(start: int, length: int): ImmutableArray_1<T>;
    sort(): ImmutableArray_1<T>;
    sort(comparison: Comparison_1<T>): ImmutableArray_1<T>;
    sort(comparer: IComparer_1<T>): ImmutableArray_1<T>;
    sort(index: int, count: int, comparer: IComparer_1<T>): ImmutableArray_1<T>;
    toBuilder(): ImmutableArray_1_Builder<T>;
}


export const ImmutableArray_1: {
    new<T>(): ImmutableArray_1$instance<T>;
    readonly empty: unknown;
    castUp<T, TDerived extends T>(items: ImmutableArray_1<TDerived>): ImmutableArray_1<T>;
};


export interface __ImmutableArray_1$views<T> {
    As_IImmutableList_1(): IImmutableList_1$instance<T>;
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<ImmutableArray_1<T>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ImmutableArray_1<T>): boolean;
}

export interface ImmutableArray_1$instance<T> extends System_Collections_Internal.IStructuralComparable$instance {}

export type ImmutableArray_1<T> = ImmutableArray_1$instance<T> & __ImmutableArray_1$views<T>;


export interface ImmutableArray_1_Enumerator$instance<T> {
    readonly current: T;
    moveNext(): boolean;
}


export const ImmutableArray_1_Enumerator: {
    new<T>(): ImmutableArray_1_Enumerator$instance<T>;
};


export type ImmutableArray_1_Enumerator<T> = ImmutableArray_1_Enumerator$instance<T>;

export interface ImmutableDictionary_2_Enumerator$instance<TKey, TValue> extends IDisposable {
    readonly current: KeyValuePair_2<TKey, TValue>;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const ImmutableDictionary_2_Enumerator: {
    new<TKey, TValue>(): ImmutableDictionary_2_Enumerator$instance<TKey, TValue>;
};


export interface __ImmutableDictionary_2_Enumerator$views<TKey, TValue> {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type ImmutableDictionary_2_Enumerator<TKey, TValue> = ImmutableDictionary_2_Enumerator$instance<TKey, TValue> & __ImmutableDictionary_2_Enumerator$views<TKey, TValue>;


export interface ImmutableHashSet_1_Enumerator$instance<T> extends IDisposable {
    readonly current: T;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const ImmutableHashSet_1_Enumerator: {
    new<T>(): ImmutableHashSet_1_Enumerator$instance<T>;
};


export interface __ImmutableHashSet_1_Enumerator$views<T> {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type ImmutableHashSet_1_Enumerator<T> = ImmutableHashSet_1_Enumerator$instance<T> & __ImmutableHashSet_1_Enumerator$views<T>;


export interface ImmutableList_1_Enumerator$instance<T> extends IDisposable {
    readonly current: T;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const ImmutableList_1_Enumerator: {
    new<T>(): ImmutableList_1_Enumerator$instance<T>;
};


export interface __ImmutableList_1_Enumerator$views<T> {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type ImmutableList_1_Enumerator<T> = ImmutableList_1_Enumerator$instance<T> & __ImmutableList_1_Enumerator$views<T>;


export interface ImmutableQueue_1_Enumerator$instance<T> {
    readonly current: T;
    moveNext(): boolean;
}


export const ImmutableQueue_1_Enumerator: {
    new<T>(): ImmutableQueue_1_Enumerator$instance<T>;
};


export type ImmutableQueue_1_Enumerator<T> = ImmutableQueue_1_Enumerator$instance<T>;

export interface ImmutableSortedDictionary_2_Enumerator$instance<TKey, TValue> extends IDisposable {
    readonly current: KeyValuePair_2<TKey, TValue>;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const ImmutableSortedDictionary_2_Enumerator: {
    new<TKey, TValue>(): ImmutableSortedDictionary_2_Enumerator$instance<TKey, TValue>;
};


export interface __ImmutableSortedDictionary_2_Enumerator$views<TKey, TValue> {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type ImmutableSortedDictionary_2_Enumerator<TKey, TValue> = ImmutableSortedDictionary_2_Enumerator$instance<TKey, TValue> & __ImmutableSortedDictionary_2_Enumerator$views<TKey, TValue>;


export interface ImmutableSortedSet_1_Enumerator$instance<T> extends IDisposable {
    readonly current: T;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const ImmutableSortedSet_1_Enumerator: {
    new<T>(): ImmutableSortedSet_1_Enumerator$instance<T>;
};


export interface __ImmutableSortedSet_1_Enumerator$views<T> {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type ImmutableSortedSet_1_Enumerator<T> = ImmutableSortedSet_1_Enumerator$instance<T> & __ImmutableSortedSet_1_Enumerator$views<T>;


export interface ImmutableStack_1_Enumerator$instance<T> {
    readonly current: T;
    moveNext(): boolean;
}


export const ImmutableStack_1_Enumerator: {
    new<T>(): ImmutableStack_1_Enumerator$instance<T>;
};


export type ImmutableStack_1_Enumerator<T> = ImmutableStack_1_Enumerator$instance<T>;

export interface ImmutableArray_1_Builder$instance<T> {
    capacity: int;
    count: int;
    item: T;
    add(item: T): void;
    addRange(items: IEnumerable_1<T>): void;
    addRange(items: T[]): void;
    addRange<TDerived extends T>(items: TDerived[]): void;
    addRange(items: T[], length: int): void;
    addRange(items: ImmutableArray_1<T>): void;
    addRange(items: ImmutableArray_1<T>, length: int): void;
    addRange(items: ReadOnlySpan_1<T>): void;
    addRange(items: ImmutableArray_1_Builder<T>): void;
    clear(): void;
    contains(item: T): boolean;
    copyTo(array: T[], index: int): void;
    copyTo(destination: T[]): void;
    copyTo(sourceIndex: int, destination: T[], destinationIndex: int, length: int): void;
    copyTo(destination: Span_1<T>): void;
    drainToImmutable(): ImmutableArray_1<T>;
    getEnumerator(): IEnumerator_1<T>;
    indexOf(item: T): int;
    indexOf(item: T, startIndex: int): int;
    indexOf(item: T, startIndex: int, count: int): int;
    indexOf(item: T, startIndex: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    indexOf(item: T, startIndex: int, equalityComparer: IEqualityComparer_1<T>): int;
    insert(index: int, item: T): void;
    insertRange(index: int, items: IEnumerable_1<T>): void;
    insertRange(index: int, items: ImmutableArray_1<T>): void;
    itemRef(index: int): ref<T>;
    lastIndexOf(item: T): int;
    lastIndexOf(item: T, startIndex: int): int;
    lastIndexOf(item: T, startIndex: int, count: int): int;
    lastIndexOf(item: T, startIndex: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    moveToImmutable(): ImmutableArray_1<T>;
    remove(element: T): boolean;
    remove(element: T, equalityComparer: IEqualityComparer_1<T>): boolean;
    removeAll(match: Predicate_1<T>): void;
    removeAt(index: int): void;
    removeRange(index: int, length: int): void;
    removeRange(items: IEnumerable_1<T>): void;
    removeRange(items: IEnumerable_1<T>, equalityComparer: IEqualityComparer_1<T>): void;
    replace(oldValue: T, newValue: T): void;
    replace(oldValue: T, newValue: T, equalityComparer: IEqualityComparer_1<T>): void;
    reverse(): void;
    sort(): void;
    sort(comparison: Comparison_1<T>): void;
    sort(comparer: IComparer_1<T>): void;
    sort(index: int, count: int, comparer: IComparer_1<T>): void;
    toArray(): T[];
    toImmutable(): ImmutableArray_1<T>;
}


export const ImmutableArray_1_Builder: {
    new<T>(): ImmutableArray_1_Builder$instance<T>;
};


export interface __ImmutableArray_1_Builder$views<T> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableArray_1_Builder<T> = ImmutableArray_1_Builder$instance<T> & __ImmutableArray_1_Builder$views<T>;


export interface ImmutableDictionary_2$instance<TKey, TValue> {
    readonly count: int;
    readonly isEmpty: boolean;
    readonly item: TValue;
    readonly keyComparer: IEqualityComparer_1<TKey>;
    readonly keys: IEnumerable_1<TKey>;
    readonly valueComparer: IEqualityComparer_1<TValue>;
    readonly values: IEnumerable_1<TValue>;
    add(key: TKey, value: TValue): ImmutableDictionary_2<TKey, TValue>;
    addRange(pairs: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableDictionary_2<TKey, TValue>;
    clear(): ImmutableDictionary_2<TKey, TValue>;
    contains(pair: KeyValuePair_2<TKey, TValue>): boolean;
    containsKey(key: TKey): boolean;
    containsValue(value: TValue): boolean;
    getEnumerator(): ImmutableDictionary_2_Enumerator<TKey, TValue>;
    remove(key: TKey): ImmutableDictionary_2<TKey, TValue>;
    removeRange(keys: IEnumerable_1<TKey>): ImmutableDictionary_2<TKey, TValue>;
    setItem(key: TKey, value: TValue): ImmutableDictionary_2<TKey, TValue>;
    setItems(items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableDictionary_2<TKey, TValue>;
    toBuilder(): ImmutableDictionary_2_Builder<TKey, TValue>;
    tryGetKey(equalKey: TKey, actualKey: { value: ref<TKey> }): boolean;
    tryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
    withComparers(keyComparer: IEqualityComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableDictionary_2<TKey, TValue>;
    withComparers(keyComparer: IEqualityComparer_1<TKey>): ImmutableDictionary_2<TKey, TValue>;
}


export const ImmutableDictionary_2: {
    new<TKey, TValue>(): ImmutableDictionary_2$instance<TKey, TValue>;
    readonly empty: unknown;
};


export interface __ImmutableDictionary_2$views<TKey, TValue> {
    As_IImmutableDictionary_2(): IImmutableDictionary_2$instance<TKey, TValue>;
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionary_2(): System_Collections_Generic_Internal.IDictionary_2$instance<TKey, TValue>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyDictionary_2(): System_Collections_Generic_Internal.IReadOnlyDictionary_2$instance<TKey, TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableDictionary_2<TKey, TValue> = ImmutableDictionary_2$instance<TKey, TValue> & __ImmutableDictionary_2$views<TKey, TValue>;


export interface ImmutableDictionary_2_Builder$instance<TKey, TValue> {
    readonly count: int;
    item: TValue;
    keyComparer: IEqualityComparer_1<TKey>;
    readonly keys: IEnumerable_1<TKey>;
    valueComparer: IEqualityComparer_1<TValue>;
    readonly values: IEnumerable_1<TValue>;
    add(key: TKey, value: TValue): void;
    add(item: KeyValuePair_2<TKey, TValue>): void;
    addRange(items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): void;
    clear(): void;
    contains(item: KeyValuePair_2<TKey, TValue>): boolean;
    containsKey(key: TKey): boolean;
    containsValue(value: TValue): boolean;
    getEnumerator(): ImmutableDictionary_2_Enumerator<TKey, TValue>;
    getValueOrDefault(key: TKey): TValue;
    getValueOrDefault(key: TKey, defaultValue: TValue): TValue;
    remove(key: TKey): boolean;
    remove(item: KeyValuePair_2<TKey, TValue>): boolean;
    removeRange(keys: IEnumerable_1<TKey>): void;
    toImmutable(): ImmutableDictionary_2<TKey, TValue>;
    tryGetKey(equalKey: TKey, actualKey: { value: ref<TKey> }): boolean;
    tryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
}


export const ImmutableDictionary_2_Builder: {
    new<TKey, TValue>(): ImmutableDictionary_2_Builder$instance<TKey, TValue>;
};


export interface __ImmutableDictionary_2_Builder$views<TKey, TValue> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionary_2(): System_Collections_Generic_Internal.IDictionary_2$instance<TKey, TValue>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyDictionary_2(): System_Collections_Generic_Internal.IReadOnlyDictionary_2$instance<TKey, TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableDictionary_2_Builder<TKey, TValue> = ImmutableDictionary_2_Builder$instance<TKey, TValue> & __ImmutableDictionary_2_Builder$views<TKey, TValue>;


export interface ImmutableHashSet_1$instance<T> {
    readonly count: int;
    readonly isEmpty: boolean;
    readonly keyComparer: IEqualityComparer_1<T>;
    add(item: T): ImmutableHashSet_1<T>;
    clear(): ImmutableHashSet_1<T>;
    contains(item: T): boolean;
    except(other: IEnumerable_1<T>): ImmutableHashSet_1<T>;
    getEnumerator(): ImmutableHashSet_1_Enumerator<T>;
    intersect(other: IEnumerable_1<T>): ImmutableHashSet_1<T>;
    isProperSubsetOf(other: IEnumerable_1<T>): boolean;
    isProperSupersetOf(other: IEnumerable_1<T>): boolean;
    isSubsetOf(other: IEnumerable_1<T>): boolean;
    isSupersetOf(other: IEnumerable_1<T>): boolean;
    overlaps(other: IEnumerable_1<T>): boolean;
    remove(item: T): ImmutableHashSet_1<T>;
    setEquals(other: IEnumerable_1<T>): boolean;
    symmetricExcept(other: IEnumerable_1<T>): ImmutableHashSet_1<T>;
    toBuilder(): ImmutableHashSet_1_Builder<T>;
    tryGetValue(equalValue: T, actualValue: { value: ref<T> }): boolean;
    union(other: IEnumerable_1<T>): ImmutableHashSet_1<T>;
    withComparer(equalityComparer: IEqualityComparer_1<T>): ImmutableHashSet_1<T>;
}


export const ImmutableHashSet_1: {
    new<T>(): ImmutableHashSet_1$instance<T>;
    readonly empty: unknown;
};


export interface __ImmutableHashSet_1$views<T> {
    As_IImmutableSet_1(): IImmutableSet_1$instance<T>;
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_IReadOnlySet_1(): System_Collections_Generic_Internal.IReadOnlySet_1$instance<T>;
    As_ISet_1(): System_Collections_Generic_Internal.ISet_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableHashSet_1<T> = ImmutableHashSet_1$instance<T> & __ImmutableHashSet_1$views<T>;


export interface ImmutableHashSet_1_Builder$instance<T> {
    readonly count: int;
    keyComparer: IEqualityComparer_1<T>;
    add(item: T): boolean;
    clear(): void;
    contains(item: T): boolean;
    exceptWith(other: IEnumerable_1<T>): void;
    getEnumerator(): ImmutableHashSet_1_Enumerator<T>;
    intersectWith(other: IEnumerable_1<T>): void;
    isProperSubsetOf(other: IEnumerable_1<T>): boolean;
    isProperSupersetOf(other: IEnumerable_1<T>): boolean;
    isSubsetOf(other: IEnumerable_1<T>): boolean;
    isSupersetOf(other: IEnumerable_1<T>): boolean;
    overlaps(other: IEnumerable_1<T>): boolean;
    remove(item: T): boolean;
    setEquals(other: IEnumerable_1<T>): boolean;
    symmetricExceptWith(other: IEnumerable_1<T>): void;
    toImmutable(): ImmutableHashSet_1<T>;
    tryGetValue(equalValue: T, actualValue: { value: ref<T> }): boolean;
    unionWith(other: IEnumerable_1<T>): void;
}


export const ImmutableHashSet_1_Builder: {
    new<T>(): ImmutableHashSet_1_Builder$instance<T>;
};


export interface __ImmutableHashSet_1_Builder$views<T> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_ISet_1(): System_Collections_Generic_Internal.ISet_1$instance<T>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableHashSet_1_Builder<T> = ImmutableHashSet_1_Builder$instance<T> & __ImmutableHashSet_1_Builder$views<T>;


export interface ImmutableList_1$instance<T> {
    readonly count: int;
    readonly isEmpty: boolean;
    readonly item: T;
    add(value: T): ImmutableList_1<T>;
    addRange(items: IEnumerable_1<T>): ImmutableList_1<T>;
    binarySearch(item: T): int;
    binarySearch(item: T, comparer: IComparer_1<T>): int;
    binarySearch(index: int, count: int, item: T, comparer: IComparer_1<T>): int;
    clear(): ImmutableList_1<T>;
    contains(value: T): boolean;
    convertAll<TOutput>(converter: Func_2<T, TOutput>): ImmutableList_1<TOutput>;
    copyTo(array: T[]): void;
    copyTo(array: T[], arrayIndex: int): void;
    copyTo(index: int, array: T[], arrayIndex: int, count: int): void;
    exists(match: Predicate_1<T>): boolean;
    find(match: Predicate_1<T>): T;
    findAll(match: Predicate_1<T>): ImmutableList_1<T>;
    findIndex(match: Predicate_1<T>): int;
    findIndex(startIndex: int, match: Predicate_1<T>): int;
    findIndex(startIndex: int, count: int, match: Predicate_1<T>): int;
    findLast(match: Predicate_1<T>): T;
    findLastIndex(match: Predicate_1<T>): int;
    findLastIndex(startIndex: int, match: Predicate_1<T>): int;
    findLastIndex(startIndex: int, count: int, match: Predicate_1<T>): int;
    forEach(action: Action_1<T>): void;
    getEnumerator(): ImmutableList_1_Enumerator<T>;
    getRange(index: int, count: int): ImmutableList_1<T>;
    indexOf(item: T, index: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    indexOf(value: T): int;
    insert(index: int, item: T): ImmutableList_1<T>;
    insertRange(index: int, items: IEnumerable_1<T>): ImmutableList_1<T>;
    itemRef(index: int): ref<T>;
    lastIndexOf(item: T, index: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    remove(value: T): ImmutableList_1<T>;
    remove(value: T, equalityComparer: IEqualityComparer_1<T>): ImmutableList_1<T>;
    removeAll(match: Predicate_1<T>): ImmutableList_1<T>;
    removeAt(index: int): ImmutableList_1<T>;
    removeRange(index: int, count: int): ImmutableList_1<T>;
    removeRange(items: IEnumerable_1<T>): ImmutableList_1<T>;
    removeRange(items: IEnumerable_1<T>, equalityComparer: IEqualityComparer_1<T>): ImmutableList_1<T>;
    replace(oldValue: T, newValue: T): ImmutableList_1<T>;
    replace(oldValue: T, newValue: T, equalityComparer: IEqualityComparer_1<T>): ImmutableList_1<T>;
    reverse(): ImmutableList_1<T>;
    reverse(index: int, count: int): ImmutableList_1<T>;
    setItem(index: int, value: T): ImmutableList_1<T>;
    sort(): ImmutableList_1<T>;
    sort(comparison: Comparison_1<T>): ImmutableList_1<T>;
    sort(comparer: IComparer_1<T>): ImmutableList_1<T>;
    sort(index: int, count: int, comparer: IComparer_1<T>): ImmutableList_1<T>;
    toBuilder(): ImmutableList_1_Builder<T>;
    trueForAll(match: Predicate_1<T>): boolean;
}


export const ImmutableList_1: {
    new<T>(): ImmutableList_1$instance<T>;
    readonly empty: unknown;
};


export interface __ImmutableList_1$views<T> {
    As_IImmutableList_1(): IImmutableList_1$instance<T>;
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type ImmutableList_1<T> = ImmutableList_1$instance<T> & __ImmutableList_1$views<T>;


export interface ImmutableList_1_Builder$instance<T> {
    readonly count: int;
    item: T;
    add(item: T): void;
    addRange(items: IEnumerable_1<T>): void;
    binarySearch(item: T): int;
    binarySearch(item: T, comparer: IComparer_1<T>): int;
    binarySearch(index: int, count: int, item: T, comparer: IComparer_1<T>): int;
    clear(): void;
    contains(item: T): boolean;
    convertAll<TOutput>(converter: Func_2<T, TOutput>): ImmutableList_1<TOutput>;
    copyTo(array: T[]): void;
    copyTo(array: T[], arrayIndex: int): void;
    copyTo(index: int, array: T[], arrayIndex: int, count: int): void;
    exists(match: Predicate_1<T>): boolean;
    find(match: Predicate_1<T>): T;
    findAll(match: Predicate_1<T>): ImmutableList_1<T>;
    findIndex(match: Predicate_1<T>): int;
    findIndex(startIndex: int, match: Predicate_1<T>): int;
    findIndex(startIndex: int, count: int, match: Predicate_1<T>): int;
    findLast(match: Predicate_1<T>): T;
    findLastIndex(match: Predicate_1<T>): int;
    findLastIndex(startIndex: int, match: Predicate_1<T>): int;
    findLastIndex(startIndex: int, count: int, match: Predicate_1<T>): int;
    forEach(action: Action_1<T>): void;
    getEnumerator(): ImmutableList_1_Enumerator<T>;
    getRange(index: int, count: int): ImmutableList_1<T>;
    indexOf(item: T): int;
    indexOf(item: T, index: int): int;
    indexOf(item: T, index: int, count: int): int;
    indexOf(item: T, index: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    insert(index: int, item: T): void;
    insertRange(index: int, items: IEnumerable_1<T>): void;
    itemRef(index: int): ref<T>;
    lastIndexOf(item: T): int;
    lastIndexOf(item: T, startIndex: int): int;
    lastIndexOf(item: T, startIndex: int, count: int): int;
    lastIndexOf(item: T, startIndex: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    remove(item: T): boolean;
    remove(item: T, equalityComparer: IEqualityComparer_1<T>): boolean;
    removeAll(match: Predicate_1<T>): int;
    removeAt(index: int): void;
    removeRange(index: int, count: int): void;
    removeRange(items: IEnumerable_1<T>, equalityComparer: IEqualityComparer_1<T>): void;
    removeRange(items: IEnumerable_1<T>): void;
    replace(oldValue: T, newValue: T): void;
    replace(oldValue: T, newValue: T, equalityComparer: IEqualityComparer_1<T>): void;
    reverse(): void;
    reverse(index: int, count: int): void;
    sort(): void;
    sort(comparison: Comparison_1<T>): void;
    sort(comparer: IComparer_1<T>): void;
    sort(index: int, count: int, comparer: IComparer_1<T>): void;
    toImmutable(): ImmutableList_1<T>;
    trueForAll(match: Predicate_1<T>): boolean;
}


export const ImmutableList_1_Builder: {
    new<T>(): ImmutableList_1_Builder$instance<T>;
};


export interface __ImmutableList_1_Builder$views<T> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type ImmutableList_1_Builder<T> = ImmutableList_1_Builder$instance<T> & __ImmutableList_1_Builder$views<T>;


export interface ImmutableQueue_1$instance<T> {
    readonly isEmpty: boolean;
    clear(): ImmutableQueue_1<T>;
    dequeue(): ImmutableQueue_1<T>;
    dequeue(value: { value: ref<T> }): ImmutableQueue_1<T>;
    enqueue(value: T): ImmutableQueue_1<T>;
    getEnumerator(): ImmutableQueue_1_Enumerator<T>;
    peek(): T;
    peekRef(): ref<T>;
}


export const ImmutableQueue_1: {
    new<T>(): ImmutableQueue_1$instance<T>;
    readonly empty: unknown;
};


export interface __ImmutableQueue_1$views<T> {
    As_IImmutableQueue_1(): IImmutableQueue_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableQueue_1<T> = ImmutableQueue_1$instance<T> & __ImmutableQueue_1$views<T>;


export interface ImmutableSortedDictionary_2$instance<TKey, TValue> {
    readonly count: int;
    readonly isEmpty: boolean;
    readonly item: TValue;
    readonly keyComparer: IComparer_1<TKey>;
    readonly keys: IEnumerable_1<TKey>;
    readonly valueComparer: IEqualityComparer_1<TValue>;
    readonly values: IEnumerable_1<TValue>;
    add(key: TKey, value: TValue): ImmutableSortedDictionary_2<TKey, TValue>;
    addRange(items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableSortedDictionary_2<TKey, TValue>;
    clear(): ImmutableSortedDictionary_2<TKey, TValue>;
    contains(pair: KeyValuePair_2<TKey, TValue>): boolean;
    containsKey(key: TKey): boolean;
    containsValue(value: TValue): boolean;
    getEnumerator(): ImmutableSortedDictionary_2_Enumerator<TKey, TValue>;
    remove(value: TKey): ImmutableSortedDictionary_2<TKey, TValue>;
    removeRange(keys: IEnumerable_1<TKey>): ImmutableSortedDictionary_2<TKey, TValue>;
    setItem(key: TKey, value: TValue): ImmutableSortedDictionary_2<TKey, TValue>;
    setItems(items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableSortedDictionary_2<TKey, TValue>;
    toBuilder(): ImmutableSortedDictionary_2_Builder<TKey, TValue>;
    tryGetKey(equalKey: TKey, actualKey: { value: ref<TKey> }): boolean;
    tryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
    valueRef(key: TKey): ref<TValue>;
    withComparers(keyComparer: IComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableSortedDictionary_2<TKey, TValue>;
    withComparers(keyComparer: IComparer_1<TKey>): ImmutableSortedDictionary_2<TKey, TValue>;
}


export const ImmutableSortedDictionary_2: {
    new<TKey, TValue>(): ImmutableSortedDictionary_2$instance<TKey, TValue>;
    readonly empty: unknown;
};


export interface __ImmutableSortedDictionary_2$views<TKey, TValue> {
    As_IImmutableDictionary_2(): IImmutableDictionary_2$instance<TKey, TValue>;
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionary_2(): System_Collections_Generic_Internal.IDictionary_2$instance<TKey, TValue>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyDictionary_2(): System_Collections_Generic_Internal.IReadOnlyDictionary_2$instance<TKey, TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableSortedDictionary_2<TKey, TValue> = ImmutableSortedDictionary_2$instance<TKey, TValue> & __ImmutableSortedDictionary_2$views<TKey, TValue>;


export interface ImmutableSortedDictionary_2_Builder$instance<TKey, TValue> {
    readonly count: int;
    item: TValue;
    keyComparer: IComparer_1<TKey>;
    readonly keys: IEnumerable_1<TKey>;
    valueComparer: IEqualityComparer_1<TValue>;
    readonly values: IEnumerable_1<TValue>;
    add(key: TKey, value: TValue): void;
    add(item: KeyValuePair_2<TKey, TValue>): void;
    addRange(items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): void;
    clear(): void;
    contains(item: KeyValuePair_2<TKey, TValue>): boolean;
    containsKey(key: TKey): boolean;
    containsValue(value: TValue): boolean;
    getEnumerator(): ImmutableSortedDictionary_2_Enumerator<TKey, TValue>;
    getValueOrDefault(key: TKey): TValue;
    getValueOrDefault(key: TKey, defaultValue: TValue): TValue;
    remove(key: TKey): boolean;
    remove(item: KeyValuePair_2<TKey, TValue>): boolean;
    removeRange(keys: IEnumerable_1<TKey>): void;
    toImmutable(): ImmutableSortedDictionary_2<TKey, TValue>;
    tryGetKey(equalKey: TKey, actualKey: { value: ref<TKey> }): boolean;
    tryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
    valueRef(key: TKey): ref<TValue>;
}


export const ImmutableSortedDictionary_2_Builder: {
    new<TKey, TValue>(): ImmutableSortedDictionary_2_Builder$instance<TKey, TValue>;
};


export interface __ImmutableSortedDictionary_2_Builder$views<TKey, TValue> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionary_2(): System_Collections_Generic_Internal.IDictionary_2$instance<TKey, TValue>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyDictionary_2(): System_Collections_Generic_Internal.IReadOnlyDictionary_2$instance<TKey, TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableSortedDictionary_2_Builder<TKey, TValue> = ImmutableSortedDictionary_2_Builder$instance<TKey, TValue> & __ImmutableSortedDictionary_2_Builder$views<TKey, TValue>;


export interface ImmutableSortedSet_1$instance<T> {
    readonly count: int;
    readonly isEmpty: boolean;
    readonly item: T;
    readonly keyComparer: IComparer_1<T>;
    readonly max: T;
    readonly min: T;
    add(value: T): ImmutableSortedSet_1<T>;
    clear(): ImmutableSortedSet_1<T>;
    contains(value: T): boolean;
    except(other: IEnumerable_1<T>): ImmutableSortedSet_1<T>;
    getEnumerator(): ImmutableSortedSet_1_Enumerator<T>;
    indexOf(item: T): int;
    intersect(other: IEnumerable_1<T>): ImmutableSortedSet_1<T>;
    isProperSubsetOf(other: IEnumerable_1<T>): boolean;
    isProperSupersetOf(other: IEnumerable_1<T>): boolean;
    isSubsetOf(other: IEnumerable_1<T>): boolean;
    isSupersetOf(other: IEnumerable_1<T>): boolean;
    itemRef(index: int): ref<T>;
    overlaps(other: IEnumerable_1<T>): boolean;
    remove(value: T): ImmutableSortedSet_1<T>;
    reverse(): IEnumerable_1<T>;
    setEquals(other: IEnumerable_1<T>): boolean;
    symmetricExcept(other: IEnumerable_1<T>): ImmutableSortedSet_1<T>;
    toBuilder(): ImmutableSortedSet_1_Builder<T>;
    tryGetValue(equalValue: T, actualValue: { value: ref<T> }): boolean;
    union(other: IEnumerable_1<T>): ImmutableSortedSet_1<T>;
    withComparer(comparer: IComparer_1<T>): ImmutableSortedSet_1<T>;
}


export const ImmutableSortedSet_1: {
    new<T>(): ImmutableSortedSet_1$instance<T>;
    readonly empty: unknown;
};


export interface __ImmutableSortedSet_1$views<T> {
    As_IImmutableSet_1(): IImmutableSet_1$instance<T>;
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_IReadOnlySet_1(): System_Collections_Generic_Internal.IReadOnlySet_1$instance<T>;
    As_ISet_1(): System_Collections_Generic_Internal.ISet_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type ImmutableSortedSet_1<T> = ImmutableSortedSet_1$instance<T> & __ImmutableSortedSet_1$views<T>;


export interface ImmutableSortedSet_1_Builder$instance<T> {
    readonly count: int;
    readonly item: T;
    keyComparer: IComparer_1<T>;
    readonly max: T;
    readonly min: T;
    add(item: T): boolean;
    clear(): void;
    contains(item: T): boolean;
    exceptWith(other: IEnumerable_1<T>): void;
    getEnumerator(): ImmutableSortedSet_1_Enumerator<T>;
    indexOf(item: T): int;
    intersectWith(other: IEnumerable_1<T>): void;
    isProperSubsetOf(other: IEnumerable_1<T>): boolean;
    isProperSupersetOf(other: IEnumerable_1<T>): boolean;
    isSubsetOf(other: IEnumerable_1<T>): boolean;
    isSupersetOf(other: IEnumerable_1<T>): boolean;
    itemRef(index: int): ref<T>;
    overlaps(other: IEnumerable_1<T>): boolean;
    remove(item: T): boolean;
    reverse(): IEnumerable_1<T>;
    setEquals(other: IEnumerable_1<T>): boolean;
    symmetricExceptWith(other: IEnumerable_1<T>): void;
    toImmutable(): ImmutableSortedSet_1<T>;
    tryGetValue(equalValue: T, actualValue: { value: ref<T> }): boolean;
    unionWith(other: IEnumerable_1<T>): void;
}


export const ImmutableSortedSet_1_Builder: {
    new<T>(): ImmutableSortedSet_1_Builder$instance<T>;
};


export interface __ImmutableSortedSet_1_Builder$views<T> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_ISet_1(): System_Collections_Generic_Internal.ISet_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableSortedSet_1_Builder<T> = ImmutableSortedSet_1_Builder$instance<T> & __ImmutableSortedSet_1_Builder$views<T>;


export interface ImmutableStack_1$instance<T> {
    readonly isEmpty: boolean;
    clear(): ImmutableStack_1<T>;
    getEnumerator(): ImmutableStack_1_Enumerator<T>;
    peek(): T;
    peekRef(): ref<T>;
    pop(): ImmutableStack_1<T>;
    pop(value: { value: ref<T> }): ImmutableStack_1<T>;
    push(value: T): ImmutableStack_1<T>;
}


export const ImmutableStack_1: {
    new<T>(): ImmutableStack_1$instance<T>;
    readonly empty: unknown;
};


export interface __ImmutableStack_1$views<T> {
    As_IImmutableStack_1(): IImmutableStack_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableStack_1<T> = ImmutableStack_1$instance<T> & __ImmutableStack_1$views<T>;


export abstract class ImmutableArray$instance {
    static binarySearch<T>(array: ImmutableArray_1<T>, index: int, length: int, value: T, comparer: IComparer_1<T>): int;
    static binarySearch<T>(array: ImmutableArray_1<T>, index: int, length: int, value: T): int;
    static binarySearch<T>(array: ImmutableArray_1<T>, value: T, comparer: IComparer_1<T>): int;
    static binarySearch<T>(array: ImmutableArray_1<T>, value: T): int;
    static create<T>(): ImmutableArray_1<T>;
    static create<T>(items: ImmutableArray_1<T>, start: int, length: int): ImmutableArray_1<T>;
    static create<T>(items: ReadOnlySpan_1<T>): ImmutableArray_1<T>;
    static create<T>(items: Span_1<T>): ImmutableArray_1<T>;
    static create<T>(item1: T, item2: T, item3: T, item4: T): ImmutableArray_1<T>;
    static create<T>(item1: T, item2: T, item3: T): ImmutableArray_1<T>;
    static create<T>(item1: T, item2: T): ImmutableArray_1<T>;
    static create<T>(item: T): ImmutableArray_1<T>;
    static create<T>(items: T[], start: int, length: int): ImmutableArray_1<T>;
    static create<T>(items: T[]): ImmutableArray_1<T>;
    static createBuilder<T>(): ImmutableArray_1_Builder<T>;
    static createBuilder<T>(initialCapacity: int): ImmutableArray_1_Builder<T>;
    static createRange<T>(items: IEnumerable_1<T>): ImmutableArray_1<T>;
    static createRange<TSource, TResult>(items: ImmutableArray_1<TSource>, selector: Func_2<TSource, TResult>): ImmutableArray_1<TResult>;
    static createRange<TSource, TArg, TResult>(items: ImmutableArray_1<TSource>, selector: Func_3<TSource, TArg, TResult>, arg: TArg): ImmutableArray_1<TResult>;
    static createRange<TSource, TResult>(items: ImmutableArray_1<TSource>, start: int, length: int, selector: Func_2<TSource, TResult>): ImmutableArray_1<TResult>;
    static createRange<TSource, TArg, TResult>(items: ImmutableArray_1<TSource>, start: int, length: int, selector: Func_3<TSource, TArg, TResult>, arg: TArg): ImmutableArray_1<TResult>;
    static toImmutableArray<TSource>(builder: ImmutableArray_1_Builder<TSource>): ImmutableArray_1<TSource>;
    static toImmutableArray<TSource>(items: IEnumerable_1<TSource>): ImmutableArray_1<TSource>;
    static toImmutableArray<T>(items: ReadOnlySpan_1<T>): ImmutableArray_1<T>;
    static toImmutableArray<T>(items: Span_1<T>): ImmutableArray_1<T>;
}


export type ImmutableArray = ImmutableArray$instance;

export abstract class ImmutableDictionary$instance {
    static contains<TKey, TValue>(map: IImmutableDictionary_2<TKey, TValue>, key: TKey, value: TValue): boolean;
    static create<TKey, TValue>(): ImmutableDictionary_2<TKey, TValue>;
    static create<TKey, TValue>(keyComparer: IEqualityComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableDictionary_2<TKey, TValue>;
    static create<TKey, TValue>(keyComparer: IEqualityComparer_1<TKey>): ImmutableDictionary_2<TKey, TValue>;
    static createBuilder<TKey, TValue>(): ImmutableDictionary_2_Builder<TKey, TValue>;
    static createBuilder<TKey, TValue>(keyComparer: IEqualityComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableDictionary_2_Builder<TKey, TValue>;
    static createBuilder<TKey, TValue>(keyComparer: IEqualityComparer_1<TKey>): ImmutableDictionary_2_Builder<TKey, TValue>;
    static createRange<TKey, TValue>(items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableDictionary_2<TKey, TValue>;
    static createRange<TKey, TValue>(keyComparer: IEqualityComparer_1<TKey>, items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableDictionary_2<TKey, TValue>;
    static createRange<TKey, TValue>(keyComparer: IEqualityComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>, items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableDictionary_2<TKey, TValue>;
    static createRangeWithOverwrite<TKey, TValue>(keyComparer: IEqualityComparer_1<TKey>, items: ReadOnlySpan_1<KeyValuePair_2<TKey, TValue>>): ImmutableDictionary_2<TKey, TValue>;
    static createRangeWithOverwrite<TKey, TValue>(items: ReadOnlySpan_1<KeyValuePair_2<TKey, TValue>>): ImmutableDictionary_2<TKey, TValue>;
    static getValueOrDefault<TKey, TValue>(dictionary: IImmutableDictionary_2<TKey, TValue>, key: TKey, defaultValue: TValue): TValue;
    static getValueOrDefault<TKey, TValue>(dictionary: IImmutableDictionary_2<TKey, TValue>, key: TKey): TValue;
    static toImmutableDictionary<TKey, TValue>(builder: ImmutableDictionary_2_Builder<TKey, TValue>): ImmutableDictionary_2<TKey, TValue>;
    static toImmutableDictionary<TSource, TKey, TValue>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TValue>, keyComparer: IEqualityComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableDictionary_2<TKey, TValue>;
    static toImmutableDictionary<TSource, TKey, TValue>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TValue>, keyComparer: IEqualityComparer_1<TKey>): ImmutableDictionary_2<TKey, TValue>;
    static toImmutableDictionary<TSource, TKey, TValue>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TValue>): ImmutableDictionary_2<TKey, TValue>;
    static toImmutableDictionary<TSource, TKey>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, keyComparer: IEqualityComparer_1<TKey>): ImmutableDictionary_2<TKey, TSource>;
    static toImmutableDictionary<TSource, TKey>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>): ImmutableDictionary_2<TKey, TSource>;
    static toImmutableDictionary<TKey, TValue>(source: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, keyComparer: IEqualityComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableDictionary_2<TKey, TValue>;
    static toImmutableDictionary<TKey, TValue>(source: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, keyComparer: IEqualityComparer_1<TKey>): ImmutableDictionary_2<TKey, TValue>;
    static toImmutableDictionary<TKey, TValue>(source: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableDictionary_2<TKey, TValue>;
}


export type ImmutableDictionary = ImmutableDictionary$instance;

export abstract class ImmutableHashSet$instance {
    static create<T>(): ImmutableHashSet_1<T>;
    static create<T>(equalityComparer: IEqualityComparer_1<T>, items: ReadOnlySpan_1<T>): ImmutableHashSet_1<T>;
    static create<T>(equalityComparer: IEqualityComparer_1<T>, item: T): ImmutableHashSet_1<T>;
    static create<T>(equalityComparer: IEqualityComparer_1<T>, items: T[]): ImmutableHashSet_1<T>;
    static create<T>(equalityComparer: IEqualityComparer_1<T>): ImmutableHashSet_1<T>;
    static create<T>(items: ReadOnlySpan_1<T>): ImmutableHashSet_1<T>;
    static create<T>(item: T): ImmutableHashSet_1<T>;
    static create<T>(items: T[]): ImmutableHashSet_1<T>;
    static createBuilder<T>(): ImmutableHashSet_1_Builder<T>;
    static createBuilder<T>(equalityComparer: IEqualityComparer_1<T>): ImmutableHashSet_1_Builder<T>;
    static createRange<T>(items: IEnumerable_1<T>): ImmutableHashSet_1<T>;
    static createRange<T>(equalityComparer: IEqualityComparer_1<T>, items: IEnumerable_1<T>): ImmutableHashSet_1<T>;
    static toImmutableHashSet<TSource>(builder: ImmutableHashSet_1_Builder<TSource>): ImmutableHashSet_1<TSource>;
    static toImmutableHashSet<TSource>(source: IEnumerable_1<TSource>, equalityComparer: IEqualityComparer_1<TSource>): ImmutableHashSet_1<TSource>;
    static toImmutableHashSet<TSource>(source: IEnumerable_1<TSource>): ImmutableHashSet_1<TSource>;
}


export type ImmutableHashSet = ImmutableHashSet$instance;

export abstract class ImmutableInterlocked$instance {
    static addOrUpdate<TKey, TValue>(location: { value: ref<ImmutableDictionary_2<TKey, TValue>> }, key: TKey, addValueFactory: Func_2<TKey, TValue>, updateValueFactory: Func_3<TKey, TValue, TValue>): TValue;
    static addOrUpdate<TKey, TValue>(location: { value: ref<ImmutableDictionary_2<TKey, TValue>> }, key: TKey, addValue: TValue, updateValueFactory: Func_3<TKey, TValue, TValue>): TValue;
    static enqueue<T>(location: { value: ref<ImmutableQueue_1<T>> }, value: T): void;
    static getOrAdd<TKey, TValue>(location: { value: ref<ImmutableDictionary_2<TKey, TValue>> }, key: TKey, valueFactory: Func_2<TKey, TValue>): TValue;
    static getOrAdd<TKey, TValue, TArg>(location: { value: ref<ImmutableDictionary_2<TKey, TValue>> }, key: TKey, valueFactory: Func_3<TKey, TArg, TValue>, factoryArgument: TArg): TValue;
    static getOrAdd<TKey, TValue>(location: { value: ref<ImmutableDictionary_2<TKey, TValue>> }, key: TKey, value: TValue): TValue;
    static interlockedCompareExchange<T>(location: { value: ref<ImmutableArray_1<T>> }, value: ImmutableArray_1<T>, comparand: ImmutableArray_1<T>): ImmutableArray_1<T>;
    static interlockedExchange<T>(location: { value: ref<ImmutableArray_1<T>> }, value: ImmutableArray_1<T>): ImmutableArray_1<T>;
    static interlockedInitialize<T>(location: { value: ref<ImmutableArray_1<T>> }, value: ImmutableArray_1<T>): boolean;
    static push<T>(location: { value: ref<ImmutableStack_1<T>> }, value: T): void;
    static tryAdd<TKey, TValue>(location: { value: ref<ImmutableDictionary_2<TKey, TValue>> }, key: TKey, value: TValue): boolean;
    static tryDequeue<T>(location: { value: ref<ImmutableQueue_1<T>> }, value: { value: ref<T> }): boolean;
    static tryPop<T>(location: { value: ref<ImmutableStack_1<T>> }, value: { value: ref<T> }): boolean;
    static tryRemove<TKey, TValue>(location: { value: ref<ImmutableDictionary_2<TKey, TValue>> }, key: TKey, value: { value: ref<TValue> }): boolean;
    static tryUpdate<TKey, TValue>(location: { value: ref<ImmutableDictionary_2<TKey, TValue>> }, key: TKey, newValue: TValue, comparisonValue: TValue): boolean;
    static update<T>(location: { value: ref<ImmutableArray_1<T>> }, transformer: Func_2<ImmutableArray_1<T>, ImmutableArray_1<T>>): boolean;
    static update<T, TArg>(location: { value: ref<ImmutableArray_1<T>> }, transformer: Func_3<ImmutableArray_1<T>, TArg, ImmutableArray_1<T>>, transformerArgument: TArg): boolean;
    static update<T>(location: { value: ref<T> }, transformer: Func_2<T, T>): boolean;
    static update<T, TArg>(location: { value: ref<T> }, transformer: Func_3<T, TArg, T>, transformerArgument: TArg): boolean;
}


export type ImmutableInterlocked = ImmutableInterlocked$instance;

export abstract class ImmutableList$instance {
    static create<T>(): ImmutableList_1<T>;
    static create<T>(items: ReadOnlySpan_1<T>): ImmutableList_1<T>;
    static create<T>(item: T): ImmutableList_1<T>;
    static create<T>(items: T[]): ImmutableList_1<T>;
    static createBuilder<T>(): ImmutableList_1_Builder<T>;
    static createRange<T>(items: IEnumerable_1<T>): ImmutableList_1<T>;
    static indexOf<T>(list: IImmutableList_1<T>, item: T, equalityComparer: IEqualityComparer_1<T>): int;
    static indexOf<T>(list: IImmutableList_1<T>, item: T, startIndex: int, count: int): int;
    static indexOf<T>(list: IImmutableList_1<T>, item: T, startIndex: int): int;
    static indexOf<T>(list: IImmutableList_1<T>, item: T): int;
    static lastIndexOf<T>(list: IImmutableList_1<T>, item: T, equalityComparer: IEqualityComparer_1<T>): int;
    static lastIndexOf<T>(list: IImmutableList_1<T>, item: T, startIndex: int, count: int): int;
    static lastIndexOf<T>(list: IImmutableList_1<T>, item: T, startIndex: int): int;
    static lastIndexOf<T>(list: IImmutableList_1<T>, item: T): int;
    static remove<T>(list: IImmutableList_1<T>, value: T): IImmutableList_1<T>;
    static removeRange<T>(list: IImmutableList_1<T>, items: IEnumerable_1<T>): IImmutableList_1<T>;
    static replace<T>(list: IImmutableList_1<T>, oldValue: T, newValue: T): IImmutableList_1<T>;
    static toImmutableList<TSource>(builder: ImmutableList_1_Builder<TSource>): ImmutableList_1<TSource>;
    static toImmutableList<TSource>(source: IEnumerable_1<TSource>): ImmutableList_1<TSource>;
}


export type ImmutableList = ImmutableList$instance;

export abstract class ImmutableQueue$instance {
    static create<T>(): ImmutableQueue_1<T>;
    static create<T>(items: ReadOnlySpan_1<T>): ImmutableQueue_1<T>;
    static create<T>(item: T): ImmutableQueue_1<T>;
    static create<T>(items: T[]): ImmutableQueue_1<T>;
    static createRange<T>(items: IEnumerable_1<T>): ImmutableQueue_1<T>;
    static dequeue<T>(queue: IImmutableQueue_1<T>, value: { value: ref<T> }): IImmutableQueue_1<T>;
}


export type ImmutableQueue = ImmutableQueue$instance;

export abstract class ImmutableSortedDictionary$instance {
    static create<TKey, TValue>(): ImmutableSortedDictionary_2<TKey, TValue>;
    static create<TKey, TValue>(keyComparer: IComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableSortedDictionary_2<TKey, TValue>;
    static create<TKey, TValue>(keyComparer: IComparer_1<TKey>): ImmutableSortedDictionary_2<TKey, TValue>;
    static createBuilder<TKey, TValue>(): ImmutableSortedDictionary_2_Builder<TKey, TValue>;
    static createBuilder<TKey, TValue>(keyComparer: IComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableSortedDictionary_2_Builder<TKey, TValue>;
    static createBuilder<TKey, TValue>(keyComparer: IComparer_1<TKey>): ImmutableSortedDictionary_2_Builder<TKey, TValue>;
    static createRange<TKey, TValue>(keyComparer: IComparer_1<TKey>, items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableSortedDictionary_2<TKey, TValue>;
    static createRange<TKey, TValue>(keyComparer: IComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>, items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableSortedDictionary_2<TKey, TValue>;
    static createRange<TKey, TValue>(items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableSortedDictionary_2<TKey, TValue>;
    static toImmutableSortedDictionary<TKey, TValue>(builder: ImmutableSortedDictionary_2_Builder<TKey, TValue>): ImmutableSortedDictionary_2<TKey, TValue>;
    static toImmutableSortedDictionary<TSource, TKey, TValue>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TValue>, keyComparer: IComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableSortedDictionary_2<TKey, TValue>;
    static toImmutableSortedDictionary<TSource, TKey, TValue>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TValue>, keyComparer: IComparer_1<TKey>): ImmutableSortedDictionary_2<TKey, TValue>;
    static toImmutableSortedDictionary<TSource, TKey, TValue>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TValue>): ImmutableSortedDictionary_2<TKey, TValue>;
    static toImmutableSortedDictionary<TKey, TValue>(source: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, keyComparer: IComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableSortedDictionary_2<TKey, TValue>;
    static toImmutableSortedDictionary<TKey, TValue>(source: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, keyComparer: IComparer_1<TKey>): ImmutableSortedDictionary_2<TKey, TValue>;
    static toImmutableSortedDictionary<TKey, TValue>(source: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableSortedDictionary_2<TKey, TValue>;
}


export type ImmutableSortedDictionary = ImmutableSortedDictionary$instance;

export abstract class ImmutableSortedSet$instance {
    static create<T>(): ImmutableSortedSet_1<T>;
    static create<T>(comparer: IComparer_1<T>, items: ReadOnlySpan_1<T>): ImmutableSortedSet_1<T>;
    static create<T>(comparer: IComparer_1<T>, item: T): ImmutableSortedSet_1<T>;
    static create<T>(comparer: IComparer_1<T>, items: T[]): ImmutableSortedSet_1<T>;
    static create<T>(comparer: IComparer_1<T>): ImmutableSortedSet_1<T>;
    static create<T>(items: ReadOnlySpan_1<T>): ImmutableSortedSet_1<T>;
    static create<T>(item: T): ImmutableSortedSet_1<T>;
    static create<T>(items: T[]): ImmutableSortedSet_1<T>;
    static createBuilder<T>(): ImmutableSortedSet_1_Builder<T>;
    static createBuilder<T>(comparer: IComparer_1<T>): ImmutableSortedSet_1_Builder<T>;
    static createRange<T>(comparer: IComparer_1<T>, items: IEnumerable_1<T>): ImmutableSortedSet_1<T>;
    static createRange<T>(items: IEnumerable_1<T>): ImmutableSortedSet_1<T>;
    static toImmutableSortedSet<TSource>(builder: ImmutableSortedSet_1_Builder<TSource>): ImmutableSortedSet_1<TSource>;
    static toImmutableSortedSet<TSource>(source: IEnumerable_1<TSource>, comparer: IComparer_1<TSource>): ImmutableSortedSet_1<TSource>;
    static toImmutableSortedSet<TSource>(source: IEnumerable_1<TSource>): ImmutableSortedSet_1<TSource>;
}


export type ImmutableSortedSet = ImmutableSortedSet$instance;

export abstract class ImmutableStack$instance {
    static create<T>(): ImmutableStack_1<T>;
    static create<T>(items: ReadOnlySpan_1<T>): ImmutableStack_1<T>;
    static create<T>(item: T): ImmutableStack_1<T>;
    static create<T>(items: T[]): ImmutableStack_1<T>;
    static createRange<T>(items: IEnumerable_1<T>): ImmutableStack_1<T>;
    static pop<T>(stack: IImmutableStack_1<T>, value: { value: ref<T> }): IImmutableStack_1<T>;
}


export type ImmutableStack = ImmutableStack$instance;

