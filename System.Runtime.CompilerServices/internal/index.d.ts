// Generated by tsbindgen - Architecture
// Namespace: System.Runtime.CompilerServices
// Assembly: System.Linq.Expressions, System.Private.CoreLib, System.Runtime.CompilerServices.VisualC, System.Runtime.InteropServices

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IList_1, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import type { ReadOnlyCollection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import type { ContractFailureKind } from "../../System.Diagnostics.Contracts/internal/index.js";
import type { ExpandoObject } from "../../System.Dynamic/internal/index.js";
import type { DebugInfoExpression, Expression, LabelTarget, LambdaExpression, ParameterExpression } from "../../System.Linq.Expressions/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action, Array as ClrArray, AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Char, Decimal, Delegate, Enum, Exception, FormattableString, Func_2, Func_3, IAsyncResult, ICloneable, IComparable, IConvertible, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, InvalidOperationException, ISpanFormattable, ModuleHandle, MulticastDelegate, Object as ClrObject, Range, ReadOnlySpan_1, RuntimeFieldHandle, RuntimeMethodHandle, RuntimeTypeHandle, Span_1, String as ClrString, Type, TypeCode, UInt32, UIntPtr, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum CompilationRelaxations {
    noStringInterning = 8
}


export enum LoadHint {
    default_ = 0,
    always = 1,
    sometimes = 2
}


export enum MethodCodeType {
    IL = 0,
    native = 1,
    OPTIL = 2,
    runtime = 3
}


export enum MethodImplOptions {
    unmanaged = 4,
    noInlining = 8,
    forwardRef = 16,
    synchronized = 32,
    noOptimization = 64,
    preserveSig = 128,
    aggressiveInlining = 256,
    aggressiveOptimization = 512,
    async_ = 8192,
    internalCall = 4096
}


export enum UnsafeAccessorKind {
    constructor_ = 0,
    method = 1,
    staticMethod = 2,
    field = 3,
    staticField = 4
}


export type ConditionalWeakTable_2_CreateValueCallback<TKey, TValue> = (key: TKey) => TValue;


export type RuntimeHelpers_CleanupCode = (userData: unknown, exceptionThrown: boolean) => void;


export type RuntimeHelpers_TryCode = (userData: unknown) => void;


export interface IAsyncStateMachine$instance {
    moveNext(): void;
    setStateMachine(stateMachine: IAsyncStateMachine): void;
}


export type IAsyncStateMachine = IAsyncStateMachine$instance;

export interface ICriticalNotifyCompletion$instance extends INotifyCompletion {
    unsafeOnCompleted(continuation: Action): void;
}


export interface ICriticalNotifyCompletion$instance extends INotifyCompletion$instance {}

export type ICriticalNotifyCompletion = ICriticalNotifyCompletion$instance;

export interface INotifyCompletion$instance {
    onCompleted(continuation: Action): void;
}


export type INotifyCompletion = INotifyCompletion$instance;

export interface IRuntimeVariables$instance {
    readonly count: int;
    item: unknown;
}


export type IRuntimeVariables = IRuntimeVariables$instance;

export interface IStrongBox$instance {
    value: unknown;
}


export type IStrongBox = IStrongBox$instance;

export interface ITuple$instance {
    readonly length: int;
    readonly item: unknown;
}


export type ITuple = ITuple$instance;

export interface AsyncIteratorMethodBuilder$instance {
    awaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    awaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    complete(): void;
    moveNext<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
}


export const AsyncIteratorMethodBuilder: {
    new(): AsyncIteratorMethodBuilder$instance;
    create(): AsyncIteratorMethodBuilder;
};


export type AsyncIteratorMethodBuilder = AsyncIteratorMethodBuilder$instance;

export interface AsyncTaskMethodBuilder$instance {
    readonly task: Task;
    awaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    awaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    setException(exception: Exception): void;
    setResult(): void;
    setStateMachine(stateMachine: IAsyncStateMachine): void;
    start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
}


export const AsyncTaskMethodBuilder: {
    new(): AsyncTaskMethodBuilder$instance;
    create(): AsyncTaskMethodBuilder;
};


export type AsyncTaskMethodBuilder = AsyncTaskMethodBuilder$instance;

export interface AsyncTaskMethodBuilder_1$instance<TResult> {
    readonly task: Task_1<TResult>;
    awaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    awaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    setException(exception: Exception): void;
    setResult(result: TResult): void;
    setStateMachine(stateMachine: IAsyncStateMachine): void;
    start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
}


export const AsyncTaskMethodBuilder_1: {
    new<TResult>(): AsyncTaskMethodBuilder_1$instance<TResult>;
    create<TResult>(): AsyncTaskMethodBuilder_1<TResult>;
};


export type AsyncTaskMethodBuilder_1<TResult> = AsyncTaskMethodBuilder_1$instance<TResult>;

export interface AsyncValueTaskMethodBuilder$instance {
    readonly task: ValueTask;
    awaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    awaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    setException(exception: Exception): void;
    setResult(): void;
    setStateMachine(stateMachine: IAsyncStateMachine): void;
    start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
}


export const AsyncValueTaskMethodBuilder: {
    new(): AsyncValueTaskMethodBuilder$instance;
    create(): AsyncValueTaskMethodBuilder;
};


export type AsyncValueTaskMethodBuilder = AsyncValueTaskMethodBuilder$instance;

export interface AsyncValueTaskMethodBuilder_1$instance<TResult> {
    readonly task: ValueTask_1<TResult>;
    awaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    awaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    setException(exception: Exception): void;
    setResult(result: TResult): void;
    setStateMachine(stateMachine: IAsyncStateMachine): void;
    start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
}


export const AsyncValueTaskMethodBuilder_1: {
    new<TResult>(): AsyncValueTaskMethodBuilder_1$instance<TResult>;
    create<TResult>(): AsyncValueTaskMethodBuilder_1<TResult>;
};


export type AsyncValueTaskMethodBuilder_1<TResult> = AsyncValueTaskMethodBuilder_1$instance<TResult>;

export interface AsyncVoidMethodBuilder$instance {
    awaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    awaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    setException(exception: Exception): void;
    setResult(): void;
    setStateMachine(stateMachine: IAsyncStateMachine): void;
    start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
}


export const AsyncVoidMethodBuilder: {
    new(): AsyncVoidMethodBuilder$instance;
    create(): AsyncVoidMethodBuilder;
};


export type AsyncVoidMethodBuilder = AsyncVoidMethodBuilder$instance;

export interface ConfiguredAsyncDisposable$instance {
    disposeAsync(): ConfiguredValueTaskAwaitable;
}


export const ConfiguredAsyncDisposable: {
    new(): ConfiguredAsyncDisposable$instance;
};


export type ConfiguredAsyncDisposable = ConfiguredAsyncDisposable$instance;

export interface ConfiguredCancelableAsyncEnumerable_1$instance<T> {
    configureAwait(continueOnCapturedContext: boolean): ConfiguredCancelableAsyncEnumerable_1<T>;
    getAsyncEnumerator(): ConfiguredCancelableAsyncEnumerable_1_Enumerator<T>;
    withCancellation(cancellationToken: CancellationToken): ConfiguredCancelableAsyncEnumerable_1<T>;
}


export const ConfiguredCancelableAsyncEnumerable_1: {
    new<T>(): ConfiguredCancelableAsyncEnumerable_1$instance<T>;
};


export type ConfiguredCancelableAsyncEnumerable_1<T> = ConfiguredCancelableAsyncEnumerable_1$instance<T>;

export interface ConfiguredCancelableAsyncEnumerable_1_Enumerator$instance<T> {
    readonly current: T;
    disposeAsync(): ConfiguredValueTaskAwaitable;
    moveNextAsync(): ConfiguredValueTaskAwaitable_1<CLROf<boolean>>;
}


export const ConfiguredCancelableAsyncEnumerable_1_Enumerator: {
    new<T>(): ConfiguredCancelableAsyncEnumerable_1_Enumerator$instance<T>;
};


export type ConfiguredCancelableAsyncEnumerable_1_Enumerator<T> = ConfiguredCancelableAsyncEnumerable_1_Enumerator$instance<T>;

export interface ConfiguredTaskAwaitable$instance {
    getAwaiter(): ConfiguredTaskAwaitable_ConfiguredTaskAwaiter;
}


export const ConfiguredTaskAwaitable: {
    new(): ConfiguredTaskAwaitable$instance;
};


export type ConfiguredTaskAwaitable = ConfiguredTaskAwaitable$instance;

export interface ConfiguredTaskAwaitable_1$instance<TResult> {
    getAwaiter(): ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter<TResult>;
}


export const ConfiguredTaskAwaitable_1: {
    new<TResult>(): ConfiguredTaskAwaitable_1$instance<TResult>;
};


export type ConfiguredTaskAwaitable_1<TResult> = ConfiguredTaskAwaitable_1$instance<TResult>;

export interface ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter$instance<TResult> extends ICriticalNotifyCompletion {
    readonly isCompleted: boolean;
    getResult(): TResult;
    onCompleted(continuation: Action): void;
    unsafeOnCompleted(continuation: Action): void;
}


export const ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter: {
    new<TResult>(): ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter$instance<TResult>;
};


export interface __ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter$views<TResult> {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter$instance<TResult> extends ICriticalNotifyCompletion$instance {}

export type ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter<TResult> = ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter$instance<TResult> & __ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter$views<TResult>;


export interface ConfiguredTaskAwaitable_ConfiguredTaskAwaiter$instance extends ICriticalNotifyCompletion {
    readonly isCompleted: boolean;
    getResult(): void;
    onCompleted(continuation: Action): void;
    unsafeOnCompleted(continuation: Action): void;
}


export const ConfiguredTaskAwaitable_ConfiguredTaskAwaiter: {
    new(): ConfiguredTaskAwaitable_ConfiguredTaskAwaiter$instance;
};


export interface __ConfiguredTaskAwaitable_ConfiguredTaskAwaiter$views {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface ConfiguredTaskAwaitable_ConfiguredTaskAwaiter$instance extends ICriticalNotifyCompletion$instance {}

export type ConfiguredTaskAwaitable_ConfiguredTaskAwaiter = ConfiguredTaskAwaitable_ConfiguredTaskAwaiter$instance & __ConfiguredTaskAwaitable_ConfiguredTaskAwaiter$views;


export interface ConfiguredValueTaskAwaitable$instance {
    getAwaiter(): ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter;
}


export const ConfiguredValueTaskAwaitable: {
    new(): ConfiguredValueTaskAwaitable$instance;
};


export type ConfiguredValueTaskAwaitable = ConfiguredValueTaskAwaitable$instance;

export interface ConfiguredValueTaskAwaitable_1$instance<TResult> {
    getAwaiter(): ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter<TResult>;
}


export const ConfiguredValueTaskAwaitable_1: {
    new<TResult>(): ConfiguredValueTaskAwaitable_1$instance<TResult>;
};


export type ConfiguredValueTaskAwaitable_1<TResult> = ConfiguredValueTaskAwaitable_1$instance<TResult>;

export interface ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter$instance<TResult> extends ICriticalNotifyCompletion {
    readonly isCompleted: boolean;
    getResult(): TResult;
    onCompleted(continuation: Action): void;
    unsafeOnCompleted(continuation: Action): void;
}


export const ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter: {
    new<TResult>(): ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter$instance<TResult>;
};


export interface __ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter$views<TResult> {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter$instance<TResult> extends ICriticalNotifyCompletion$instance {}

export type ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter<TResult> = ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter$instance<TResult> & __ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter$views<TResult>;


export interface ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter$instance extends ICriticalNotifyCompletion {
    readonly isCompleted: boolean;
    getResult(): void;
    onCompleted(continuation: Action): void;
    unsafeOnCompleted(continuation: Action): void;
}


export const ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter: {
    new(): ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter$instance;
};


export interface __ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter$views {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter$instance extends ICriticalNotifyCompletion$instance {}

export type ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter = ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter$instance & __ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter$views;


export interface DefaultInterpolatedStringHandler$instance {
    readonly text: ReadOnlySpan_1<CLROf<char>>;
    appendFormatted<T>(value: T): void;
    appendFormatted<T>(value: T, format: string): void;
    appendFormatted<T>(value: T, alignment: int): void;
    appendFormatted<T>(value: T, alignment: int, format: string): void;
    appendFormatted(value: ReadOnlySpan_1<CLROf<char>>): void;
    appendFormatted(value: ReadOnlySpan_1<CLROf<char>>, alignment?: int, format?: string): void;
    appendFormatted(value: string): void;
    appendFormatted(value: string, alignment?: int, format?: string): void;
    appendFormatted(value: unknown, alignment?: int, format?: string): void;
    appendLiteral(value: string): void;
    clear(): void;
    toString(): string;
    toStringAndClear(): string;
}


export const DefaultInterpolatedStringHandler: {
    new(literalLength: int, formattedCount: int): DefaultInterpolatedStringHandler$instance;
    new(literalLength: int, formattedCount: int, provider: IFormatProvider): DefaultInterpolatedStringHandler$instance;
    new(literalLength: int, formattedCount: int, provider: IFormatProvider, initialBuffer: Span_1<CLROf<char>>): DefaultInterpolatedStringHandler$instance;
};


export type DefaultInterpolatedStringHandler = DefaultInterpolatedStringHandler$instance;

export interface InlineArray10_1$instance<T> {
}


export const InlineArray10_1: {
    new<T>(): InlineArray10_1$instance<T>;
};


export type InlineArray10_1<T> = InlineArray10_1$instance<T>;

export interface InlineArray11_1$instance<T> {
}


export const InlineArray11_1: {
    new<T>(): InlineArray11_1$instance<T>;
};


export type InlineArray11_1<T> = InlineArray11_1$instance<T>;

export interface InlineArray12_1$instance<T> {
}


export const InlineArray12_1: {
    new<T>(): InlineArray12_1$instance<T>;
};


export type InlineArray12_1<T> = InlineArray12_1$instance<T>;

export interface InlineArray13_1$instance<T> {
}


export const InlineArray13_1: {
    new<T>(): InlineArray13_1$instance<T>;
};


export type InlineArray13_1<T> = InlineArray13_1$instance<T>;

export interface InlineArray14_1$instance<T> {
}


export const InlineArray14_1: {
    new<T>(): InlineArray14_1$instance<T>;
};


export type InlineArray14_1<T> = InlineArray14_1$instance<T>;

export interface InlineArray15_1$instance<T> {
}


export const InlineArray15_1: {
    new<T>(): InlineArray15_1$instance<T>;
};


export type InlineArray15_1<T> = InlineArray15_1$instance<T>;

export interface InlineArray16_1$instance<T> {
}


export const InlineArray16_1: {
    new<T>(): InlineArray16_1$instance<T>;
};


export type InlineArray16_1<T> = InlineArray16_1$instance<T>;

export interface InlineArray2_1$instance<T> {
}


export const InlineArray2_1: {
    new<T>(): InlineArray2_1$instance<T>;
};


export type InlineArray2_1<T> = InlineArray2_1$instance<T>;

export interface InlineArray3_1$instance<T> {
}


export const InlineArray3_1: {
    new<T>(): InlineArray3_1$instance<T>;
};


export type InlineArray3_1<T> = InlineArray3_1$instance<T>;

export interface InlineArray4_1$instance<T> {
}


export const InlineArray4_1: {
    new<T>(): InlineArray4_1$instance<T>;
};


export type InlineArray4_1<T> = InlineArray4_1$instance<T>;

export interface InlineArray5_1$instance<T> {
}


export const InlineArray5_1: {
    new<T>(): InlineArray5_1$instance<T>;
};


export type InlineArray5_1<T> = InlineArray5_1$instance<T>;

export interface InlineArray6_1$instance<T> {
}


export const InlineArray6_1: {
    new<T>(): InlineArray6_1$instance<T>;
};


export type InlineArray6_1<T> = InlineArray6_1$instance<T>;

export interface InlineArray7_1$instance<T> {
}


export const InlineArray7_1: {
    new<T>(): InlineArray7_1$instance<T>;
};


export type InlineArray7_1<T> = InlineArray7_1$instance<T>;

export interface InlineArray8_1$instance<T> {
}


export const InlineArray8_1: {
    new<T>(): InlineArray8_1$instance<T>;
};


export type InlineArray8_1<T> = InlineArray8_1$instance<T>;

export interface InlineArray9_1$instance<T> {
}


export const InlineArray9_1: {
    new<T>(): InlineArray9_1$instance<T>;
};


export type InlineArray9_1<T> = InlineArray9_1$instance<T>;

export interface PoolingAsyncValueTaskMethodBuilder$instance {
    readonly task: ValueTask;
    awaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    awaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    setException(exception: Exception): void;
    setResult(): void;
    setStateMachine(stateMachine: IAsyncStateMachine): void;
    start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
}


export const PoolingAsyncValueTaskMethodBuilder: {
    new(): PoolingAsyncValueTaskMethodBuilder$instance;
    create(): PoolingAsyncValueTaskMethodBuilder;
};


export type PoolingAsyncValueTaskMethodBuilder = PoolingAsyncValueTaskMethodBuilder$instance;

export interface PoolingAsyncValueTaskMethodBuilder_1$instance<TResult> {
    readonly task: ValueTask_1<TResult>;
    awaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    awaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    setException(exception: Exception): void;
    setResult(result: TResult): void;
    setStateMachine(stateMachine: IAsyncStateMachine): void;
    start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
}


export const PoolingAsyncValueTaskMethodBuilder_1: {
    new<TResult>(): PoolingAsyncValueTaskMethodBuilder_1$instance<TResult>;
    create<TResult>(): PoolingAsyncValueTaskMethodBuilder_1<TResult>;
};


export type PoolingAsyncValueTaskMethodBuilder_1<TResult> = PoolingAsyncValueTaskMethodBuilder_1$instance<TResult>;

export interface TaskAwaiter$instance extends ICriticalNotifyCompletion {
    readonly isCompleted: boolean;
    getResult(): void;
    onCompleted(continuation: Action): void;
    unsafeOnCompleted(continuation: Action): void;
}


export const TaskAwaiter: {
    new(): TaskAwaiter$instance;
};


export interface __TaskAwaiter$views {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface TaskAwaiter$instance extends ICriticalNotifyCompletion$instance {}

export type TaskAwaiter = TaskAwaiter$instance & __TaskAwaiter$views;


export interface TaskAwaiter_1$instance<TResult> extends ICriticalNotifyCompletion {
    readonly isCompleted: boolean;
    getResult(): TResult;
    onCompleted(continuation: Action): void;
    unsafeOnCompleted(continuation: Action): void;
}


export const TaskAwaiter_1: {
    new<TResult>(): TaskAwaiter_1$instance<TResult>;
};


export interface __TaskAwaiter_1$views<TResult> {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface TaskAwaiter_1$instance<TResult> extends ICriticalNotifyCompletion$instance {}

export type TaskAwaiter_1<TResult> = TaskAwaiter_1$instance<TResult> & __TaskAwaiter_1$views<TResult>;


export interface ValueTaskAwaiter$instance extends ICriticalNotifyCompletion {
    readonly isCompleted: boolean;
    getResult(): void;
    onCompleted(continuation: Action): void;
    unsafeOnCompleted(continuation: Action): void;
}


export const ValueTaskAwaiter: {
    new(): ValueTaskAwaiter$instance;
};


export interface __ValueTaskAwaiter$views {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface ValueTaskAwaiter$instance extends ICriticalNotifyCompletion$instance {}

export type ValueTaskAwaiter = ValueTaskAwaiter$instance & __ValueTaskAwaiter$views;


export interface ValueTaskAwaiter_1$instance<TResult> extends ICriticalNotifyCompletion {
    readonly isCompleted: boolean;
    getResult(): TResult;
    onCompleted(continuation: Action): void;
    unsafeOnCompleted(continuation: Action): void;
}


export const ValueTaskAwaiter_1: {
    new<TResult>(): ValueTaskAwaiter_1$instance<TResult>;
};


export interface __ValueTaskAwaiter_1$views<TResult> {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface ValueTaskAwaiter_1$instance<TResult> extends ICriticalNotifyCompletion$instance {}

export type ValueTaskAwaiter_1<TResult> = ValueTaskAwaiter_1$instance<TResult> & __ValueTaskAwaiter_1$views<TResult>;


export interface YieldAwaitable$instance {
    getAwaiter(): YieldAwaitable_YieldAwaiter;
}


export const YieldAwaitable: {
    new(): YieldAwaitable$instance;
};


export type YieldAwaitable = YieldAwaitable$instance;

export interface YieldAwaitable_YieldAwaiter$instance extends ICriticalNotifyCompletion {
    readonly isCompleted: boolean;
    getResult(): void;
    onCompleted(continuation: Action): void;
    unsafeOnCompleted(continuation: Action): void;
}


export const YieldAwaitable_YieldAwaiter: {
    new(): YieldAwaitable_YieldAwaiter$instance;
};


export interface __YieldAwaitable_YieldAwaiter$views {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface YieldAwaitable_YieldAwaiter$instance extends ICriticalNotifyCompletion$instance {}

export type YieldAwaitable_YieldAwaiter = YieldAwaitable_YieldAwaiter$instance & __YieldAwaitable_YieldAwaiter$views;


export interface AccessedThroughPropertyAttribute$instance extends Attribute {
    readonly propertyName: string;
}


export const AccessedThroughPropertyAttribute: {
    new(propertyName: string): AccessedThroughPropertyAttribute$instance;
};


export type AccessedThroughPropertyAttribute = AccessedThroughPropertyAttribute$instance;

export interface AsyncIteratorStateMachineAttribute$instance extends StateMachineAttribute {
}


export const AsyncIteratorStateMachineAttribute: {
    new(stateMachineType: Type): AsyncIteratorStateMachineAttribute$instance;
};


export type AsyncIteratorStateMachineAttribute = AsyncIteratorStateMachineAttribute$instance;

export interface AsyncMethodBuilderAttribute$instance extends Attribute {
    readonly builderType: Type;
}


export const AsyncMethodBuilderAttribute: {
    new(builderType: Type): AsyncMethodBuilderAttribute$instance;
};


export type AsyncMethodBuilderAttribute = AsyncMethodBuilderAttribute$instance;

export interface AsyncStateMachineAttribute$instance extends StateMachineAttribute {
}


export const AsyncStateMachineAttribute: {
    new(stateMachineType: Type): AsyncStateMachineAttribute$instance;
};


export type AsyncStateMachineAttribute = AsyncStateMachineAttribute$instance;

export interface CallConvCdecl$instance {
}


export const CallConvCdecl: {
    new(): CallConvCdecl$instance;
};


export type CallConvCdecl = CallConvCdecl$instance;

export interface CallConvFastcall$instance {
}


export const CallConvFastcall: {
    new(): CallConvFastcall$instance;
};


export type CallConvFastcall = CallConvFastcall$instance;

export interface CallConvMemberFunction$instance {
}


export const CallConvMemberFunction: {
    new(): CallConvMemberFunction$instance;
};


export type CallConvMemberFunction = CallConvMemberFunction$instance;

export interface CallConvStdcall$instance {
}


export const CallConvStdcall: {
    new(): CallConvStdcall$instance;
};


export type CallConvStdcall = CallConvStdcall$instance;

export interface CallConvSuppressGCTransition$instance {
}


export const CallConvSuppressGCTransition: {
    new(): CallConvSuppressGCTransition$instance;
};


export type CallConvSuppressGCTransition = CallConvSuppressGCTransition$instance;

export interface CallConvSwift$instance {
}


export const CallConvSwift: {
    new(): CallConvSwift$instance;
};


export type CallConvSwift = CallConvSwift$instance;

export interface CallConvThiscall$instance {
}


export const CallConvThiscall: {
    new(): CallConvThiscall$instance;
};


export type CallConvThiscall = CallConvThiscall$instance;

export interface CallerArgumentExpressionAttribute$instance extends Attribute {
    readonly parameterName: string;
}


export const CallerArgumentExpressionAttribute: {
    new(parameterName: string): CallerArgumentExpressionAttribute$instance;
};


export type CallerArgumentExpressionAttribute = CallerArgumentExpressionAttribute$instance;

export interface CallerFilePathAttribute$instance extends Attribute {
}


export const CallerFilePathAttribute: {
    new(): CallerFilePathAttribute$instance;
};


export type CallerFilePathAttribute = CallerFilePathAttribute$instance;

export interface CallerLineNumberAttribute$instance extends Attribute {
}


export const CallerLineNumberAttribute: {
    new(): CallerLineNumberAttribute$instance;
};


export type CallerLineNumberAttribute = CallerLineNumberAttribute$instance;

export interface CallerMemberNameAttribute$instance extends Attribute {
}


export const CallerMemberNameAttribute: {
    new(): CallerMemberNameAttribute$instance;
};


export type CallerMemberNameAttribute = CallerMemberNameAttribute$instance;

export interface CallSite$instance {
    readonly binder: CallSiteBinder;
}


export const CallSite: {
    new(): CallSite$instance;
    create(delegateType: Type, binder: CallSiteBinder): CallSite;
};


export type CallSite = CallSite$instance;

export interface CallSite_1$instance<T> extends CallSite {
    target: T;
    readonly update: T;
}


export const CallSite_1: {
    new<T>(): CallSite_1$instance<T>;
};


export type CallSite_1<T> = CallSite_1$instance<T>;

export interface CallSiteBinder$instance {
    bind(args: unknown[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    bindDelegate<T>(site: CallSite_1<T>, args: unknown[]): T;
}


export const CallSiteBinder: {
    readonly updateLabel: LabelTarget;
};


export type CallSiteBinder = CallSiteBinder$instance;

export interface Closure$instance {
    readonly constants: unknown[];
    readonly locals: unknown[];
}


export const Closure: {
    new(constants: unknown[], locals: unknown[]): Closure$instance;
};


export type Closure = Closure$instance;

export interface CollectionBuilderAttribute$instance extends Attribute {
    readonly builderType: Type;
    readonly methodName: string;
}


export const CollectionBuilderAttribute: {
    new(builderType: Type, methodName: string): CollectionBuilderAttribute$instance;
};


export type CollectionBuilderAttribute = CollectionBuilderAttribute$instance;

export interface CompilationRelaxationsAttribute$instance extends Attribute {
    readonly compilationRelaxations: int;
}


export const CompilationRelaxationsAttribute: {
    new(relaxations: int): CompilationRelaxationsAttribute$instance;
    new(relaxations: CompilationRelaxations): CompilationRelaxationsAttribute$instance;
};


export type CompilationRelaxationsAttribute = CompilationRelaxationsAttribute$instance;

export interface CompilerFeatureRequiredAttribute$instance extends Attribute {
    readonly featureName: string;
    isOptional: boolean;
}


export const CompilerFeatureRequiredAttribute: {
    new(featureName: string): CompilerFeatureRequiredAttribute$instance;
    readonly refStructs: string;
    readonly requiredMembers: string;
};


export type CompilerFeatureRequiredAttribute = CompilerFeatureRequiredAttribute$instance;

export interface CompilerGeneratedAttribute$instance extends Attribute {
}


export const CompilerGeneratedAttribute: {
    new(): CompilerGeneratedAttribute$instance;
};


export type CompilerGeneratedAttribute = CompilerGeneratedAttribute$instance;

export interface CompilerGlobalScopeAttribute$instance extends Attribute {
}


export const CompilerGlobalScopeAttribute: {
    new(): CompilerGlobalScopeAttribute$instance;
};


export type CompilerGlobalScopeAttribute = CompilerGlobalScopeAttribute$instance;

export interface CompilerLoweringPreserveAttribute$instance extends Attribute {
}


export const CompilerLoweringPreserveAttribute: {
    new(): CompilerLoweringPreserveAttribute$instance;
};


export type CompilerLoweringPreserveAttribute = CompilerLoweringPreserveAttribute$instance;

export interface ConditionalWeakTable_2$instance<TKey, TValue> {
    add(key: TKey, value: TValue): void;
    addOrUpdate(key: TKey, value: TValue): void;
    clear(): void;
    getOrAdd(key: TKey, value: TValue): TValue;
    getOrAdd(key: TKey, valueFactory: Func_2<TKey, TValue>): TValue;
    getOrAdd<TArg>(key: TKey, valueFactory: Func_3<TKey, TArg, TValue>, factoryArgument: TArg): TValue;
    getOrCreateValue(key: TKey): TValue;
    getValue(key: TKey, createValueCallback: ConditionalWeakTable_2_CreateValueCallback<TKey, TValue>): TValue;
    remove(key: TKey): boolean;
    remove(key: TKey, value: { value: ref<TValue> }): boolean;
    tryAdd(key: TKey, value: TValue): boolean;
    tryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
}


export const ConditionalWeakTable_2: {
    new<TKey, TValue>(): ConditionalWeakTable_2$instance<TKey, TValue>;
};


export interface __ConditionalWeakTable_2$views<TKey, TValue> {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export interface ConditionalWeakTable_2$instance<TKey, TValue> extends System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>> {}

export type ConditionalWeakTable_2<TKey, TValue> = ConditionalWeakTable_2$instance<TKey, TValue> & __ConditionalWeakTable_2$views<TKey, TValue>;


export interface CppInlineNamespaceAttribute$instance extends Attribute {
}


export const CppInlineNamespaceAttribute: {
    new(dottedName: string): CppInlineNamespaceAttribute$instance;
};


export type CppInlineNamespaceAttribute = CppInlineNamespaceAttribute$instance;

export interface CreateNewOnMetadataUpdateAttribute$instance extends Attribute {
}


export const CreateNewOnMetadataUpdateAttribute: {
    new(): CreateNewOnMetadataUpdateAttribute$instance;
};


export type CreateNewOnMetadataUpdateAttribute = CreateNewOnMetadataUpdateAttribute$instance;

export interface CustomConstantAttribute$instance extends Attribute {
    readonly value: unknown;
}


export const CustomConstantAttribute: {
};


export type CustomConstantAttribute = CustomConstantAttribute$instance;

export interface DateTimeConstantAttribute$instance extends CustomConstantAttribute {
    readonly value: unknown;
}


export const DateTimeConstantAttribute: {
    new(ticks: long): DateTimeConstantAttribute$instance;
};


export type DateTimeConstantAttribute = DateTimeConstantAttribute$instance;

export interface DebugInfoGenerator$instance {
    markSequencePoint(method: LambdaExpression, ilOffset: int, sequencePoint: DebugInfoExpression): void;
}


export const DebugInfoGenerator: {
    createPdbGenerator(): DebugInfoGenerator;
};


export type DebugInfoGenerator = DebugInfoGenerator$instance;

export interface DecimalConstantAttribute$instance extends Attribute {
    readonly value: decimal;
}


export const DecimalConstantAttribute: {
    new(scale: byte, sign: byte, hi: uint, mid: uint, low: uint): DecimalConstantAttribute$instance;
    new(scale: byte, sign: byte, hi: int, mid: int, low: int): DecimalConstantAttribute$instance;
};


export type DecimalConstantAttribute = DecimalConstantAttribute$instance;

export interface DefaultDependencyAttribute$instance extends Attribute {
    readonly loadHint: LoadHint;
}


export const DefaultDependencyAttribute: {
    new(loadHintArgument: LoadHint): DefaultDependencyAttribute$instance;
};


export type DefaultDependencyAttribute = DefaultDependencyAttribute$instance;

export interface DependencyAttribute$instance extends Attribute {
    readonly dependentAssembly: string;
    readonly loadHint: LoadHint;
}


export const DependencyAttribute: {
    new(dependentAssemblyArgument: string, loadHintArgument: LoadHint): DependencyAttribute$instance;
};


export type DependencyAttribute = DependencyAttribute$instance;

export interface DisablePrivateReflectionAttribute$instance extends Attribute {
}


export const DisablePrivateReflectionAttribute: {
    new(): DisablePrivateReflectionAttribute$instance;
};


export type DisablePrivateReflectionAttribute = DisablePrivateReflectionAttribute$instance;

export interface DisableRuntimeMarshallingAttribute$instance extends Attribute {
}


export const DisableRuntimeMarshallingAttribute: {
    new(): DisableRuntimeMarshallingAttribute$instance;
};


export type DisableRuntimeMarshallingAttribute = DisableRuntimeMarshallingAttribute$instance;

export interface DiscardableAttribute$instance extends Attribute {
}


export const DiscardableAttribute: {
    new(): DiscardableAttribute$instance;
};


export type DiscardableAttribute = DiscardableAttribute$instance;

export interface DynamicAttribute$instance extends Attribute {
    readonly transformFlags: IList_1<CLROf<boolean>>;
}


export const DynamicAttribute: {
    new(): DynamicAttribute$instance;
    new(transformFlags: boolean[]): DynamicAttribute$instance;
};


export type DynamicAttribute = DynamicAttribute$instance;

export interface EnumeratorCancellationAttribute$instance extends Attribute {
}


export const EnumeratorCancellationAttribute: {
    new(): EnumeratorCancellationAttribute$instance;
};


export type EnumeratorCancellationAttribute = EnumeratorCancellationAttribute$instance;

export interface ExtensionAttribute$instance extends Attribute {
}


export const ExtensionAttribute: {
    new(): ExtensionAttribute$instance;
};


export type ExtensionAttribute = ExtensionAttribute$instance;

export interface ExtensionMarkerAttribute$instance extends Attribute {
    readonly name: string;
}


export const ExtensionMarkerAttribute: {
    new(name: string): ExtensionMarkerAttribute$instance;
};


export type ExtensionMarkerAttribute = ExtensionMarkerAttribute$instance;

export interface FixedAddressValueTypeAttribute$instance extends Attribute {
}


export const FixedAddressValueTypeAttribute: {
    new(): FixedAddressValueTypeAttribute$instance;
};


export type FixedAddressValueTypeAttribute = FixedAddressValueTypeAttribute$instance;

export interface FixedBufferAttribute$instance extends Attribute {
    readonly elementType: Type;
    readonly length: int;
}


export const FixedBufferAttribute: {
    new(elementType: Type, length: int): FixedBufferAttribute$instance;
};


export type FixedBufferAttribute = FixedBufferAttribute$instance;

export interface HasCopySemanticsAttribute$instance extends Attribute {
}


export const HasCopySemanticsAttribute: {
    new(): HasCopySemanticsAttribute$instance;
};


export type HasCopySemanticsAttribute = HasCopySemanticsAttribute$instance;

export interface IDispatchConstantAttribute$instance extends CustomConstantAttribute {
    readonly value: unknown;
}


export const IDispatchConstantAttribute: {
    new(): IDispatchConstantAttribute$instance;
};


export type IDispatchConstantAttribute = IDispatchConstantAttribute$instance;

export interface IndexerNameAttribute$instance extends Attribute {
}


export const IndexerNameAttribute: {
    new(indexerName: string): IndexerNameAttribute$instance;
};


export type IndexerNameAttribute = IndexerNameAttribute$instance;

export interface InlineArrayAttribute$instance extends Attribute {
    readonly length: int;
}


export const InlineArrayAttribute: {
    new(length: int): InlineArrayAttribute$instance;
};


export type InlineArrayAttribute = InlineArrayAttribute$instance;

export interface InternalsVisibleToAttribute$instance extends Attribute {
    allInternalsVisible: boolean;
    readonly assemblyName: string;
}


export const InternalsVisibleToAttribute: {
    new(assemblyName: string): InternalsVisibleToAttribute$instance;
};


export type InternalsVisibleToAttribute = InternalsVisibleToAttribute$instance;

export interface InterpolatedStringHandlerArgumentAttribute$instance extends Attribute {
    readonly arguments: string[];
}


export const InterpolatedStringHandlerArgumentAttribute: {
    new(argument: string): InterpolatedStringHandlerArgumentAttribute$instance;
    new(arguments: string[]): InterpolatedStringHandlerArgumentAttribute$instance;
};


export type InterpolatedStringHandlerArgumentAttribute = InterpolatedStringHandlerArgumentAttribute$instance;

export interface InterpolatedStringHandlerAttribute$instance extends Attribute {
}


export const InterpolatedStringHandlerAttribute: {
    new(): InterpolatedStringHandlerAttribute$instance;
};


export type InterpolatedStringHandlerAttribute = InterpolatedStringHandlerAttribute$instance;

export interface IsByRefLikeAttribute$instance extends Attribute {
}


export const IsByRefLikeAttribute: {
    new(): IsByRefLikeAttribute$instance;
};


export type IsByRefLikeAttribute = IsByRefLikeAttribute$instance;

export interface IsReadOnlyAttribute$instance extends Attribute {
}


export const IsReadOnlyAttribute: {
    new(): IsReadOnlyAttribute$instance;
};


export type IsReadOnlyAttribute = IsReadOnlyAttribute$instance;

export interface IsUnmanagedAttribute$instance extends Attribute {
}


export const IsUnmanagedAttribute: {
    new(): IsUnmanagedAttribute$instance;
};


export type IsUnmanagedAttribute = IsUnmanagedAttribute$instance;

export interface IteratorStateMachineAttribute$instance extends StateMachineAttribute {
}


export const IteratorStateMachineAttribute: {
    new(stateMachineType: Type): IteratorStateMachineAttribute$instance;
};


export type IteratorStateMachineAttribute = IteratorStateMachineAttribute$instance;

export interface IUnknownConstantAttribute$instance extends CustomConstantAttribute {
    readonly value: unknown;
}


export const IUnknownConstantAttribute: {
    new(): IUnknownConstantAttribute$instance;
};


export type IUnknownConstantAttribute = IUnknownConstantAttribute$instance;

export interface MetadataUpdateDeletedAttribute$instance extends Attribute {
}


export const MetadataUpdateDeletedAttribute: {
    new(): MetadataUpdateDeletedAttribute$instance;
};


export type MetadataUpdateDeletedAttribute = MetadataUpdateDeletedAttribute$instance;

export interface MetadataUpdateOriginalTypeAttribute$instance extends Attribute {
    readonly originalType: Type;
}


export const MetadataUpdateOriginalTypeAttribute: {
    new(originalType: Type): MetadataUpdateOriginalTypeAttribute$instance;
};


export type MetadataUpdateOriginalTypeAttribute = MetadataUpdateOriginalTypeAttribute$instance;

export interface MethodImplAttribute$instance extends Attribute {
    methodCodeType: MethodCodeType;
    readonly value: MethodImplOptions;
}


export const MethodImplAttribute: {
    new(methodImplOptions: MethodImplOptions): MethodImplAttribute$instance;
    new(value: short): MethodImplAttribute$instance;
    new(): MethodImplAttribute$instance;
};


export type MethodImplAttribute = MethodImplAttribute$instance;

export interface ModuleInitializerAttribute$instance extends Attribute {
}


export const ModuleInitializerAttribute: {
    new(): ModuleInitializerAttribute$instance;
};


export type ModuleInitializerAttribute = ModuleInitializerAttribute$instance;

export interface NativeCppClassAttribute$instance extends Attribute {
}


export const NativeCppClassAttribute: {
    new(): NativeCppClassAttribute$instance;
};


export type NativeCppClassAttribute = NativeCppClassAttribute$instance;

export interface NullableAttribute$instance extends Attribute {
    readonly nullableFlags: byte[];
}


export const NullableAttribute: {
    new(value: byte): NullableAttribute$instance;
    new(value: byte[]): NullableAttribute$instance;
};


export type NullableAttribute = NullableAttribute$instance;

export interface NullableContextAttribute$instance extends Attribute {
    readonly flag: byte;
}


export const NullableContextAttribute: {
    new(value: byte): NullableContextAttribute$instance;
};


export type NullableContextAttribute = NullableContextAttribute$instance;

export interface NullablePublicOnlyAttribute$instance extends Attribute {
    readonly includesInternals: boolean;
}


export const NullablePublicOnlyAttribute: {
    new(value: boolean): NullablePublicOnlyAttribute$instance;
};


export type NullablePublicOnlyAttribute = NullablePublicOnlyAttribute$instance;

export interface OverloadResolutionPriorityAttribute$instance extends Attribute {
    readonly priority: int;
}


export const OverloadResolutionPriorityAttribute: {
    new(priority: int): OverloadResolutionPriorityAttribute$instance;
};


export type OverloadResolutionPriorityAttribute = OverloadResolutionPriorityAttribute$instance;

export interface ParamCollectionAttribute$instance extends Attribute {
}


export const ParamCollectionAttribute: {
    new(): ParamCollectionAttribute$instance;
};


export type ParamCollectionAttribute = ParamCollectionAttribute$instance;

export interface PreserveBaseOverridesAttribute$instance extends Attribute {
}


export const PreserveBaseOverridesAttribute: {
    new(): PreserveBaseOverridesAttribute$instance;
};


export type PreserveBaseOverridesAttribute = PreserveBaseOverridesAttribute$instance;

export interface ReadOnlyCollectionBuilder_1$instance<T> {
    capacity: int;
    readonly count: int;
    item: T;
    add(item: T): void;
    clear(): void;
    contains(item: T): boolean;
    copyTo(array: T[], arrayIndex: int): void;
    getEnumerator(): IEnumerator_1<T>;
    indexOf(item: T): int;
    insert(index: int, item: T): void;
    remove(item: T): boolean;
    removeAt(index: int): void;
    reverse(): void;
    reverse(index: int, count: int): void;
    toArray(): T[];
    toReadOnlyCollection(): ReadOnlyCollection_1<T>;
}


export const ReadOnlyCollectionBuilder_1: {
    new<T>(): ReadOnlyCollectionBuilder_1$instance<T>;
    new<T>(capacity: int): ReadOnlyCollectionBuilder_1$instance<T>;
    new<T>(collection: IEnumerable_1<T>): ReadOnlyCollectionBuilder_1$instance<T>;
};


export interface __ReadOnlyCollectionBuilder_1$views<T> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type ReadOnlyCollectionBuilder_1<T> = ReadOnlyCollectionBuilder_1$instance<T> & __ReadOnlyCollectionBuilder_1$views<T>;


export interface ReferenceAssemblyAttribute$instance extends Attribute {
    readonly description: string;
}


export const ReferenceAssemblyAttribute: {
    new(): ReferenceAssemblyAttribute$instance;
    new(description: string): ReferenceAssemblyAttribute$instance;
};


export type ReferenceAssemblyAttribute = ReferenceAssemblyAttribute$instance;

export interface RefSafetyRulesAttribute$instance extends Attribute {
    readonly version: int;
}


export const RefSafetyRulesAttribute: {
    new(version: int): RefSafetyRulesAttribute$instance;
};


export type RefSafetyRulesAttribute = RefSafetyRulesAttribute$instance;

export interface RequiredAttributeAttribute$instance extends Attribute {
    readonly requiredContract: Type;
}


export const RequiredAttributeAttribute: {
    new(requiredContract: Type): RequiredAttributeAttribute$instance;
};


export type RequiredAttributeAttribute = RequiredAttributeAttribute$instance;

export interface RequiredMemberAttribute$instance extends Attribute {
}


export const RequiredMemberAttribute: {
    new(): RequiredMemberAttribute$instance;
};


export type RequiredMemberAttribute = RequiredMemberAttribute$instance;

export interface RequiresLocationAttribute$instance extends Attribute {
}


export const RequiresLocationAttribute: {
    new(): RequiresLocationAttribute$instance;
};


export type RequiresLocationAttribute = RequiresLocationAttribute$instance;

export interface RuleCache_1$instance<T> {
}


export const RuleCache_1: {
    new<T>(): RuleCache_1$instance<T>;
};


export type RuleCache_1<T> = RuleCache_1$instance<T>;

export interface RuntimeCompatibilityAttribute$instance extends Attribute {
    wrapNonExceptionThrows: boolean;
}


export const RuntimeCompatibilityAttribute: {
    new(): RuntimeCompatibilityAttribute$instance;
};


export type RuntimeCompatibilityAttribute = RuntimeCompatibilityAttribute$instance;

export interface RuntimeWrappedException$instance extends Exception {
    readonly wrappedException: unknown;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const RuntimeWrappedException: {
    new(thrownObject: unknown): RuntimeWrappedException$instance;
};


export interface __RuntimeWrappedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type RuntimeWrappedException = RuntimeWrappedException$instance & __RuntimeWrappedException$views;


export interface ScopedRefAttribute$instance extends Attribute {
}


export const ScopedRefAttribute: {
    new(): ScopedRefAttribute$instance;
};


export type ScopedRefAttribute = ScopedRefAttribute$instance;

export interface ScopelessEnumAttribute$instance extends Attribute {
}


export const ScopelessEnumAttribute: {
    new(): ScopelessEnumAttribute$instance;
};


export type ScopelessEnumAttribute = ScopelessEnumAttribute$instance;

export interface SkipLocalsInitAttribute$instance extends Attribute {
}


export const SkipLocalsInitAttribute: {
    new(): SkipLocalsInitAttribute$instance;
};


export type SkipLocalsInitAttribute = SkipLocalsInitAttribute$instance;

export interface SpecialNameAttribute$instance extends Attribute {
}


export const SpecialNameAttribute: {
    new(): SpecialNameAttribute$instance;
};


export type SpecialNameAttribute = SpecialNameAttribute$instance;

export interface StateMachineAttribute$instance extends Attribute {
    readonly stateMachineType: Type;
}


export const StateMachineAttribute: {
    new(stateMachineType: Type): StateMachineAttribute$instance;
};


export type StateMachineAttribute = StateMachineAttribute$instance;

export interface StringFreezingAttribute$instance extends Attribute {
}


export const StringFreezingAttribute: {
    new(): StringFreezingAttribute$instance;
};


export type StringFreezingAttribute = StringFreezingAttribute$instance;

export interface StrongBox_1$instance<T> {
    value: T;
}


export const StrongBox_1: {
    new<T>(): StrongBox_1$instance<T>;
    new<T>(value: T): StrongBox_1$instance<T>;
};


export interface __StrongBox_1$views<T> {
    As_IStrongBox(): IStrongBox$instance;
}

export interface StrongBox_1$instance<T> extends IStrongBox$instance {}

export type StrongBox_1<T> = StrongBox_1$instance<T> & __StrongBox_1$views<T>;


export interface SuppressIldasmAttribute$instance extends Attribute {
}


export const SuppressIldasmAttribute: {
    new(): SuppressIldasmAttribute$instance;
};


export type SuppressIldasmAttribute = SuppressIldasmAttribute$instance;

export interface SwitchExpressionException$instance extends InvalidOperationException {
    readonly message: string;
    readonly unmatchedValue: unknown;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SwitchExpressionException: {
    new(): SwitchExpressionException$instance;
    new(innerException: Exception): SwitchExpressionException$instance;
    new(unmatchedValue: unknown): SwitchExpressionException$instance;
    new(message: string): SwitchExpressionException$instance;
    new(message: string, innerException: Exception): SwitchExpressionException$instance;
};


export interface __SwitchExpressionException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SwitchExpressionException = SwitchExpressionException$instance & __SwitchExpressionException$views;


export interface TupleElementNamesAttribute$instance extends Attribute {
    readonly transformNames: IList_1<CLROf<string>>;
}


export const TupleElementNamesAttribute: {
    new(transformNames: string[]): TupleElementNamesAttribute$instance;
};


export type TupleElementNamesAttribute = TupleElementNamesAttribute$instance;

export interface TypeForwardedFromAttribute$instance extends Attribute {
    readonly assemblyFullName: string;
}


export const TypeForwardedFromAttribute: {
    new(assemblyFullName: string): TypeForwardedFromAttribute$instance;
};


export type TypeForwardedFromAttribute = TypeForwardedFromAttribute$instance;

export interface TypeForwardedToAttribute$instance extends Attribute {
    readonly destination: Type;
}


export const TypeForwardedToAttribute: {
    new(destination: Type): TypeForwardedToAttribute$instance;
};


export type TypeForwardedToAttribute = TypeForwardedToAttribute$instance;

export interface UnsafeAccessorAttribute$instance extends Attribute {
    readonly kind: UnsafeAccessorKind;
    name: string;
}


export const UnsafeAccessorAttribute: {
    new(kind: UnsafeAccessorKind): UnsafeAccessorAttribute$instance;
};


export type UnsafeAccessorAttribute = UnsafeAccessorAttribute$instance;

export interface UnsafeAccessorTypeAttribute$instance extends Attribute {
    readonly typeName: string;
}


export const UnsafeAccessorTypeAttribute: {
    new(typeName: string): UnsafeAccessorTypeAttribute$instance;
};


export type UnsafeAccessorTypeAttribute = UnsafeAccessorTypeAttribute$instance;

export interface UnsafeValueTypeAttribute$instance extends Attribute {
}


export const UnsafeValueTypeAttribute: {
    new(): UnsafeValueTypeAttribute$instance;
};


export type UnsafeValueTypeAttribute = UnsafeValueTypeAttribute$instance;

export abstract class AsyncHelpers$instance {
    static await_<T>(configuredAwaitable: ConfiguredTaskAwaitable_1<T>): T;
    static await_<T>(configuredAwaitable: ConfiguredValueTaskAwaitable_1<T>): T;
    static await_(configuredAwaitable: ConfiguredTaskAwaitable): void;
    static await_(configuredAwaitable: ConfiguredValueTaskAwaitable): void;
    static await_(task: Task): void;
    static await_(task: ValueTask): void;
    static await_<T>(task: Task_1<T>): T;
    static await_<T>(task: ValueTask_1<T>): T;
    static awaitAwaiter<TAwaiter extends INotifyCompletion>(awaiter: TAwaiter): void;
    static unsafeAwaitAwaiter<TAwaiter extends ICriticalNotifyCompletion>(awaiter: TAwaiter): void;
}


export type AsyncHelpers = AsyncHelpers$instance;

export abstract class CallSiteHelpers$instance {
    static isInternalFrame(mb: MethodBase): boolean;
}


export type CallSiteHelpers = CallSiteHelpers$instance;

export abstract class CallSiteOps$instance {
    static addRule<T>(site: CallSite_1<T>, rule: T): void;
    static bind<T>(binder: CallSiteBinder, site: CallSite_1<T>, args: unknown[]): T;
    static clearMatch(site: CallSite): void;
    static createMatchmaker<T>(site: CallSite_1<T>): CallSite_1<T>;
    static getCachedRules<T>(cache: RuleCache_1<T>): T[];
    static getMatch(site: CallSite): boolean;
    static getRuleCache<T>(site: CallSite_1<T>): RuleCache_1<T>;
    static getRules<T>(site: CallSite_1<T>): T[];
    static moveRule<T>(cache: RuleCache_1<T>, rule: T, i: int): void;
    static setNotMatched(site: CallSite): boolean;
    static updateRules<T>(this_: CallSite_1<T>, matched: int): void;
}


export type CallSiteOps = CallSiteOps$instance;

export abstract class CompilerMarshalOverride$instance {
}


export type CompilerMarshalOverride = CompilerMarshalOverride$instance;

export abstract class ContractHelper$instance {
    static raiseContractFailedEvent(failureKind: ContractFailureKind, userMessage: string, conditionText: string, innerException: Exception): string;
    static triggerFailure(kind: ContractFailureKind, displayMessage: string, userMessage: string, conditionText: string, innerException: Exception): void;
}


export type ContractHelper = ContractHelper$instance;

export abstract class FormattableStringFactory$instance {
    static create(format: string, arguments: unknown[]): FormattableString;
}


export type FormattableStringFactory = FormattableStringFactory$instance;

export abstract class IsBoxed$instance {
}


export type IsBoxed = IsBoxed$instance;

export abstract class IsByValue$instance {
}


export type IsByValue = IsByValue$instance;

export abstract class IsConst$instance {
}


export type IsConst = IsConst$instance;

export abstract class IsCopyConstructed$instance {
}


export type IsCopyConstructed = IsCopyConstructed$instance;

export abstract class IsExplicitlyDereferenced$instance {
}


export type IsExplicitlyDereferenced = IsExplicitlyDereferenced$instance;

export abstract class IsExternalInit$instance {
}


export type IsExternalInit = IsExternalInit$instance;

export abstract class IsImplicitlyDereferenced$instance {
}


export type IsImplicitlyDereferenced = IsImplicitlyDereferenced$instance;

export abstract class IsJitIntrinsic$instance {
}


export type IsJitIntrinsic = IsJitIntrinsic$instance;

export abstract class IsLong$instance {
}


export type IsLong = IsLong$instance;

export abstract class IsPinned$instance {
}


export type IsPinned = IsPinned$instance;

export abstract class IsSignUnspecifiedByte$instance {
}


export type IsSignUnspecifiedByte = IsSignUnspecifiedByte$instance;

export abstract class IsUdtReturn$instance {
}


export type IsUdtReturn = IsUdtReturn$instance;

export abstract class IsVolatile$instance {
}


export type IsVolatile = IsVolatile$instance;

export abstract class RuntimeFeature$instance {
    static readonly portablePdb: string;
    static readonly defaultImplementationsOfInterfaces: string;
    static readonly unmanagedSignatureCallingConvention: string;
    static readonly covariantReturnsOfClasses: string;
    static readonly byRefFields: string;
    static readonly byRefLikeGenerics: string;
    static readonly virtualStaticsInInterfaces: string;
    static readonly numericIntPtr: string;
    static readonly isDynamicCodeSupported: boolean;
    static readonly isDynamicCodeCompiled: boolean;
    static isSupported(feature: string): boolean;
}


export type RuntimeFeature = RuntimeFeature$instance;

export abstract class RuntimeHelpers$instance {
    static readonly offsetToStringData: int;
    static allocateTypeAssociatedMemory(type_: Type, size: int): nint;
    static box(target: { value: ref<byte> }, type_: RuntimeTypeHandle): unknown;
    static createSpan<T>(fldHandle: RuntimeFieldHandle): ReadOnlySpan_1<T>;
    static ensureSufficientExecutionStack(): void;
    static equals(o1: unknown, o2: unknown): boolean;
    static executeCodeWithGuaranteedCleanup(code: RuntimeHelpers_TryCode, backoutCode: RuntimeHelpers_CleanupCode, userData: unknown): void;
    static getHashCode(o: unknown): int;
    static getObjectValue(obj: unknown): unknown;
    static getSubArray<T>(array: T[], range: Range): T[];
    static getUninitializedObject(type_: Type): unknown;
    static initializeArray(array: ClrArray, fldHandle: RuntimeFieldHandle): void;
    static isReferenceOrContainsReferences<T>(): boolean;
    static prepareConstrainedRegions(): void;
    static prepareConstrainedRegionsNoOP(): void;
    static prepareContractedDelegate(d: Function): void;
    static prepareDelegate(d: Function): void;
    static prepareMethod(method: RuntimeMethodHandle, instantiation: RuntimeTypeHandle[]): void;
    static prepareMethod(method: RuntimeMethodHandle): void;
    static probeForSufficientStack(): void;
    static runClassConstructor(type_: RuntimeTypeHandle): void;
    static runModuleConstructor(module_: ModuleHandle): void;
    static sizeOf(type_: RuntimeTypeHandle): int;
    static tryEnsureSufficientExecutionStack(): boolean;
}


export type RuntimeHelpers = RuntimeHelpers$instance;

export abstract class RuntimeOps$instance {
    static createRuntimeVariables(): IRuntimeVariables;
    static createRuntimeVariables(data: unknown[], indexes: long[]): IRuntimeVariables;
    static expandoCheckVersion(expando: ExpandoObject, version: unknown): boolean;
    static expandoPromoteClass(expando: ExpandoObject, oldClass: unknown, newClass: unknown): void;
    static expandoTryDeleteValue(expando: ExpandoObject, indexClass: unknown, index: int, name: string, ignoreCase: boolean): boolean;
    static expandoTryGetValue(expando: ExpandoObject, indexClass: unknown, index: int, name: string, ignoreCase: boolean, value: { value: ref<unknown> }): boolean;
    static expandoTrySetValue(expando: ExpandoObject, indexClass: unknown, index: int, value: unknown, name: string, ignoreCase: boolean): unknown;
    static mergeRuntimeVariables(first: IRuntimeVariables, second: IRuntimeVariables, indexes: int[]): IRuntimeVariables;
    static quote(expression: Expression, hoistedLocals: unknown, locals: unknown[]): Expression;
}


export type RuntimeOps = RuntimeOps$instance;

export abstract class Unsafe$instance {
    static add<T>(source: ptr<void>, elementOffset: int): ptr<void>;
    static add<T>(source: { value: ref<T> }, elementOffset: int): ref<T>;
    static add<T>(source: { value: ref<T> }, elementOffset: nint): ref<T>;
    static add<T>(source: { value: ref<T> }, elementOffset: nuint): ref<T>;
    static addByteOffset<T>(source: { value: ref<T> }, byteOffset: nint): ref<T>;
    static addByteOffset<T>(source: { value: ref<T> }, byteOffset: nuint): ref<T>;
    static areSame<T>(left: { value: ref<T> }, right: { value: ref<T> }): boolean;
    static as_<T>(o: unknown): T;
    static as_<TFrom, TTo>(source: { value: ref<TFrom> }): ref<TTo>;
    static asPointer<T>(value: { value: ref<T> }): ptr<void>;
    static asRef<T>(source: ptr<void>): ref<T>;
    static asRef<T>(source: { value: ref<T> }): ref<T>;
    static bitCast<TFrom, TTo>(source: TFrom): TTo;
    static byteOffset<T>(origin: { value: ref<T> }, target: { value: ref<T> }): nint;
    static copy<T>(destination: ptr<void>, source: { value: ref<T> }): void;
    static copy<T>(destination: { value: ref<T> }, source: ptr<void>): void;
    static copyBlock(destination: { value: ref<byte> }, source: { value: ref<byte> }, byteCount: uint): void;
    static copyBlock(destination: ptr<void>, source: ptr<void>, byteCount: uint): void;
    static copyBlockUnaligned(destination: { value: ref<byte> }, source: { value: ref<byte> }, byteCount: uint): void;
    static copyBlockUnaligned(destination: ptr<void>, source: ptr<void>, byteCount: uint): void;
    static initBlock(startAddress: { value: ref<byte> }, value: byte, byteCount: uint): void;
    static initBlock(startAddress: ptr<void>, value: byte, byteCount: uint): void;
    static initBlockUnaligned(startAddress: { value: ref<byte> }, value: byte, byteCount: uint): void;
    static initBlockUnaligned(startAddress: ptr<void>, value: byte, byteCount: uint): void;
    static isAddressGreaterThan<T>(left: { value: ref<T> }, right: { value: ref<T> }): boolean;
    static isAddressGreaterThanOrEqualTo<T>(left: { value: ref<T> }, right: { value: ref<T> }): boolean;
    static isAddressLessThan<T>(left: { value: ref<T> }, right: { value: ref<T> }): boolean;
    static isAddressLessThanOrEqualTo<T>(left: { value: ref<T> }, right: { value: ref<T> }): boolean;
    static isNullRef<T>(source: { value: ref<T> }): boolean;
    static nullRef<T>(): ref<T>;
    static read<T>(source: ptr<void>): T;
    static readUnaligned<T>(source: { value: ref<byte> }): T;
    static readUnaligned<T>(source: ptr<void>): T;
    static sizeOf<T>(): int;
    static skipInit<T>(value: { value: ref<T> }): void;
    static subtract<T>(source: ptr<void>, elementOffset: int): ptr<void>;
    static subtract<T>(source: { value: ref<T> }, elementOffset: int): ref<T>;
    static subtract<T>(source: { value: ref<T> }, elementOffset: nint): ref<T>;
    static subtract<T>(source: { value: ref<T> }, elementOffset: nuint): ref<T>;
    static subtractByteOffset<T>(source: { value: ref<T> }, byteOffset: nint): ref<T>;
    static subtractByteOffset<T>(source: { value: ref<T> }, byteOffset: nuint): ref<T>;
    static unbox<T extends unknown>(box: unknown): ref<T>;
    static write<T>(destination: ptr<void>, value: T): void;
    static writeUnaligned<T>(destination: { value: ref<byte> }, value: T): void;
    static writeUnaligned<T>(destination: ptr<void>, value: T): void;
}


export type Unsafe = Unsafe$instance;

