// Generated by tsbindgen - Architecture
// Namespace: System.Runtime.InteropServices
// Assembly: System.Collections.Immutable, System.Memory, System.Private.CoreLib, System.Runtime.InteropServices, System.Text.Json

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as Microsoft_Win32_SafeHandles_Internal from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import type { SafeHandleZeroOrMinusOneIsInvalid } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import type { MemoryManager_1, ReadOnlySequence_1, ReadOnlySequenceSegment_1, SequenceReader_1 } from "../../System.Buffers/internal/index.js";
import type { Dictionary_2, Dictionary_2_AlternateLookup_1, IEnumerable_1, IList_1, IReadOnlyDictionary_2, List_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ImmutableArray_1, ImmutableArray_1_Builder } from "../../System.Collections.Immutable/internal/index.js";
import type { BitArray, IDictionary } from "../../System.Collections/internal/index.js";
import type { NumberStyles } from "../../System.Globalization/internal/index.js";
import * as System_Numerics_Internal from "../../System.Numerics/internal/index.js";
import type { IAdditionOperators_3, IAdditiveIdentity_2, IBinaryFloatingPointIeee754_1, IBinaryInteger_1, IBinaryNumber_1, IBitwiseOperators_3, IComparisonOperators_3, IDecrementOperators_1, IDivisionOperators_3, IEqualityOperators_3, IExponentialFunctions_1, IFloatingPoint_1, IFloatingPointConstants_1, IFloatingPointIeee754_1, IHyperbolicFunctions_1, IIncrementOperators_1, ILogarithmicFunctions_1, IMinMaxValue_1, IModulusOperators_3, IMultiplicativeIdentity_2, IMultiplyOperators_3, INumber_1, INumberBase_1, IPowerFunctions_1, IRootFunctions_1, ISignedNumber_1, ISubtractionOperators_3, ITrigonometricFunctions_1, IUnaryNegationOperators_2, IUnaryPlusOperators_2 } from "../../System.Numerics/internal/index.js";
import { EventInfo } from "../../System.Reflection/internal/index.js";
import * as System_Reflection_Internal from "../../System.Reflection/internal/index.js";
import type { Assembly, CustomAttributeData, EventAttributes, ICustomAttributeProvider, MemberInfo, MemberTypes, MethodBase, MethodInfo, Module } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_ConstrainedExecution_Internal from "../../System.Runtime.ConstrainedExecution/internal/index.js";
import type { CriticalFinalizerObject } from "../../System.Runtime.ConstrainedExecution/internal/index.js";
import type { ITypeInfo } from "../../System.Runtime.InteropServices.ComTypes/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { SecureString } from "../../System.Security/internal/index.js";
import type { JsonElement, JsonProperty } from "../../System.Text.Json/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Array as ClrArray, ArraySegment_1, AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Char, Decimal, Delegate, Double, Enum, Exception, Guid, IAsyncResult, ICloneable, IComparable, IComparable_1, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, IParsable_1, ISpanFormattable, ISpanParsable_1, IUtf8SpanFormattable, IUtf8SpanParsable_1, MarshalByRefObject, Memory_1, MidpointRounding, MulticastDelegate, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, RuntimeTypeHandle, Single, Span_1, String as ClrString, SystemException, Type, TypeCode, UInt32, UInt64, UIntPtr, ValueTuple_2, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum Architecture {
    X86 = 0,
    X64 = 1,
    arm = 2,
    arm64 = 3,
    wasm = 4,
    s390x = 5,
    loongArch64 = 6,
    armv6 = 7,
    ppc64le = 8,
    riscV64 = 9
}


export enum AssemblyRegistrationFlags {
    none = 0,
    setCodeBase = 1
}


export enum CallingConvention {
    winapi = 1,
    cdecl = 2,
    stdCall = 3,
    thisCall = 4,
    fastCall = 5
}


export enum CharSet {
    none = 1,
    ansi = 2,
    unicode = 3,
    auto = 4
}


export enum ClassInterfaceType {
    none = 0,
    autoDispatch = 1,
    autoDual = 2
}


export enum ComInterfaceType {
    interfaceIsDual = 0,
    interfaceIsIUnknown = 1,
    interfaceIsIDispatch = 2,
    interfaceIsIInspectable = 3
}


export enum ComMemberType {
    method = 0,
    propGet = 1,
    propSet = 2
}


export enum CreateComInterfaceFlags {
    none = 0,
    callerDefinedIUnknown = 1,
    trackerSupport = 2
}


export enum CreatedWrapperFlags {
    none = 0,
    trackerObject = 1,
    nonWrapping = 2
}


export enum CreateObjectFlags {
    none = 0,
    trackerObject = 1,
    uniqueInstance = 2,
    aggregation = 4,
    unwrap = 8
}


export enum CustomQueryInterfaceMode {
    ignore = 0,
    allow = 1
}


export enum CustomQueryInterfaceResult {
    handled = 0,
    notHandled = 1,
    failed = 2
}


export enum DllImportSearchPath {
    useDllDirectoryForDependencies = 256,
    applicationDirectory = 512,
    userDirectories = 1024,
    system32 = 2048,
    safeDirectories = 4096,
    assemblyDirectory = 2,
    legacyBehavior = 0
}


export enum ExporterEventKind {
    NOTIF_TYPECONVERTED = 0,
    NOTIF_CONVERTWARNING = 1,
    ERROR_REFTOINVALIDASSEMBLY = 2
}


export enum GCHandleType {
    weak = 0,
    weakTrackResurrection = 1,
    normal = 2,
    pinned = 3
}


export enum LayoutKind {
    sequential = 0,
    explicit = 2,
    auto = 3
}


export enum PosixSignal {
    SIGHUP = -1,
    SIGINT = -2,
    SIGQUIT = -3,
    SIGTERM = -4,
    SIGCHLD = -5,
    SIGCONT = -6,
    SIGWINCH = -7,
    SIGTTIN = -8,
    SIGTTOU = -9,
    SIGTSTP = -10
}


export enum RegistrationClassContext {
    inProcessServer = 1,
    inProcessHandler = 2,
    localServer = 4,
    inProcessServer16 = 8,
    remoteServer = 16,
    inProcessHandler16 = 32,
    reserved1 = 64,
    reserved2 = 128,
    reserved3 = 256,
    reserved4 = 512,
    noCodeDownload = 1024,
    reserved5 = 2048,
    noCustomMarshal = 4096,
    enableCodeDownload = 8192,
    noFailureLog = 16384,
    disableActivateAsActivator = 32768,
    enableActivateAsActivator = 65536,
    fromDefaultContext = 131072
}


export enum RegistrationConnectionType {
    singleUse = 0,
    multipleUse = 1,
    multiSeparate = 2,
    suspended = 4,
    surrogate = 8
}


export enum StringMarshalling {
    custom = 0,
    utf8 = 1,
    utf16 = 2
}


export enum TypeLibFuncFlags {
    fRestricted = 1,
    fSource = 2,
    fBindable = 4,
    fRequestEdit = 8,
    fDisplayBind = 16,
    fDefaultBind = 32,
    fHidden = 64,
    fUsesGetLastError = 128,
    fDefaultCollelem = 256,
    fUiDefault = 512,
    fNonBrowsable = 1024,
    fReplaceable = 2048,
    fImmediateBind = 4096
}


export enum TypeLibTypeFlags {
    fAppObject = 1,
    fCanCreate = 2,
    fLicensed = 4,
    fPreDeclId = 8,
    fHidden = 16,
    fControl = 32,
    fDual = 64,
    fNonExtensible = 128,
    fOleAutomation = 256,
    fRestricted = 512,
    fAggregatable = 1024,
    fReplaceable = 2048,
    fDispatchable = 4096,
    fReverseBind = 8192
}


export enum TypeLibVarFlags {
    fReadOnly = 1,
    fSource = 2,
    fBindable = 4,
    fRequestEdit = 8,
    fDisplayBind = 16,
    fDefaultBind = 32,
    fHidden = 64,
    fRestricted = 128,
    fDefaultCollelem = 256,
    fUiDefault = 512,
    fNonBrowsable = 1024,
    fReplaceable = 2048,
    fImmediateBind = 4096
}


export enum UnmanagedType {
    bool = 2,
    I1 = 3,
    U1 = 4,
    I2 = 5,
    U2 = 6,
    I4 = 7,
    U4 = 8,
    I8 = 9,
    U8 = 10,
    R4 = 11,
    R8 = 12,
    currency = 15,
    bStr = 19,
    lpStr = 20,
    lpwStr = 21,
    lptStr = 22,
    byValTStr = 23,
    iUnknown = 25,
    iDispatch = 26,
    struct = 27,
    interface_ = 28,
    safeArray = 29,
    byValArray = 30,
    sysInt = 31,
    sysUInt = 32,
    vbByRefStr = 34,
    ansiBStr = 35,
    tbStr = 36,
    variantBool = 37,
    functionPtr = 38,
    asAny = 40,
    lpArray = 42,
    lpStruct = 43,
    customMarshaler = 44,
    error = 45,
    iInspectable = 46,
    hString = 47,
    lputF8Str = 48
}


export enum VarEnum {
    VT_EMPTY = 0,
    VT_NULL = 1,
    VT_I2 = 2,
    VT_I4 = 3,
    VT_R4 = 4,
    VT_R8 = 5,
    VT_CY = 6,
    VT_DATE = 7,
    VT_BSTR = 8,
    VT_DISPATCH = 9,
    VT_ERROR = 10,
    VT_BOOL = 11,
    VT_VARIANT = 12,
    VT_UNKNOWN = 13,
    VT_DECIMAL = 14,
    VT_I1 = 16,
    VT_UI1 = 17,
    VT_UI2 = 18,
    VT_UI4 = 19,
    VT_I8 = 20,
    VT_UI8 = 21,
    VT_INT = 22,
    VT_UINT = 23,
    VT_VOID = 24,
    VT_HRESULT = 25,
    VT_PTR = 26,
    VT_SAFEARRAY = 27,
    VT_CARRAY = 28,
    VT_USERDEFINED = 29,
    VT_LPSTR = 30,
    VT_LPWSTR = 31,
    VT_RECORD = 36,
    VT_FILETIME = 64,
    VT_BLOB = 65,
    VT_STREAM = 66,
    VT_STORAGE = 67,
    VT_STREAMED_OBJECT = 68,
    VT_STORED_OBJECT = 69,
    VT_BLOB_OBJECT = 70,
    VT_CF = 71,
    VT_CLSID = 72,
    VT_VECTOR = 4096,
    VT_ARRAY = 8192,
    VT_BYREF = 16384
}


export type DllImportResolver = (libraryName: string, assembly: Assembly, searchPath: Nullable_1<DllImportSearchPath>) => nint;


export interface ICustomAdapter$instance {
    getUnderlyingObject(): unknown;
}


export type ICustomAdapter = ICustomAdapter$instance;

export interface ICustomFactory$instance {
    createInstance(serverType: Type): MarshalByRefObject;
}


export type ICustomFactory = ICustomFactory$instance;

export interface ICustomMarshaler$instance {
    cleanUpManagedData(ManagedObj: unknown): void;
    cleanUpNativeData(pNativeData: nint): void;
    getNativeDataSize(): int;
    marshalManagedToNative(ManagedObj: unknown): nint;
    marshalNativeToManaged(pNativeData: nint): unknown;
}


export type ICustomMarshaler = ICustomMarshaler$instance;

export interface ICustomQueryInterface$instance {
    getInterface(iid: { value: ref<Guid> }, ppv: { value: ref<nint> }): CustomQueryInterfaceResult;
}


export type ICustomQueryInterface = ICustomQueryInterface$instance;

export interface IDynamicInterfaceCastable$instance {
    getInterfaceImplementation(interfaceType: RuntimeTypeHandle): RuntimeTypeHandle;
    isInterfaceImplemented(interfaceType: RuntimeTypeHandle, throwIfNotImplemented: boolean): boolean;
}


export type IDynamicInterfaceCastable = IDynamicInterfaceCastable$instance;

export interface ArrayWithOffset$instance {
    equals(obj: unknown): boolean;
    equals(obj: ArrayWithOffset): boolean;
    getArray(): unknown;
    getHashCode(): int;
    getOffset(): int;
}


export const ArrayWithOffset: {
    new(array: unknown, offset: int): ArrayWithOffset$instance;
};


export interface __ArrayWithOffset$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<ArrayWithOffset>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ArrayWithOffset): boolean;
}

export type ArrayWithOffset = ArrayWithOffset$instance & __ArrayWithOffset$views;


export interface CLong$instance {
    readonly value: nint;
    equals(o: unknown): boolean;
    equals(other: CLong): boolean;
    getHashCode(): int;
    toString(): string;
}


export const CLong: {
    new(value: int): CLong$instance;
    new(value: nint): CLong$instance;
};


export interface __CLong$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CLong>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CLong): boolean;
}

export type CLong = CLong$instance & __CLong$views;


export interface ComWrappers_ComInterfaceDispatch$instance {
    vtable: nint;
}


export const ComWrappers_ComInterfaceDispatch: {
    new(): ComWrappers_ComInterfaceDispatch$instance;
    getInstance<T>(dispatchPtr: ptr<ComWrappers_ComInterfaceDispatch>): T;
};


export type ComWrappers_ComInterfaceDispatch = ComWrappers_ComInterfaceDispatch$instance;

export interface ComWrappers_ComInterfaceEntry$instance {
    IID: Guid;
    vtable: nint;
}


export const ComWrappers_ComInterfaceEntry: {
    new(): ComWrappers_ComInterfaceEntry$instance;
};


export type ComWrappers_ComInterfaceEntry = ComWrappers_ComInterfaceEntry$instance;

export interface CULong$instance {
    readonly value: nuint;
    equals(o: unknown): boolean;
    equals(other: CULong): boolean;
    getHashCode(): int;
    toString(): string;
}


export const CULong: {
    new(value: uint): CULong$instance;
    new(value: nuint): CULong$instance;
};


export interface __CULong$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CULong>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CULong): boolean;
}

export type CULong = CULong$instance & __CULong$views;


export interface GCHandle$instance {
    readonly isAllocated: boolean;
    target: unknown;
    addrOfPinnedObject(): nint;
    equals(o: unknown): boolean;
    equals(other: GCHandle): boolean;
    free(): void;
    getHashCode(): int;
}


export const GCHandle: {
    new(): GCHandle$instance;
    alloc(value: unknown, type_: GCHandleType): GCHandle;
    alloc(value: unknown): GCHandle;
    fromIntPtr(value: nint): GCHandle;
    toIntPtr(value: GCHandle): nint;
};


export interface __GCHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<GCHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: GCHandle): boolean;
}

export type GCHandle = GCHandle$instance & __GCHandle$views;


export interface GCHandle_1$instance<T> {
    readonly isAllocated: boolean;
    target: T;
    dispose(): void;
    equals(obj: unknown): boolean;
    equals(other: GCHandle_1<T>): boolean;
    getHashCode(): int;
}


export const GCHandle_1: {
    new<T>(target: T): GCHandle_1$instance<T>;
    fromIntPtr<T>(value: nint): GCHandle_1<T>;
    toIntPtr<T>(value: GCHandle_1<T>): nint;
};


export interface __GCHandle_1$views<T> {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<GCHandle_1<T>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: GCHandle_1<T>): boolean;
}

export interface GCHandle_1$instance<T> extends System_Internal.IDisposable$instance {}

export type GCHandle_1<T> = GCHandle_1$instance<T> & __GCHandle_1$views<T>;


export interface HandleRef$instance {
    readonly handle: nint;
    readonly wrapper: unknown;
}


export const HandleRef: {
    new(wrapper: unknown, handle: nint): HandleRef$instance;
    toIntPtr(value: HandleRef): nint;
};


export type HandleRef = HandleRef$instance;

export interface NFloat$instance extends IBitwiseOperators_3<NFloat, NFloat, NFloat>, IComparisonOperators_3<NFloat, NFloat, CLROf<boolean>>, IEqualityOperators_3<NFloat, NFloat, CLROf<boolean>>, IModulusOperators_3<NFloat, NFloat, NFloat>, IAdditionOperators_3<NFloat, NFloat, NFloat>, IDecrementOperators_1<NFloat>, IDivisionOperators_3<NFloat, NFloat, NFloat>, IIncrementOperators_1<NFloat>, IMultiplyOperators_3<NFloat, NFloat, NFloat>, ISubtractionOperators_3<NFloat, NFloat, NFloat>, IUnaryPlusOperators_2<NFloat, NFloat>, IUnaryNegationOperators_2<NFloat, NFloat> {
    readonly value: double;
    compareTo(obj: unknown): int;
    compareTo(other: NFloat): int;
    equals(obj: unknown): boolean;
    equals(other: NFloat): boolean;
    getHashCode(): int;
    toString(): string;
    toString(format: string): string;
    toString(provider: IFormatProvider): string;
    toString(format: string, provider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
}


export const NFloat: {
    new(value: float): NFloat$instance;
    new(value: double): NFloat$instance;
    readonly epsilon: NFloat;
    readonly maxValue: NFloat;
    readonly minValue: NFloat;
    readonly naN: NFloat;
    readonly negativeInfinity: NFloat;
    readonly positiveInfinity: NFloat;
    readonly size: int;
    readonly E: NFloat;
    readonly pi: NFloat;
    readonly tau: NFloat;
    readonly negativeZero: NFloat;
    abs(value: NFloat): NFloat;
    acos(x: NFloat): NFloat;
    acosh(x: NFloat): NFloat;
    acosPi(x: NFloat): NFloat;
    asin(x: NFloat): NFloat;
    asinh(x: NFloat): NFloat;
    asinPi(x: NFloat): NFloat;
    atan(x: NFloat): NFloat;
    atan2(y: NFloat, x: NFloat): NFloat;
    atan2Pi(y: NFloat, x: NFloat): NFloat;
    atanh(x: NFloat): NFloat;
    atanPi(x: NFloat): NFloat;
    bitDecrement(x: NFloat): NFloat;
    bitIncrement(x: NFloat): NFloat;
    cbrt(x: NFloat): NFloat;
    ceiling(x: NFloat): NFloat;
    clamp(value: NFloat, min: NFloat, max: NFloat): NFloat;
    clampNative(value: NFloat, min: NFloat, max: NFloat): NFloat;
    convertToInteger<TInteger extends IBinaryInteger_1<TInteger>>(value: NFloat): TInteger;
    convertToIntegerNative<TInteger extends IBinaryInteger_1<TInteger>>(value: NFloat): TInteger;
    copySign(value: NFloat, sign: NFloat): NFloat;
    cos(x: NFloat): NFloat;
    cosh(x: NFloat): NFloat;
    cosPi(x: NFloat): NFloat;
    createChecked<TOther extends INumberBase_1<TOther>>(value: TOther): NFloat;
    createSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): NFloat;
    createTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): NFloat;
    degreesToRadians(degrees: NFloat): NFloat;
    exp(x: NFloat): NFloat;
    exp10(x: NFloat): NFloat;
    exp10M1(x: NFloat): NFloat;
    exp2(x: NFloat): NFloat;
    exp2M1(x: NFloat): NFloat;
    expM1(x: NFloat): NFloat;
    floor(x: NFloat): NFloat;
    fusedMultiplyAdd(left: NFloat, right: NFloat, addend: NFloat): NFloat;
    hypot(x: NFloat, y: NFloat): NFloat;
    ieee754Remainder(left: NFloat, right: NFloat): NFloat;
    iLogB(x: NFloat): int;
    isEvenInteger(value: NFloat): boolean;
    isFinite(value: NFloat): boolean;
    isInfinity(value: NFloat): boolean;
    isInteger(value: NFloat): boolean;
    isNaN(value: NFloat): boolean;
    isNegative(value: NFloat): boolean;
    isNegativeInfinity(value: NFloat): boolean;
    isNormal(value: NFloat): boolean;
    isOddInteger(value: NFloat): boolean;
    isPositive(value: NFloat): boolean;
    isPositiveInfinity(value: NFloat): boolean;
    isPow2(value: NFloat): boolean;
    isRealNumber(value: NFloat): boolean;
    isSubnormal(value: NFloat): boolean;
    lerp(value1: NFloat, value2: NFloat, amount: NFloat): NFloat;
    log(x: NFloat, newBase: NFloat): NFloat;
    log(x: NFloat): NFloat;
    log10(x: NFloat): NFloat;
    log10P1(x: NFloat): NFloat;
    log2(value: NFloat): NFloat;
    log2P1(x: NFloat): NFloat;
    logP1(x: NFloat): NFloat;
    max(x: NFloat, y: NFloat): NFloat;
    maxMagnitude(x: NFloat, y: NFloat): NFloat;
    maxMagnitudeNumber(x: NFloat, y: NFloat): NFloat;
    maxNative(x: NFloat, y: NFloat): NFloat;
    maxNumber(x: NFloat, y: NFloat): NFloat;
    min(x: NFloat, y: NFloat): NFloat;
    minMagnitude(x: NFloat, y: NFloat): NFloat;
    minMagnitudeNumber(x: NFloat, y: NFloat): NFloat;
    minNative(x: NFloat, y: NFloat): NFloat;
    minNumber(x: NFloat, y: NFloat): NFloat;
    multiplyAddEstimate(left: NFloat, right: NFloat, addend: NFloat): NFloat;
    parse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style?: NumberStyles, provider?: IFormatProvider): NFloat;
    parse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider): NFloat;
    parse(s: ReadOnlySpan_1<CLROf<char>>, style?: NumberStyles, provider?: IFormatProvider): NFloat;
    parse(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): NFloat;
    parse(s: string, style: NumberStyles, provider: IFormatProvider): NFloat;
    parse(s: string, style: NumberStyles): NFloat;
    parse(s: string, provider: IFormatProvider): NFloat;
    parse(s: string): NFloat;
    pow(x: NFloat, y: NFloat): NFloat;
    radiansToDegrees(radians: NFloat): NFloat;
    reciprocalEstimate(x: NFloat): NFloat;
    reciprocalSqrtEstimate(x: NFloat): NFloat;
    rootN(x: NFloat, n: int): NFloat;
    round(x: NFloat, digits: int, mode: MidpointRounding): NFloat;
    round(x: NFloat, digits: int): NFloat;
    round(x: NFloat, mode: MidpointRounding): NFloat;
    round(x: NFloat): NFloat;
    scaleB(x: NFloat, n: int): NFloat;
    sign(value: NFloat): int;
    sin(x: NFloat): NFloat;
    sinCos(x: NFloat): ValueTuple_2<NFloat, NFloat>;
    sinCosPi(x: NFloat): ValueTuple_2<NFloat, NFloat>;
    sinh(x: NFloat): NFloat;
    sinPi(x: NFloat): NFloat;
    sqrt(x: NFloat): NFloat;
    tan(x: NFloat): NFloat;
    tanh(x: NFloat): NFloat;
    tanPi(x: NFloat): NFloat;
    truncate(x: NFloat): NFloat;
    tryParse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<NFloat> }): boolean;
    tryParse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider, result: { value: ref<NFloat> }): boolean;
    tryParse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<NFloat> }): boolean;
    tryParse(s: ReadOnlySpan_1<CLROf<char>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<NFloat> }): boolean;
    tryParse(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<NFloat> }): boolean;
    tryParse(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<NFloat> }): boolean;
    tryParse(s: string, style: NumberStyles, provider: IFormatProvider, result: { value: ref<NFloat> }): boolean;
    tryParse(s: string, provider: IFormatProvider, result: { value: ref<NFloat> }): boolean;
    tryParse(s: string, result: { value: ref<NFloat> }): boolean;
};


export interface __NFloat$views {
    As_IComparable(): System_Internal.IComparable$instance;
    As_IComparable_1(): System_Internal.IComparable_1$instance<NFloat>;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<NFloat>;
    As_IFormattable(): System_Internal.IFormattable$instance;
    As_IParsable_1(): System_Internal.IParsable_1$instance<NFloat>;
    As_ISpanParsable_1(): System_Internal.ISpanParsable_1$instance<NFloat>;
    As_IUtf8SpanFormattable(): System_Internal.IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): System_Internal.IUtf8SpanParsable_1$instance<NFloat>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<NFloat, NFloat>;
    As_IFloatingPoint_1(): System_Numerics_Internal.IFloatingPoint_1$instance<NFloat>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<NFloat>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<NFloat>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<NFloat>;
    As_IRootFunctions_1(): System_Numerics_Internal.IRootFunctions_1$instance<NFloat>;
    As_ITrigonometricFunctions_1(): System_Numerics_Internal.ITrigonometricFunctions_1$instance<NFloat>;

    // Structural method bridges for numeric interface constraints
    Equals(other: NFloat): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: import("../../System/internal/index").IFormatProvider): string;
    TryFormat(destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").CLROf<char>>, charsWritten: { value: ref<int> }, format: import("../../System/internal/index").ReadOnlySpan_1<import("../../System/internal/index").CLROf<char>>, provider: import("../../System/internal/index").IFormatProvider): boolean;
    GetExponentByteCount(): int;
    GetExponentShortestBitLength(): int;
    TryWriteExponentBigEndian(destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    WriteExponentBigEndian(destination: byte[], startIndex: int): int;
    WriteExponentBigEndian(destination: byte[]): int;
    WriteExponentBigEndian(destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").CLROf<byte>>): int;
}

export interface NFloat$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<NFloat> {}

export type NFloat = NFloat$instance & __NFloat$views;


export interface OSPlatform$instance {
    equals(other: OSPlatform): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const OSPlatform: {
    new(): OSPlatform$instance;
    readonly freeBSD: OSPlatform;
    readonly linux: OSPlatform;
    readonly OSX: OSPlatform;
    readonly windows: OSPlatform;
    create(osPlatform: string): OSPlatform;
};


export interface __OSPlatform$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<OSPlatform>;

    // Structural method bridges for numeric interface constraints
    Equals(other: OSPlatform): boolean;
}

export type OSPlatform = OSPlatform$instance & __OSPlatform$views;


export interface PinnedGCHandle_1$instance<T> {
    readonly isAllocated: boolean;
    target: T;
    dispose(): void;
    equals(obj: unknown): boolean;
    equals(other: PinnedGCHandle_1<T>): boolean;
    getAddressOfObjectData(): ptr<void>;
    getHashCode(): int;
}


export const PinnedGCHandle_1: {
    new<T>(target: T): PinnedGCHandle_1$instance<T>;
    fromIntPtr<T>(value: nint): PinnedGCHandle_1<T>;
    toIntPtr<T>(value: PinnedGCHandle_1<T>): nint;
};


export interface __PinnedGCHandle_1$views<T> {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<PinnedGCHandle_1<T>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: PinnedGCHandle_1<T>): boolean;
}

export interface PinnedGCHandle_1$instance<T> extends System_Internal.IDisposable$instance {}

export type PinnedGCHandle_1<T> = PinnedGCHandle_1$instance<T> & __PinnedGCHandle_1$views<T>;


export interface WeakGCHandle_1$instance<T> {
    readonly isAllocated: boolean;
    dispose(): void;
    equals(obj: unknown): boolean;
    equals(other: WeakGCHandle_1<T>): boolean;
    getHashCode(): int;
    setTarget(target: T): void;
    tryGetTarget(target: { value: ref<T> }): boolean;
}


export const WeakGCHandle_1: {
    new<T>(target: T, trackResurrection: boolean): WeakGCHandle_1$instance<T>;
    fromIntPtr<T>(value: nint): WeakGCHandle_1<T>;
    toIntPtr<T>(value: WeakGCHandle_1<T>): nint;
};


export interface __WeakGCHandle_1$views<T> {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<WeakGCHandle_1<T>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: WeakGCHandle_1<T>): boolean;
}

export interface WeakGCHandle_1$instance<T> extends System_Internal.IDisposable$instance {}

export type WeakGCHandle_1<T> = WeakGCHandle_1$instance<T> & __WeakGCHandle_1$views<T>;


export interface AllowReversePInvokeCallsAttribute$instance extends Attribute {
}


export const AllowReversePInvokeCallsAttribute: {
    new(): AllowReversePInvokeCallsAttribute$instance;
};


export type AllowReversePInvokeCallsAttribute = AllowReversePInvokeCallsAttribute$instance;

export interface AutomationProxyAttribute$instance extends Attribute {
    readonly value: boolean;
}


export const AutomationProxyAttribute: {
    new(val: boolean): AutomationProxyAttribute$instance;
};


export type AutomationProxyAttribute = AutomationProxyAttribute$instance;

export interface BestFitMappingAttribute$instance extends Attribute {
    throwOnUnmappableChar: boolean;
    readonly bestFitMapping: boolean;
}


export const BestFitMappingAttribute: {
    new(BestFitMapping: boolean): BestFitMappingAttribute$instance;
};


export type BestFitMappingAttribute = BestFitMappingAttribute$instance;

export interface BStrWrapper$instance {
    readonly wrappedObject: string;
}


export const BStrWrapper: {
    new(value: string): BStrWrapper$instance;
    new(value: unknown): BStrWrapper$instance;
};


export type BStrWrapper = BStrWrapper$instance;

export interface ClassInterfaceAttribute$instance extends Attribute {
    readonly value: ClassInterfaceType;
}


export const ClassInterfaceAttribute: {
    new(classInterfaceType: ClassInterfaceType): ClassInterfaceAttribute$instance;
    new(classInterfaceType: short): ClassInterfaceAttribute$instance;
};


export type ClassInterfaceAttribute = ClassInterfaceAttribute$instance;

export interface CoClassAttribute$instance extends Attribute {
    readonly coClass: Type;
}


export const CoClassAttribute: {
    new(coClass: Type): CoClassAttribute$instance;
};


export type CoClassAttribute = CoClassAttribute$instance;

export interface ComAliasNameAttribute$instance extends Attribute {
    readonly value: string;
}


export const ComAliasNameAttribute: {
    new(alias: string): ComAliasNameAttribute$instance;
};


export type ComAliasNameAttribute = ComAliasNameAttribute$instance;

export interface ComAwareEventInfo$instance extends EventInfo {
    readonly attributes: EventAttributes;
    readonly declaringType: Type;
    readonly metadataToken: int;
    readonly module_: Module;
    readonly name: string;
    readonly reflectedType: Type;
    addEventHandler(target: unknown, handler: Function): void;
    getAddMethod(nonPublic: boolean): MethodInfo;
    getAddMethod(): MethodInfo;
    getCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getCustomAttributes(inherit: boolean): unknown[];
    getCustomAttributesData(): IList_1<CustomAttributeData>;
    getCustomAttributesData(): IList_1<CustomAttributeData>;
    getOtherMethods(nonPublic: boolean): MethodInfo[];
    getOtherMethods(): MethodInfo[];
    getRaiseMethod(nonPublic: boolean): MethodInfo;
    getRaiseMethod(): MethodInfo;
    getRemoveMethod(nonPublic: boolean): MethodInfo;
    getRemoveMethod(): MethodInfo;
    isDefined(attributeType: Type, inherit: boolean): boolean;
    removeEventHandler(target: unknown, handler: Function): void;
}


export const ComAwareEventInfo: {
    new(type_: Type, eventName: string): ComAwareEventInfo$instance;
};


export interface __ComAwareEventInfo$views {
    As_ICustomAttributeProvider(): System_Reflection_Internal.ICustomAttributeProvider$instance;
}

export type ComAwareEventInfo = ComAwareEventInfo$instance & __ComAwareEventInfo$views;


export interface ComCompatibleVersionAttribute$instance extends Attribute {
    readonly buildNumber: int;
    readonly majorVersion: int;
    readonly minorVersion: int;
    readonly revisionNumber: int;
}


export const ComCompatibleVersionAttribute: {
    new(major: int, minor: int, build: int, revision: int): ComCompatibleVersionAttribute$instance;
};


export type ComCompatibleVersionAttribute = ComCompatibleVersionAttribute$instance;

export interface ComConversionLossAttribute$instance extends Attribute {
}


export const ComConversionLossAttribute: {
    new(): ComConversionLossAttribute$instance;
};


export type ComConversionLossAttribute = ComConversionLossAttribute$instance;

export interface ComDefaultInterfaceAttribute$instance extends Attribute {
    readonly value: Type;
}


export const ComDefaultInterfaceAttribute: {
    new(defaultInterface: Type): ComDefaultInterfaceAttribute$instance;
};


export type ComDefaultInterfaceAttribute = ComDefaultInterfaceAttribute$instance;

export interface ComEventInterfaceAttribute$instance extends Attribute {
    readonly eventProvider: Type;
    readonly sourceInterface: Type;
}


export const ComEventInterfaceAttribute: {
    new(SourceInterface: Type, EventProvider: Type): ComEventInterfaceAttribute$instance;
};


export type ComEventInterfaceAttribute = ComEventInterfaceAttribute$instance;

export interface COMException$instance extends ExternalException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    toString(): string;
}


export const COMException: {
    new(): COMException$instance;
    new(message: string): COMException$instance;
    new(message: string, inner: Exception): COMException$instance;
    new(message: string, errorCode: int): COMException$instance;
};


export interface __COMException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type COMException = COMException$instance & __COMException$views;


export interface ComImportAttribute$instance extends Attribute {
}


export const ComImportAttribute: {
    new(): ComImportAttribute$instance;
};


export type ComImportAttribute = ComImportAttribute$instance;

export interface ComRegisterFunctionAttribute$instance extends Attribute {
}


export const ComRegisterFunctionAttribute: {
    new(): ComRegisterFunctionAttribute$instance;
};


export type ComRegisterFunctionAttribute = ComRegisterFunctionAttribute$instance;

export interface ComSourceInterfacesAttribute$instance extends Attribute {
    readonly value: string;
}


export const ComSourceInterfacesAttribute: {
    new(sourceInterfaces: string): ComSourceInterfacesAttribute$instance;
    new(sourceInterface: Type): ComSourceInterfacesAttribute$instance;
    new(sourceInterface1: Type, sourceInterface2: Type): ComSourceInterfacesAttribute$instance;
    new(sourceInterface1: Type, sourceInterface2: Type, sourceInterface3: Type): ComSourceInterfacesAttribute$instance;
    new(sourceInterface1: Type, sourceInterface2: Type, sourceInterface3: Type, sourceInterface4: Type): ComSourceInterfacesAttribute$instance;
};


export type ComSourceInterfacesAttribute = ComSourceInterfacesAttribute$instance;

export interface ComUnregisterFunctionAttribute$instance extends Attribute {
}


export const ComUnregisterFunctionAttribute: {
    new(): ComUnregisterFunctionAttribute$instance;
};


export type ComUnregisterFunctionAttribute = ComUnregisterFunctionAttribute$instance;

export interface ComVisibleAttribute$instance extends Attribute {
    readonly value: boolean;
}


export const ComVisibleAttribute: {
    new(visibility: boolean): ComVisibleAttribute$instance;
};


export type ComVisibleAttribute = ComVisibleAttribute$instance;

export interface ComWrappers$instance {
    getOrCreateComInterfaceForObject(instance: unknown, flags: CreateComInterfaceFlags): nint;
    getOrCreateObjectForComInstance(externalComObject: nint, flags: CreateObjectFlags): unknown;
    getOrCreateObjectForComInstance(externalComObject: nint, flags: CreateObjectFlags, userState: unknown): unknown;
    getOrRegisterObjectForComInstance(externalComObject: nint, flags: CreateObjectFlags, wrapper: unknown): unknown;
    getOrRegisterObjectForComInstance(externalComObject: nint, flags: CreateObjectFlags, wrapper: unknown, inner: nint): unknown;
}


export const ComWrappers: {
    getIUnknownImpl(fpQueryInterface: { value: ref<nint> }, fpAddRef: { value: ref<nint> }, fpRelease: { value: ref<nint> }): void;
    registerForMarshalling(instance: ComWrappers): void;
    registerForTrackerSupport(instance: ComWrappers): void;
    tryGetComInstance(obj: unknown, unknown_: { value: ref<nint> }): boolean;
    tryGetObject(unknown_: nint, obj: { value: ref<unknown> }): boolean;
};


export type ComWrappers = ComWrappers$instance;

export interface CriticalHandle$instance extends CriticalFinalizerObject {
    readonly isClosed: boolean;
    readonly isInvalid: boolean;
    close(): void;
    dispose(): void;
    setHandleAsInvalid(): void;
}


export const CriticalHandle: {
};


export interface __CriticalHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface CriticalHandle$instance extends System_Internal.IDisposable$instance {}

export type CriticalHandle = CriticalHandle$instance & __CriticalHandle$views;


export interface CurrencyWrapper$instance {
    readonly wrappedObject: decimal;
}


export const CurrencyWrapper: {
    new(obj: decimal): CurrencyWrapper$instance;
    new(obj: unknown): CurrencyWrapper$instance;
};


export type CurrencyWrapper = CurrencyWrapper$instance;

export interface DefaultCharSetAttribute$instance extends Attribute {
    readonly charSet: CharSet;
}


export const DefaultCharSetAttribute: {
    new(charSet: CharSet): DefaultCharSetAttribute$instance;
};


export type DefaultCharSetAttribute = DefaultCharSetAttribute$instance;

export interface DefaultDllImportSearchPathsAttribute$instance extends Attribute {
    readonly paths: DllImportSearchPath;
}


export const DefaultDllImportSearchPathsAttribute: {
    new(paths: DllImportSearchPath): DefaultDllImportSearchPathsAttribute$instance;
};


export type DefaultDllImportSearchPathsAttribute = DefaultDllImportSearchPathsAttribute$instance;

export interface DefaultParameterValueAttribute$instance extends Attribute {
    readonly value: unknown;
}


export const DefaultParameterValueAttribute: {
    new(value: unknown): DefaultParameterValueAttribute$instance;
};


export type DefaultParameterValueAttribute = DefaultParameterValueAttribute$instance;

export interface DispatchWrapper$instance {
    readonly wrappedObject: unknown;
}


export const DispatchWrapper: {
    new(obj: unknown): DispatchWrapper$instance;
};


export type DispatchWrapper = DispatchWrapper$instance;

export interface DispIdAttribute$instance extends Attribute {
    readonly value: int;
}


export const DispIdAttribute: {
    new(dispId: int): DispIdAttribute$instance;
};


export type DispIdAttribute = DispIdAttribute$instance;

export interface DllImportAttribute$instance extends Attribute {
    entryPoint: string;
    charSet: CharSet;
    setLastError: boolean;
    exactSpelling: boolean;
    callingConvention: CallingConvention;
    bestFitMapping: boolean;
    preserveSig: boolean;
    throwOnUnmappableChar: boolean;
    readonly value: string;
}


export const DllImportAttribute: {
    new(dllName: string): DllImportAttribute$instance;
};


export type DllImportAttribute = DllImportAttribute$instance;

export interface DynamicInterfaceCastableImplementationAttribute$instance extends Attribute {
}


export const DynamicInterfaceCastableImplementationAttribute: {
    new(): DynamicInterfaceCastableImplementationAttribute$instance;
};


export type DynamicInterfaceCastableImplementationAttribute = DynamicInterfaceCastableImplementationAttribute$instance;

export interface ErrorWrapper$instance {
    readonly errorCode: int;
}


export const ErrorWrapper: {
    new(errorCode: int): ErrorWrapper$instance;
    new(errorCode: unknown): ErrorWrapper$instance;
    new(e: Exception): ErrorWrapper$instance;
};


export type ErrorWrapper = ErrorWrapper$instance;

export interface ExternalException$instance extends SystemException {
    readonly errorCode: int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    toString(): string;
}


export const ExternalException: {
    new(): ExternalException$instance;
    new(message: string): ExternalException$instance;
    new(message: string, inner: Exception): ExternalException$instance;
    new(message: string, errorCode: int): ExternalException$instance;
};


export interface __ExternalException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ExternalException = ExternalException$instance & __ExternalException$views;


export interface FieldOffsetAttribute$instance extends Attribute {
    readonly value: int;
}


export const FieldOffsetAttribute: {
    new(offset: int): FieldOffsetAttribute$instance;
};


export type FieldOffsetAttribute = FieldOffsetAttribute$instance;

export interface GuidAttribute$instance extends Attribute {
    readonly value: string;
}


export const GuidAttribute: {
    new(guid: string): GuidAttribute$instance;
};


export type GuidAttribute = GuidAttribute$instance;

export interface HandleCollector$instance {
    readonly count: int;
    readonly initialThreshold: int;
    readonly maximumThreshold: int;
    readonly name: string;
    add(): void;
    remove(): void;
}


export const HandleCollector: {
    new(name: string, initialThreshold: int): HandleCollector$instance;
    new(name: string, initialThreshold: int, maximumThreshold: int): HandleCollector$instance;
};


export type HandleCollector = HandleCollector$instance;

export interface ImportedFromTypeLibAttribute$instance extends Attribute {
    readonly value: string;
}


export const ImportedFromTypeLibAttribute: {
    new(tlbFile: string): ImportedFromTypeLibAttribute$instance;
};


export type ImportedFromTypeLibAttribute = ImportedFromTypeLibAttribute$instance;

export interface InAttribute$instance extends Attribute {
}


export const InAttribute: {
    new(): InAttribute$instance;
};


export type InAttribute = InAttribute$instance;

export interface InterfaceTypeAttribute$instance extends Attribute {
    readonly value: ComInterfaceType;
}


export const InterfaceTypeAttribute: {
    new(interfaceType: ComInterfaceType): InterfaceTypeAttribute$instance;
    new(interfaceType: short): InterfaceTypeAttribute$instance;
};


export type InterfaceTypeAttribute = InterfaceTypeAttribute$instance;

export interface InvalidComObjectException$instance extends SystemException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const InvalidComObjectException: {
    new(): InvalidComObjectException$instance;
    new(message: string): InvalidComObjectException$instance;
    new(message: string, inner: Exception): InvalidComObjectException$instance;
};


export interface __InvalidComObjectException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidComObjectException = InvalidComObjectException$instance & __InvalidComObjectException$views;


export interface InvalidOleVariantTypeException$instance extends SystemException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const InvalidOleVariantTypeException: {
    new(): InvalidOleVariantTypeException$instance;
    new(message: string): InvalidOleVariantTypeException$instance;
    new(message: string, inner: Exception): InvalidOleVariantTypeException$instance;
};


export interface __InvalidOleVariantTypeException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidOleVariantTypeException = InvalidOleVariantTypeException$instance & __InvalidOleVariantTypeException$views;


export interface LCIDConversionAttribute$instance extends Attribute {
    readonly value: int;
}


export const LCIDConversionAttribute: {
    new(lcid: int): LCIDConversionAttribute$instance;
};


export type LCIDConversionAttribute = LCIDConversionAttribute$instance;

export interface LibraryImportAttribute$instance extends Attribute {
    entryPoint: string;
    readonly libraryName: string;
    setLastError: boolean;
    stringMarshalling: StringMarshalling;
    stringMarshallingCustomType: Type;
}


export const LibraryImportAttribute: {
    new(libraryName: string): LibraryImportAttribute$instance;
};


export type LibraryImportAttribute = LibraryImportAttribute$instance;

export interface ManagedToNativeComInteropStubAttribute$instance extends Attribute {
    readonly classType: Type;
    readonly methodName: string;
}


export const ManagedToNativeComInteropStubAttribute: {
    new(classType: Type, methodName: string): ManagedToNativeComInteropStubAttribute$instance;
};


export type ManagedToNativeComInteropStubAttribute = ManagedToNativeComInteropStubAttribute$instance;

export interface MarshalAsAttribute$instance extends Attribute {
    safeArraySubType: VarEnum;
    safeArrayUserDefinedSubType: Type;
    iidParameterIndex: int;
    arraySubType: UnmanagedType;
    sizeParamIndex: short;
    sizeConst: int;
    marshalType: string;
    marshalTypeRef: Type;
    marshalCookie: string;
    readonly value: UnmanagedType;
}


export const MarshalAsAttribute: {
    new(unmanagedType: UnmanagedType): MarshalAsAttribute$instance;
    new(unmanagedType: short): MarshalAsAttribute$instance;
};


export type MarshalAsAttribute = MarshalAsAttribute$instance;

export interface MarshalDirectiveException$instance extends SystemException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const MarshalDirectiveException: {
    new(): MarshalDirectiveException$instance;
    new(message: string): MarshalDirectiveException$instance;
    new(message: string, inner: Exception): MarshalDirectiveException$instance;
};


export interface __MarshalDirectiveException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MarshalDirectiveException = MarshalDirectiveException$instance & __MarshalDirectiveException$views;


export interface OptionalAttribute$instance extends Attribute {
}


export const OptionalAttribute: {
    new(): OptionalAttribute$instance;
};


export type OptionalAttribute = OptionalAttribute$instance;

export interface OutAttribute$instance extends Attribute {
}


export const OutAttribute: {
    new(): OutAttribute$instance;
};


export type OutAttribute = OutAttribute$instance;

export interface PosixSignalContext$instance {
    cancel: boolean;
    readonly signal: PosixSignal;
}


export const PosixSignalContext: {
    new(signal: PosixSignal): PosixSignalContext$instance;
};


export type PosixSignalContext = PosixSignalContext$instance;

export interface PosixSignalRegistration$instance {
    dispose(): void;
}


export const PosixSignalRegistration: {
    new(): PosixSignalRegistration$instance;
    create(signal: PosixSignal, handler: Action_1<PosixSignalContext>): PosixSignalRegistration;
};


export interface __PosixSignalRegistration$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface PosixSignalRegistration$instance extends System_Internal.IDisposable$instance {}

export type PosixSignalRegistration = PosixSignalRegistration$instance & __PosixSignalRegistration$views;


export interface PreserveSigAttribute$instance extends Attribute {
}


export const PreserveSigAttribute: {
    new(): PreserveSigAttribute$instance;
};


export type PreserveSigAttribute = PreserveSigAttribute$instance;

export interface PrimaryInteropAssemblyAttribute$instance extends Attribute {
    readonly majorVersion: int;
    readonly minorVersion: int;
}


export const PrimaryInteropAssemblyAttribute: {
    new(major: int, minor: int): PrimaryInteropAssemblyAttribute$instance;
};


export type PrimaryInteropAssemblyAttribute = PrimaryInteropAssemblyAttribute$instance;

export interface ProgIdAttribute$instance extends Attribute {
    readonly value: string;
}


export const ProgIdAttribute: {
    new(progId: string): ProgIdAttribute$instance;
};


export type ProgIdAttribute = ProgIdAttribute$instance;

export interface SafeArrayRankMismatchException$instance extends SystemException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SafeArrayRankMismatchException: {
    new(): SafeArrayRankMismatchException$instance;
    new(message: string): SafeArrayRankMismatchException$instance;
    new(message: string, inner: Exception): SafeArrayRankMismatchException$instance;
};


export interface __SafeArrayRankMismatchException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SafeArrayRankMismatchException = SafeArrayRankMismatchException$instance & __SafeArrayRankMismatchException$views;


export interface SafeArrayTypeMismatchException$instance extends SystemException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SafeArrayTypeMismatchException: {
    new(): SafeArrayTypeMismatchException$instance;
    new(message: string): SafeArrayTypeMismatchException$instance;
    new(message: string, inner: Exception): SafeArrayTypeMismatchException$instance;
};


export interface __SafeArrayTypeMismatchException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SafeArrayTypeMismatchException = SafeArrayTypeMismatchException$instance & __SafeArrayTypeMismatchException$views;


export interface SafeBuffer$instance extends SafeHandleZeroOrMinusOneIsInvalid {
    readonly byteLength: ulong;
    acquirePointer(pointer: { value: ref<ptr<byte>> }): void;
    dispose(): void;
    initialize(numBytes: ulong): void;
    initialize(numElements: uint, sizeOfEachElement: uint): void;
    initialize<T extends unknown>(numElements: uint): void;
    read<T extends unknown>(byteOffset: ulong): T;
    readArray<T extends unknown>(byteOffset: ulong, array: T[], index: int, count: int): void;
    readSpan<T extends unknown>(byteOffset: ulong, buffer: Span_1<T>): void;
    releasePointer(): void;
    write<T extends unknown>(byteOffset: ulong, value: T): void;
    writeArray<T extends unknown>(byteOffset: ulong, array: T[], index: int, count: int): void;
    writeSpan<T extends unknown>(byteOffset: ulong, data: ReadOnlySpan_1<T>): void;
}


export const SafeBuffer: {
};


export interface __SafeBuffer$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type SafeBuffer = SafeBuffer$instance & __SafeBuffer$views;


export interface SafeHandle$instance extends CriticalFinalizerObject {
    readonly isClosed: boolean;
    readonly isInvalid: boolean;
    close(): void;
    dangerousAddRef(success: { value: ref<boolean> }): void;
    dangerousGetHandle(): nint;
    dangerousRelease(): void;
    dispose(): void;
    setHandleAsInvalid(): void;
}


export const SafeHandle: {
};


export interface __SafeHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface SafeHandle$instance extends System_Internal.IDisposable$instance {}

export type SafeHandle = SafeHandle$instance & __SafeHandle$views;


export interface SEHException$instance extends ExternalException$instance {
    canResume(): boolean;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SEHException: {
    new(): SEHException$instance;
    new(message: string): SEHException$instance;
    new(message: string, inner: Exception): SEHException$instance;
};


export interface __SEHException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SEHException = SEHException$instance & __SEHException$views;


export interface StandardOleMarshalObject$instance extends MarshalByRefObject {
}


export const StandardOleMarshalObject: {
    new(): StandardOleMarshalObject$instance;
};


export type StandardOleMarshalObject = StandardOleMarshalObject$instance;

export interface StructLayoutAttribute$instance extends Attribute {
    pack: int;
    size: int;
    charSet: CharSet;
    readonly value: LayoutKind;
}


export const StructLayoutAttribute: {
    new(layoutKind: LayoutKind): StructLayoutAttribute$instance;
    new(layoutKind: short): StructLayoutAttribute$instance;
};


export type StructLayoutAttribute = StructLayoutAttribute$instance;

export interface SuppressGCTransitionAttribute$instance extends Attribute {
}


export const SuppressGCTransitionAttribute: {
    new(): SuppressGCTransitionAttribute$instance;
};


export type SuppressGCTransitionAttribute = SuppressGCTransitionAttribute$instance;

export interface TypeIdentifierAttribute$instance extends Attribute {
    readonly identifier: string;
    readonly scope: string;
}


export const TypeIdentifierAttribute: {
    new(): TypeIdentifierAttribute$instance;
    new(scope: string, identifier: string): TypeIdentifierAttribute$instance;
};


export type TypeIdentifierAttribute = TypeIdentifierAttribute$instance;

export interface TypeLibFuncAttribute$instance extends Attribute {
    readonly value: TypeLibFuncFlags;
}


export const TypeLibFuncAttribute: {
    new(flags: TypeLibFuncFlags): TypeLibFuncAttribute$instance;
    new(flags: short): TypeLibFuncAttribute$instance;
};


export type TypeLibFuncAttribute = TypeLibFuncAttribute$instance;

export interface TypeLibImportClassAttribute$instance extends Attribute {
    readonly value: string;
}


export const TypeLibImportClassAttribute: {
    new(importClass: Type): TypeLibImportClassAttribute$instance;
};


export type TypeLibImportClassAttribute = TypeLibImportClassAttribute$instance;

export interface TypeLibTypeAttribute$instance extends Attribute {
    readonly value: TypeLibTypeFlags;
}


export const TypeLibTypeAttribute: {
    new(flags: TypeLibTypeFlags): TypeLibTypeAttribute$instance;
    new(flags: short): TypeLibTypeAttribute$instance;
};


export type TypeLibTypeAttribute = TypeLibTypeAttribute$instance;

export interface TypeLibVarAttribute$instance extends Attribute {
    readonly value: TypeLibVarFlags;
}


export const TypeLibVarAttribute: {
    new(flags: TypeLibVarFlags): TypeLibVarAttribute$instance;
    new(flags: short): TypeLibVarAttribute$instance;
};


export type TypeLibVarAttribute = TypeLibVarAttribute$instance;

export interface TypeLibVersionAttribute$instance extends Attribute {
    readonly majorVersion: int;
    readonly minorVersion: int;
}


export const TypeLibVersionAttribute: {
    new(major: int, minor: int): TypeLibVersionAttribute$instance;
};


export type TypeLibVersionAttribute = TypeLibVersionAttribute$instance;

export interface TypeMapAssemblyTargetAttribute_1$instance<TTypeMapGroup> extends Attribute {
}


export const TypeMapAssemblyTargetAttribute_1: {
    new<TTypeMapGroup>(assemblyName: string): TypeMapAssemblyTargetAttribute_1$instance<TTypeMapGroup>;
};


export type TypeMapAssemblyTargetAttribute_1<TTypeMapGroup> = TypeMapAssemblyTargetAttribute_1$instance<TTypeMapGroup>;

export interface TypeMapAssociationAttribute_1$instance<TTypeMapGroup> extends Attribute {
}


export const TypeMapAssociationAttribute_1: {
    new<TTypeMapGroup>(source: Type, proxy: Type): TypeMapAssociationAttribute_1$instance<TTypeMapGroup>;
};


export type TypeMapAssociationAttribute_1<TTypeMapGroup> = TypeMapAssociationAttribute_1$instance<TTypeMapGroup>;

export interface TypeMapAttribute_1$instance<TTypeMapGroup> extends Attribute {
}


export const TypeMapAttribute_1: {
    new<TTypeMapGroup>(value: string, target: Type): TypeMapAttribute_1$instance<TTypeMapGroup>;
    new<TTypeMapGroup>(value: string, target: Type, trimTarget: Type): TypeMapAttribute_1$instance<TTypeMapGroup>;
};


export type TypeMapAttribute_1<TTypeMapGroup> = TypeMapAttribute_1$instance<TTypeMapGroup>;

export interface UnknownWrapper$instance {
    readonly wrappedObject: unknown;
}


export const UnknownWrapper: {
    new(obj: unknown): UnknownWrapper$instance;
};


export type UnknownWrapper = UnknownWrapper$instance;

export interface UnmanagedCallConvAttribute$instance extends Attribute {
    callConvs: Type[];
}


export const UnmanagedCallConvAttribute: {
    new(): UnmanagedCallConvAttribute$instance;
};


export type UnmanagedCallConvAttribute = UnmanagedCallConvAttribute$instance;

export interface UnmanagedCallersOnlyAttribute$instance extends Attribute {
    callConvs: Type[];
    entryPoint: string;
}


export const UnmanagedCallersOnlyAttribute: {
    new(): UnmanagedCallersOnlyAttribute$instance;
};


export type UnmanagedCallersOnlyAttribute = UnmanagedCallersOnlyAttribute$instance;

export interface UnmanagedFunctionPointerAttribute$instance extends Attribute {
    bestFitMapping: boolean;
    setLastError: boolean;
    throwOnUnmappableChar: boolean;
    charSet: CharSet;
    readonly callingConvention: CallingConvention;
}


export const UnmanagedFunctionPointerAttribute: {
    new(callingConvention: CallingConvention): UnmanagedFunctionPointerAttribute$instance;
};


export type UnmanagedFunctionPointerAttribute = UnmanagedFunctionPointerAttribute$instance;

export interface VariantWrapper$instance {
    readonly wrappedObject: unknown;
}


export const VariantWrapper: {
    new(obj: unknown): VariantWrapper$instance;
};


export type VariantWrapper = VariantWrapper$instance;

export interface WasmImportLinkageAttribute$instance extends Attribute {
}


export const WasmImportLinkageAttribute: {
    new(): WasmImportLinkageAttribute$instance;
};


export type WasmImportLinkageAttribute = WasmImportLinkageAttribute$instance;

export abstract class CollectionsMarshal$instance {
    static asBytes(array: BitArray): Span_1<CLROf<byte>>;
    static asSpan<T>(list: List_1<T>): Span_1<T>;
    static getValueRefOrAddDefault<TKey, TValue, TAlternateKey>(dictionary: Dictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>, key: TAlternateKey, exists: { value: ref<boolean> }): ref<TValue>;
    static getValueRefOrAddDefault<TKey, TValue>(dictionary: Dictionary_2<TKey, TValue>, key: TKey, exists: { value: ref<boolean> }): ref<TValue>;
    static getValueRefOrNullRef<TKey, TValue, TAlternateKey>(dictionary: Dictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>, key: TAlternateKey): ref<TValue>;
    static getValueRefOrNullRef<TKey, TValue>(dictionary: Dictionary_2<TKey, TValue>, key: TKey): ref<TValue>;
    static setCount<T>(list: List_1<T>, count: int): void;
}


export type CollectionsMarshal = CollectionsMarshal$instance;

export abstract class ComEventsHelper$instance {
    static combine(rcw: unknown, iid: Guid, dispid: int, d: Function): void;
    static remove(rcw: unknown, iid: Guid, dispid: int, d: Function): Function;
}


export type ComEventsHelper = ComEventsHelper$instance;

export abstract class GCHandleExtensions$instance {
    static getAddressOfArrayData<T>(handle: PinnedGCHandle_1<T[]>): ptr<T>;
    static getAddressOfStringData(handle: PinnedGCHandle_1<CLROf<string>>): ptr<char>;
}


export type GCHandleExtensions = GCHandleExtensions$instance;

export abstract class ImmutableCollectionsMarshal$instance {
    static asArray<T>(array: ImmutableArray_1<T>): T[];
    static asImmutableArray<T>(array: T[]): ImmutableArray_1<T>;
    static asMemory<T>(builder: ImmutableArray_1_Builder<T>): Memory_1<T>;
}


export type ImmutableCollectionsMarshal = ImmutableCollectionsMarshal$instance;

export abstract class JsonMarshal$instance {
    static getRawUtf8PropertyName(property: JsonProperty): ReadOnlySpan_1<CLROf<byte>>;
    static getRawUtf8Value(element: JsonElement): ReadOnlySpan_1<CLROf<byte>>;
}


export type JsonMarshal = JsonMarshal$instance;

export abstract class Marshal$instance {
    static readonly systemDefaultCharSize: int;
    static readonly systemMaxDBCSCharSize: int;
    static addRef(pUnk: nint): int;
    static allocCoTaskMem(cb: int): nint;
    static allocHGlobal(cb: int): nint;
    static allocHGlobal(cb: nint): nint;
    static areComObjectsAvailableForCleanup(): boolean;
    static bindToMoniker(monikerName: string): unknown;
    static changeWrapperHandleStrength(otp: unknown, fIsWeak: boolean): void;
    static cleanupUnusedObjectsInCurrentContext(): void;
    static copy(source: byte[], startIndex: int, destination: nint, length: int): void;
    static copy(source: char[], startIndex: int, destination: nint, length: int): void;
    static copy(source: double[], startIndex: int, destination: nint, length: int): void;
    static copy(source: short[], startIndex: int, destination: nint, length: int): void;
    static copy(source: int[], startIndex: int, destination: nint, length: int): void;
    static copy(source: long[], startIndex: int, destination: nint, length: int): void;
    static copy(source: nint, destination: byte[], startIndex: int, length: int): void;
    static copy(source: nint, destination: char[], startIndex: int, length: int): void;
    static copy(source: nint, destination: double[], startIndex: int, length: int): void;
    static copy(source: nint, destination: short[], startIndex: int, length: int): void;
    static copy(source: nint, destination: int[], startIndex: int, length: int): void;
    static copy(source: nint, destination: long[], startIndex: int, length: int): void;
    static copy(source: nint, destination: nint[], startIndex: int, length: int): void;
    static copy(source: nint, destination: float[], startIndex: int, length: int): void;
    static copy(source: nint[], startIndex: int, destination: nint, length: int): void;
    static copy(source: float[], startIndex: int, destination: nint, length: int): void;
    static createAggregatedObject(pOuter: nint, o: unknown): nint;
    static createAggregatedObject<T>(pOuter: nint, o: T): nint;
    static createWrapperOfType(o: unknown, t: Type): unknown;
    static createWrapperOfType<T, TWrapper>(o: T): TWrapper;
    static destroyStructure(ptr: nint, structuretype: Type): void;
    static destroyStructure<T>(ptr: nint): void;
    static finalReleaseComObject(o: unknown): int;
    static freeBSTR(ptr: nint): void;
    static freeCoTaskMem(ptr: nint): void;
    static freeHGlobal(hglobal: nint): void;
    static generateGuidForType(type_: Type): Guid;
    static generateProgIdForType(type_: Type): string;
    static getComInterfaceForObject(o: unknown, T: Type, mode: CustomQueryInterfaceMode): nint;
    static getComInterfaceForObject(o: unknown, T: Type): nint;
    static getComInterfaceForObject<T, TInterface>(o: T): nint;
    static getComObjectData(obj: unknown, key: unknown): unknown;
    static getDelegateForFunctionPointer(ptr: nint, t: Type): Function;
    static getDelegateForFunctionPointer<TDelegate>(ptr: nint): TDelegate;
    static getEndComSlot(t: Type): int;
    static getExceptionCode(): int;
    static getExceptionForHR(errorCode: int, iid: { value: ref<Guid> }, pUnk: nint): Exception;
    static getExceptionForHR(errorCode: int, errorInfo: nint): Exception;
    static getExceptionForHR(errorCode: int): Exception;
    static getExceptionPointers(): nint;
    static getFunctionPointerForDelegate(d: Function): nint;
    static getFunctionPointerForDelegate<TDelegate>(d: TDelegate): nint;
    static getHINSTANCE(m: Module): nint;
    static getHRForException(e: Exception): int;
    static getHRForLastWin32Error(): int;
    static getIDispatchForObject(o: unknown): nint;
    static getIUnknownForObject(o: unknown): nint;
    static getLastPInvokeError(): int;
    static getLastPInvokeErrorMessage(): string;
    static getLastSystemError(): int;
    static getLastWin32Error(): int;
    static getNativeVariantForObject(obj: unknown, pDstNativeVariant: nint): void;
    static getNativeVariantForObject<T>(obj: T, pDstNativeVariant: nint): void;
    static getObjectForIUnknown(pUnk: nint): unknown;
    static getObjectForNativeVariant(pSrcNativeVariant: nint): unknown;
    static getObjectForNativeVariant<T>(pSrcNativeVariant: nint): T;
    static getObjectsForNativeVariants(aSrcNativeVariant: nint, cVars: int): unknown[];
    static getObjectsForNativeVariants<T>(aSrcNativeVariant: nint, cVars: int): T[];
    static getPInvokeErrorMessage(error: int): string;
    static getStartComSlot(t: Type): int;
    static getTypedObjectForIUnknown(pUnk: nint, t: Type): unknown;
    static getTypeFromCLSID(clsid: Guid): Type;
    static getTypeInfoName(typeInfo: ITypeInfo): string;
    static getUniqueObjectForIUnknown(unknown_: nint): unknown;
    static initHandle(safeHandle: SafeHandle, handle: nint): void;
    static isComObject(o: unknown): boolean;
    static isTypeVisibleFromCom(t: Type): boolean;
    static offsetOf<T>(fieldName: string): nint;
    static offsetOf(t: Type, fieldName: string): nint;
    static prelink(m: MethodInfo): void;
    static prelinkAll(c: Type): void;
    static ptrToStringAnsi(ptr: nint, len: int): string;
    static ptrToStringAnsi(ptr: nint): string;
    static ptrToStringAuto(ptr: nint, len: int): string;
    static ptrToStringAuto(ptr: nint): string;
    static ptrToStringBSTR(ptr: nint): string;
    static ptrToStringUni(ptr: nint, len: int): string;
    static ptrToStringUni(ptr: nint): string;
    static ptrToStringUTF8(ptr: nint, byteLen: int): string;
    static ptrToStringUTF8(ptr: nint): string;
    static ptrToStructure(ptr: nint, structure: unknown): void;
    static ptrToStructure(ptr: nint, structureType: Type): unknown;
    static ptrToStructure<T>(ptr: nint, structure: T): void;
    static ptrToStructure<T>(ptr: nint): T;
    static queryInterface(pUnk: nint, iid: { value: ref<Guid> }, ppv: { value: ref<nint> }): int;
    static readByte(ptr: nint, ofs: int): byte;
    static readByte(ptr: nint): byte;
    static readByte(ptr: unknown, ofs: int): byte;
    static readInt16(ptr: nint, ofs: int): short;
    static readInt16(ptr: nint): short;
    static readInt16(ptr: unknown, ofs: int): short;
    static readInt32(ptr: nint, ofs: int): int;
    static readInt32(ptr: nint): int;
    static readInt32(ptr: unknown, ofs: int): int;
    static readInt64(ptr: nint, ofs: int): long;
    static readInt64(ptr: nint): long;
    static readInt64(ptr: unknown, ofs: int): long;
    static readIntPtr(ptr: nint, ofs: int): nint;
    static readIntPtr(ptr: nint): nint;
    static readIntPtr(ptr: unknown, ofs: int): nint;
    static reAllocCoTaskMem(pv: nint, cb: int): nint;
    static reAllocHGlobal(pv: nint, cb: nint): nint;
    static release(pUnk: nint): int;
    static releaseComObject(o: unknown): int;
    static secureStringToBSTR(s: SecureString): nint;
    static secureStringToCoTaskMemAnsi(s: SecureString): nint;
    static secureStringToCoTaskMemUnicode(s: SecureString): nint;
    static secureStringToGlobalAllocAnsi(s: SecureString): nint;
    static secureStringToGlobalAllocUnicode(s: SecureString): nint;
    static setComObjectData(obj: unknown, key: unknown, data: unknown): boolean;
    static setLastPInvokeError(error: int): void;
    static setLastSystemError(error: int): void;
    static sizeOf<T>(): int;
    static sizeOf(structure: unknown): int;
    static sizeOf(t: Type): int;
    static sizeOf<T>(structure: T): int;
    static stringToBSTR(s: string): nint;
    static stringToCoTaskMemAnsi(s: string): nint;
    static stringToCoTaskMemAuto(s: string): nint;
    static stringToCoTaskMemUni(s: string): nint;
    static stringToCoTaskMemUTF8(s: string): nint;
    static stringToHGlobalAnsi(s: string): nint;
    static stringToHGlobalAuto(s: string): nint;
    static stringToHGlobalUni(s: string): nint;
    static structureToPtr(structure: unknown, ptr: nint, fDeleteOld: boolean): void;
    static structureToPtr<T>(structure: T, ptr: nint, fDeleteOld: boolean): void;
    static throwExceptionForHR(errorCode: int, iid: { value: ref<Guid> }, pUnk: nint): void;
    static throwExceptionForHR(errorCode: int, errorInfo: nint): void;
    static throwExceptionForHR(errorCode: int): void;
    static unsafeAddrOfPinnedArrayElement(arr: ClrArray, index: int): nint;
    static unsafeAddrOfPinnedArrayElement<T>(arr: T[], index: int): nint;
    static writeByte(ptr: nint, val: byte): void;
    static writeByte(ptr: nint, ofs: int, val: byte): void;
    static writeByte(ptr: unknown, ofs: int, val: byte): void;
    static writeInt16(ptr: nint, val: char): void;
    static writeInt16(ptr: nint, val: short): void;
    static writeInt16(ptr: nint, ofs: int, val: char): void;
    static writeInt16(ptr: nint, ofs: int, val: short): void;
    static writeInt16(ptr: { value: unknown }, ofs: int, val: char): void;
    static writeInt16(ptr: unknown, ofs: int, val: short): void;
    static writeInt32(ptr: nint, ofs: int, val: int): void;
    static writeInt32(ptr: nint, val: int): void;
    static writeInt32(ptr: unknown, ofs: int, val: int): void;
    static writeInt64(ptr: nint, ofs: int, val: long): void;
    static writeInt64(ptr: nint, val: long): void;
    static writeInt64(ptr: unknown, ofs: int, val: long): void;
    static writeIntPtr(ptr: nint, ofs: int, val: nint): void;
    static writeIntPtr(ptr: nint, val: nint): void;
    static writeIntPtr(ptr: unknown, ofs: int, val: nint): void;
    static zeroFreeBSTR(s: nint): void;
    static zeroFreeCoTaskMemAnsi(s: nint): void;
    static zeroFreeCoTaskMemUnicode(s: nint): void;
    static zeroFreeCoTaskMemUTF8(s: nint): void;
    static zeroFreeGlobalAllocAnsi(s: nint): void;
    static zeroFreeGlobalAllocUnicode(s: nint): void;
}


export type Marshal = Marshal$instance;

export abstract class MemoryMarshal$instance {
    static asBytes<T extends unknown>(span: ReadOnlySpan_1<T>): ReadOnlySpan_1<CLROf<byte>>;
    static asBytes<T extends unknown>(span: Span_1<T>): Span_1<CLROf<byte>>;
    static asMemory<T>(memory: ReadOnlyMemory_1<T>): Memory_1<T>;
    static asRef<T extends unknown>(span: ReadOnlySpan_1<CLROf<byte>>): ref<T>;
    static asRef<T extends unknown>(span: Span_1<CLROf<byte>>): ref<T>;
    static cast<TFrom extends unknown, TTo extends unknown>(span: ReadOnlySpan_1<TFrom>): ReadOnlySpan_1<TTo>;
    static cast<TFrom extends unknown, TTo extends unknown>(span: Span_1<TFrom>): Span_1<TTo>;
    static createFromPinnedArray<T>(array: T[], start: int, length: int): Memory_1<T>;
    static createReadOnlySpan<T>(reference: { value: ref<T> }, length: int): ReadOnlySpan_1<T>;
    static createReadOnlySpanFromNullTerminated(value: ptr<byte>): ReadOnlySpan_1<CLROf<byte>>;
    static createReadOnlySpanFromNullTerminated(value: ptr<char>): ReadOnlySpan_1<CLROf<char>>;
    static createSpan<T>(reference: { value: ref<T> }, length: int): Span_1<T>;
    static getArrayDataReference(array: ClrArray): ref<byte>;
    static getArrayDataReference<T>(array: T[]): ref<T>;
    static getReference<T>(span: ReadOnlySpan_1<T>): ref<T>;
    static getReference<T>(span: Span_1<T>): ref<T>;
    static read<T extends unknown>(source: ReadOnlySpan_1<CLROf<byte>>): T;
    static toEnumerable<T>(memory: ReadOnlyMemory_1<T>): IEnumerable_1<T>;
    static tryGetArray<T>(memory: ReadOnlyMemory_1<T>, segment: { value: ref<ArraySegment_1<T>> }): boolean;
    static tryGetMemoryManager<T, TManager extends MemoryManager_1<T>>(memory: ReadOnlyMemory_1<T>, manager: { value: ref<TManager> }, start: { value: ref<int> }, length: { value: ref<int> }): boolean;
    static tryGetMemoryManager<T, TManager extends MemoryManager_1<T>>(memory: ReadOnlyMemory_1<T>, manager: { value: ref<TManager> }): boolean;
    static tryGetString(memory: ReadOnlyMemory_1<CLROf<char>>, text: { value: ref<string> }, start: { value: ref<int> }, length: { value: ref<int> }): boolean;
    static tryRead<T extends unknown>(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: ref<T> }): boolean;
    static tryWrite<T extends unknown>(destination: Span_1<CLROf<byte>>, value: { value: ref<T> }): boolean;
    static write<T extends unknown>(destination: Span_1<CLROf<byte>>, value: { value: ref<T> }): void;
}


export type MemoryMarshal = MemoryMarshal$instance;

export abstract class NativeLibrary$instance {
    static free(handle: nint): void;
    static getExport(handle: nint, name: string): nint;
    static getMainProgramHandle(): nint;
    static load(libraryName: string, assembly: Assembly, searchPath: Nullable_1<DllImportSearchPath>): nint;
    static load(libraryPath: string): nint;
    static setDllImportResolver(assembly: Assembly, resolver: DllImportResolver): void;
    static tryGetExport(handle: nint, name: string, address: { value: ref<nint> }): boolean;
    static tryLoad(libraryPath: string, handle: { value: ref<nint> }): boolean;
    static tryLoad(libraryName: string, assembly: Assembly, searchPath: Nullable_1<DllImportSearchPath>, handle: { value: ref<nint> }): boolean;
}


export type NativeLibrary = NativeLibrary$instance;

export abstract class NativeMemory$instance {
    static alignedAlloc(byteCount: nuint, alignment: nuint): ptr<void>;
    static alignedFree(ptr: ptr<void>): void;
    static alignedRealloc(ptr: ptr<void>, byteCount: nuint, alignment: nuint): ptr<void>;
    static alloc(elementCount: nuint, elementSize: nuint): ptr<void>;
    static alloc(byteCount: nuint): ptr<void>;
    static allocZeroed(elementCount: nuint, elementSize: nuint): ptr<void>;
    static allocZeroed(byteCount: nuint): ptr<void>;
    static clear(ptr: ptr<void>, byteCount: nuint): void;
    static copy(source: ptr<void>, destination: ptr<void>, byteCount: nuint): void;
    static fill(ptr: ptr<void>, byteCount: nuint, value: byte): void;
    static free(ptr: ptr<void>): void;
    static realloc(ptr: ptr<void>, byteCount: nuint): ptr<void>;
}


export type NativeMemory = NativeMemory$instance;

export abstract class RuntimeEnvironment$instance {
    static readonly systemConfigurationFile: string;
    static fromGlobalAccessCache(a: Assembly): boolean;
    static getRuntimeDirectory(): string;
    static getRuntimeInterfaceAsIntPtr(clsid: Guid, riid: Guid): nint;
    static getRuntimeInterfaceAsObject(clsid: Guid, riid: Guid): unknown;
    static getSystemVersion(): string;
}


export type RuntimeEnvironment = RuntimeEnvironment$instance;

export abstract class RuntimeInformation$instance {
    static readonly runtimeIdentifier: string;
    static readonly processArchitecture: Architecture;
    static readonly osDescription: string;
    static readonly osArchitecture: Architecture;
    static readonly frameworkDescription: string;
    static isOSPlatform(osPlatform: OSPlatform): boolean;
}


export type RuntimeInformation = RuntimeInformation$instance;

export abstract class SequenceMarshal$instance {
    static tryGetArray<T>(sequence: ReadOnlySequence_1<T>, segment: { value: ref<ArraySegment_1<T>> }): boolean;
    static tryGetReadOnlyMemory<T>(sequence: ReadOnlySequence_1<T>, memory: { value: ref<ReadOnlyMemory_1<T>> }): boolean;
    static tryGetReadOnlySequenceSegment<T>(sequence: ReadOnlySequence_1<T>, startSegment: { value: ref<ReadOnlySequenceSegment_1<T>> }, startIndex: { value: ref<int> }, endSegment: { value: ref<ReadOnlySequenceSegment_1<T>> }, endIndex: { value: ref<int> }): boolean;
    static tryRead<T extends unknown>(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<T> }): boolean;
}


export type SequenceMarshal = SequenceMarshal$instance;

export abstract class TypeMapping$instance {
    static getOrCreateExternalTypeMapping<TTypeMapGroup>(): IReadOnlyDictionary_2<CLROf<string>, Type>;
    static getOrCreateProxyTypeMapping<TTypeMapGroup>(): IReadOnlyDictionary_2<Type, Type>;
}


export type TypeMapping = TypeMapping$instance;

