// Generated by tsbindgen - Architecture
// Namespace: System.Xml.Serialization
// Assembly: System.Private.Xml

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { IEnumerable_1, IEnumerator_1 } from "../../System.Collections.Generic/internal/index.js";
import type { StringCollection } from "../../System.Collections.Specialized/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { CollectionBase, Hashtable, ICollection, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import type { Stream, TextReader, TextWriter } from "../../System.IO/internal/index.js";
import type { ICustomAttributeProvider, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Xml_Schema_Internal from "../../System.Xml.Schema/internal/index.js";
import type { ValidationEventHandler, XmlSchema, XmlSchemaForm } from "../../System.Xml.Schema/internal/index.js";
import type { WhitespaceHandling, XmlAttribute, XmlElement, XmlNodeType, XmlQualifiedName, XmlReader, XmlWriter } from "../../System.Xml/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, AsyncCallback, Attribute, Boolean as ClrBoolean, Delegate, Enum, EventArgs, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, MulticastDelegate, Object as ClrObject, String as ClrString, Type, TypeCode, Uri, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum CodeGenerationOptions {
    none = 0,
    generateProperties = 1,
    generateNewAsync = 2,
    generateOldAsync = 4,
    generateOrder = 8,
    enableDataBinding = 16
}


export enum XmlMappingAccess {
    none = 0,
    read = 1,
    write = 2
}


export type UnreferencedObjectEventHandler = (sender: unknown, e: UnreferencedObjectEventArgs) => void;


export type XmlAttributeEventHandler = (sender: unknown, e: XmlAttributeEventArgs) => void;


export type XmlElementEventHandler = (sender: unknown, e: XmlElementEventArgs) => void;


export type XmlNodeEventHandler = (sender: unknown, e: XmlNodeEventArgs) => void;


export type XmlSerializationCollectionFixupCallback = (collection: unknown, collectionItems: unknown) => void;


export type XmlSerializationFixupCallback = (fixup: unknown) => void;


export type XmlSerializationReadCallback = () => unknown;


export type XmlSerializationWriteCallback = (o: unknown) => void;


export interface IXmlSerializable$instance {
    getSchema(): XmlSchema;
    readXml(reader: XmlReader): void;
    writeXml(writer: XmlWriter): void;
}


export type IXmlSerializable = IXmlSerializable$instance;

export interface IXmlTextParser$instance {
    normalized: boolean;
    whitespaceHandling: WhitespaceHandling;
}


export type IXmlTextParser = IXmlTextParser$instance;

export interface XmlDeserializationEvents$instance {
    onUnknownAttribute: XmlAttributeEventHandler;
    onUnknownElement: XmlElementEventHandler;
    onUnknownNode: XmlNodeEventHandler;
    onUnreferencedObject: UnreferencedObjectEventHandler;
}


export const XmlDeserializationEvents: {
    new(): XmlDeserializationEvents$instance;
};


export type XmlDeserializationEvents = XmlDeserializationEvents$instance;

export interface CodeIdentifier$instance {
}


export const CodeIdentifier: {
    new(): CodeIdentifier$instance;
    makeCamel(identifier: string): string;
    makePascal(identifier: string): string;
    makeValid(identifier: string): string;
};


export type CodeIdentifier = CodeIdentifier$instance;

export interface CodeIdentifiers$instance {
    useCamelCasing: boolean;
    add(identifier: string, value: unknown): void;
    addReserved(identifier: string): void;
    addUnique(identifier: string, value: unknown): string;
    clear(): void;
    isInUse(identifier: string): boolean;
    makeRightCase(identifier: string): string;
    makeUnique(identifier: string): string;
    remove(identifier: string): void;
    removeReserved(identifier: string): void;
    toArray(type_: Type): unknown;
}


export const CodeIdentifiers: {
    new(): CodeIdentifiers$instance;
    new(caseSensitive: boolean): CodeIdentifiers$instance;
};


export type CodeIdentifiers = CodeIdentifiers$instance;

export interface ImportContext$instance {
    readonly shareTypes: boolean;
    readonly typeIdentifiers: CodeIdentifiers;
    readonly warnings: StringCollection;
}


export const ImportContext: {
    new(identifiers: CodeIdentifiers, shareTypes: boolean): ImportContext$instance;
};


export type ImportContext = ImportContext$instance;

export interface SchemaImporter$instance {
}


export const SchemaImporter: {
};


export type SchemaImporter = SchemaImporter$instance;

export interface SoapAttributeAttribute$instance extends Attribute {
    attributeName: string;
    dataType: string;
    namespace_: string;
}


export const SoapAttributeAttribute: {
    new(): SoapAttributeAttribute$instance;
    new(attributeName: string): SoapAttributeAttribute$instance;
};


export type SoapAttributeAttribute = SoapAttributeAttribute$instance;

export interface SoapAttributeOverrides$instance {
    add(type_: Type, attributes: SoapAttributes): void;
    add(type_: Type, member: string, attributes: SoapAttributes): void;
    get_Item(type_: Type): SoapAttributes;
    get_Item(type_: Type, member: string): SoapAttributes;
}


export const SoapAttributeOverrides: {
    new(): SoapAttributeOverrides$instance;
};


export type SoapAttributeOverrides = SoapAttributeOverrides$instance;

export interface SoapAttributes$instance {
    soapAttribute: SoapAttributeAttribute;
    soapDefaultValue: unknown;
    soapElement: SoapElementAttribute;
    soapEnum: SoapEnumAttribute;
    soapIgnore: boolean;
    soapType: SoapTypeAttribute;
}


export const SoapAttributes: {
    new(): SoapAttributes$instance;
    new(provider: ICustomAttributeProvider): SoapAttributes$instance;
};


export type SoapAttributes = SoapAttributes$instance;

export interface SoapElementAttribute$instance extends Attribute {
    dataType: string;
    elementName: string;
    isNullable: boolean;
}


export const SoapElementAttribute: {
    new(): SoapElementAttribute$instance;
    new(elementName: string): SoapElementAttribute$instance;
};


export type SoapElementAttribute = SoapElementAttribute$instance;

export interface SoapEnumAttribute$instance extends Attribute {
    name: string;
}


export const SoapEnumAttribute: {
    new(): SoapEnumAttribute$instance;
    new(name: string): SoapEnumAttribute$instance;
};


export type SoapEnumAttribute = SoapEnumAttribute$instance;

export interface SoapIgnoreAttribute$instance extends Attribute {
}


export const SoapIgnoreAttribute: {
    new(): SoapIgnoreAttribute$instance;
};


export type SoapIgnoreAttribute = SoapIgnoreAttribute$instance;

export interface SoapIncludeAttribute$instance extends Attribute {
    type_: Type;
}


export const SoapIncludeAttribute: {
    new(type_: Type): SoapIncludeAttribute$instance;
};


export type SoapIncludeAttribute = SoapIncludeAttribute$instance;

export interface SoapReflectionImporter$instance {
    importMembersMapping(elementName: string, ns: string, members: XmlReflectionMember[]): XmlMembersMapping;
    importMembersMapping(elementName: string, ns: string, members: XmlReflectionMember[], hasWrapperElement: boolean, writeAccessors: boolean): XmlMembersMapping;
    importMembersMapping(elementName: string, ns: string, members: XmlReflectionMember[], hasWrapperElement: boolean, writeAccessors: boolean, validate: boolean): XmlMembersMapping;
    importMembersMapping(elementName: string, ns: string, members: XmlReflectionMember[], hasWrapperElement: boolean, writeAccessors: boolean, validate: boolean, access: XmlMappingAccess): XmlMembersMapping;
    importTypeMapping(type_: Type): XmlTypeMapping;
    importTypeMapping(type_: Type, defaultNamespace: string): XmlTypeMapping;
    includeType(type_: Type): void;
    includeTypes(provider: ICustomAttributeProvider): void;
}


export const SoapReflectionImporter: {
    new(): SoapReflectionImporter$instance;
    new(defaultNamespace: string): SoapReflectionImporter$instance;
    new(attributeOverrides: SoapAttributeOverrides): SoapReflectionImporter$instance;
    new(attributeOverrides: SoapAttributeOverrides, defaultNamespace: string): SoapReflectionImporter$instance;
};


export type SoapReflectionImporter = SoapReflectionImporter$instance;

export interface SoapSchemaMember$instance {
    memberName: string;
    memberType: XmlQualifiedName;
}


export const SoapSchemaMember: {
    new(): SoapSchemaMember$instance;
};


export type SoapSchemaMember = SoapSchemaMember$instance;

export interface SoapTypeAttribute$instance extends Attribute {
    includeInSchema: boolean;
    namespace_: string;
    typeName: string;
}


export const SoapTypeAttribute: {
    new(): SoapTypeAttribute$instance;
    new(typeName: string): SoapTypeAttribute$instance;
    new(typeName: string, ns: string): SoapTypeAttribute$instance;
};


export type SoapTypeAttribute = SoapTypeAttribute$instance;

export interface UnreferencedObjectEventArgs$instance extends EventArgs {
    readonly unreferencedId: string;
    readonly unreferencedObject: unknown;
}


export const UnreferencedObjectEventArgs: {
    new(o: unknown, id: string): UnreferencedObjectEventArgs$instance;
};


export type UnreferencedObjectEventArgs = UnreferencedObjectEventArgs$instance;

export interface XmlAnyAttributeAttribute$instance extends Attribute {
}


export const XmlAnyAttributeAttribute: {
    new(): XmlAnyAttributeAttribute$instance;
};


export type XmlAnyAttributeAttribute = XmlAnyAttributeAttribute$instance;

export interface XmlAnyElementAttribute$instance extends Attribute {
    name: string;
    namespace_: string;
    order: int;
}


export const XmlAnyElementAttribute: {
    new(): XmlAnyElementAttribute$instance;
    new(name: string): XmlAnyElementAttribute$instance;
    new(name: string, ns: string): XmlAnyElementAttribute$instance;
};


export type XmlAnyElementAttribute = XmlAnyElementAttribute$instance;

export interface XmlAnyElementAttributes$instance extends CollectionBase {
    item: XmlAnyElementAttribute;
    add(value: unknown): int;
    clear(): void;
    contains(value: unknown): boolean;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator;
    indexOf(attribute: XmlAnyElementAttribute): int;
    insert(index: int, value: unknown): void;
    remove(value: unknown): void;
    removeAt(index: int): void;
}


export const XmlAnyElementAttributes: {
    new(): XmlAnyElementAttributes$instance;
};


export interface __XmlAnyElementAttributes$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type XmlAnyElementAttributes = XmlAnyElementAttributes$instance & __XmlAnyElementAttributes$views;


export interface XmlArrayAttribute$instance extends Attribute {
    elementName: string;
    form: XmlSchemaForm;
    isNullable: boolean;
    namespace_: string;
    order: int;
}


export const XmlArrayAttribute: {
    new(): XmlArrayAttribute$instance;
    new(elementName: string): XmlArrayAttribute$instance;
};


export type XmlArrayAttribute = XmlArrayAttribute$instance;

export interface XmlArrayItemAttribute$instance extends Attribute {
    dataType: string;
    elementName: string;
    form: XmlSchemaForm;
    isNullable: boolean;
    namespace_: string;
    nestingLevel: int;
    type_: Type;
}


export const XmlArrayItemAttribute: {
    new(): XmlArrayItemAttribute$instance;
    new(elementName: string): XmlArrayItemAttribute$instance;
    new(type_: Type): XmlArrayItemAttribute$instance;
    new(elementName: string, type_: Type): XmlArrayItemAttribute$instance;
};


export type XmlArrayItemAttribute = XmlArrayItemAttribute$instance;

export interface XmlArrayItemAttributes$instance extends CollectionBase {
    item: XmlArrayItemAttribute;
    add(value: unknown): int;
    clear(): void;
    contains(value: unknown): boolean;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator;
    indexOf(attribute: XmlArrayItemAttribute): int;
    insert(index: int, value: unknown): void;
    remove(value: unknown): void;
    removeAt(index: int): void;
}


export const XmlArrayItemAttributes: {
    new(): XmlArrayItemAttributes$instance;
};


export interface __XmlArrayItemAttributes$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type XmlArrayItemAttributes = XmlArrayItemAttributes$instance & __XmlArrayItemAttributes$views;


export interface XmlAttributeAttribute$instance extends Attribute {
    attributeName: string;
    dataType: string;
    form: XmlSchemaForm;
    namespace_: string;
    type_: Type;
}


export const XmlAttributeAttribute: {
    new(): XmlAttributeAttribute$instance;
    new(attributeName: string): XmlAttributeAttribute$instance;
    new(type_: Type): XmlAttributeAttribute$instance;
    new(attributeName: string, type_: Type): XmlAttributeAttribute$instance;
};


export type XmlAttributeAttribute = XmlAttributeAttribute$instance;

export interface XmlAttributeEventArgs$instance extends EventArgs {
    readonly attr: XmlAttribute;
    readonly expectedAttributes: string;
    readonly lineNumber: int;
    readonly linePosition: int;
    readonly objectBeingDeserialized: unknown;
}


export const XmlAttributeEventArgs: {
    new(): XmlAttributeEventArgs$instance;
};


export type XmlAttributeEventArgs = XmlAttributeEventArgs$instance;

export interface XmlAttributeOverrides$instance {
    add(type_: Type, attributes: XmlAttributes): void;
    add(type_: Type, member: string, attributes: XmlAttributes): void;
    get_Item(type_: Type): XmlAttributes;
    get_Item(type_: Type, member: string): XmlAttributes;
}


export const XmlAttributeOverrides: {
    new(): XmlAttributeOverrides$instance;
};


export type XmlAttributeOverrides = XmlAttributeOverrides$instance;

export interface XmlAttributes$instance {
    xmlAnyAttribute: XmlAnyAttributeAttribute;
    readonly xmlAnyElements: XmlAnyElementAttributes;
    xmlArray: XmlArrayAttribute;
    readonly xmlArrayItems: XmlArrayItemAttributes;
    xmlAttribute: XmlAttributeAttribute;
    readonly xmlChoiceIdentifier: XmlChoiceIdentifierAttribute;
    xmlDefaultValue: unknown;
    readonly xmlElements: XmlElementAttributes;
    xmlEnum: XmlEnumAttribute;
    xmlIgnore: boolean;
    xmlns: boolean;
    xmlRoot: XmlRootAttribute;
    xmlText: XmlTextAttribute;
    xmlType: XmlTypeAttribute;
}


export const XmlAttributes: {
    new(): XmlAttributes$instance;
    new(provider: ICustomAttributeProvider): XmlAttributes$instance;
};


export type XmlAttributes = XmlAttributes$instance;

export interface XmlChoiceIdentifierAttribute$instance extends Attribute {
    memberName: string;
}


export const XmlChoiceIdentifierAttribute: {
    new(): XmlChoiceIdentifierAttribute$instance;
    new(name: string): XmlChoiceIdentifierAttribute$instance;
};


export type XmlChoiceIdentifierAttribute = XmlChoiceIdentifierAttribute$instance;

export interface XmlElementAttribute$instance extends Attribute {
    dataType: string;
    elementName: string;
    form: XmlSchemaForm;
    isNullable: boolean;
    namespace_: string;
    order: int;
    type_: Type;
}


export const XmlElementAttribute: {
    new(): XmlElementAttribute$instance;
    new(elementName: string): XmlElementAttribute$instance;
    new(type_: Type): XmlElementAttribute$instance;
    new(elementName: string, type_: Type): XmlElementAttribute$instance;
};


export type XmlElementAttribute = XmlElementAttribute$instance;

export interface XmlElementAttributes$instance extends CollectionBase {
    item: XmlElementAttribute;
    add(value: unknown): int;
    clear(): void;
    contains(value: unknown): boolean;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator;
    indexOf(attribute: XmlElementAttribute): int;
    insert(index: int, value: unknown): void;
    remove(value: unknown): void;
    removeAt(index: int): void;
}


export const XmlElementAttributes: {
    new(): XmlElementAttributes$instance;
};


export interface __XmlElementAttributes$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type XmlElementAttributes = XmlElementAttributes$instance & __XmlElementAttributes$views;


export interface XmlElementEventArgs$instance extends EventArgs {
    readonly element: XmlElement;
    readonly expectedElements: string;
    readonly lineNumber: int;
    readonly linePosition: int;
    readonly objectBeingDeserialized: unknown;
}


export const XmlElementEventArgs: {
    new(): XmlElementEventArgs$instance;
};


export type XmlElementEventArgs = XmlElementEventArgs$instance;

export interface XmlEnumAttribute$instance extends Attribute {
    name: string;
}


export const XmlEnumAttribute: {
    new(): XmlEnumAttribute$instance;
    new(name: string): XmlEnumAttribute$instance;
};


export type XmlEnumAttribute = XmlEnumAttribute$instance;

export interface XmlIgnoreAttribute$instance extends Attribute {
}


export const XmlIgnoreAttribute: {
    new(): XmlIgnoreAttribute$instance;
};


export type XmlIgnoreAttribute = XmlIgnoreAttribute$instance;

export interface XmlIncludeAttribute$instance extends Attribute {
    type_: Type;
}


export const XmlIncludeAttribute: {
    new(type_: Type): XmlIncludeAttribute$instance;
};


export type XmlIncludeAttribute = XmlIncludeAttribute$instance;

export interface XmlMapping$instance {
    readonly elementName: string;
    readonly namespace_: string;
    readonly xsdElementName: string;
    setKey(key: string): void;
}


export const XmlMapping: {
};


export type XmlMapping = XmlMapping$instance;

export interface XmlMemberMapping$instance {
    readonly any_: boolean;
    readonly checkSpecified: boolean;
    readonly elementName: string;
    readonly memberName: string;
    readonly namespace_: string;
    readonly typeFullName: string;
    readonly typeName: string;
    readonly typeNamespace: string;
    readonly xsdElementName: string;
}


export const XmlMemberMapping: {
    new(): XmlMemberMapping$instance;
};


export type XmlMemberMapping = XmlMemberMapping$instance;

export interface XmlMembersMapping$instance extends XmlMapping {
    readonly count: int;
    readonly item: XmlMemberMapping;
    readonly typeName: string;
    readonly typeNamespace: string;
}


export const XmlMembersMapping: {
    new(): XmlMembersMapping$instance;
};


export type XmlMembersMapping = XmlMembersMapping$instance;

export interface XmlNamespaceDeclarationsAttribute$instance extends Attribute {
}


export const XmlNamespaceDeclarationsAttribute: {
    new(): XmlNamespaceDeclarationsAttribute$instance;
};


export type XmlNamespaceDeclarationsAttribute = XmlNamespaceDeclarationsAttribute$instance;

export interface XmlNodeEventArgs$instance extends EventArgs {
    readonly lineNumber: int;
    readonly linePosition: int;
    readonly localName: string;
    readonly name: string;
    readonly namespaceURI: string;
    readonly nodeType: XmlNodeType;
    readonly objectBeingDeserialized: unknown;
    readonly text: string;
}


export const XmlNodeEventArgs: {
    new(): XmlNodeEventArgs$instance;
};


export type XmlNodeEventArgs = XmlNodeEventArgs$instance;

export interface XmlReflectionImporter$instance {
    importMembersMapping(elementName: string, ns: string, members: XmlReflectionMember[], hasWrapperElement: boolean): XmlMembersMapping;
    importMembersMapping(elementName: string, ns: string, members: XmlReflectionMember[], hasWrapperElement: boolean, rpc: boolean): XmlMembersMapping;
    importMembersMapping(elementName: string, ns: string, members: XmlReflectionMember[], hasWrapperElement: boolean, rpc: boolean, openModel: boolean): XmlMembersMapping;
    importMembersMapping(elementName: string, ns: string, members: XmlReflectionMember[], hasWrapperElement: boolean, rpc: boolean, openModel: boolean, access: XmlMappingAccess): XmlMembersMapping;
    importTypeMapping(type_: Type): XmlTypeMapping;
    importTypeMapping(type_: Type, defaultNamespace: string): XmlTypeMapping;
    importTypeMapping(type_: Type, root: XmlRootAttribute): XmlTypeMapping;
    importTypeMapping(type_: Type, root: XmlRootAttribute, defaultNamespace: string): XmlTypeMapping;
    includeType(type_: Type): void;
    includeTypes(provider: ICustomAttributeProvider): void;
}


export const XmlReflectionImporter: {
    new(): XmlReflectionImporter$instance;
    new(defaultNamespace: string): XmlReflectionImporter$instance;
    new(attributeOverrides: XmlAttributeOverrides): XmlReflectionImporter$instance;
    new(attributeOverrides: XmlAttributeOverrides, defaultNamespace: string): XmlReflectionImporter$instance;
};


export type XmlReflectionImporter = XmlReflectionImporter$instance;

export interface XmlReflectionMember$instance {
    isReturnValue: boolean;
    memberName: string;
    memberType: Type;
    overrideIsNullable: boolean;
    soapAttributes: SoapAttributes;
    xmlAttributes: XmlAttributes;
}


export const XmlReflectionMember: {
    new(): XmlReflectionMember$instance;
};


export type XmlReflectionMember = XmlReflectionMember$instance;

export interface XmlRootAttribute$instance extends Attribute {
    dataType: string;
    elementName: string;
    isNullable: boolean;
    namespace_: string;
}


export const XmlRootAttribute: {
    new(): XmlRootAttribute$instance;
    new(elementName: string): XmlRootAttribute$instance;
};


export type XmlRootAttribute = XmlRootAttribute$instance;

export interface XmlSchemaEnumerator$instance extends IDisposable {
    readonly current: XmlSchema;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const XmlSchemaEnumerator: {
    new(list: XmlSchemas): XmlSchemaEnumerator$instance;
};


export interface __XmlSchemaEnumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<XmlSchema>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type XmlSchemaEnumerator = XmlSchemaEnumerator$instance & __XmlSchemaEnumerator$views;


export interface XmlSchemaExporter$instance {
    exportAnyType(ns: string): string;
    exportAnyType(members: XmlMembersMapping): string;
    exportMembersMapping(xmlMembersMapping: XmlMembersMapping): void;
    exportMembersMapping(xmlMembersMapping: XmlMembersMapping, exportEnclosingType: boolean): void;
    exportTypeMapping(xmlTypeMapping: XmlTypeMapping): void;
    exportTypeMapping(xmlMembersMapping: XmlMembersMapping): XmlQualifiedName;
}


export const XmlSchemaExporter: {
    new(schemas: XmlSchemas): XmlSchemaExporter$instance;
};


export type XmlSchemaExporter = XmlSchemaExporter$instance;

export interface XmlSchemaImporter$instance extends SchemaImporter {
    importAnyType(typeName: XmlQualifiedName, elementName: string): XmlMembersMapping;
    importDerivedTypeMapping(name: XmlQualifiedName, baseType: Type): XmlTypeMapping;
    importDerivedTypeMapping(name: XmlQualifiedName, baseType: Type, baseTypeCanBeIndirect: boolean): XmlTypeMapping;
    importMembersMapping(name: XmlQualifiedName): XmlMembersMapping;
    importMembersMapping(names: XmlQualifiedName[]): XmlMembersMapping;
    importMembersMapping(names: XmlQualifiedName[], baseType: Type, baseTypeCanBeIndirect: boolean): XmlMembersMapping;
    importMembersMapping(name: string, ns: string, members: SoapSchemaMember[]): XmlMembersMapping;
    importSchemaType(typeName: XmlQualifiedName): XmlTypeMapping;
    importSchemaType(typeName: XmlQualifiedName, baseType: Type): XmlTypeMapping;
    importSchemaType(typeName: XmlQualifiedName, baseType: Type, baseTypeCanBeIndirect: boolean): XmlTypeMapping;
    importTypeMapping(name: XmlQualifiedName): XmlTypeMapping;
}


export const XmlSchemaImporter: {
    new(schemas: XmlSchemas): XmlSchemaImporter$instance;
    new(schemas: XmlSchemas, typeIdentifiers: CodeIdentifiers): XmlSchemaImporter$instance;
};


export type XmlSchemaImporter = XmlSchemaImporter$instance;

export interface XmlSchemaProviderAttribute$instance extends Attribute {
    isAny: boolean;
    readonly methodName: string;
}


export const XmlSchemaProviderAttribute: {
    new(methodName: string): XmlSchemaProviderAttribute$instance;
};


export type XmlSchemaProviderAttribute = XmlSchemaProviderAttribute$instance;

export interface XmlSchemas$instance extends CollectionBase {
    readonly isCompiled: boolean;
    add(schemas: XmlSchemas): void;
    add(value: unknown): int;
    addReference(schema: XmlSchema): void;
    clear(): void;
    compile(handler: ValidationEventHandler, fullCompile: boolean): void;
    contains(schema: XmlSchema): boolean;
    contains(value: unknown): boolean;
    copyTo(array: ClrArray, index: int): void;
    find(name: XmlQualifiedName, type_: Type): unknown;
    get_Item(index: int): XmlSchema;
    get_Item(ns: string): XmlSchema;
    getEnumerator(): IEnumerator;
    getSchemas(ns: string): IList;
    indexOf(schema: XmlSchema): int;
    insert(index: int, value: unknown): void;
    remove(value: unknown): void;
    removeAt(index: int): void;
    set_Item(index: int, value: XmlSchema): void;
}


export const XmlSchemas: {
    new(): XmlSchemas$instance;
    isDataSet(schema: XmlSchema): boolean;
};


export interface __XmlSchemas$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<XmlSchema>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type XmlSchemas = XmlSchemas$instance & __XmlSchemas$views;


export interface XmlSerializationGeneratedCode$instance {
}


export const XmlSerializationGeneratedCode: {
};


export type XmlSerializationGeneratedCode = XmlSerializationGeneratedCode$instance;

export interface XmlSerializationReader$instance extends XmlSerializationGeneratedCode {
}


export const XmlSerializationReader: {
};


export type XmlSerializationReader = XmlSerializationReader$instance;

export interface XmlSerializationWriter$instance extends XmlSerializationGeneratedCode {
}


export const XmlSerializationWriter: {
};


export type XmlSerializationWriter = XmlSerializationWriter$instance;

export interface XmlSerializer$instance {
    canDeserialize(xmlReader: XmlReader): boolean;
    deserialize(stream: Stream): unknown;
    deserialize(textReader: TextReader): unknown;
    deserialize(xmlReader: XmlReader): unknown;
    deserialize(xmlReader: XmlReader, events: XmlDeserializationEvents): unknown;
    deserialize(xmlReader: XmlReader, encodingStyle: string): unknown;
    deserialize(xmlReader: XmlReader, encodingStyle: string, events: XmlDeserializationEvents): unknown;
    serialize(textWriter: TextWriter, o: unknown): void;
    serialize(textWriter: TextWriter, o: unknown, namespaces: XmlSerializerNamespaces): void;
    serialize(stream: Stream, o: unknown): void;
    serialize(stream: Stream, o: unknown, namespaces: XmlSerializerNamespaces): void;
    serialize(xmlWriter: XmlWriter, o: unknown): void;
    serialize(xmlWriter: XmlWriter, o: unknown, namespaces: XmlSerializerNamespaces): void;
    serialize(xmlWriter: XmlWriter, o: unknown, namespaces: XmlSerializerNamespaces, encodingStyle: string): void;
    serialize(xmlWriter: XmlWriter, o: unknown, namespaces: XmlSerializerNamespaces, encodingStyle: string, id: string): void;
}


export const XmlSerializer: {
    new(type_: Type, overrides: XmlAttributeOverrides, extraTypes: Type[], root: XmlRootAttribute, defaultNamespace: string): XmlSerializer$instance;
    new(type_: Type, root: XmlRootAttribute): XmlSerializer$instance;
    new(type_: Type, extraTypes: Type[]): XmlSerializer$instance;
    new(type_: Type, overrides: XmlAttributeOverrides): XmlSerializer$instance;
    new(xmlTypeMapping: XmlTypeMapping): XmlSerializer$instance;
    new(type_: Type): XmlSerializer$instance;
    new(type_: Type, defaultNamespace: string): XmlSerializer$instance;
    new(type_: Type, overrides: XmlAttributeOverrides, extraTypes: Type[], root: XmlRootAttribute, defaultNamespace: string, location: string): XmlSerializer$instance;
    fromMappings(mappings: XmlMapping[], type_: Type): XmlSerializer[];
    fromMappings(mappings: XmlMapping[]): XmlSerializer[];
    fromTypes(types: Type[]): XmlSerializer[];
    getXmlSerializerAssemblyName(type_: Type, defaultNamespace: string): string;
    getXmlSerializerAssemblyName(type_: Type): string;
};


export type XmlSerializer = XmlSerializer$instance;

export interface XmlSerializerAssemblyAttribute$instance extends Attribute {
    assemblyName: string;
    codeBase: string;
}


export const XmlSerializerAssemblyAttribute: {
    new(): XmlSerializerAssemblyAttribute$instance;
    new(assemblyName: string): XmlSerializerAssemblyAttribute$instance;
    new(assemblyName: string, codeBase: string): XmlSerializerAssemblyAttribute$instance;
};


export type XmlSerializerAssemblyAttribute = XmlSerializerAssemblyAttribute$instance;

export interface XmlSerializerFactory$instance {
    createSerializer(type_: Type, overrides: XmlAttributeOverrides, extraTypes: Type[], root: XmlRootAttribute, defaultNamespace: string): XmlSerializer;
    createSerializer(type_: Type, root: XmlRootAttribute): XmlSerializer;
    createSerializer(type_: Type, extraTypes: Type[]): XmlSerializer;
    createSerializer(type_: Type, overrides: XmlAttributeOverrides): XmlSerializer;
    createSerializer(xmlTypeMapping: XmlTypeMapping): XmlSerializer;
    createSerializer(type_: Type): XmlSerializer;
    createSerializer(type_: Type, defaultNamespace: string): XmlSerializer;
    createSerializer(type_: Type, overrides: XmlAttributeOverrides, extraTypes: Type[], root: XmlRootAttribute, defaultNamespace: string, location: string): XmlSerializer;
}


export const XmlSerializerFactory: {
    new(): XmlSerializerFactory$instance;
};


export type XmlSerializerFactory = XmlSerializerFactory$instance;

export interface XmlSerializerImplementation$instance {
    readonly reader: XmlSerializationReader;
    readonly readMethods: Hashtable;
    readonly typedSerializers: Hashtable;
    readonly writeMethods: Hashtable;
    readonly writer: XmlSerializationWriter;
    canSerialize(type_: Type): boolean;
    getSerializer(type_: Type): XmlSerializer;
}


export const XmlSerializerImplementation: {
};


export type XmlSerializerImplementation = XmlSerializerImplementation$instance;

export interface XmlSerializerNamespaces$instance {
    readonly count: int;
    add(prefix: string, ns: string): void;
    toArray(): XmlQualifiedName[];
}


export const XmlSerializerNamespaces: {
    new(): XmlSerializerNamespaces$instance;
    new(namespaces: XmlSerializerNamespaces): XmlSerializerNamespaces$instance;
    new(namespaces: XmlQualifiedName[]): XmlSerializerNamespaces$instance;
};


export type XmlSerializerNamespaces = XmlSerializerNamespaces$instance;

export interface XmlSerializerVersionAttribute$instance extends Attribute {
    namespace_: string;
    parentAssemblyId: string;
    type_: Type;
    version: string;
}


export const XmlSerializerVersionAttribute: {
    new(): XmlSerializerVersionAttribute$instance;
    new(type_: Type): XmlSerializerVersionAttribute$instance;
};


export type XmlSerializerVersionAttribute = XmlSerializerVersionAttribute$instance;

export interface XmlTextAttribute$instance extends Attribute {
    dataType: string;
    type_: Type;
}


export const XmlTextAttribute: {
    new(): XmlTextAttribute$instance;
    new(type_: Type): XmlTextAttribute$instance;
};


export type XmlTextAttribute = XmlTextAttribute$instance;

export interface XmlTypeAttribute$instance extends Attribute {
    anonymousType: boolean;
    includeInSchema: boolean;
    namespace_: string;
    typeName: string;
}


export const XmlTypeAttribute: {
    new(): XmlTypeAttribute$instance;
    new(typeName: string): XmlTypeAttribute$instance;
};


export type XmlTypeAttribute = XmlTypeAttribute$instance;

export interface XmlTypeMapping$instance extends XmlMapping {
    readonly typeFullName: string;
    readonly typeName: string;
    readonly xsdTypeName: string;
    readonly xsdTypeNamespace: string;
}


export const XmlTypeMapping: {
    new(): XmlTypeMapping$instance;
};


export type XmlTypeMapping = XmlTypeMapping$instance;

