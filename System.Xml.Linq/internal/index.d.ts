// Generated by tsbindgen - Architecture
// Namespace: System.Xml.Linq
// Assembly: System.Private.Xml.Linq

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { IComparer_1, IEnumerable_1, IEqualityComparer_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IComparer, IEqualityComparer } from "../../System.Collections/internal/index.js";
import type { Stream, TextReader, TextWriter } from "../../System.IO/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { Task, Task_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import type { XmlSchema } from "../../System.Xml.Schema/internal/index.js";
import * as System_Xml_Serialization_Internal from "../../System.Xml.Serialization/internal/index.js";
import type { IXmlSerializable } from "../../System.Xml.Serialization/internal/index.js";
import * as System_Xml_Internal from "../../System.Xml/internal/index.js";
import type { IXmlLineInfo, XmlNodeType, XmlReader, XmlWriter } from "../../System.Xml/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Enum, EventArgs, EventHandler_1, IComparable, IConvertible, IEquatable_1, IFormatProvider, IFormattable, Int32, ISpanFormattable, Object as ClrObject, String as ClrString, Type, TypeCode, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum LoadOptions {
    none = 0,
    preserveWhitespace = 1,
    setBaseUri = 2,
    setLineInfo = 4
}


export enum ReaderOptions {
    none = 0,
    omitDuplicateNamespaces = 1
}


export enum SaveOptions {
    none = 0,
    disableFormatting = 1,
    omitDuplicateNamespaces = 2
}


export enum XObjectChange {
    add = 0,
    remove = 1,
    name = 2,
    value = 3
}


export interface XAttribute$instance extends XObject$instance {
    readonly isNamespaceDeclaration: boolean;
    readonly name: XName;
    readonly nextAttribute: XAttribute;
    readonly nodeType: XmlNodeType;
    readonly previousAttribute: XAttribute;
    value: string;
    hasLineInfo(): boolean;
    remove(): void;
    setValue(value: unknown): void;
    toString(): string;
}


export const XAttribute: {
    new(name: XName, value: unknown): XAttribute$instance;
    new(other: XAttribute): XAttribute$instance;
    readonly emptySequence: IEnumerable_1<XAttribute>;
};


export interface __XAttribute$views {
    As_IXmlLineInfo(): System_Xml_Internal.IXmlLineInfo$instance;
}

export interface XAttribute$instance extends System_Xml_Internal.IXmlLineInfo$instance {}

export type XAttribute = XAttribute$instance & __XAttribute$views;


export interface XCData$instance extends XText$instance {
    readonly nodeType: XmlNodeType;
    hasLineInfo(): boolean;
    writeTo(writer: XmlWriter): void;
    writeToAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
}


export const XCData: {
    new(value: string): XCData$instance;
    new(other: XCData): XCData$instance;
};


export interface __XCData$views {
    As_IXmlLineInfo(): System_Xml_Internal.IXmlLineInfo$instance;
}

export type XCData = XCData$instance & __XCData$views;


export interface XComment$instance extends XNode$instance {
    readonly nodeType: XmlNodeType;
    value: string;
    hasLineInfo(): boolean;
    writeTo(writer: XmlWriter): void;
    writeToAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
}


export const XComment: {
    new(value: string): XComment$instance;
    new(other: XComment): XComment$instance;
};


export interface __XComment$views {
    As_IXmlLineInfo(): System_Xml_Internal.IXmlLineInfo$instance;
}

export type XComment = XComment$instance & __XComment$views;


export interface XContainer$instance extends XNode$instance {
    readonly firstNode: XNode;
    readonly lastNode: XNode;
    add(content: unknown): void;
    add(content: unknown[]): void;
    addFirst(content: unknown): void;
    addFirst(content: unknown[]): void;
    createWriter(): XmlWriter;
    descendantNodes(): IEnumerable_1<XNode>;
    descendants(): IEnumerable_1<XElement>;
    descendants(name: XName): IEnumerable_1<XElement>;
    element(name: XName): XElement;
    elements(): IEnumerable_1<XElement>;
    elements(name: XName): IEnumerable_1<XElement>;
    hasLineInfo(): boolean;
    nodes(): IEnumerable_1<XNode>;
    removeNodes(): void;
    replaceNodes(content: unknown): void;
    replaceNodes(content: unknown[]): void;
}


export const XContainer: {
};


export interface __XContainer$views {
    As_IXmlLineInfo(): System_Xml_Internal.IXmlLineInfo$instance;
}

export type XContainer = XContainer$instance & __XContainer$views;


export interface XDeclaration$instance {
    encoding: string;
    standalone: string;
    version: string;
    toString(): string;
}


export const XDeclaration: {
    new(version: string, encoding: string, standalone: string): XDeclaration$instance;
    new(other: XDeclaration): XDeclaration$instance;
};


export type XDeclaration = XDeclaration$instance;

export interface XDocument$instance extends XContainer$instance {
    declaration: XDeclaration;
    readonly documentType: XDocumentType;
    readonly nodeType: XmlNodeType;
    readonly root: XElement;
    hasLineInfo(): boolean;
    save(stream: Stream): void;
    save(stream: Stream, options: SaveOptions): void;
    save(textWriter: TextWriter): void;
    save(textWriter: TextWriter, options: SaveOptions): void;
    save(writer: XmlWriter): void;
    save(fileName: string): void;
    save(fileName: string, options: SaveOptions): void;
    saveAsync(stream: Stream, options: SaveOptions, cancellationToken: CancellationToken): Task;
    saveAsync(textWriter: TextWriter, options: SaveOptions, cancellationToken: CancellationToken): Task;
    saveAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
    writeTo(writer: XmlWriter): void;
    writeToAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
}


export const XDocument: {
    new(): XDocument$instance;
    new(content: unknown[]): XDocument$instance;
    new(declaration: XDeclaration, content: unknown[]): XDocument$instance;
    new(other: XDocument): XDocument$instance;
    load(stream: Stream, options: LoadOptions): XDocument;
    load(stream: Stream): XDocument;
    load(textReader: TextReader, options: LoadOptions): XDocument;
    load(textReader: TextReader): XDocument;
    load(uri: string, options: LoadOptions): XDocument;
    load(uri: string): XDocument;
    load(reader: XmlReader, options: LoadOptions): XDocument;
    load(reader: XmlReader): XDocument;
    loadAsync(stream: Stream, options: LoadOptions, cancellationToken: CancellationToken): Task_1<XDocument>;
    loadAsync(textReader: TextReader, options: LoadOptions, cancellationToken: CancellationToken): Task_1<XDocument>;
    loadAsync(reader: XmlReader, options: LoadOptions, cancellationToken: CancellationToken): Task_1<XDocument>;
    parse(text: string, options: LoadOptions): XDocument;
    parse(text: string): XDocument;
};


export interface __XDocument$views {
    As_IXmlLineInfo(): System_Xml_Internal.IXmlLineInfo$instance;
}

export type XDocument = XDocument$instance & __XDocument$views;


export interface XDocumentType$instance extends XNode$instance {
    internalSubset: string;
    name: string;
    readonly nodeType: XmlNodeType;
    publicId: string;
    systemId: string;
    hasLineInfo(): boolean;
    writeTo(writer: XmlWriter): void;
    writeToAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
}


export const XDocumentType: {
    new(name: string, publicId: string, systemId: string, internalSubset: string): XDocumentType$instance;
    new(other: XDocumentType): XDocumentType$instance;
};


export interface __XDocumentType$views {
    As_IXmlLineInfo(): System_Xml_Internal.IXmlLineInfo$instance;
}

export type XDocumentType = XDocumentType$instance & __XDocumentType$views;


export interface XElement$instance extends XContainer$instance {
    readonly firstAttribute: XAttribute;
    readonly hasAttributes: boolean;
    readonly hasElements: boolean;
    readonly isEmpty: boolean;
    readonly lastAttribute: XAttribute;
    name: XName;
    readonly nodeType: XmlNodeType;
    value: string;
    ancestorsAndSelf(): IEnumerable_1<XElement>;
    ancestorsAndSelf(name: XName): IEnumerable_1<XElement>;
    attribute(name: XName): XAttribute;
    attributes(): IEnumerable_1<XAttribute>;
    attributes(name: XName): IEnumerable_1<XAttribute>;
    descendantNodesAndSelf(): IEnumerable_1<XNode>;
    descendantsAndSelf(): IEnumerable_1<XElement>;
    descendantsAndSelf(name: XName): IEnumerable_1<XElement>;
    getDefaultNamespace(): XNamespace;
    getNamespaceOfPrefix(prefix: string): XNamespace;
    getPrefixOfNamespace(ns: XNamespace): string;
    hasLineInfo(): boolean;
    removeAll(): void;
    removeAttributes(): void;
    replaceAll(content: unknown): void;
    replaceAll(content: unknown[]): void;
    replaceAttributes(content: unknown): void;
    replaceAttributes(content: unknown[]): void;
    save(fileName: string): void;
    save(fileName: string, options: SaveOptions): void;
    save(stream: Stream): void;
    save(stream: Stream, options: SaveOptions): void;
    save(textWriter: TextWriter): void;
    save(textWriter: TextWriter, options: SaveOptions): void;
    save(writer: XmlWriter): void;
    saveAsync(stream: Stream, options: SaveOptions, cancellationToken: CancellationToken): Task;
    saveAsync(textWriter: TextWriter, options: SaveOptions, cancellationToken: CancellationToken): Task;
    saveAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
    setAttributeValue(name: XName, value: unknown): void;
    setElementValue(name: XName, value: unknown): void;
    setValue(value: unknown): void;
    writeTo(writer: XmlWriter): void;
    writeToAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
}


export const XElement: {
    new(name: XName): XElement$instance;
    new(name: XName, content: unknown): XElement$instance;
    new(name: XName, content: unknown[]): XElement$instance;
    new(other: XElement): XElement$instance;
    new(other: XStreamingElement): XElement$instance;
    readonly emptySequence: IEnumerable_1<XElement>;
    load(stream: Stream, options: LoadOptions): XElement;
    load(stream: Stream): XElement;
    load(textReader: TextReader, options: LoadOptions): XElement;
    load(textReader: TextReader): XElement;
    load(uri: string, options: LoadOptions): XElement;
    load(uri: string): XElement;
    load(reader: XmlReader, options: LoadOptions): XElement;
    load(reader: XmlReader): XElement;
    loadAsync(stream: Stream, options: LoadOptions, cancellationToken: CancellationToken): Task_1<XElement>;
    loadAsync(textReader: TextReader, options: LoadOptions, cancellationToken: CancellationToken): Task_1<XElement>;
    loadAsync(reader: XmlReader, options: LoadOptions, cancellationToken: CancellationToken): Task_1<XElement>;
    parse(text: string, options: LoadOptions): XElement;
    parse(text: string): XElement;
};


export interface __XElement$views {
    As_IXmlLineInfo(): System_Xml_Internal.IXmlLineInfo$instance;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;
}

export interface XElement$instance extends System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type XElement = XElement$instance & __XElement$views;


export interface XName$instance {
    readonly localName: string;
    readonly namespace_: XNamespace;
    readonly namespaceName: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const XName: {
    new(): XName$instance;
    get_(localName: string, namespaceName: string): XName;
    get_(expandedName: string): XName;
};


export interface __XName$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<XName>;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: XName): boolean;
}

export interface XName$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type XName = XName$instance & __XName$views;


export interface XNamespace$instance {
    readonly namespaceName: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    getName(localName: string): XName;
    toString(): string;
}


export const XNamespace: {
    new(): XNamespace$instance;
    readonly none: XNamespace;
    readonly xml: XNamespace;
    readonly xmlns: XNamespace;
    get_(namespaceName: string): XNamespace;
};


export type XNamespace = XNamespace$instance;

export interface XNode$instance extends XObject$instance {
    readonly nextNode: XNode;
    readonly previousNode: XNode;
    addAfterSelf(content: unknown): void;
    addAfterSelf(content: unknown[]): void;
    addBeforeSelf(content: unknown): void;
    addBeforeSelf(content: unknown[]): void;
    ancestors(): IEnumerable_1<XElement>;
    ancestors(name: XName): IEnumerable_1<XElement>;
    createReader(): XmlReader;
    createReader(readerOptions: ReaderOptions): XmlReader;
    elementsAfterSelf(): IEnumerable_1<XElement>;
    elementsAfterSelf(name: XName): IEnumerable_1<XElement>;
    elementsBeforeSelf(): IEnumerable_1<XElement>;
    elementsBeforeSelf(name: XName): IEnumerable_1<XElement>;
    hasLineInfo(): boolean;
    isAfter(node: XNode): boolean;
    isBefore(node: XNode): boolean;
    nodesAfterSelf(): IEnumerable_1<XNode>;
    nodesBeforeSelf(): IEnumerable_1<XNode>;
    remove(): void;
    replaceWith(content: unknown): void;
    replaceWith(content: unknown[]): void;
    toString(): string;
    toString(options: SaveOptions): string;
    writeTo(writer: XmlWriter): void;
    writeToAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
}


export const XNode: {
    readonly documentOrderComparer: XNodeDocumentOrderComparer;
    readonly equalityComparer: XNodeEqualityComparer;
    compareDocumentOrder(n1: XNode, n2: XNode): int;
    deepEquals(n1: XNode, n2: XNode): boolean;
    readFrom(reader: XmlReader): XNode;
    readFromAsync(reader: XmlReader, cancellationToken: CancellationToken): Task_1<XNode>;
};


export interface __XNode$views {
    As_IXmlLineInfo(): System_Xml_Internal.IXmlLineInfo$instance;
}

export interface XNode$instance extends System_Xml_Internal.IXmlLineInfo$instance {}

export type XNode = XNode$instance & __XNode$views;


export interface XNodeDocumentOrderComparer$instance {
    compare(x: XNode, y: XNode): int;
}


export const XNodeDocumentOrderComparer: {
    new(): XNodeDocumentOrderComparer$instance;
};


export interface __XNodeDocumentOrderComparer$views {
    As_IComparer_1(): System_Collections_Generic_Internal.IComparer_1$instance<XNode>;
    As_IComparer(): System_Collections_Internal.IComparer$instance;
}

export interface XNodeDocumentOrderComparer$instance extends System_Collections_Generic_Internal.IComparer_1$instance<XNode> {}

export type XNodeDocumentOrderComparer = XNodeDocumentOrderComparer$instance & __XNodeDocumentOrderComparer$views;


export interface XNodeEqualityComparer$instance {
    equals(x: XNode, y: XNode): boolean;
    getHashCode(obj: XNode): int;
}


export const XNodeEqualityComparer: {
    new(): XNodeEqualityComparer$instance;
};


export interface __XNodeEqualityComparer$views {
    As_IEqualityComparer_1(): System_Collections_Generic_Internal.IEqualityComparer_1$instance<XNode>;
    As_IEqualityComparer(): System_Collections_Internal.IEqualityComparer$instance;
}

export type XNodeEqualityComparer = XNodeEqualityComparer$instance & __XNodeEqualityComparer$views;


export interface XObject$instance {
    readonly baseUri: string;
    readonly document: XDocument;
    readonly nodeType: XmlNodeType;
    readonly parent: XElement;
    addAnnotation(annotation: unknown): void;
    annotation(type_: Type): unknown;
    annotation<T>(): T;
    annotations(type_: Type): IEnumerable_1<unknown>;
    annotations<T>(): IEnumerable_1<T>;
    removeAnnotations(type_: Type): void;
    removeAnnotations<T>(): void;
}


export const XObject: {
};


export interface __XObject$views {
    As_IXmlLineInfo(): System_Xml_Internal.IXmlLineInfo$instance;
}

export interface XObject$instance extends System_Xml_Internal.IXmlLineInfo$instance {}

export type XObject = XObject$instance & __XObject$views;


export interface XObjectChangeEventArgs$instance extends EventArgs {
    readonly objectChange: XObjectChange;
}


export const XObjectChangeEventArgs: {
    new(objectChange: XObjectChange): XObjectChangeEventArgs$instance;
    readonly add: XObjectChangeEventArgs;
    readonly remove: XObjectChangeEventArgs;
    readonly name: XObjectChangeEventArgs;
    readonly value: XObjectChangeEventArgs;
};


export type XObjectChangeEventArgs = XObjectChangeEventArgs$instance;

export interface XProcessingInstruction$instance extends XNode$instance {
    data: string;
    readonly nodeType: XmlNodeType;
    target: string;
    hasLineInfo(): boolean;
    writeTo(writer: XmlWriter): void;
    writeToAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
}


export const XProcessingInstruction: {
    new(target: string, data: string): XProcessingInstruction$instance;
    new(other: XProcessingInstruction): XProcessingInstruction$instance;
};


export interface __XProcessingInstruction$views {
    As_IXmlLineInfo(): System_Xml_Internal.IXmlLineInfo$instance;
}

export type XProcessingInstruction = XProcessingInstruction$instance & __XProcessingInstruction$views;


export interface XStreamingElement$instance {
    name: XName;
    add(content: unknown): void;
    add(content: unknown[]): void;
    save(stream: Stream): void;
    save(stream: Stream, options: SaveOptions): void;
    save(textWriter: TextWriter): void;
    save(textWriter: TextWriter, options: SaveOptions): void;
    save(writer: XmlWriter): void;
    save(fileName: string): void;
    save(fileName: string, options: SaveOptions): void;
    toString(): string;
    toString(options: SaveOptions): string;
    writeTo(writer: XmlWriter): void;
}


export const XStreamingElement: {
    new(name: XName): XStreamingElement$instance;
    new(name: XName, content: unknown): XStreamingElement$instance;
    new(name: XName, content: unknown[]): XStreamingElement$instance;
};


export type XStreamingElement = XStreamingElement$instance;

export interface XText$instance extends XNode$instance {
    readonly nodeType: XmlNodeType;
    value: string;
    hasLineInfo(): boolean;
    writeTo(writer: XmlWriter): void;
    writeToAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
}


export const XText: {
    new(value: string): XText$instance;
    new(other: XText): XText$instance;
};


export interface __XText$views {
    As_IXmlLineInfo(): System_Xml_Internal.IXmlLineInfo$instance;
}

export type XText = XText$instance & __XText$views;


export abstract class Extensions$instance {
    static ancestors<T extends XNode>(source: IEnumerable_1<T>, name: XName): IEnumerable_1<XElement>;
    static ancestors<T extends XNode>(source: IEnumerable_1<T>): IEnumerable_1<XElement>;
    static ancestorsAndSelf(source: IEnumerable_1<XElement>, name: XName): IEnumerable_1<XElement>;
    static ancestorsAndSelf(source: IEnumerable_1<XElement>): IEnumerable_1<XElement>;
    static attributes(source: IEnumerable_1<XElement>, name: XName): IEnumerable_1<XAttribute>;
    static attributes(source: IEnumerable_1<XElement>): IEnumerable_1<XAttribute>;
    static descendantNodes<T extends XContainer>(source: IEnumerable_1<T>): IEnumerable_1<XNode>;
    static descendantNodesAndSelf(source: IEnumerable_1<XElement>): IEnumerable_1<XNode>;
    static descendants<T extends XContainer>(source: IEnumerable_1<T>, name: XName): IEnumerable_1<XElement>;
    static descendants<T extends XContainer>(source: IEnumerable_1<T>): IEnumerable_1<XElement>;
    static descendantsAndSelf(source: IEnumerable_1<XElement>, name: XName): IEnumerable_1<XElement>;
    static descendantsAndSelf(source: IEnumerable_1<XElement>): IEnumerable_1<XElement>;
    static elements<T extends XContainer>(source: IEnumerable_1<T>, name: XName): IEnumerable_1<XElement>;
    static elements<T extends XContainer>(source: IEnumerable_1<T>): IEnumerable_1<XElement>;
    static inDocumentOrder<T extends XNode>(source: IEnumerable_1<T>): IEnumerable_1<T>;
    static nodes<T extends XContainer>(source: IEnumerable_1<T>): IEnumerable_1<XNode>;
    static remove<T extends XNode>(source: IEnumerable_1<T>): void;
    static remove(source: IEnumerable_1<XAttribute>): void;
}


export type Extensions = Extensions$instance;

