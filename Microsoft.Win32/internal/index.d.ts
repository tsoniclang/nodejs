// Generated by tsbindgen - Architecture
// Namespace: Microsoft.Win32
// Assembly: Microsoft.Win32.Registry

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { SafeRegistryHandle } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import type { AccessControlSections, RegistryRights, RegistrySecurity } from "../../System.Security.AccessControl/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Enum, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, ISpanFormattable, MarshalByRefObject, Object as ClrObject, String as ClrString, Type, TypeCode, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum RegistryHive {
    classesRoot = -2147483648,
    currentUser = -2147483647,
    localMachine = -2147483646,
    users = -2147483645,
    performanceData = -2147483644,
    currentConfig = -2147483643
}


export enum RegistryKeyPermissionCheck {
    default_ = 0,
    readSubTree = 1,
    readWriteSubTree = 2
}


export enum RegistryOptions {
    none = 0,
    volatile = 1
}


export enum RegistryValueKind {
    none = -1,
    unknown_ = 0,
    string_ = 1,
    expandString = 2,
    binary = 3,
    dWord = 4,
    multiString = 7,
    qWord = 11
}


export enum RegistryValueOptions {
    none = 0,
    doNotExpandEnvironmentNames = 1
}


export enum RegistryView {
    default_ = 0,
    registry64 = 256,
    registry32 = 512
}


export interface RegistryKey$instance extends MarshalByRefObject {
    readonly handle: SafeRegistryHandle;
    readonly name: string;
    readonly subKeyCount: int;
    readonly valueCount: int;
    readonly view: RegistryView;
    close(): void;
    createSubKey(subkey: string): RegistryKey;
    createSubKey(subkey: string, permissionCheck: RegistryKeyPermissionCheck): RegistryKey;
    createSubKey(subkey: string, permissionCheck: RegistryKeyPermissionCheck, registryOptions: RegistryOptions): RegistryKey;
    createSubKey(subkey: string, permissionCheck: RegistryKeyPermissionCheck, registryOptions: RegistryOptions, registrySecurity: RegistrySecurity): RegistryKey;
    createSubKey(subkey: string, permissionCheck: RegistryKeyPermissionCheck, registrySecurity: RegistrySecurity): RegistryKey;
    createSubKey(subkey: string, writable: boolean): RegistryKey;
    createSubKey(subkey: string, writable: boolean, options: RegistryOptions): RegistryKey;
    deleteSubKey(subkey: string): void;
    deleteSubKey(subkey: string, throwOnMissingSubKey: boolean): void;
    deleteSubKeyTree(subkey: string): void;
    deleteSubKeyTree(subkey: string, throwOnMissingSubKey: boolean): void;
    deleteValue(name: string): void;
    deleteValue(name: string, throwOnMissingValue: boolean): void;
    dispose(): void;
    flush(): void;
    getAccessControl(): RegistrySecurity;
    getAccessControl(includeSections: AccessControlSections): RegistrySecurity;
    getSubKeyNames(): string[];
    getValue(name: string): unknown;
    getValue(name: string, defaultValue: unknown): unknown;
    getValue(name: string, defaultValue: unknown, options: RegistryValueOptions): unknown;
    getValueKind(name: string): RegistryValueKind;
    getValueNames(): string[];
    openSubKey(name: string): RegistryKey;
    openSubKey(name: string, permissionCheck: RegistryKeyPermissionCheck): RegistryKey;
    openSubKey(name: string, permissionCheck: RegistryKeyPermissionCheck, rights: RegistryRights): RegistryKey;
    openSubKey(name: string, writable: boolean): RegistryKey;
    openSubKey(name: string, rights: RegistryRights): RegistryKey;
    setAccessControl(registrySecurity: RegistrySecurity): void;
    setValue(name: string, value: unknown): void;
    setValue(name: string, value: unknown, valueKind: RegistryValueKind): void;
    toString(): string;
}


export const RegistryKey: {
    new(): RegistryKey$instance;
    fromHandle(handle: SafeRegistryHandle, view: RegistryView): RegistryKey;
    fromHandle(handle: SafeRegistryHandle): RegistryKey;
    openBaseKey(hKey: RegistryHive, view: RegistryView): RegistryKey;
    openRemoteBaseKey(hKey: RegistryHive, machineName: string, view: RegistryView): RegistryKey;
    openRemoteBaseKey(hKey: RegistryHive, machineName: string): RegistryKey;
};


export interface __RegistryKey$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface RegistryKey$instance extends System_Internal.IDisposable$instance {}

export type RegistryKey = RegistryKey$instance & __RegistryKey$views;


export abstract class Registry$instance {
    static readonly classesRoot: RegistryKey;
    static readonly currentConfig: RegistryKey;
    static readonly currentUser: RegistryKey;
    static readonly localMachine: RegistryKey;
    static readonly performanceData: RegistryKey;
    static readonly users: RegistryKey;
    static getValue(keyName: string, valueName: string, defaultValue: unknown): unknown;
    static setValue(keyName: string, valueName: string, value: unknown, valueKind: RegistryValueKind): void;
    static setValue(keyName: string, valueName: string, value: unknown): void;
}


export type Registry = Registry$instance;

