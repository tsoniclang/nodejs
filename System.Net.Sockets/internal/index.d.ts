// Generated by tsbindgen - Architecture
// Namespace: System.Net.Sockets
// Assembly: System.Net.Primitives, System.Net.Sockets

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as Microsoft_Win32_SafeHandles_Internal from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import type { SafeHandleMinusOneIsInvalid } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import type { IList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { IDictionary, IList } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { Win32Exception } from "../../System.ComponentModel/internal/index.js";
import * as System_IO_Internal from "../../System.IO/internal/index.js";
import type { FileAccess, FileStream, SeekOrigin, Stream } from "../../System.IO/internal/index.js";
import * as System_Net_Internal from "../../System.Net/internal/index.js";
import type { EndPoint, IPAddress, IPEndPoint, SocketAddress } from "../../System.Net/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ArraySegment_1, AsyncCallback, Boolean as ClrBoolean, Byte, Enum, EventArgs, EventHandler_1, Exception, IAsyncDisposable, IAsyncResult, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, Memory_1, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, Span_1, String as ClrString, TimeSpan, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum AddressFamily {
    unknown_ = -1,
    unspecified = 0,
    unix = 1,
    interNetwork = 2,
    impLink = 3,
    pup = 4,
    chaos = 5,
    NS = 6,
    ipx = 6,
    iso = 7,
    osi = 7,
    ecma = 8,
    dataKit = 9,
    ccitt = 10,
    sna = 11,
    decNet = 12,
    dataLink = 13,
    lat = 14,
    hyperChannel = 15,
    appleTalk = 16,
    netBios = 17,
    voiceView = 18,
    fireFox = 19,
    banyan = 21,
    atm = 22,
    interNetworkV6 = 23,
    cluster = 24,
    ieee12844 = 25,
    irda = 26,
    networkDesigners = 28,
    max = 29,
    packet = 65536,
    controllerAreaNetwork = 65537
}


export enum IOControlCode {
    asyncIO = 2147772029,
    nonBlockingIO = 2147772030,
    dataToRead = 1074030207,
    oobDataRead = 1074033415,
    associateHandle = 2281701377,
    enableCircularQueuing = 671088642,
    flush = 671088644,
    getBroadcastAddress = 1207959557,
    getExtensionFunctionPointer = 3355443206,
    getQos = 3355443207,
    getGroupQos = 3355443208,
    multipointLoopback = 2281701385,
    multicastScope = 2281701386,
    setQos = 2281701387,
    setGroupQos = 2281701388,
    translateHandle = 3355443213,
    routingInterfaceQuery = 3355443220,
    routingInterfaceChange = 2281701397,
    addressListQuery = 1207959574,
    addressListChange = 671088663,
    queryTargetPnpHandle = 1207959576,
    namespaceChange = 2281701401,
    addressListSort = 3355443225,
    receiveAll = 2550136833,
    receiveAllMulticast = 2550136834,
    receiveAllIgmpMulticast = 2550136835,
    keepAliveValues = 2550136836,
    absorbRouterAlert = 2550136837,
    unicastInterface = 2550136838,
    limitBroadcasts = 2550136839,
    bindToInterface = 2550136840,
    multicastInterface = 2550136841,
    addMulticastGroupOnInterface = 2550136842,
    deleteMulticastGroupFromInterface = 2550136843
}


export enum IPProtectionLevel {
    unspecified = -1,
    unrestricted = 10,
    edgeRestricted = 20,
    restricted = 30
}


export enum ProtocolFamily {
    unknown_ = -1,
    unspecified = 0,
    unix = 1,
    interNetwork = 2,
    impLink = 3,
    pup = 4,
    chaos = 5,
    NS = 6,
    ipx = 6,
    iso = 7,
    osi = 7,
    ecma = 8,
    dataKit = 9,
    ccitt = 10,
    sna = 11,
    decNet = 12,
    dataLink = 13,
    lat = 14,
    hyperChannel = 15,
    appleTalk = 16,
    netBios = 17,
    voiceView = 18,
    fireFox = 19,
    banyan = 21,
    atm = 22,
    interNetworkV6 = 23,
    cluster = 24,
    ieee12844 = 25,
    irda = 26,
    networkDesigners = 28,
    max = 29,
    packet = 65536,
    controllerAreaNetwork = 65537
}


export enum ProtocolType {
    IP = 0,
    iPv6HopByHopOptions = 0,
    icmp = 1,
    igmp = 2,
    ggp = 3,
    iPv4 = 4,
    tcp = 6,
    pup = 12,
    udp = 17,
    idp = 22,
    iPv6 = 41,
    iPv6RoutingHeader = 43,
    iPv6FragmentHeader = 44,
    ipSecEncapsulatingSecurityPayload = 50,
    ipSecAuthenticationHeader = 51,
    icmpV6 = 58,
    iPv6NoNextHeader = 59,
    iPv6DestinationOptions = 60,
    ND = 77,
    raw = 255,
    unspecified = 0,
    ipx = 1000,
    spx = 1256,
    spxII = 1257,
    unknown_ = -1
}


export enum SelectMode {
    selectRead = 0,
    selectWrite = 1,
    selectError = 2
}


export enum SocketAsyncOperation {
    none = 0,
    accept = 1,
    connect = 2,
    disconnect = 3,
    receive = 4,
    receiveFrom = 5,
    receiveMessageFrom = 6,
    send = 7,
    sendPackets = 8,
    sendTo = 9
}


export enum SocketError {
    success = 0,
    socketError = -1,
    interrupted = 10004,
    accessDenied = 10013,
    fault = 10014,
    invalidArgument = 10022,
    tooManyOpenSockets = 10024,
    wouldBlock = 10035,
    inProgress = 10036,
    alreadyInProgress = 10037,
    notSocket = 10038,
    destinationAddressRequired = 10039,
    messageSize = 10040,
    protocolType = 10041,
    protocolOption = 10042,
    protocolNotSupported = 10043,
    socketNotSupported = 10044,
    operationNotSupported = 10045,
    protocolFamilyNotSupported = 10046,
    addressFamilyNotSupported = 10047,
    addressAlreadyInUse = 10048,
    addressNotAvailable = 10049,
    networkDown = 10050,
    networkUnreachable = 10051,
    networkReset = 10052,
    connectionAborted = 10053,
    connectionReset = 10054,
    noBufferSpaceAvailable = 10055,
    isConnected = 10056,
    notConnected = 10057,
    shutdown = 10058,
    timedOut = 10060,
    connectionRefused = 10061,
    hostDown = 10064,
    hostUnreachable = 10065,
    processLimit = 10067,
    systemNotReady = 10091,
    versionNotSupported = 10092,
    notInitialized = 10093,
    disconnecting = 10101,
    typeNotFound = 10109,
    hostNotFound = 11001,
    tryAgain = 11002,
    noRecovery = 11003,
    noData = 11004,
    ioPending = 997,
    operationAborted = 995
}


export enum SocketFlags {
    none = 0,
    outOfBand = 1,
    peek = 2,
    dontRoute = 4,
    truncated = 256,
    controlDataTruncated = 512,
    broadcast = 1024,
    multicast = 2048,
    partial = 32768
}


export enum SocketInformationOptions {
    nonBlocking = 1,
    connected = 2,
    listening = 4,
    useOnlyOverlappedIO = 8
}


export enum SocketOptionLevel {
    socket = 65535,
    IP = 0,
    iPv6 = 41,
    tcp = 6,
    udp = 17
}


export enum SocketOptionName {
    debug = 1,
    acceptConnection = 2,
    reuseAddress = 4,
    keepAlive = 8,
    dontRoute = 16,
    broadcast = 32,
    useLoopback = 64,
    linger = 128,
    outOfBandInline = 256,
    dontLinger = -129,
    exclusiveAddressUse = -5,
    sendBuffer = 4097,
    receiveBuffer = 4098,
    sendLowWater = 4099,
    receiveLowWater = 4100,
    sendTimeout = 4101,
    receiveTimeout = 4102,
    error = 4103,
    type_ = 4104,
    reuseUnicastPort = 12295,
    maxConnections = 2147483647,
    ipOptions = 1,
    headerIncluded = 2,
    typeOfService = 3,
    ipTimeToLive = 4,
    multicastInterface = 9,
    multicastTimeToLive = 10,
    multicastLoopback = 11,
    addMembership = 12,
    dropMembership = 13,
    dontFragment = 14,
    addSourceMembership = 15,
    dropSourceMembership = 16,
    blockSource = 17,
    unblockSource = 18,
    packetInformation = 19,
    hopLimit = 21,
    ipProtectionLevel = 23,
    iPv6Only = 27,
    noDelay = 1,
    bsdUrgent = 2,
    expedited = 2,
    fastOpen = 15,
    tcpKeepAliveRetryCount = 16,
    tcpKeepAliveTime = 3,
    tcpKeepAliveInterval = 17,
    noChecksum = 1,
    checksumCoverage = 20,
    updateAcceptContext = 28683,
    updateConnectContext = 28688
}


export enum SocketShutdown {
    receive = 0,
    send = 1,
    both = 2
}


export enum SocketType {
    stream = 1,
    dgram = 2,
    raw = 3,
    rdm = 4,
    seqpacket = 5,
    unknown_ = -1
}


export enum TransmitFileOptions {
    useDefaultWorkerThread = 0,
    disconnect = 1,
    reuseSocket = 2,
    writeBehind = 4,
    useSystemThread = 16,
    useKernelApc = 32
}


export interface IPPacketInformation$instance {
    readonly address: IPAddress;
    readonly interface_: int;
    equals(comparand: unknown): boolean;
    equals(other: IPPacketInformation): boolean;
    getHashCode(): int;
}


export const IPPacketInformation: {
    new(): IPPacketInformation$instance;
};


export interface __IPPacketInformation$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<IPPacketInformation>;

    // Structural method bridges for numeric interface constraints
    Equals(other: IPPacketInformation): boolean;
}

export type IPPacketInformation = IPPacketInformation$instance & __IPPacketInformation$views;


export interface SocketInformation$instance {
    options: SocketInformationOptions;
    protocolInformation: byte[];
}


export const SocketInformation: {
    new(): SocketInformation$instance;
};


export type SocketInformation = SocketInformation$instance;

export interface SocketReceiveFromResult$instance {
    receivedBytes: int;
    remoteEndPoint: EndPoint;
}


export const SocketReceiveFromResult: {
    new(): SocketReceiveFromResult$instance;
};


export type SocketReceiveFromResult = SocketReceiveFromResult$instance;

export interface SocketReceiveMessageFromResult$instance {
    receivedBytes: int;
    socketFlags: SocketFlags;
    remoteEndPoint: EndPoint;
    packetInformation: IPPacketInformation;
}


export const SocketReceiveMessageFromResult: {
    new(): SocketReceiveMessageFromResult$instance;
};


export type SocketReceiveMessageFromResult = SocketReceiveMessageFromResult$instance;

export interface UdpReceiveResult$instance {
    readonly buffer: byte[];
    readonly remoteEndPoint: IPEndPoint;
    equals(obj: unknown): boolean;
    equals(other: UdpReceiveResult): boolean;
    getHashCode(): int;
}


export const UdpReceiveResult: {
    new(buffer: byte[], remoteEndPoint: IPEndPoint): UdpReceiveResult$instance;
};


export interface __UdpReceiveResult$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<UdpReceiveResult>;

    // Structural method bridges for numeric interface constraints
    Equals(other: UdpReceiveResult): boolean;
}

export type UdpReceiveResult = UdpReceiveResult$instance & __UdpReceiveResult$views;


export interface IPv6MulticastOption$instance {
    group: IPAddress;
    interfaceIndex: long;
}


export const IPv6MulticastOption: {
    new(group: IPAddress, ifindex: long): IPv6MulticastOption$instance;
    new(group: IPAddress): IPv6MulticastOption$instance;
};


export type IPv6MulticastOption = IPv6MulticastOption$instance;

export interface LingerOption$instance {
    enabled: boolean;
    lingerTime: int;
    equals(comparand: unknown): boolean;
    getHashCode(): int;
}


export const LingerOption: {
    new(enable: boolean, seconds: int): LingerOption$instance;
};


export type LingerOption = LingerOption$instance;

export interface MulticastOption$instance {
    group: IPAddress;
    interfaceIndex: int;
    localAddress: IPAddress;
}


export const MulticastOption: {
    new(group: IPAddress, mcint: IPAddress): MulticastOption$instance;
    new(group: IPAddress, interfaceIndex: int): MulticastOption$instance;
    new(group: IPAddress): MulticastOption$instance;
};


export type MulticastOption = MulticastOption$instance;

export interface NetworkStream$instance extends Stream {
    readonly canRead: boolean;
    readonly canSeek: boolean;
    readonly canTimeout: boolean;
    readonly canWrite: boolean;
    readonly dataAvailable: boolean;
    readonly length: long;
    position: long;
    readTimeout: int;
    readonly socket: Socket;
    writeTimeout: int;
    beginRead(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginWrite(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    close(timeout: TimeSpan): void;
    close(): void;
    dispose(): void;
    disposeAsync(): ValueTask;
    endRead(asyncResult: IAsyncResult): int;
    endWrite(asyncResult: IAsyncResult): void;
    flush(): void;
    flushAsync(cancellationToken: CancellationToken): Task;
    flushAsync(): Task;
    read(buffer: byte[], offset: int, count: int): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readByte(): int;
    seek(offset: long, origin: SeekOrigin): long;
    setLength(value: long): void;
    write(buffer: byte[], offset: int, count: int): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    writeAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeAsync(buffer: byte[], offset: int, count: int): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeByte(value: byte): void;
}


export const NetworkStream: {
    new(socket: Socket): NetworkStream$instance;
    new(socket: Socket, ownsSocket: boolean): NetworkStream$instance;
    new(socket: Socket, access: FileAccess): NetworkStream$instance;
    new(socket: Socket, access: FileAccess, ownsSocket: boolean): NetworkStream$instance;
};


export interface __NetworkStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type NetworkStream = NetworkStream$instance & __NetworkStream$views;


export interface SafeSocketHandle$instance extends SafeHandleMinusOneIsInvalid {
    readonly isInvalid: boolean;
    dispose(): void;
}


export const SafeSocketHandle: {
    new(): SafeSocketHandle$instance;
    new(preexistingHandle: nint, ownsHandle: boolean): SafeSocketHandle$instance;
};


export interface __SafeSocketHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type SafeSocketHandle = SafeSocketHandle$instance & __SafeSocketHandle$views;


export interface SendPacketsElement$instance {
    readonly buffer: byte[];
    readonly count: int;
    readonly endOfPacket: boolean;
    readonly filePath: string;
    readonly fileStream: FileStream;
    readonly memoryBuffer: Nullable_1<ReadOnlyMemory_1<CLROf<byte>>>;
    readonly offset: int;
    readonly offsetLong: long;
}


export const SendPacketsElement: {
    new(filepath: string): SendPacketsElement$instance;
    new(filepath: string, offset: int, count: int): SendPacketsElement$instance;
    new(filepath: string, offset: int, count: int, endOfPacket: boolean): SendPacketsElement$instance;
    new(filepath: string, offset: long, count: int): SendPacketsElement$instance;
    new(filepath: string, offset: long, count: int, endOfPacket: boolean): SendPacketsElement$instance;
    new(fileStream: FileStream): SendPacketsElement$instance;
    new(fileStream: FileStream, offset: long, count: int): SendPacketsElement$instance;
    new(fileStream: FileStream, offset: long, count: int, endOfPacket: boolean): SendPacketsElement$instance;
    new(buffer: byte[]): SendPacketsElement$instance;
    new(buffer: byte[], offset: int, count: int): SendPacketsElement$instance;
    new(buffer: byte[], offset: int, count: int, endOfPacket: boolean): SendPacketsElement$instance;
    new(buffer: ReadOnlyMemory_1<CLROf<byte>>): SendPacketsElement$instance;
    new(buffer: ReadOnlyMemory_1<CLROf<byte>>, endOfPacket: boolean): SendPacketsElement$instance;
};


export type SendPacketsElement = SendPacketsElement$instance;

export interface Socket$instance {
    readonly addressFamily: AddressFamily;
    readonly available: int;
    blocking: boolean;
    readonly connected: boolean;
    dontFragment: boolean;
    dualMode: boolean;
    enableBroadcast: boolean;
    exclusiveAddressUse: boolean;
    readonly handle: nint;
    readonly isBound: boolean;
    lingerState: LingerOption;
    readonly localEndPoint: EndPoint;
    multicastLoopback: boolean;
    noDelay: boolean;
    readonly protocolType: ProtocolType;
    receiveBufferSize: int;
    receiveTimeout: int;
    readonly remoteEndPoint: EndPoint;
    readonly safeHandle: SafeSocketHandle;
    sendBufferSize: int;
    sendTimeout: int;
    readonly socketType: SocketType;
    ttl: short;
    useOnlyOverlappedIO: boolean;
    accept(): Socket;
    acceptAsync(e: SocketAsyncEventArgs): boolean;
    acceptAsync(): Task_1<Socket>;
    acceptAsync(cancellationToken: CancellationToken): ValueTask_1<Socket>;
    acceptAsync(acceptSocket: Socket): Task_1<Socket>;
    acceptAsync(acceptSocket: Socket, cancellationToken: CancellationToken): ValueTask_1<Socket>;
    beginAccept(callback: AsyncCallback, state: unknown): IAsyncResult;
    beginAccept(receiveSize: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginAccept(acceptSocket: Socket, receiveSize: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginConnect(remoteEP: EndPoint, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginConnect(host: string, port: int, requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    beginConnect(address: IPAddress, port: int, requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    beginConnect(addresses: IPAddress[], port: int, requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    beginDisconnect(reuseSocket: boolean, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginReceive(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginReceive(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags, errorCode: { value: ref<SocketError> }, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginReceive(buffers: IList_1<ArraySegment_1<CLROf<byte>>>, socketFlags: SocketFlags, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginReceive(buffers: IList_1<ArraySegment_1<CLROf<byte>>>, socketFlags: SocketFlags, errorCode: { value: ref<SocketError> }, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginReceiveFrom(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags, remoteEP: { value: ref<EndPoint> }, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginReceiveMessageFrom(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags, remoteEP: { value: ref<EndPoint> }, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginSend(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginSend(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags, errorCode: { value: ref<SocketError> }, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginSend(buffers: IList_1<ArraySegment_1<CLROf<byte>>>, socketFlags: SocketFlags, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginSend(buffers: IList_1<ArraySegment_1<CLROf<byte>>>, socketFlags: SocketFlags, errorCode: { value: ref<SocketError> }, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginSendFile(fileName: string, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginSendFile(fileName: string, preBuffer: byte[], postBuffer: byte[], flags: TransmitFileOptions, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginSendTo(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags, remoteEP: EndPoint, callback: AsyncCallback, state: unknown): IAsyncResult;
    bind(localEP: EndPoint): void;
    close(): void;
    close(timeout: int): void;
    connect(remoteEP: EndPoint): void;
    connect(address: IPAddress, port: int): void;
    connect(host: string, port: int): void;
    connect(addresses: IPAddress[], port: int): void;
    connectAsync(e: SocketAsyncEventArgs): boolean;
    connectAsync(remoteEP: EndPoint): Task;
    connectAsync(remoteEP: EndPoint, cancellationToken: CancellationToken): ValueTask;
    connectAsync(address: IPAddress, port: int): Task;
    connectAsync(address: IPAddress, port: int, cancellationToken: CancellationToken): ValueTask;
    connectAsync(addresses: IPAddress[], port: int): Task;
    connectAsync(addresses: IPAddress[], port: int, cancellationToken: CancellationToken): ValueTask;
    connectAsync(host: string, port: int): Task;
    connectAsync(host: string, port: int, cancellationToken: CancellationToken): ValueTask;
    disconnect(reuseSocket: boolean): void;
    disconnectAsync(e: SocketAsyncEventArgs): boolean;
    disconnectAsync(reuseSocket: boolean, cancellationToken?: CancellationToken): ValueTask;
    dispose(): void;
    duplicateAndClose(targetProcessId: int): SocketInformation;
    endAccept(asyncResult: IAsyncResult): Socket;
    endAccept(buffer: { value: ref<byte[]> }, asyncResult: IAsyncResult): Socket;
    endAccept(buffer: { value: ref<byte[]> }, bytesTransferred: { value: ref<int> }, asyncResult: IAsyncResult): Socket;
    endConnect(asyncResult: IAsyncResult): void;
    endDisconnect(asyncResult: IAsyncResult): void;
    endReceive(asyncResult: IAsyncResult): int;
    endReceive(asyncResult: IAsyncResult, errorCode: { value: ref<SocketError> }): int;
    endReceiveFrom(asyncResult: IAsyncResult, endPoint: { value: ref<EndPoint> }): int;
    endReceiveMessageFrom(asyncResult: IAsyncResult, socketFlags: { value: ref<SocketFlags> }, endPoint: { value: ref<EndPoint> }, ipPacketInformation: { value: ref<IPPacketInformation> }): int;
    endSend(asyncResult: IAsyncResult): int;
    endSend(asyncResult: IAsyncResult, errorCode: { value: ref<SocketError> }): int;
    endSendFile(asyncResult: IAsyncResult): void;
    endSendTo(asyncResult: IAsyncResult): int;
    getRawSocketOption(optionLevel: int, optionName: int, optionValue: Span_1<CLROf<byte>>): int;
    getSocketOption(optionLevel: SocketOptionLevel, optionName: SocketOptionName): unknown;
    getSocketOption(optionLevel: SocketOptionLevel, optionName: SocketOptionName, optionValue: byte[]): void;
    getSocketOption(optionLevel: SocketOptionLevel, optionName: SocketOptionName, optionLength: int): byte[];
    ioControl(ioControlCode: int, optionInValue: byte[], optionOutValue: byte[]): int;
    ioControl(ioControlCode: IOControlCode, optionInValue: byte[], optionOutValue: byte[]): int;
    listen(): void;
    listen(backlog: int): void;
    poll(microSeconds: int, mode: SelectMode): boolean;
    poll(timeout: TimeSpan, mode: SelectMode): boolean;
    receive(buffer: byte[], size: int, socketFlags: SocketFlags): int;
    receive(buffer: byte[], socketFlags: SocketFlags): int;
    receive(buffer: byte[]): int;
    receive(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags): int;
    receive(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags, errorCode: { value: ref<SocketError> }): int;
    receive(buffer: Span_1<CLROf<byte>>): int;
    receive(buffer: Span_1<CLROf<byte>>, socketFlags: SocketFlags): int;
    receive(buffer: Span_1<CLROf<byte>>, socketFlags: SocketFlags, errorCode: { value: ref<SocketError> }): int;
    receive(buffers: IList_1<ArraySegment_1<CLROf<byte>>>): int;
    receive(buffers: IList_1<ArraySegment_1<CLROf<byte>>>, socketFlags: SocketFlags): int;
    receive(buffers: IList_1<ArraySegment_1<CLROf<byte>>>, socketFlags: SocketFlags, errorCode: { value: ref<SocketError> }): int;
    receiveAsync(e: SocketAsyncEventArgs): boolean;
    receiveAsync(buffer: ArraySegment_1<CLROf<byte>>): Task_1<CLROf<int>>;
    receiveAsync(buffer: ArraySegment_1<CLROf<byte>>, socketFlags: SocketFlags): Task_1<CLROf<int>>;
    receiveAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    receiveAsync(buffer: Memory_1<CLROf<byte>>, socketFlags: SocketFlags, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    receiveAsync(buffers: IList_1<ArraySegment_1<CLROf<byte>>>): Task_1<CLROf<int>>;
    receiveAsync(buffers: IList_1<ArraySegment_1<CLROf<byte>>>, socketFlags: SocketFlags): Task_1<CLROf<int>>;
    receiveFrom(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags, remoteEP: { value: ref<EndPoint> }): int;
    receiveFrom(buffer: byte[], size: int, socketFlags: SocketFlags, remoteEP: { value: ref<EndPoint> }): int;
    receiveFrom(buffer: byte[], socketFlags: SocketFlags, remoteEP: { value: ref<EndPoint> }): int;
    receiveFrom(buffer: byte[], remoteEP: { value: ref<EndPoint> }): int;
    receiveFrom(buffer: Span_1<CLROf<byte>>, remoteEP: { value: ref<EndPoint> }): int;
    receiveFrom(buffer: Span_1<CLROf<byte>>, socketFlags: SocketFlags, remoteEP: { value: ref<EndPoint> }): int;
    receiveFrom(buffer: Span_1<CLROf<byte>>, socketFlags: SocketFlags, receivedAddress: SocketAddress): int;
    receiveFromAsync(e: SocketAsyncEventArgs): boolean;
    receiveFromAsync(buffer: ArraySegment_1<CLROf<byte>>, remoteEndPoint: EndPoint): Task_1<SocketReceiveFromResult>;
    receiveFromAsync(buffer: ArraySegment_1<CLROf<byte>>, socketFlags: SocketFlags, remoteEndPoint: EndPoint): Task_1<SocketReceiveFromResult>;
    receiveFromAsync(buffer: Memory_1<CLROf<byte>>, remoteEndPoint: EndPoint, cancellationToken?: CancellationToken): ValueTask_1<SocketReceiveFromResult>;
    receiveFromAsync(buffer: Memory_1<CLROf<byte>>, socketFlags: SocketFlags, remoteEndPoint: EndPoint, cancellationToken?: CancellationToken): ValueTask_1<SocketReceiveFromResult>;
    receiveFromAsync(buffer: Memory_1<CLROf<byte>>, socketFlags: SocketFlags, receivedAddress: SocketAddress, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    receiveMessageFrom(buffer: byte[], offset: int, size: int, socketFlags: { value: ref<SocketFlags> }, remoteEP: { value: ref<EndPoint> }, ipPacketInformation: { value: ref<IPPacketInformation> }): int;
    receiveMessageFrom(buffer: Span_1<CLROf<byte>>, socketFlags: { value: ref<SocketFlags> }, remoteEP: { value: ref<EndPoint> }, ipPacketInformation: { value: ref<IPPacketInformation> }): int;
    receiveMessageFromAsync(e: SocketAsyncEventArgs): boolean;
    receiveMessageFromAsync(buffer: ArraySegment_1<CLROf<byte>>, remoteEndPoint: EndPoint): Task_1<SocketReceiveMessageFromResult>;
    receiveMessageFromAsync(buffer: ArraySegment_1<CLROf<byte>>, socketFlags: SocketFlags, remoteEndPoint: EndPoint): Task_1<SocketReceiveMessageFromResult>;
    receiveMessageFromAsync(buffer: Memory_1<CLROf<byte>>, remoteEndPoint: EndPoint, cancellationToken?: CancellationToken): ValueTask_1<SocketReceiveMessageFromResult>;
    receiveMessageFromAsync(buffer: Memory_1<CLROf<byte>>, socketFlags: SocketFlags, remoteEndPoint: EndPoint, cancellationToken?: CancellationToken): ValueTask_1<SocketReceiveMessageFromResult>;
    send(buffer: byte[], size: int, socketFlags: SocketFlags): int;
    send(buffer: byte[], socketFlags: SocketFlags): int;
    send(buffer: byte[]): int;
    send(buffers: IList_1<ArraySegment_1<CLROf<byte>>>): int;
    send(buffers: IList_1<ArraySegment_1<CLROf<byte>>>, socketFlags: SocketFlags): int;
    send(buffers: IList_1<ArraySegment_1<CLROf<byte>>>, socketFlags: SocketFlags, errorCode: { value: ref<SocketError> }): int;
    send(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags): int;
    send(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags, errorCode: { value: ref<SocketError> }): int;
    send(buffer: ReadOnlySpan_1<CLROf<byte>>): int;
    send(buffer: ReadOnlySpan_1<CLROf<byte>>, socketFlags: SocketFlags): int;
    send(buffer: ReadOnlySpan_1<CLROf<byte>>, socketFlags: SocketFlags, errorCode: { value: ref<SocketError> }): int;
    sendAsync(e: SocketAsyncEventArgs): boolean;
    sendAsync(buffer: ArraySegment_1<CLROf<byte>>): Task_1<CLROf<int>>;
    sendAsync(buffer: ArraySegment_1<CLROf<byte>>, socketFlags: SocketFlags): Task_1<CLROf<int>>;
    sendAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    sendAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, socketFlags: SocketFlags, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    sendAsync(buffers: IList_1<ArraySegment_1<CLROf<byte>>>): Task_1<CLROf<int>>;
    sendAsync(buffers: IList_1<ArraySegment_1<CLROf<byte>>>, socketFlags: SocketFlags): Task_1<CLROf<int>>;
    sendFile(fileName: string): void;
    sendFile(fileName: string, preBuffer: byte[], postBuffer: byte[], flags: TransmitFileOptions): void;
    sendFile(fileName: string, preBuffer: ReadOnlySpan_1<CLROf<byte>>, postBuffer: ReadOnlySpan_1<CLROf<byte>>, flags: TransmitFileOptions): void;
    sendFileAsync(fileName: string, cancellationToken?: CancellationToken): ValueTask;
    sendFileAsync(fileName: string, preBuffer: ReadOnlyMemory_1<CLROf<byte>>, postBuffer: ReadOnlyMemory_1<CLROf<byte>>, flags: TransmitFileOptions, cancellationToken?: CancellationToken): ValueTask;
    sendPacketsAsync(e: SocketAsyncEventArgs): boolean;
    sendTo(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags, remoteEP: EndPoint): int;
    sendTo(buffer: byte[], size: int, socketFlags: SocketFlags, remoteEP: EndPoint): int;
    sendTo(buffer: byte[], socketFlags: SocketFlags, remoteEP: EndPoint): int;
    sendTo(buffer: byte[], remoteEP: EndPoint): int;
    sendTo(buffer: ReadOnlySpan_1<CLROf<byte>>, remoteEP: EndPoint): int;
    sendTo(buffer: ReadOnlySpan_1<CLROf<byte>>, socketFlags: SocketFlags, remoteEP: EndPoint): int;
    sendTo(buffer: ReadOnlySpan_1<CLROf<byte>>, socketFlags: SocketFlags, socketAddress: SocketAddress): int;
    sendToAsync(e: SocketAsyncEventArgs): boolean;
    sendToAsync(buffer: ArraySegment_1<CLROf<byte>>, remoteEP: EndPoint): Task_1<CLROf<int>>;
    sendToAsync(buffer: ArraySegment_1<CLROf<byte>>, socketFlags: SocketFlags, remoteEP: EndPoint): Task_1<CLROf<int>>;
    sendToAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, remoteEP: EndPoint, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    sendToAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, socketFlags: SocketFlags, remoteEP: EndPoint, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    sendToAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, socketFlags: SocketFlags, socketAddress: SocketAddress, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    setIPProtectionLevel(level: IPProtectionLevel): void;
    setRawSocketOption(optionLevel: int, optionName: int, optionValue: ReadOnlySpan_1<CLROf<byte>>): void;
    setSocketOption(optionLevel: SocketOptionLevel, optionName: SocketOptionName, optionValue: int): void;
    setSocketOption(optionLevel: SocketOptionLevel, optionName: SocketOptionName, optionValue: byte[]): void;
    setSocketOption(optionLevel: SocketOptionLevel, optionName: SocketOptionName, optionValue: boolean): void;
    setSocketOption(optionLevel: SocketOptionLevel, optionName: SocketOptionName, optionValue: unknown): void;
    shutdown(how: SocketShutdown): void;
}


export const Socket: {
    new(socketType: SocketType, protocolType: ProtocolType): Socket$instance;
    new(addressFamily: AddressFamily, socketType: SocketType, protocolType: ProtocolType): Socket$instance;
    new(handle: SafeSocketHandle): Socket$instance;
    new(socketInformation: SocketInformation): Socket$instance;
    readonly supportsIPv4: boolean;
    readonly supportsIPv6: boolean;
    readonly osSupportsIPv4: boolean;
    readonly osSupportsIPv6: boolean;
    readonly osSupportsUnixDomainSockets: boolean;
    cancelConnectAsync(e: SocketAsyncEventArgs): void;
    connectAsync(socketType: SocketType, protocolType: ProtocolType, e: SocketAsyncEventArgs): boolean;
    select(checkRead: IList, checkWrite: IList, checkError: IList, microSeconds: int): void;
    select(checkRead: IList, checkWrite: IList, checkError: IList, timeout: TimeSpan): void;
};


export interface __Socket$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Socket$instance extends System_Internal.IDisposable$instance {}

export type Socket = Socket$instance & __Socket$views;


export interface SocketAsyncEventArgs$instance extends EventArgs {
    acceptSocket: Socket;
    readonly buffer: byte[];
    bufferList: IList_1<ArraySegment_1<CLROf<byte>>>;
    readonly bytesTransferred: int;
    readonly connectByNameError: Exception;
    readonly connectSocket: Socket;
    readonly count: int;
    disconnectReuseSocket: boolean;
    readonly lastOperation: SocketAsyncOperation;
    readonly memoryBuffer: Memory_1<CLROf<byte>>;
    readonly offset: int;
    readonly receiveMessageFromPacketInfo: IPPacketInformation;
    remoteEndPoint: EndPoint;
    sendPacketsElements: SendPacketsElement[];
    sendPacketsFlags: TransmitFileOptions;
    sendPacketsSendSize: int;
    socketError: SocketError;
    socketFlags: SocketFlags;
    userToken: unknown;
    dispose(): void;
    setBuffer(offset: int, count: int): void;
    setBuffer(buffer: byte[], offset: int, count: int): void;
    setBuffer(buffer: Memory_1<CLROf<byte>>): void;
}


export const SocketAsyncEventArgs: {
    new(): SocketAsyncEventArgs$instance;
    new(unsafeSuppressExecutionContextFlow: boolean): SocketAsyncEventArgs$instance;
};


export interface __SocketAsyncEventArgs$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface SocketAsyncEventArgs$instance extends System_Internal.IDisposable$instance {}

export type SocketAsyncEventArgs = SocketAsyncEventArgs$instance & __SocketAsyncEventArgs$views;


export interface SocketException$instance extends Win32Exception {
    readonly errorCode: int;
    readonly message: string;
    readonly socketErrorCode: SocketError;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SocketException: {
    new(errorCode: int): SocketException$instance;
    new(errorCode: int, message: string): SocketException$instance;
    new(): SocketException$instance;
};


export interface __SocketException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SocketException = SocketException$instance & __SocketException$views;


export interface TcpClient$instance {
    readonly available: int;
    client: Socket;
    readonly connected: boolean;
    exclusiveAddressUse: boolean;
    lingerState: LingerOption;
    noDelay: boolean;
    receiveBufferSize: int;
    receiveTimeout: int;
    sendBufferSize: int;
    sendTimeout: int;
    beginConnect(address: IPAddress, port: int, requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    beginConnect(host: string, port: int, requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    beginConnect(addresses: IPAddress[], port: int, requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    close(): void;
    connect(hostname: string, port: int): void;
    connect(address: IPAddress, port: int): void;
    connect(remoteEP: IPEndPoint): void;
    connect(ipAddresses: IPAddress[], port: int): void;
    connectAsync(address: IPAddress, port: int): Task;
    connectAsync(host: string, port: int): Task;
    connectAsync(addresses: IPAddress[], port: int): Task;
    connectAsync(remoteEP: IPEndPoint): Task;
    connectAsync(address: IPAddress, port: int, cancellationToken: CancellationToken): ValueTask;
    connectAsync(host: string, port: int, cancellationToken: CancellationToken): ValueTask;
    connectAsync(addresses: IPAddress[], port: int, cancellationToken: CancellationToken): ValueTask;
    connectAsync(remoteEP: IPEndPoint, cancellationToken: CancellationToken): ValueTask;
    dispose(): void;
    endConnect(asyncResult: IAsyncResult): void;
    getStream(): NetworkStream;
}


export const TcpClient: {
    new(): TcpClient$instance;
    new(family: AddressFamily): TcpClient$instance;
    new(localEP: IPEndPoint): TcpClient$instance;
    new(hostname: string, port: int): TcpClient$instance;
};


export interface __TcpClient$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface TcpClient$instance extends System_Internal.IDisposable$instance {}

export type TcpClient = TcpClient$instance & __TcpClient$views;


export interface TcpListener$instance {
    exclusiveAddressUse: boolean;
    readonly localEndpoint: EndPoint;
    readonly server: Socket;
    acceptSocket(): Socket;
    acceptSocketAsync(): Task_1<Socket>;
    acceptSocketAsync(cancellationToken: CancellationToken): ValueTask_1<Socket>;
    acceptTcpClient(): TcpClient;
    acceptTcpClientAsync(): Task_1<TcpClient>;
    acceptTcpClientAsync(cancellationToken: CancellationToken): ValueTask_1<TcpClient>;
    allowNatTraversal(allowed: boolean): void;
    beginAcceptSocket(callback: AsyncCallback, state: unknown): IAsyncResult;
    beginAcceptTcpClient(callback: AsyncCallback, state: unknown): IAsyncResult;
    dispose(): void;
    endAcceptSocket(asyncResult: IAsyncResult): Socket;
    endAcceptTcpClient(asyncResult: IAsyncResult): TcpClient;
    pending(): boolean;
    start(): void;
    start(backlog: int): void;
    stop(): void;
}


export const TcpListener: {
    new(localEP: IPEndPoint): TcpListener$instance;
    new(localaddr: IPAddress, port: int): TcpListener$instance;
    new(port: int): TcpListener$instance;
    create(port: int): TcpListener;
};


export interface __TcpListener$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface TcpListener$instance extends System_Internal.IDisposable$instance {}

export type TcpListener = TcpListener$instance & __TcpListener$views;


export interface UdpClient$instance {
    readonly available: int;
    client: Socket;
    dontFragment: boolean;
    enableBroadcast: boolean;
    exclusiveAddressUse: boolean;
    multicastLoopback: boolean;
    ttl: short;
    allowNatTraversal(allowed: boolean): void;
    beginReceive(requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    beginSend(datagram: byte[], bytes: int, requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    beginSend(datagram: byte[], bytes: int, hostname: string, port: int, requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    beginSend(datagram: byte[], bytes: int, endPoint: IPEndPoint, requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    close(): void;
    connect(hostname: string, port: int): void;
    connect(addr: IPAddress, port: int): void;
    connect(endPoint: IPEndPoint): void;
    dispose(): void;
    dropMulticastGroup(multicastAddr: IPAddress): void;
    dropMulticastGroup(multicastAddr: IPAddress, ifindex: int): void;
    endReceive(asyncResult: IAsyncResult, remoteEP: { value: ref<IPEndPoint> }): byte[];
    endSend(asyncResult: IAsyncResult): int;
    joinMulticastGroup(multicastAddr: IPAddress): void;
    joinMulticastGroup(multicastAddr: IPAddress, localAddress: IPAddress): void;
    joinMulticastGroup(ifindex: int, multicastAddr: IPAddress): void;
    joinMulticastGroup(multicastAddr: IPAddress, timeToLive: int): void;
    receive(remoteEP: { value: ref<IPEndPoint> }): byte[];
    receiveAsync(): Task_1<UdpReceiveResult>;
    receiveAsync(cancellationToken: CancellationToken): ValueTask_1<UdpReceiveResult>;
    send(dgram: byte[], bytes: int, endPoint: IPEndPoint): int;
    send(datagram: ReadOnlySpan_1<CLROf<byte>>, endPoint: IPEndPoint): int;
    send(dgram: byte[], bytes: int, hostname: string, port: int): int;
    send(datagram: ReadOnlySpan_1<CLROf<byte>>, hostname: string, port: int): int;
    send(dgram: byte[], bytes: int): int;
    send(datagram: ReadOnlySpan_1<CLROf<byte>>): int;
    sendAsync(datagram: byte[], bytes: int): Task_1<CLROf<int>>;
    sendAsync(datagram: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    sendAsync(datagram: byte[], bytes: int, hostname: string, port: int): Task_1<CLROf<int>>;
    sendAsync(datagram: ReadOnlyMemory_1<CLROf<byte>>, hostname: string, port: int, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    sendAsync(datagram: byte[], bytes: int, endPoint: IPEndPoint): Task_1<CLROf<int>>;
    sendAsync(datagram: ReadOnlyMemory_1<CLROf<byte>>, endPoint: IPEndPoint, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
}


export const UdpClient: {
    new(): UdpClient$instance;
    new(family: AddressFamily): UdpClient$instance;
    new(port: int): UdpClient$instance;
    new(port: int, family: AddressFamily): UdpClient$instance;
    new(localEP: IPEndPoint): UdpClient$instance;
    new(hostname: string, port: int): UdpClient$instance;
};


export interface __UdpClient$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface UdpClient$instance extends System_Internal.IDisposable$instance {}

export type UdpClient = UdpClient$instance & __UdpClient$views;


export interface UnixDomainSocketEndPoint$instance extends EndPoint {
    readonly addressFamily: AddressFamily;
    create(socketAddress: SocketAddress): EndPoint;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    serialize(): SocketAddress;
    toString(): string;
}


export const UnixDomainSocketEndPoint: {
    new(path: string): UnixDomainSocketEndPoint$instance;
};


export type UnixDomainSocketEndPoint = UnixDomainSocketEndPoint$instance;

export abstract class SocketTaskExtensions$instance {
    static acceptAsync(socket: Socket, acceptSocket: Socket): Task_1<Socket>;
    static acceptAsync(socket: Socket): Task_1<Socket>;
    static connectAsync(socket: Socket, remoteEP: EndPoint, cancellationToken: CancellationToken): ValueTask;
    static connectAsync(socket: Socket, remoteEP: EndPoint): Task;
    static connectAsync(socket: Socket, address: IPAddress, port: int, cancellationToken: CancellationToken): ValueTask;
    static connectAsync(socket: Socket, address: IPAddress, port: int): Task;
    static connectAsync(socket: Socket, addresses: IPAddress[], port: int, cancellationToken: CancellationToken): ValueTask;
    static connectAsync(socket: Socket, addresses: IPAddress[], port: int): Task;
    static connectAsync(socket: Socket, host: string, port: int, cancellationToken: CancellationToken): ValueTask;
    static connectAsync(socket: Socket, host: string, port: int): Task;
    static receiveAsync(socket: Socket, buffer: ArraySegment_1<CLROf<byte>>, socketFlags: SocketFlags): Task_1<CLROf<int>>;
    static receiveAsync(socket: Socket, buffers: IList_1<ArraySegment_1<CLROf<byte>>>, socketFlags: SocketFlags): Task_1<CLROf<int>>;
    static receiveAsync(socket: Socket, buffer: Memory_1<CLROf<byte>>, socketFlags: SocketFlags, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static receiveFromAsync(socket: Socket, buffer: ArraySegment_1<CLROf<byte>>, socketFlags: SocketFlags, remoteEndPoint: EndPoint): Task_1<SocketReceiveFromResult>;
    static receiveMessageFromAsync(socket: Socket, buffer: ArraySegment_1<CLROf<byte>>, socketFlags: SocketFlags, remoteEndPoint: EndPoint): Task_1<SocketReceiveMessageFromResult>;
    static sendAsync(socket: Socket, buffer: ArraySegment_1<CLROf<byte>>, socketFlags: SocketFlags): Task_1<CLROf<int>>;
    static sendAsync(socket: Socket, buffers: IList_1<ArraySegment_1<CLROf<byte>>>, socketFlags: SocketFlags): Task_1<CLROf<int>>;
    static sendAsync(socket: Socket, buffer: ReadOnlyMemory_1<CLROf<byte>>, socketFlags: SocketFlags, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static sendToAsync(socket: Socket, buffer: ArraySegment_1<CLROf<byte>>, socketFlags: SocketFlags, remoteEP: EndPoint): Task_1<CLROf<int>>;
}


export type SocketTaskExtensions = SocketTaskExtensions$instance;

