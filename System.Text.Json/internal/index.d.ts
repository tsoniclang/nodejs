// Generated by tsbindgen - Architecture
// Namespace: System.Text.Json
// Assembly: System.Text.Json

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { IBufferWriter_1, ReadOnlySequence_1 } from "../../System.Buffers/internal/index.js";
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { IAsyncEnumerable_1, IEnumerable_1, IEnumerator_1, IList_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { PipeReader, PipeWriter } from "../../System.IO.Pipelines/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { JavaScriptEncoder } from "../../System.Text.Encodings.Web/internal/index.js";
import type { JsonNode } from "../../System.Text.Json.Nodes/internal/index.js";
import type { IJsonTypeInfoResolver, JsonTypeInfo, JsonTypeInfo_1 } from "../../System.Text.Json.Serialization.Metadata/internal/index.js";
import type { JsonConverter, JsonIgnoreCondition, JsonNumberHandling, JsonObjectCreationHandling, JsonSerializerContext, JsonUnknownTypeHandling, JsonUnmappedMemberHandling, ReferenceHandler } from "../../System.Text.Json.Serialization/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Byte, Char, DateTime, DateTimeOffset, Decimal, Double, Enum, Exception, Guid, IAsyncDisposable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, ISpanFormattable, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, SByte, SequencePosition, Single, Span_1, String as ClrString, Type, TypeCode, UInt16, UInt32, UInt64, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum JsonCommentHandling {
    disallow = 0,
    skip = 1,
    allow = 2
}


export enum JsonSerializerDefaults {
    general = 0,
    web = 1,
    strict = 2
}


export enum JsonTokenType {
    none = 0,
    startObject = 1,
    endObject = 2,
    startArray = 3,
    endArray = 4,
    propertyName = 5,
    comment = 6,
    string_ = 7,
    number_ = 8,
    true_ = 9,
    false_ = 10,
    null_ = 11
}


export enum JsonValueKind {
    undefined = 0,
    object_ = 1,
    array = 2,
    string_ = 3,
    number_ = 4,
    true_ = 5,
    false_ = 6,
    null_ = 7
}


export interface JsonDocumentOptions$instance {
    allowDuplicateProperties: boolean;
    allowTrailingCommas: boolean;
    commentHandling: JsonCommentHandling;
    maxDepth: int;
}


export const JsonDocumentOptions: {
    new(): JsonDocumentOptions$instance;
};


export type JsonDocumentOptions = JsonDocumentOptions$instance;

export interface JsonElement$instance {
    readonly item: JsonElement;
    readonly valueKind: JsonValueKind;
    clone(): JsonElement;
    enumerateArray(): JsonElement_ArrayEnumerator;
    enumerateObject(): JsonElement_ObjectEnumerator;
    getArrayLength(): int;
    getBoolean(): boolean;
    getByte(): byte;
    getBytesFromBase64(): byte[];
    getDateTime(): DateTime;
    getDateTimeOffset(): DateTimeOffset;
    getDecimal(): decimal;
    getDouble(): double;
    getGuid(): Guid;
    getInt16(): short;
    getInt32(): int;
    getInt64(): long;
    getProperty(propertyName: string): JsonElement;
    getProperty(propertyName: ReadOnlySpan_1<CLROf<char>>): JsonElement;
    getProperty(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>): JsonElement;
    getPropertyCount(): int;
    getRawText(): string;
    getSByte(): sbyte;
    getSingle(): float;
    getString(): string;
    getUInt16(): ushort;
    getUInt32(): uint;
    getUInt64(): ulong;
    toString(): string;
    tryGetByte(value: { value: ref<byte> }): boolean;
    tryGetBytesFromBase64(value: { value: ref<byte[]> }): boolean;
    tryGetDateTime(value: { value: ref<DateTime> }): boolean;
    tryGetDateTimeOffset(value: { value: ref<DateTimeOffset> }): boolean;
    tryGetDecimal(value: { value: ref<decimal> }): boolean;
    tryGetDouble(value: { value: ref<double> }): boolean;
    tryGetGuid(value: { value: ref<Guid> }): boolean;
    tryGetInt16(value: { value: ref<short> }): boolean;
    tryGetInt32(value: { value: ref<int> }): boolean;
    tryGetInt64(value: { value: ref<long> }): boolean;
    tryGetProperty(propertyName: string, value: { value: ref<JsonElement> }): boolean;
    tryGetProperty(propertyName: ReadOnlySpan_1<CLROf<char>>, value: { value: ref<JsonElement> }): boolean;
    tryGetProperty(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: { value: ref<JsonElement> }): boolean;
    tryGetSByte(value: { value: ref<sbyte> }): boolean;
    tryGetSingle(value: { value: ref<float> }): boolean;
    tryGetUInt16(value: { value: ref<ushort> }): boolean;
    tryGetUInt32(value: { value: ref<uint> }): boolean;
    tryGetUInt64(value: { value: ref<ulong> }): boolean;
    valueEquals(text: string): boolean;
    valueEquals(utf8Text: ReadOnlySpan_1<CLROf<byte>>): boolean;
    valueEquals(text: ReadOnlySpan_1<CLROf<char>>): boolean;
    writeTo(writer: Utf8JsonWriter): void;
}


export const JsonElement: {
    new(): JsonElement$instance;
    deepEquals(element1: JsonElement, element2: JsonElement): boolean;
    parse(utf8Json: ReadOnlySpan_1<CLROf<byte>>, options?: JsonDocumentOptions): JsonElement;
    parse(json: ReadOnlySpan_1<CLROf<char>>, options?: JsonDocumentOptions): JsonElement;
    parse(json: string, options?: JsonDocumentOptions): JsonElement;
    parseValue(reader: { value: ref<Utf8JsonReader> }): JsonElement;
    tryParseValue(reader: { value: ref<Utf8JsonReader> }, element: { value: ref<Nullable_1<JsonElement>> }): boolean;
};


export type JsonElement = JsonElement$instance;

export interface JsonElement_ArrayEnumerator$instance extends IDisposable {
    readonly current: JsonElement;
    dispose(): void;
    getEnumerator(): JsonElement_ArrayEnumerator;
    moveNext(): boolean;
    reset(): void;
}


export const JsonElement_ArrayEnumerator: {
    new(): JsonElement_ArrayEnumerator$instance;
};


export interface __JsonElement_ArrayEnumerator$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<JsonElement>;
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<JsonElement>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type JsonElement_ArrayEnumerator = JsonElement_ArrayEnumerator$instance & __JsonElement_ArrayEnumerator$views;


export interface JsonElement_ObjectEnumerator$instance extends IDisposable {
    readonly current: JsonProperty;
    dispose(): void;
    getEnumerator(): JsonElement_ObjectEnumerator;
    moveNext(): boolean;
    reset(): void;
}


export const JsonElement_ObjectEnumerator: {
    new(): JsonElement_ObjectEnumerator$instance;
};


export interface __JsonElement_ObjectEnumerator$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<JsonProperty>;
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<JsonProperty>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type JsonElement_ObjectEnumerator = JsonElement_ObjectEnumerator$instance & __JsonElement_ObjectEnumerator$views;


export interface JsonEncodedText$instance {
    readonly encodedUtf8Bytes: ReadOnlySpan_1<CLROf<byte>>;
    readonly value: string;
    equals(other: JsonEncodedText): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const JsonEncodedText: {
    new(): JsonEncodedText$instance;
    encode(utf8Value: ReadOnlySpan_1<CLROf<byte>>, encoder?: JavaScriptEncoder): JsonEncodedText;
    encode(value: ReadOnlySpan_1<CLROf<char>>, encoder?: JavaScriptEncoder): JsonEncodedText;
    encode(value: string, encoder?: JavaScriptEncoder): JsonEncodedText;
};


export interface __JsonEncodedText$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<JsonEncodedText>;

    // Structural method bridges for numeric interface constraints
    Equals(other: JsonEncodedText): boolean;
}

export type JsonEncodedText = JsonEncodedText$instance & __JsonEncodedText$views;


export interface JsonProperty$instance {
    readonly name: string;
    readonly value: JsonElement;
    nameEquals(text: string): boolean;
    nameEquals(utf8Text: ReadOnlySpan_1<CLROf<byte>>): boolean;
    nameEquals(text: ReadOnlySpan_1<CLROf<char>>): boolean;
    toString(): string;
    writeTo(writer: Utf8JsonWriter): void;
}


export const JsonProperty: {
    new(): JsonProperty$instance;
};


export type JsonProperty = JsonProperty$instance;

export interface JsonReaderOptions$instance {
    allowMultipleValues: boolean;
    allowTrailingCommas: boolean;
    commentHandling: JsonCommentHandling;
    maxDepth: int;
}


export const JsonReaderOptions: {
    new(): JsonReaderOptions$instance;
};


export type JsonReaderOptions = JsonReaderOptions$instance;

export interface JsonReaderState$instance {
    readonly options: JsonReaderOptions;
}


export const JsonReaderState: {
    new(options: JsonReaderOptions): JsonReaderState$instance;
};


export type JsonReaderState = JsonReaderState$instance;

export interface JsonWriterOptions$instance {
    encoder: JavaScriptEncoder;
    indentCharacter: char;
    indented: boolean;
    indentSize: int;
    maxDepth: int;
    newLine: string;
    skipValidation: boolean;
}


export const JsonWriterOptions: {
    new(): JsonWriterOptions$instance;
};


export type JsonWriterOptions = JsonWriterOptions$instance;

export interface Utf8JsonReader$instance {
    readonly bytesConsumed: long;
    readonly currentDepth: int;
    readonly currentState: JsonReaderState;
    readonly hasValueSequence: boolean;
    readonly isFinalBlock: boolean;
    readonly position: SequencePosition;
    readonly tokenStartIndex: long;
    readonly tokenType: JsonTokenType;
    readonly valueIsEscaped: boolean;
    readonly valueSequence: ReadOnlySequence_1<CLROf<byte>>;
    readonly valueSpan: ReadOnlySpan_1<CLROf<byte>>;
    copyString(utf8Destination: Span_1<CLROf<byte>>): int;
    copyString(destination: Span_1<CLROf<char>>): int;
    getBoolean(): boolean;
    getByte(): byte;
    getBytesFromBase64(): byte[];
    getComment(): string;
    getDateTime(): DateTime;
    getDateTimeOffset(): DateTimeOffset;
    getDecimal(): decimal;
    getDouble(): double;
    getGuid(): Guid;
    getInt16(): short;
    getInt32(): int;
    getInt64(): long;
    getSByte(): sbyte;
    getSingle(): float;
    getString(): string;
    getUInt16(): ushort;
    getUInt32(): uint;
    getUInt64(): ulong;
    read(): boolean;
    skip(): void;
    tryGetByte(value: { value: ref<byte> }): boolean;
    tryGetBytesFromBase64(value: { value: ref<byte[]> }): boolean;
    tryGetDateTime(value: { value: ref<DateTime> }): boolean;
    tryGetDateTimeOffset(value: { value: ref<DateTimeOffset> }): boolean;
    tryGetDecimal(value: { value: ref<decimal> }): boolean;
    tryGetDouble(value: { value: ref<double> }): boolean;
    tryGetGuid(value: { value: ref<Guid> }): boolean;
    tryGetInt16(value: { value: ref<short> }): boolean;
    tryGetInt32(value: { value: ref<int> }): boolean;
    tryGetInt64(value: { value: ref<long> }): boolean;
    tryGetSByte(value: { value: ref<sbyte> }): boolean;
    tryGetSingle(value: { value: ref<float> }): boolean;
    tryGetUInt16(value: { value: ref<ushort> }): boolean;
    tryGetUInt32(value: { value: ref<uint> }): boolean;
    tryGetUInt64(value: { value: ref<ulong> }): boolean;
    trySkip(): boolean;
    valueTextEquals(utf8Text: ReadOnlySpan_1<CLROf<byte>>): boolean;
    valueTextEquals(text: string): boolean;
    valueTextEquals(text: ReadOnlySpan_1<CLROf<char>>): boolean;
}


export const Utf8JsonReader: {
    new(jsonData: ReadOnlySpan_1<CLROf<byte>>, isFinalBlock: boolean, state: JsonReaderState): Utf8JsonReader$instance;
    new(jsonData: ReadOnlySpan_1<CLROf<byte>>, options: JsonReaderOptions): Utf8JsonReader$instance;
    new(jsonData: ReadOnlySequence_1<CLROf<byte>>, isFinalBlock: boolean, state: JsonReaderState): Utf8JsonReader$instance;
    new(jsonData: ReadOnlySequence_1<CLROf<byte>>, options: JsonReaderOptions): Utf8JsonReader$instance;
};


export type Utf8JsonReader = Utf8JsonReader$instance;

export interface JsonDocument$instance {
    readonly rootElement: JsonElement;
    dispose(): void;
    writeTo(writer: Utf8JsonWriter): void;
}


export const JsonDocument: {
    new(): JsonDocument$instance;
    parse(utf8Json: ReadOnlySequence_1<CLROf<byte>>, options?: JsonDocumentOptions): JsonDocument;
    parse(utf8Json: Stream, options?: JsonDocumentOptions): JsonDocument;
    parse(utf8Json: ReadOnlyMemory_1<CLROf<byte>>, options?: JsonDocumentOptions): JsonDocument;
    parse(json: ReadOnlyMemory_1<CLROf<char>>, options?: JsonDocumentOptions): JsonDocument;
    parse(json: string, options?: JsonDocumentOptions): JsonDocument;
    parseAsync(utf8Json: Stream, options?: JsonDocumentOptions, cancellationToken?: CancellationToken): Task_1<JsonDocument>;
    parseValue(reader: { value: ref<Utf8JsonReader> }): JsonDocument;
    tryParseValue(reader: { value: ref<Utf8JsonReader> }, document: { value: ref<JsonDocument> }): boolean;
};


export interface __JsonDocument$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface JsonDocument$instance extends System_Internal.IDisposable$instance {}

export type JsonDocument = JsonDocument$instance & __JsonDocument$views;


export interface JsonException$instance extends Exception {
    readonly bytePositionInLine: Nullable_1<CLROf<long>>;
    readonly lineNumber: Nullable_1<CLROf<long>>;
    readonly message: string;
    readonly path: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const JsonException: {
    new(message: string, path: string, lineNumber: Nullable_1<CLROf<long>>, bytePositionInLine: Nullable_1<CLROf<long>>, innerException: Exception): JsonException$instance;
    new(message: string, path: string, lineNumber: Nullable_1<CLROf<long>>, bytePositionInLine: Nullable_1<CLROf<long>>): JsonException$instance;
    new(message: string, innerException: Exception): JsonException$instance;
    new(message: string): JsonException$instance;
    new(): JsonException$instance;
};


export interface __JsonException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type JsonException = JsonException$instance & __JsonException$views;


export interface JsonNamingPolicy$instance {
    convertName(name: string): string;
}


export const JsonNamingPolicy: {
    readonly camelCase: JsonNamingPolicy;
    readonly snakeCaseLower: JsonNamingPolicy;
    readonly snakeCaseUpper: JsonNamingPolicy;
    readonly kebabCaseLower: JsonNamingPolicy;
    readonly kebabCaseUpper: JsonNamingPolicy;
};


export type JsonNamingPolicy = JsonNamingPolicy$instance;

export interface JsonSerializerOptions$instance {
    allowDuplicateProperties: boolean;
    allowOutOfOrderMetadataProperties: boolean;
    allowTrailingCommas: boolean;
    readonly converters: IList_1<JsonConverter>;
    defaultBufferSize: int;
    defaultIgnoreCondition: JsonIgnoreCondition;
    dictionaryKeyPolicy: JsonNamingPolicy;
    encoder: JavaScriptEncoder;
    ignoreNullValues: boolean;
    ignoreReadOnlyFields: boolean;
    ignoreReadOnlyProperties: boolean;
    includeFields: boolean;
    indentCharacter: char;
    indentSize: int;
    readonly isReadOnly: boolean;
    maxDepth: int;
    newLine: string;
    numberHandling: JsonNumberHandling;
    preferredObjectCreationHandling: JsonObjectCreationHandling;
    propertyNameCaseInsensitive: boolean;
    propertyNamingPolicy: JsonNamingPolicy;
    readCommentHandling: JsonCommentHandling;
    referenceHandler: ReferenceHandler;
    respectNullableAnnotations: boolean;
    respectRequiredConstructorParameters: boolean;
    typeInfoResolver: IJsonTypeInfoResolver;
    readonly typeInfoResolverChain: IList_1<IJsonTypeInfoResolver>;
    unknownTypeHandling: JsonUnknownTypeHandling;
    unmappedMemberHandling: JsonUnmappedMemberHandling;
    writeIndented: boolean;
    addContext<TContext extends JsonSerializerContext>(): void;
    getConverter(typeToConvert: Type): JsonConverter;
    getTypeInfo(type_: Type): JsonTypeInfo;
    makeReadOnly(): void;
    makeReadOnly(populateMissingResolver: boolean): void;
    tryGetTypeInfo(type_: Type, typeInfo: { value: ref<JsonTypeInfo> }): boolean;
}


export const JsonSerializerOptions: {
    new(): JsonSerializerOptions$instance;
    new(options: JsonSerializerOptions): JsonSerializerOptions$instance;
    new(defaults: JsonSerializerDefaults): JsonSerializerOptions$instance;
    readonly default_: JsonSerializerOptions;
    readonly web: JsonSerializerOptions;
    readonly strict: JsonSerializerOptions;
};


export type JsonSerializerOptions = JsonSerializerOptions$instance;

export interface Utf8JsonWriter$instance {
    readonly bytesCommitted: long;
    readonly bytesPending: int;
    readonly currentDepth: int;
    readonly options: JsonWriterOptions;
    dispose(): void;
    disposeAsync(): ValueTask;
    flush(): void;
    flushAsync(cancellationToken?: CancellationToken): Task;
    reset(): void;
    reset(utf8Json: Stream): void;
    reset(bufferWriter: IBufferWriter_1<CLROf<byte>>): void;
    writeBase64String(propertyName: JsonEncodedText, bytes: ReadOnlySpan_1<CLROf<byte>>): void;
    writeBase64String(propertyName: string, bytes: ReadOnlySpan_1<CLROf<byte>>): void;
    writeBase64String(propertyName: ReadOnlySpan_1<CLROf<char>>, bytes: ReadOnlySpan_1<CLROf<byte>>): void;
    writeBase64String(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, bytes: ReadOnlySpan_1<CLROf<byte>>): void;
    writeBase64StringSegment(value: ReadOnlySpan_1<CLROf<byte>>, isFinalSegment: boolean): void;
    writeBase64StringValue(bytes: ReadOnlySpan_1<CLROf<byte>>): void;
    writeBoolean(propertyName: JsonEncodedText, value: boolean): void;
    writeBoolean(propertyName: string, value: boolean): void;
    writeBoolean(propertyName: ReadOnlySpan_1<CLROf<char>>, value: boolean): void;
    writeBoolean(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: boolean): void;
    writeBooleanValue(value: boolean): void;
    writeCommentValue(value: string): void;
    writeCommentValue(value: ReadOnlySpan_1<CLROf<char>>): void;
    writeCommentValue(utf8Value: ReadOnlySpan_1<CLROf<byte>>): void;
    writeEndArray(): void;
    writeEndObject(): void;
    writeNull(propertyName: JsonEncodedText): void;
    writeNull(propertyName: string): void;
    writeNull(propertyName: ReadOnlySpan_1<CLROf<char>>): void;
    writeNull(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>): void;
    writeNullValue(): void;
    writeNumber(propertyName: JsonEncodedText, value: decimal): void;
    writeNumber(propertyName: string, value: decimal): void;
    writeNumber(propertyName: ReadOnlySpan_1<CLROf<char>>, value: decimal): void;
    writeNumber(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: decimal): void;
    writeNumber(propertyName: JsonEncodedText, value: double): void;
    writeNumber(propertyName: string, value: double): void;
    writeNumber(propertyName: ReadOnlySpan_1<CLROf<char>>, value: double): void;
    writeNumber(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: double): void;
    writeNumber(propertyName: JsonEncodedText, value: float): void;
    writeNumber(propertyName: string, value: float): void;
    writeNumber(propertyName: ReadOnlySpan_1<CLROf<char>>, value: float): void;
    writeNumber(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: float): void;
    writeNumber(propertyName: JsonEncodedText, value: long): void;
    writeNumber(propertyName: string, value: long): void;
    writeNumber(propertyName: ReadOnlySpan_1<CLROf<char>>, value: long): void;
    writeNumber(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: long): void;
    writeNumber(propertyName: JsonEncodedText, value: int): void;
    writeNumber(propertyName: string, value: int): void;
    writeNumber(propertyName: ReadOnlySpan_1<CLROf<char>>, value: int): void;
    writeNumber(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: int): void;
    writeNumber(propertyName: JsonEncodedText, value: ulong): void;
    writeNumber(propertyName: string, value: ulong): void;
    writeNumber(propertyName: ReadOnlySpan_1<CLROf<char>>, value: ulong): void;
    writeNumber(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: ulong): void;
    writeNumber(propertyName: JsonEncodedText, value: uint): void;
    writeNumber(propertyName: string, value: uint): void;
    writeNumber(propertyName: ReadOnlySpan_1<CLROf<char>>, value: uint): void;
    writeNumber(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: uint): void;
    writeNumberValue(value: decimal): void;
    writeNumberValue(value: double): void;
    writeNumberValue(value: float): void;
    writeNumberValue(value: int): void;
    writeNumberValue(value: long): void;
    writeNumberValue(value: uint): void;
    writeNumberValue(value: ulong): void;
    writePropertyName(propertyName: JsonEncodedText): void;
    writePropertyName(propertyName: string): void;
    writePropertyName(propertyName: ReadOnlySpan_1<CLROf<char>>): void;
    writePropertyName(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>): void;
    writeRawValue(json: string, skipInputValidation?: boolean): void;
    writeRawValue(json: ReadOnlySpan_1<CLROf<char>>, skipInputValidation?: boolean): void;
    writeRawValue(utf8Json: ReadOnlySpan_1<CLROf<byte>>, skipInputValidation?: boolean): void;
    writeRawValue(utf8Json: ReadOnlySequence_1<CLROf<byte>>, skipInputValidation?: boolean): void;
    writeStartArray(): void;
    writeStartArray(propertyName: JsonEncodedText): void;
    writeStartArray(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>): void;
    writeStartArray(propertyName: string): void;
    writeStartArray(propertyName: ReadOnlySpan_1<CLROf<char>>): void;
    writeStartObject(): void;
    writeStartObject(propertyName: JsonEncodedText): void;
    writeStartObject(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>): void;
    writeStartObject(propertyName: string): void;
    writeStartObject(propertyName: ReadOnlySpan_1<CLROf<char>>): void;
    writeString(propertyName: JsonEncodedText, value: DateTime): void;
    writeString(propertyName: string, value: DateTime): void;
    writeString(propertyName: ReadOnlySpan_1<CLROf<char>>, value: DateTime): void;
    writeString(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: DateTime): void;
    writeString(propertyName: JsonEncodedText, value: DateTimeOffset): void;
    writeString(propertyName: string, value: DateTimeOffset): void;
    writeString(propertyName: ReadOnlySpan_1<CLROf<char>>, value: DateTimeOffset): void;
    writeString(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: DateTimeOffset): void;
    writeString(propertyName: JsonEncodedText, value: Guid): void;
    writeString(propertyName: string, value: Guid): void;
    writeString(propertyName: ReadOnlySpan_1<CLROf<char>>, value: Guid): void;
    writeString(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: Guid): void;
    writeString(propertyName: JsonEncodedText, value: JsonEncodedText): void;
    writeString(propertyName: string, value: JsonEncodedText): void;
    writeString(propertyName: string, value: string): void;
    writeString(propertyName: ReadOnlySpan_1<CLROf<char>>, value: ReadOnlySpan_1<CLROf<char>>): void;
    writeString(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, utf8Value: ReadOnlySpan_1<CLROf<byte>>): void;
    writeString(propertyName: JsonEncodedText, value: string): void;
    writeString(propertyName: JsonEncodedText, value: ReadOnlySpan_1<CLROf<char>>): void;
    writeString(propertyName: string, value: ReadOnlySpan_1<CLROf<char>>): void;
    writeString(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: ReadOnlySpan_1<CLROf<char>>): void;
    writeString(propertyName: JsonEncodedText, utf8Value: ReadOnlySpan_1<CLROf<byte>>): void;
    writeString(propertyName: string, utf8Value: ReadOnlySpan_1<CLROf<byte>>): void;
    writeString(propertyName: ReadOnlySpan_1<CLROf<char>>, utf8Value: ReadOnlySpan_1<CLROf<byte>>): void;
    writeString(propertyName: ReadOnlySpan_1<CLROf<char>>, value: JsonEncodedText): void;
    writeString(propertyName: ReadOnlySpan_1<CLROf<char>>, value: string): void;
    writeString(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: JsonEncodedText): void;
    writeString(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: string): void;
    writeStringValue(value: DateTime): void;
    writeStringValue(value: DateTimeOffset): void;
    writeStringValue(value: Guid): void;
    writeStringValue(value: JsonEncodedText): void;
    writeStringValue(value: string): void;
    writeStringValue(value: ReadOnlySpan_1<CLROf<char>>): void;
    writeStringValue(utf8Value: ReadOnlySpan_1<CLROf<byte>>): void;
    writeStringValueSegment(value: ReadOnlySpan_1<CLROf<char>>, isFinalSegment: boolean): void;
    writeStringValueSegment(value: ReadOnlySpan_1<CLROf<byte>>, isFinalSegment: boolean): void;
}


export const Utf8JsonWriter: {
    new(bufferWriter: IBufferWriter_1<CLROf<byte>>, options: JsonWriterOptions): Utf8JsonWriter$instance;
    new(utf8Json: Stream, options: JsonWriterOptions): Utf8JsonWriter$instance;
};


export interface __Utf8JsonWriter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Utf8JsonWriter$instance extends System_Internal.IAsyncDisposable$instance, System_Internal.IDisposable$instance {}

export type Utf8JsonWriter = Utf8JsonWriter$instance & __Utf8JsonWriter$views;


export abstract class JsonSerializer$instance {
    static readonly isReflectionEnabledByDefault: boolean;
    static deserialize<TValue>(utf8Json: Stream, jsonTypeInfo: JsonTypeInfo_1<TValue>): TValue;
    static deserialize<TValue>(utf8Json: Stream, options?: JsonSerializerOptions): TValue;
    static deserialize(utf8Json: Stream, jsonTypeInfo: JsonTypeInfo): unknown;
    static deserialize(utf8Json: Stream, returnType: Type, options?: JsonSerializerOptions): unknown;
    static deserialize(utf8Json: Stream, returnType: Type, context: JsonSerializerContext): unknown;
    static deserialize<TValue>(utf8Json: ReadOnlySpan_1<CLROf<byte>>, jsonTypeInfo: JsonTypeInfo_1<TValue>): TValue;
    static deserialize<TValue>(utf8Json: ReadOnlySpan_1<CLROf<byte>>, options?: JsonSerializerOptions): TValue;
    static deserialize(utf8Json: ReadOnlySpan_1<CLROf<byte>>, jsonTypeInfo: JsonTypeInfo): unknown;
    static deserialize(utf8Json: ReadOnlySpan_1<CLROf<byte>>, returnType: Type, options?: JsonSerializerOptions): unknown;
    static deserialize(utf8Json: ReadOnlySpan_1<CLROf<byte>>, returnType: Type, context: JsonSerializerContext): unknown;
    static deserialize<TValue>(json: ReadOnlySpan_1<CLROf<char>>, jsonTypeInfo: JsonTypeInfo_1<TValue>): TValue;
    static deserialize<TValue>(json: ReadOnlySpan_1<CLROf<char>>, options?: JsonSerializerOptions): TValue;
    static deserialize(json: ReadOnlySpan_1<CLROf<char>>, jsonTypeInfo: JsonTypeInfo): unknown;
    static deserialize(json: ReadOnlySpan_1<CLROf<char>>, returnType: Type, options?: JsonSerializerOptions): unknown;
    static deserialize(json: ReadOnlySpan_1<CLROf<char>>, returnType: Type, context: JsonSerializerContext): unknown;
    static deserialize<TValue>(json: string, jsonTypeInfo: JsonTypeInfo_1<TValue>): TValue;
    static deserialize<TValue>(json: string, options?: JsonSerializerOptions): TValue;
    static deserialize(json: string, jsonTypeInfo: JsonTypeInfo): unknown;
    static deserialize(json: string, returnType: Type, options?: JsonSerializerOptions): unknown;
    static deserialize(json: string, returnType: Type, context: JsonSerializerContext): unknown;
    static deserialize<TValue>(document: JsonDocument, jsonTypeInfo: JsonTypeInfo_1<TValue>): TValue;
    static deserialize<TValue>(document: JsonDocument, options?: JsonSerializerOptions): TValue;
    static deserialize(document: JsonDocument, jsonTypeInfo: JsonTypeInfo): unknown;
    static deserialize(document: JsonDocument, returnType: Type, options?: JsonSerializerOptions): unknown;
    static deserialize(document: JsonDocument, returnType: Type, context: JsonSerializerContext): unknown;
    static deserialize<TValue>(element: JsonElement, jsonTypeInfo: JsonTypeInfo_1<TValue>): TValue;
    static deserialize<TValue>(element: JsonElement, options?: JsonSerializerOptions): TValue;
    static deserialize(element: JsonElement, jsonTypeInfo: JsonTypeInfo): unknown;
    static deserialize(element: JsonElement, returnType: Type, options?: JsonSerializerOptions): unknown;
    static deserialize(element: JsonElement, returnType: Type, context: JsonSerializerContext): unknown;
    static deserialize<TValue>(node: JsonNode, jsonTypeInfo: JsonTypeInfo_1<TValue>): TValue;
    static deserialize<TValue>(node: JsonNode, options?: JsonSerializerOptions): TValue;
    static deserialize(node: JsonNode, jsonTypeInfo: JsonTypeInfo): unknown;
    static deserialize(node: JsonNode, returnType: Type, options?: JsonSerializerOptions): unknown;
    static deserialize(node: JsonNode, returnType: Type, context: JsonSerializerContext): unknown;
    static deserialize<TValue>(reader: { value: ref<Utf8JsonReader> }, jsonTypeInfo: JsonTypeInfo_1<TValue>): TValue;
    static deserialize<TValue>(reader: { value: ref<Utf8JsonReader> }, options?: JsonSerializerOptions): TValue;
    static deserialize(reader: { value: ref<Utf8JsonReader> }, jsonTypeInfo: JsonTypeInfo): unknown;
    static deserialize(reader: { value: ref<Utf8JsonReader> }, returnType: Type, options?: JsonSerializerOptions): unknown;
    static deserialize(reader: { value: ref<Utf8JsonReader> }, returnType: Type, context: JsonSerializerContext): unknown;
    static deserializeAsync<TValue>(utf8Json: PipeReader, jsonTypeInfo: JsonTypeInfo_1<TValue>, cancellationToken?: CancellationToken): ValueTask_1<TValue>;
    static deserializeAsync<TValue>(utf8Json: PipeReader, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): ValueTask_1<TValue>;
    static deserializeAsync(utf8Json: PipeReader, jsonTypeInfo: JsonTypeInfo, cancellationToken?: CancellationToken): ValueTask_1<unknown>;
    static deserializeAsync(utf8Json: PipeReader, returnType: Type, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): ValueTask_1<unknown>;
    static deserializeAsync(utf8Json: PipeReader, returnType: Type, context: JsonSerializerContext, cancellationToken?: CancellationToken): ValueTask_1<unknown>;
    static deserializeAsync<TValue>(utf8Json: Stream, jsonTypeInfo: JsonTypeInfo_1<TValue>, cancellationToken?: CancellationToken): ValueTask_1<TValue>;
    static deserializeAsync<TValue>(utf8Json: Stream, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): ValueTask_1<TValue>;
    static deserializeAsync(utf8Json: Stream, jsonTypeInfo: JsonTypeInfo, cancellationToken?: CancellationToken): ValueTask_1<unknown>;
    static deserializeAsync(utf8Json: Stream, returnType: Type, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): ValueTask_1<unknown>;
    static deserializeAsync(utf8Json: Stream, returnType: Type, context: JsonSerializerContext, cancellationToken?: CancellationToken): ValueTask_1<unknown>;
    static deserializeAsyncEnumerable<TValue>(utf8Json: PipeReader, jsonTypeInfo: JsonTypeInfo_1<TValue>, topLevelValues: boolean, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TValue>;
    static deserializeAsyncEnumerable<TValue>(utf8Json: PipeReader, jsonTypeInfo: JsonTypeInfo_1<TValue>, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TValue>;
    static deserializeAsyncEnumerable<TValue>(utf8Json: PipeReader, topLevelValues: boolean, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TValue>;
    static deserializeAsyncEnumerable<TValue>(utf8Json: PipeReader, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TValue>;
    static deserializeAsyncEnumerable<TValue>(utf8Json: Stream, jsonTypeInfo: JsonTypeInfo_1<TValue>, topLevelValues: boolean, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TValue>;
    static deserializeAsyncEnumerable<TValue>(utf8Json: Stream, jsonTypeInfo: JsonTypeInfo_1<TValue>, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TValue>;
    static deserializeAsyncEnumerable<TValue>(utf8Json: Stream, topLevelValues: boolean, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TValue>;
    static deserializeAsyncEnumerable<TValue>(utf8Json: Stream, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TValue>;
    static serialize(utf8Json: Stream, value: unknown, jsonTypeInfo: JsonTypeInfo): void;
    static serialize(utf8Json: Stream, value: unknown, inputType: Type, options?: JsonSerializerOptions): void;
    static serialize(utf8Json: Stream, value: unknown, inputType: Type, context: JsonSerializerContext): void;
    static serialize<TValue>(utf8Json: Stream, value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>): void;
    static serialize<TValue>(utf8Json: Stream, value: TValue, options?: JsonSerializerOptions): void;
    static serialize(value: unknown, jsonTypeInfo: JsonTypeInfo): string;
    static serialize(value: unknown, inputType: Type, options?: JsonSerializerOptions): string;
    static serialize(value: unknown, inputType: Type, context: JsonSerializerContext): string;
    static serialize(writer: Utf8JsonWriter, value: unknown, jsonTypeInfo: JsonTypeInfo): void;
    static serialize(writer: Utf8JsonWriter, value: unknown, inputType: Type, options?: JsonSerializerOptions): void;
    static serialize(writer: Utf8JsonWriter, value: unknown, inputType: Type, context: JsonSerializerContext): void;
    static serialize<TValue>(writer: Utf8JsonWriter, value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>): void;
    static serialize<TValue>(writer: Utf8JsonWriter, value: TValue, options?: JsonSerializerOptions): void;
    static serialize<TValue>(value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>): string;
    static serialize<TValue>(value: TValue, options?: JsonSerializerOptions): string;
    static serializeAsync(utf8Json: PipeWriter, value: unknown, jsonTypeInfo: JsonTypeInfo, cancellationToken?: CancellationToken): Task;
    static serializeAsync(utf8Json: PipeWriter, value: unknown, inputType: Type, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): Task;
    static serializeAsync(utf8Json: PipeWriter, value: unknown, inputType: Type, context: JsonSerializerContext, cancellationToken?: CancellationToken): Task;
    static serializeAsync<TValue>(utf8Json: PipeWriter, value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>, cancellationToken?: CancellationToken): Task;
    static serializeAsync<TValue>(utf8Json: PipeWriter, value: TValue, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): Task;
    static serializeAsync(utf8Json: Stream, value: unknown, jsonTypeInfo: JsonTypeInfo, cancellationToken?: CancellationToken): Task;
    static serializeAsync(utf8Json: Stream, value: unknown, inputType: Type, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): Task;
    static serializeAsync(utf8Json: Stream, value: unknown, inputType: Type, context: JsonSerializerContext, cancellationToken?: CancellationToken): Task;
    static serializeAsync<TValue>(utf8Json: Stream, value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>, cancellationToken?: CancellationToken): Task;
    static serializeAsync<TValue>(utf8Json: Stream, value: TValue, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): Task;
    static serializeToDocument(value: unknown, jsonTypeInfo: JsonTypeInfo): JsonDocument;
    static serializeToDocument(value: unknown, inputType: Type, options?: JsonSerializerOptions): JsonDocument;
    static serializeToDocument(value: unknown, inputType: Type, context: JsonSerializerContext): JsonDocument;
    static serializeToDocument<TValue>(value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>): JsonDocument;
    static serializeToDocument<TValue>(value: TValue, options?: JsonSerializerOptions): JsonDocument;
    static serializeToElement(value: unknown, jsonTypeInfo: JsonTypeInfo): JsonElement;
    static serializeToElement(value: unknown, inputType: Type, options?: JsonSerializerOptions): JsonElement;
    static serializeToElement(value: unknown, inputType: Type, context: JsonSerializerContext): JsonElement;
    static serializeToElement<TValue>(value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>): JsonElement;
    static serializeToElement<TValue>(value: TValue, options?: JsonSerializerOptions): JsonElement;
    static serializeToNode(value: unknown, jsonTypeInfo: JsonTypeInfo): JsonNode;
    static serializeToNode(value: unknown, inputType: Type, options?: JsonSerializerOptions): JsonNode;
    static serializeToNode(value: unknown, inputType: Type, context: JsonSerializerContext): JsonNode;
    static serializeToNode<TValue>(value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>): JsonNode;
    static serializeToNode<TValue>(value: TValue, options?: JsonSerializerOptions): JsonNode;
    static serializeToUtf8Bytes(value: unknown, jsonTypeInfo: JsonTypeInfo): byte[];
    static serializeToUtf8Bytes(value: unknown, inputType: Type, options?: JsonSerializerOptions): byte[];
    static serializeToUtf8Bytes(value: unknown, inputType: Type, context: JsonSerializerContext): byte[];
    static serializeToUtf8Bytes<TValue>(value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>): byte[];
    static serializeToUtf8Bytes<TValue>(value: TValue, options?: JsonSerializerOptions): byte[];
}


export type JsonSerializer = JsonSerializer$instance;

