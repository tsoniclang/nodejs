// Generated by tsbindgen - Architecture
// Namespace: System.ComponentModel.DataAnnotations
// Assembly: System.ComponentModel.Annotations

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { ICollection_1, IDictionary_2, IEnumerable_1 } from "../../System.Collections.Generic/internal/index.js";
import type { IDictionary } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { ICustomTypeDescriptor, TypeDescriptionProvider } from "../../System.ComponentModel/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Attribute, Boolean as ClrBoolean, Double, Enum, Exception, Func_2, IComparable, IConvertible, IFormatProvider, IFormattable, Int32, IServiceProvider, ISpanFormattable, Nullable_1, Object as ClrObject, String as ClrString, TimeSpan, Type, TypeCode, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum DataType {
    custom = 0,
    dateTime = 1,
    date = 2,
    time = 3,
    duration = 4,
    phoneNumber = 5,
    currency = 6,
    text = 7,
    html = 8,
    multilineText = 9,
    emailAddress = 10,
    password = 11,
    url = 12,
    imageUrl = 13,
    creditCard = 14,
    postalCode = 15,
    upload = 16
}


export interface IValidatableObject$instance {
    validate(validationContext: ValidationContext): IEnumerable_1<ValidationResult>;
}


export type IValidatableObject = IValidatableObject$instance;

export interface AllowedValuesAttribute$instance extends ValidationAttribute {
    readonly values: unknown[];
    isValid(value: unknown): boolean;
}


export const AllowedValuesAttribute: {
    new(values: unknown[]): AllowedValuesAttribute$instance;
};


export type AllowedValuesAttribute = AllowedValuesAttribute$instance;

export interface AssociatedMetadataTypeTypeDescriptionProvider$instance extends TypeDescriptionProvider {
    getTypeDescriptor(objectType: Type, instance: unknown): ICustomTypeDescriptor;
    getTypeDescriptor(objectType: Type): ICustomTypeDescriptor;
    getTypeDescriptor(instance: unknown): ICustomTypeDescriptor;
}


export const AssociatedMetadataTypeTypeDescriptionProvider: {
    new(type_: Type): AssociatedMetadataTypeTypeDescriptionProvider$instance;
    new(type_: Type, associatedMetadataType: Type): AssociatedMetadataTypeTypeDescriptionProvider$instance;
};


export type AssociatedMetadataTypeTypeDescriptionProvider = AssociatedMetadataTypeTypeDescriptionProvider$instance;

export interface AssociationAttribute$instance extends Attribute {
    isForeignKey: boolean;
    readonly name: string;
    readonly otherKey: string;
    readonly otherKeyMembers: IEnumerable_1<CLROf<string>>;
    readonly thisKey: string;
    readonly thisKeyMembers: IEnumerable_1<CLROf<string>>;
}


export const AssociationAttribute: {
    new(name: string, thisKey: string, otherKey: string): AssociationAttribute$instance;
};


export type AssociationAttribute = AssociationAttribute$instance;

export interface Base64StringAttribute$instance extends ValidationAttribute {
    isValid(value: unknown): boolean;
}


export const Base64StringAttribute: {
    new(): Base64StringAttribute$instance;
};


export type Base64StringAttribute = Base64StringAttribute$instance;

export interface CompareAttribute$instance extends ValidationAttribute {
    readonly otherProperty: string;
    readonly otherPropertyDisplayName: string;
    readonly requiresValidationContext: boolean;
    formatErrorMessage(name: string): string;
}


export const CompareAttribute: {
    new(otherProperty: string): CompareAttribute$instance;
};


export type CompareAttribute = CompareAttribute$instance;

export interface ConcurrencyCheckAttribute$instance extends Attribute {
}


export const ConcurrencyCheckAttribute: {
    new(): ConcurrencyCheckAttribute$instance;
};


export type ConcurrencyCheckAttribute = ConcurrencyCheckAttribute$instance;

export interface CreditCardAttribute$instance extends DataTypeAttribute {
    isValid(value: unknown): boolean;
}


export const CreditCardAttribute: {
    new(): CreditCardAttribute$instance;
};


export type CreditCardAttribute = CreditCardAttribute$instance;

export interface CustomValidationAttribute$instance extends ValidationAttribute {
    readonly method: string;
    readonly requiresValidationContext: boolean;
    readonly typeId: unknown;
    readonly validatorType: Type;
    formatErrorMessage(name: string): string;
}


export const CustomValidationAttribute: {
    new(validatorType: Type, method: string): CustomValidationAttribute$instance;
};


export type CustomValidationAttribute = CustomValidationAttribute$instance;

export interface DataTypeAttribute$instance extends ValidationAttribute {
    readonly customDataType: string;
    readonly dataType: DataType;
    readonly displayFormat: DisplayFormatAttribute;
    getDataTypeName(): string;
    isValid(value: unknown): boolean;
}


export const DataTypeAttribute: {
    new(dataType: DataType): DataTypeAttribute$instance;
    new(customDataType: string): DataTypeAttribute$instance;
};


export type DataTypeAttribute = DataTypeAttribute$instance;

export interface DeniedValuesAttribute$instance extends ValidationAttribute {
    readonly values: unknown[];
    isValid(value: unknown): boolean;
}


export const DeniedValuesAttribute: {
    new(values: unknown[]): DeniedValuesAttribute$instance;
};


export type DeniedValuesAttribute = DeniedValuesAttribute$instance;

export interface DisplayAttribute$instance extends Attribute {
    autoGenerateField: boolean;
    autoGenerateFilter: boolean;
    description: string;
    groupName: string;
    name: string;
    order: int;
    prompt: string;
    resourceType: Type;
    shortName: string;
    getAutoGenerateField(): Nullable_1<CLROf<boolean>>;
    getAutoGenerateFilter(): Nullable_1<CLROf<boolean>>;
    getDescription(): string;
    getGroupName(): string;
    getName(): string;
    getOrder(): Nullable_1<CLROf<int>>;
    getPrompt(): string;
    getShortName(): string;
}


export const DisplayAttribute: {
    new(): DisplayAttribute$instance;
};


export type DisplayAttribute = DisplayAttribute$instance;

export interface DisplayColumnAttribute$instance extends Attribute {
    readonly displayColumn: string;
    readonly sortColumn: string;
    readonly sortDescending: boolean;
}


export const DisplayColumnAttribute: {
    new(displayColumn: string): DisplayColumnAttribute$instance;
    new(displayColumn: string, sortColumn: string): DisplayColumnAttribute$instance;
    new(displayColumn: string, sortColumn: string, sortDescending: boolean): DisplayColumnAttribute$instance;
};


export type DisplayColumnAttribute = DisplayColumnAttribute$instance;

export interface DisplayFormatAttribute$instance extends Attribute {
    applyFormatInEditMode: boolean;
    convertEmptyStringToNull: boolean;
    dataFormatString: string;
    htmlEncode: boolean;
    nullDisplayText: string;
    nullDisplayTextResourceType: Type;
    getNullDisplayText(): string;
}


export const DisplayFormatAttribute: {
    new(): DisplayFormatAttribute$instance;
};


export type DisplayFormatAttribute = DisplayFormatAttribute$instance;

export interface EditableAttribute$instance extends Attribute {
    readonly allowEdit: boolean;
    allowInitialValue: boolean;
}


export const EditableAttribute: {
    new(allowEdit: boolean): EditableAttribute$instance;
};


export type EditableAttribute = EditableAttribute$instance;

export interface EmailAddressAttribute$instance extends DataTypeAttribute {
    isValid(value: unknown): boolean;
}


export const EmailAddressAttribute: {
    new(): EmailAddressAttribute$instance;
};


export type EmailAddressAttribute = EmailAddressAttribute$instance;

export interface EnumDataTypeAttribute$instance extends DataTypeAttribute {
    readonly enumType: Type;
    isValid(value: unknown): boolean;
}


export const EnumDataTypeAttribute: {
    new(enumType: Type): EnumDataTypeAttribute$instance;
};


export type EnumDataTypeAttribute = EnumDataTypeAttribute$instance;

export interface FileExtensionsAttribute$instance extends DataTypeAttribute {
    extensions: string;
    formatErrorMessage(name: string): string;
    isValid(value: unknown): boolean;
}


export const FileExtensionsAttribute: {
    new(): FileExtensionsAttribute$instance;
};


export type FileExtensionsAttribute = FileExtensionsAttribute$instance;

export interface FilterUIHintAttribute$instance extends Attribute {
    readonly controlParameters: IDictionary_2<CLROf<string>, unknown>;
    readonly filterUIHint: string;
    readonly presentationLayer: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const FilterUIHintAttribute: {
    new(filterUIHint: string): FilterUIHintAttribute$instance;
    new(filterUIHint: string, presentationLayer: string): FilterUIHintAttribute$instance;
    new(filterUIHint: string, presentationLayer: string, controlParameters: unknown[]): FilterUIHintAttribute$instance;
};


export type FilterUIHintAttribute = FilterUIHintAttribute$instance;

export interface KeyAttribute$instance extends Attribute {
}


export const KeyAttribute: {
    new(): KeyAttribute$instance;
};


export type KeyAttribute = KeyAttribute$instance;

export interface LengthAttribute$instance extends ValidationAttribute {
    readonly maximumLength: int;
    readonly minimumLength: int;
    formatErrorMessage(name: string): string;
    isValid(value: unknown): boolean;
}


export const LengthAttribute: {
    new(minimumLength: int, maximumLength: int): LengthAttribute$instance;
};


export type LengthAttribute = LengthAttribute$instance;

export interface MaxLengthAttribute$instance extends ValidationAttribute {
    readonly length: int;
    formatErrorMessage(name: string): string;
    isValid(value: unknown): boolean;
}


export const MaxLengthAttribute: {
    new(length: int): MaxLengthAttribute$instance;
    new(): MaxLengthAttribute$instance;
};


export type MaxLengthAttribute = MaxLengthAttribute$instance;

export interface MetadataTypeAttribute$instance extends Attribute {
    readonly metadataClassType: Type;
}


export const MetadataTypeAttribute: {
    new(metadataClassType: Type): MetadataTypeAttribute$instance;
};


export type MetadataTypeAttribute = MetadataTypeAttribute$instance;

export interface MinLengthAttribute$instance extends ValidationAttribute {
    readonly length: int;
    formatErrorMessage(name: string): string;
    isValid(value: unknown): boolean;
}


export const MinLengthAttribute: {
    new(length: int): MinLengthAttribute$instance;
};


export type MinLengthAttribute = MinLengthAttribute$instance;

export interface PhoneAttribute$instance extends DataTypeAttribute {
    isValid(value: unknown): boolean;
}


export const PhoneAttribute: {
    new(): PhoneAttribute$instance;
};


export type PhoneAttribute = PhoneAttribute$instance;

export interface RangeAttribute$instance extends ValidationAttribute {
    convertValueInInvariantCulture: boolean;
    readonly maximum: unknown;
    maximumIsExclusive: boolean;
    readonly minimum: unknown;
    minimumIsExclusive: boolean;
    readonly operandType: Type;
    parseLimitsInInvariantCulture: boolean;
    formatErrorMessage(name: string): string;
    isValid(value: unknown): boolean;
}


export const RangeAttribute: {
    new(minimum: int, maximum: int): RangeAttribute$instance;
    new(minimum: double, maximum: double): RangeAttribute$instance;
    new(type_: Type, minimum: string, maximum: string): RangeAttribute$instance;
};


export type RangeAttribute = RangeAttribute$instance;

export interface RegularExpressionAttribute$instance extends ValidationAttribute {
    readonly matchTimeout: TimeSpan;
    matchTimeoutInMilliseconds: int;
    readonly pattern: string;
    formatErrorMessage(name: string): string;
    isValid(value: unknown): boolean;
}


export const RegularExpressionAttribute: {
    new(pattern: string): RegularExpressionAttribute$instance;
};


export type RegularExpressionAttribute = RegularExpressionAttribute$instance;

export interface RequiredAttribute$instance extends ValidationAttribute {
    allowEmptyStrings: boolean;
    isValid(value: unknown): boolean;
}


export const RequiredAttribute: {
    new(): RequiredAttribute$instance;
};


export type RequiredAttribute = RequiredAttribute$instance;

export interface ScaffoldColumnAttribute$instance extends Attribute {
    readonly scaffold: boolean;
}


export const ScaffoldColumnAttribute: {
    new(scaffold: boolean): ScaffoldColumnAttribute$instance;
};


export type ScaffoldColumnAttribute = ScaffoldColumnAttribute$instance;

export interface StringLengthAttribute$instance extends ValidationAttribute {
    readonly maximumLength: int;
    minimumLength: int;
    formatErrorMessage(name: string): string;
    isValid(value: unknown): boolean;
}


export const StringLengthAttribute: {
    new(maximumLength: int): StringLengthAttribute$instance;
};


export type StringLengthAttribute = StringLengthAttribute$instance;

export interface TimestampAttribute$instance extends Attribute {
}


export const TimestampAttribute: {
    new(): TimestampAttribute$instance;
};


export type TimestampAttribute = TimestampAttribute$instance;

export interface UIHintAttribute$instance extends Attribute {
    readonly controlParameters: IDictionary_2<CLROf<string>, unknown>;
    readonly presentationLayer: string;
    readonly uiHint: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const UIHintAttribute: {
    new(uiHint: string): UIHintAttribute$instance;
    new(uiHint: string, presentationLayer: string): UIHintAttribute$instance;
    new(uiHint: string, presentationLayer: string, controlParameters: unknown[]): UIHintAttribute$instance;
};


export type UIHintAttribute = UIHintAttribute$instance;

export interface UrlAttribute$instance extends DataTypeAttribute {
    isValid(value: unknown): boolean;
}


export const UrlAttribute: {
    new(): UrlAttribute$instance;
};


export type UrlAttribute = UrlAttribute$instance;

export interface ValidationAttribute$instance extends Attribute {
    errorMessage: string;
    errorMessageResourceName: string;
    errorMessageResourceType: Type;
    readonly requiresValidationContext: boolean;
    formatErrorMessage(name: string): string;
    getValidationResult(value: unknown, validationContext: ValidationContext): ValidationResult;
    isValid(value: unknown): boolean;
    validate(value: unknown, name: string): void;
    validate(value: unknown, validationContext: ValidationContext): void;
}


export const ValidationAttribute: {
};


export type ValidationAttribute = ValidationAttribute$instance;

export interface ValidationContext$instance {
    displayName: string;
    readonly items: IDictionary_2<unknown, unknown>;
    memberName: string;
    readonly objectInstance: unknown;
    readonly objectType: Type;
    getService(serviceType: Type): unknown;
    initializeServiceProvider(serviceProvider: Func_2<Type, unknown>): void;
}


export const ValidationContext: {
    new(instance: unknown): ValidationContext$instance;
    new(instance: unknown, items: IDictionary_2<unknown, unknown>): ValidationContext$instance;
    new(instance: unknown, serviceProvider: IServiceProvider, items: IDictionary_2<unknown, unknown>): ValidationContext$instance;
    new(instance: unknown, displayName: string, serviceProvider: IServiceProvider, items: IDictionary_2<unknown, unknown>): ValidationContext$instance;
};


export interface __ValidationContext$views {
    As_IServiceProvider(): System_Internal.IServiceProvider$instance;
}

export interface ValidationContext$instance extends System_Internal.IServiceProvider$instance {}

export type ValidationContext = ValidationContext$instance & __ValidationContext$views;


export interface ValidationException$instance extends Exception {
    readonly validationAttribute: ValidationAttribute;
    readonly validationResult: ValidationResult;
    readonly value: unknown;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const ValidationException: {
    new(validationResult: ValidationResult, validatingAttribute: ValidationAttribute, value: unknown): ValidationException$instance;
    new(errorMessage: string, validatingAttribute: ValidationAttribute, value: unknown): ValidationException$instance;
    new(): ValidationException$instance;
    new(message: string): ValidationException$instance;
    new(message: string, innerException: Exception): ValidationException$instance;
};


export interface __ValidationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ValidationException = ValidationException$instance & __ValidationException$views;


export interface ValidationResult$instance {
    errorMessage: string;
    readonly memberNames: IEnumerable_1<CLROf<string>>;
    toString(): string;
}


export const ValidationResult: {
    new(errorMessage: string): ValidationResult$instance;
    new(errorMessage: string, memberNames: IEnumerable_1<CLROf<string>>): ValidationResult$instance;
    readonly success: ValidationResult;
};


export type ValidationResult = ValidationResult$instance;

export abstract class Validator$instance {
    static tryValidateObject(instance: unknown, validationContext: ValidationContext, validationResults: ICollection_1<ValidationResult>, validateAllProperties: boolean): boolean;
    static tryValidateObject(instance: unknown, validationContext: ValidationContext, validationResults: ICollection_1<ValidationResult>): boolean;
    static tryValidateProperty(value: unknown, validationContext: ValidationContext, validationResults: ICollection_1<ValidationResult>): boolean;
    static tryValidateValue(value: unknown, validationContext: ValidationContext, validationResults: ICollection_1<ValidationResult>, validationAttributes: IEnumerable_1<ValidationAttribute>): boolean;
    static validateObject(instance: unknown, validationContext: ValidationContext, validateAllProperties: boolean): void;
    static validateObject(instance: unknown, validationContext: ValidationContext): void;
    static validateProperty(value: unknown, validationContext: ValidationContext): void;
    static validateValue(value: unknown, validationContext: ValidationContext, validationAttributes: IEnumerable_1<ValidationAttribute>): void;
}


export type Validator = Validator$instance;

