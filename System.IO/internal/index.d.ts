// Generated by tsbindgen - Architecture
// Namespace: System.IO
// Assembly: System.IO.FileSystem.AccessControl, System.IO.FileSystem.DriveInfo, System.IO.FileSystem.Watcher, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { SafeFileHandle } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import type { IAsyncEnumerable_1, IEnumerable_1, IReadOnlyList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { Collection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import type { IDictionary } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { Component, IComponent, IContainer, ISite, ISupportInitialize, ISynchronizeInvoke } from "../../System.ComponentModel/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import type { SafeBuffer } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { AccessControlSections, DirectorySecurity, FileSecurity, FileSystemRights } from "../../System.Security.AccessControl/internal/index.js";
import type { Encoding, StringBuilder } from "../../System.Text/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ArraySegment_1, AsyncCallback, Boolean as ClrBoolean, Byte, Char, DateTime, Decimal, Delegate, Double, Enum, EventArgs, Exception, Half, IAsyncDisposable, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, MarshalByRefObject, Memory_1, MulticastDelegate, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, SByte, Single, Span_1, String as ClrString, SystemException, TimeSpan, Type, TypeCode, UInt16, UInt32, UInt64, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum DriveType {
    unknown_ = 0,
    noRootDirectory = 1,
    removable = 2,
    fixed = 3,
    network = 4,
    cdRom = 5,
    ram = 6
}


export enum FileAccess {
    read = 1,
    write = 2,
    readWrite = 3
}


export enum FileAttributes {
    none = 0,
    readOnly = 1,
    hidden = 2,
    system = 4,
    directory = 16,
    archive = 32,
    device = 64,
    normal = 128,
    temporary = 256,
    sparseFile = 512,
    reparsePoint = 1024,
    compressed = 2048,
    offline = 4096,
    notContentIndexed = 8192,
    encrypted = 16384,
    integrityStream = 32768,
    noScrubData = 131072
}


export enum FileMode {
    createNew = 1,
    create = 2,
    open = 3,
    openOrCreate = 4,
    truncate = 5,
    append = 6
}


export enum FileOptions {
    none = 0,
    writeThrough = -2147483648,
    asynchronous = 1073741824,
    randomAccess = 268435456,
    deleteOnClose = 67108864,
    sequentialScan = 134217728,
    encrypted = 16384
}


export enum FileShare {
    none = 0,
    read = 1,
    write = 2,
    readWrite = 3,
    delete_ = 4,
    inheritable = 16
}


export enum HandleInheritability {
    none = 0,
    inheritable = 1
}


export enum MatchCasing {
    platformDefault = 0,
    caseSensitive = 1,
    caseInsensitive = 2
}


export enum MatchType {
    simple = 0,
    win32 = 1
}


export enum NotifyFilters {
    fileName = 1,
    directoryName = 2,
    attributes = 4,
    size = 8,
    lastWrite = 16,
    lastAccess = 32,
    creationTime = 64,
    security = 256
}


export enum SearchOption {
    topDirectoryOnly = 0,
    allDirectories = 1
}


export enum SeekOrigin {
    begin = 0,
    current = 1,
    end = 2
}


export enum UnixFileMode {
    none = 0,
    otherExecute = 1,
    otherWrite = 2,
    otherRead = 4,
    groupExecute = 8,
    groupWrite = 16,
    groupRead = 32,
    userExecute = 64,
    userWrite = 128,
    userRead = 256,
    stickyBit = 512,
    setGroup = 1024,
    setUser = 2048
}


export enum WatcherChangeTypes {
    created = 1,
    deleted = 2,
    changed = 4,
    renamed = 8,
    all = 15
}


export type ErrorEventHandler = (sender: unknown, e: ErrorEventArgs) => void;


export type FileSystemEventHandler = (sender: unknown, e: FileSystemEventArgs) => void;


export type RenamedEventHandler = (sender: unknown, e: RenamedEventArgs) => void;


export interface WaitForChangedResult$instance {
    changeType: WatcherChangeTypes;
    name: string;
    oldName: string;
    timedOut: boolean;
}


export const WaitForChangedResult: {
    new(): WaitForChangedResult$instance;
};


export type WaitForChangedResult = WaitForChangedResult$instance;

export interface BinaryReader$instance {
    readonly baseStream: Stream;
    close(): void;
    dispose(): void;
    peekChar(): int;
    read(): int;
    read(buffer: char[], index: int, count: int): int;
    read(buffer: Span_1<CLROf<char>>): int;
    read(buffer: byte[], index: int, count: int): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    read7BitEncodedInt(): int;
    read7BitEncodedInt64(): long;
    readBoolean(): boolean;
    readByte(): byte;
    readBytes(count: int): byte[];
    readChar(): char;
    readChars(count: int): char[];
    readDecimal(): decimal;
    readDouble(): double;
    readExactly(buffer: Span_1<CLROf<byte>>): void;
    readHalf(): half;
    readInt16(): short;
    readInt32(): int;
    readInt64(): long;
    readSByte(): sbyte;
    readSingle(): float;
    readString(): string;
    readUInt16(): ushort;
    readUInt32(): uint;
    readUInt64(): ulong;
}


export const BinaryReader: {
    new(input: Stream): BinaryReader$instance;
    new(input: Stream, encoding: Encoding): BinaryReader$instance;
    new(input: Stream, encoding: Encoding, leaveOpen: boolean): BinaryReader$instance;
};


export interface __BinaryReader$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface BinaryReader$instance extends System_Internal.IDisposable$instance {}

export type BinaryReader = BinaryReader$instance & __BinaryReader$views;


export interface BinaryWriter$instance {
    readonly baseStream: Stream;
    close(): void;
    dispose(): void;
    disposeAsync(): ValueTask;
    flush(): void;
    seek(offset: int, origin: SeekOrigin): long;
    write(value: boolean): void;
    write(value: byte): void;
    write(value: sbyte): void;
    write(buffer: byte[]): void;
    write(buffer: byte[], index: int, count: int): void;
    write(ch: char): void;
    write(chars: char[]): void;
    write(chars: char[], index: int, count: int): void;
    write(value: double): void;
    write(value: decimal): void;
    write(value: short): void;
    write(value: ushort): void;
    write(value: int): void;
    write(value: uint): void;
    write(value: long): void;
    write(value: ulong): void;
    write(value: float): void;
    write(value: half): void;
    write(value: string): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    write(chars: ReadOnlySpan_1<CLROf<char>>): void;
    write7BitEncodedInt(value: int): void;
    write7BitEncodedInt64(value: long): void;
}


export const BinaryWriter: {
    new(output: Stream): BinaryWriter$instance;
    new(output: Stream, encoding: Encoding): BinaryWriter$instance;
    new(output: Stream, encoding: Encoding, leaveOpen: boolean): BinaryWriter$instance;
    readonly null_: BinaryWriter;
};


export interface __BinaryWriter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface BinaryWriter$instance extends System_Internal.IAsyncDisposable$instance, System_Internal.IDisposable$instance {}

export type BinaryWriter = BinaryWriter$instance & __BinaryWriter$views;


export interface BufferedStream$instance extends Stream$instance {
    readonly bufferSize: int;
    readonly canRead: boolean;
    readonly canSeek: boolean;
    readonly canWrite: boolean;
    readonly length: long;
    position: long;
    readonly underlyingStream: Stream;
    beginRead(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginWrite(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    copyTo(destination: Stream, bufferSize: int): void;
    copyTo(destination: Stream): void;
    copyToAsync(destination: Stream, bufferSize: int, cancellationToken: CancellationToken): Task;
    copyToAsync(destination: Stream): Task;
    copyToAsync(destination: Stream, bufferSize: int): Task;
    copyToAsync(destination: Stream, cancellationToken: CancellationToken): Task;
    dispose(): void;
    disposeAsync(): ValueTask;
    endRead(asyncResult: IAsyncResult): int;
    endWrite(asyncResult: IAsyncResult): void;
    flush(): void;
    flushAsync(cancellationToken: CancellationToken): Task;
    flushAsync(): Task;
    read(buffer: byte[], offset: int, count: int): int;
    read(destination: Span_1<CLROf<byte>>): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readByte(): int;
    seek(offset: long, origin: SeekOrigin): long;
    setLength(value: long): void;
    write(buffer: byte[], offset: int, count: int): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    writeAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeAsync(buffer: byte[], offset: int, count: int): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeByte(value: byte): void;
}


export const BufferedStream: {
    new(stream: Stream): BufferedStream$instance;
    new(stream: Stream, bufferSize: int): BufferedStream$instance;
};


export interface __BufferedStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type BufferedStream = BufferedStream$instance & __BufferedStream$views;


export interface DirectoryInfo$instance extends FileSystemInfo$instance {
    readonly exists: boolean;
    readonly name: string;
    readonly parent: DirectoryInfo;
    readonly root: DirectoryInfo;
    create(): void;
    createSubdirectory(path: string): DirectoryInfo;
    delete_(): void;
    enumerateDirectories(): IEnumerable_1<DirectoryInfo>;
    enumerateDirectories(searchPattern: string): IEnumerable_1<DirectoryInfo>;
    enumerateDirectories(searchPattern: string, searchOption: SearchOption): IEnumerable_1<DirectoryInfo>;
    enumerateDirectories(searchPattern: string, enumerationOptions: EnumerationOptions): IEnumerable_1<DirectoryInfo>;
    enumerateFiles(): IEnumerable_1<FileInfo>;
    enumerateFiles(searchPattern: string): IEnumerable_1<FileInfo>;
    enumerateFiles(searchPattern: string, searchOption: SearchOption): IEnumerable_1<FileInfo>;
    enumerateFiles(searchPattern: string, enumerationOptions: EnumerationOptions): IEnumerable_1<FileInfo>;
    enumerateFileSystemInfos(): IEnumerable_1<FileSystemInfo>;
    enumerateFileSystemInfos(searchPattern: string): IEnumerable_1<FileSystemInfo>;
    enumerateFileSystemInfos(searchPattern: string, searchOption: SearchOption): IEnumerable_1<FileSystemInfo>;
    enumerateFileSystemInfos(searchPattern: string, enumerationOptions: EnumerationOptions): IEnumerable_1<FileSystemInfo>;
    getDirectories(): DirectoryInfo[];
    getDirectories(searchPattern: string): DirectoryInfo[];
    getDirectories(searchPattern: string, searchOption: SearchOption): DirectoryInfo[];
    getDirectories(searchPattern: string, enumerationOptions: EnumerationOptions): DirectoryInfo[];
    getFiles(): FileInfo[];
    getFiles(searchPattern: string): FileInfo[];
    getFiles(searchPattern: string, searchOption: SearchOption): FileInfo[];
    getFiles(searchPattern: string, enumerationOptions: EnumerationOptions): FileInfo[];
    getFileSystemInfos(): FileSystemInfo[];
    getFileSystemInfos(searchPattern: string): FileSystemInfo[];
    getFileSystemInfos(searchPattern: string, searchOption: SearchOption): FileSystemInfo[];
    getFileSystemInfos(searchPattern: string, enumerationOptions: EnumerationOptions): FileSystemInfo[];
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    moveTo(destDirName: string): void;
}


export const DirectoryInfo: {
    new(path: string): DirectoryInfo$instance;
};


export interface __DirectoryInfo$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DirectoryInfo = DirectoryInfo$instance & __DirectoryInfo$views;


export interface DirectoryNotFoundException$instance extends IOException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const DirectoryNotFoundException: {
    new(): DirectoryNotFoundException$instance;
    new(message: string): DirectoryNotFoundException$instance;
    new(message: string, innerException: Exception): DirectoryNotFoundException$instance;
};


export interface __DirectoryNotFoundException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DirectoryNotFoundException = DirectoryNotFoundException$instance & __DirectoryNotFoundException$views;


export interface DriveInfo$instance {
    readonly availableFreeSpace: long;
    readonly driveFormat: string;
    readonly driveType: DriveType;
    readonly isReady: boolean;
    readonly name: string;
    readonly rootDirectory: DirectoryInfo;
    readonly totalFreeSpace: long;
    readonly totalSize: long;
    volumeLabel: string;
    toString(): string;
}


export const DriveInfo: {
    new(driveName: string): DriveInfo$instance;
    getDrives(): DriveInfo[];
};


export interface __DriveInfo$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface DriveInfo$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type DriveInfo = DriveInfo$instance & __DriveInfo$views;


export interface DriveNotFoundException$instance extends IOException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const DriveNotFoundException: {
    new(): DriveNotFoundException$instance;
    new(message: string): DriveNotFoundException$instance;
    new(message: string, innerException: Exception): DriveNotFoundException$instance;
};


export interface __DriveNotFoundException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DriveNotFoundException = DriveNotFoundException$instance & __DriveNotFoundException$views;


export interface EndOfStreamException$instance extends IOException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const EndOfStreamException: {
    new(): EndOfStreamException$instance;
    new(message: string): EndOfStreamException$instance;
    new(message: string, innerException: Exception): EndOfStreamException$instance;
};


export interface __EndOfStreamException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type EndOfStreamException = EndOfStreamException$instance & __EndOfStreamException$views;


export interface EnumerationOptions$instance {
    attributesToSkip: FileAttributes;
    bufferSize: int;
    ignoreInaccessible: boolean;
    matchCasing: MatchCasing;
    matchType: MatchType;
    maxRecursionDepth: int;
    recurseSubdirectories: boolean;
    returnSpecialDirectories: boolean;
}


export const EnumerationOptions: {
    new(): EnumerationOptions$instance;
};


export type EnumerationOptions = EnumerationOptions$instance;

export interface ErrorEventArgs$instance extends EventArgs {
    getException(): Exception;
}


export const ErrorEventArgs: {
    new(exception: Exception): ErrorEventArgs$instance;
};


export type ErrorEventArgs = ErrorEventArgs$instance;

export interface FileInfo$instance extends FileSystemInfo$instance {
    readonly directory: DirectoryInfo;
    readonly directoryName: string;
    readonly exists: boolean;
    isReadOnly: boolean;
    readonly length: long;
    readonly name: string;
    appendText(): StreamWriter;
    copyTo(destFileName: string): FileInfo;
    copyTo(destFileName: string, overwrite: boolean): FileInfo;
    create(): FileStream;
    createText(): StreamWriter;
    decrypt(): void;
    delete_(): void;
    encrypt(): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    moveTo(destFileName: string): void;
    moveTo(destFileName: string, overwrite: boolean): void;
    open(options: FileStreamOptions): FileStream;
    open(mode: FileMode): FileStream;
    open(mode: FileMode, access: FileAccess): FileStream;
    open(mode: FileMode, access: FileAccess, share: FileShare): FileStream;
    openRead(): FileStream;
    openText(): StreamReader;
    openWrite(): FileStream;
    replace(destinationFileName: string, destinationBackupFileName: string): FileInfo;
    replace(destinationFileName: string, destinationBackupFileName: string, ignoreMetadataErrors: boolean): FileInfo;
}


export const FileInfo: {
    new(fileName: string): FileInfo$instance;
};


export interface __FileInfo$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type FileInfo = FileInfo$instance & __FileInfo$views;


export interface FileLoadException$instance extends IOException$instance {
    readonly fileName: string;
    readonly fusionLog: string;
    readonly message: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    toString(): string;
}


export const FileLoadException: {
    new(): FileLoadException$instance;
    new(message: string): FileLoadException$instance;
    new(message: string, inner: Exception): FileLoadException$instance;
    new(message: string, fileName: string): FileLoadException$instance;
    new(message: string, fileName: string, inner: Exception): FileLoadException$instance;
};


export interface __FileLoadException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type FileLoadException = FileLoadException$instance & __FileLoadException$views;


export interface FileNotFoundException$instance extends IOException$instance {
    readonly fileName: string;
    readonly fusionLog: string;
    readonly message: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    toString(): string;
}


export const FileNotFoundException: {
    new(): FileNotFoundException$instance;
    new(message: string): FileNotFoundException$instance;
    new(message: string, innerException: Exception): FileNotFoundException$instance;
    new(message: string, fileName: string): FileNotFoundException$instance;
    new(message: string, fileName: string, innerException: Exception): FileNotFoundException$instance;
};


export interface __FileNotFoundException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type FileNotFoundException = FileNotFoundException$instance & __FileNotFoundException$views;


export interface FileStream$instance extends Stream$instance {
    readonly canRead: boolean;
    readonly canSeek: boolean;
    readonly canWrite: boolean;
    readonly handle: nint;
    readonly isAsync: boolean;
    readonly length: long;
    readonly name: string;
    position: long;
    readonly safeFileHandle: SafeFileHandle;
    beginRead(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginWrite(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    copyTo(destination: Stream, bufferSize: int): void;
    copyTo(destination: Stream): void;
    copyToAsync(destination: Stream, bufferSize: int, cancellationToken: CancellationToken): Task;
    copyToAsync(destination: Stream): Task;
    copyToAsync(destination: Stream, bufferSize: int): Task;
    copyToAsync(destination: Stream, cancellationToken: CancellationToken): Task;
    dispose(): void;
    disposeAsync(): ValueTask;
    endRead(asyncResult: IAsyncResult): int;
    endWrite(asyncResult: IAsyncResult): void;
    flush(): void;
    flushAsync(cancellationToken: CancellationToken): Task;
    flushAsync(): Task;
    lock(position: long, length: long): void;
    read(buffer: byte[], offset: int, count: int): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readByte(): int;
    seek(offset: long, origin: SeekOrigin): long;
    setLength(value: long): void;
    unlock(position: long, length: long): void;
    write(buffer: byte[], offset: int, count: int): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    writeAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeAsync(buffer: byte[], offset: int, count: int): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeByte(value: byte): void;
}


export const FileStream: {
    new(handle: nint, access: FileAccess): FileStream$instance;
    new(handle: nint, access: FileAccess, ownsHandle: boolean): FileStream$instance;
    new(handle: nint, access: FileAccess, ownsHandle: boolean, bufferSize: int): FileStream$instance;
    new(handle: nint, access: FileAccess, ownsHandle: boolean, bufferSize: int, isAsync: boolean): FileStream$instance;
    new(handle: SafeFileHandle, access: FileAccess): FileStream$instance;
    new(handle: SafeFileHandle, access: FileAccess, bufferSize: int): FileStream$instance;
    new(handle: SafeFileHandle, access: FileAccess, bufferSize: int, isAsync: boolean): FileStream$instance;
    new(path: string, mode: FileMode): FileStream$instance;
    new(path: string, mode: FileMode, access: FileAccess): FileStream$instance;
    new(path: string, mode: FileMode, access: FileAccess, share: FileShare): FileStream$instance;
    new(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: int): FileStream$instance;
    new(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: int, useAsync: boolean): FileStream$instance;
    new(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: int, options: FileOptions): FileStream$instance;
    new(path: string, options: FileStreamOptions): FileStream$instance;
};


export interface __FileStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type FileStream = FileStream$instance & __FileStream$views;


export interface FileStreamOptions$instance {
    access: FileAccess;
    bufferSize: int;
    mode: FileMode;
    options: FileOptions;
    preallocationSize: long;
    share: FileShare;
    unixCreateMode: Nullable_1<UnixFileMode>;
}


export const FileStreamOptions: {
    new(): FileStreamOptions$instance;
};


export type FileStreamOptions = FileStreamOptions$instance;

export interface FileSystemEventArgs$instance extends EventArgs {
    readonly changeType: WatcherChangeTypes;
    readonly fullPath: string;
    readonly name: string;
}


export const FileSystemEventArgs: {
    new(changeType: WatcherChangeTypes, directory: string, name: string): FileSystemEventArgs$instance;
};


export type FileSystemEventArgs = FileSystemEventArgs$instance;

export interface FileSystemInfo$instance extends MarshalByRefObject {
    attributes: FileAttributes;
    creationTime: DateTime;
    creationTimeUtc: DateTime;
    readonly exists: boolean;
    readonly extension: string;
    readonly fullName: string;
    lastAccessTime: DateTime;
    lastAccessTimeUtc: DateTime;
    lastWriteTime: DateTime;
    lastWriteTimeUtc: DateTime;
    readonly linkTarget: string;
    readonly name: string;
    unixFileMode: UnixFileMode;
    createAsSymbolicLink(pathToTarget: string): void;
    delete_(): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    refresh(): void;
    resolveLinkTarget(returnFinalTarget: boolean): FileSystemInfo;
    toString(): string;
}


export const FileSystemInfo: {
};


export interface __FileSystemInfo$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface FileSystemInfo$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type FileSystemInfo = FileSystemInfo$instance & __FileSystemInfo$views;


export interface FileSystemWatcher$instance extends Component {
    enableRaisingEvents: boolean;
    filter: string;
    readonly filters: Collection_1<CLROf<string>>;
    includeSubdirectories: boolean;
    internalBufferSize: int;
    notifyFilter: NotifyFilters;
    path: string;
    site: ISite;
    synchronizingObject: ISynchronizeInvoke;
    beginInit(): void;
    dispose(): void;
    endInit(): void;
    waitForChanged(changeType: WatcherChangeTypes): WaitForChangedResult;
    waitForChanged(changeType: WatcherChangeTypes, timeout: int): WaitForChangedResult;
    waitForChanged(changeType: WatcherChangeTypes, timeout: TimeSpan): WaitForChangedResult;
}


export const FileSystemWatcher: {
    new(): FileSystemWatcher$instance;
    new(path: string): FileSystemWatcher$instance;
    new(path: string, filter: string): FileSystemWatcher$instance;
};


export interface __FileSystemWatcher$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_ISupportInitialize(): System_ComponentModel_Internal.ISupportInitialize$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface FileSystemWatcher$instance extends System_ComponentModel_Internal.IComponent$instance, System_ComponentModel_Internal.ISupportInitialize$instance {}

export type FileSystemWatcher = FileSystemWatcher$instance & __FileSystemWatcher$views;


export interface InternalBufferOverflowException$instance extends SystemException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const InternalBufferOverflowException: {
    new(): InternalBufferOverflowException$instance;
    new(message: string): InternalBufferOverflowException$instance;
    new(message: string, inner: Exception): InternalBufferOverflowException$instance;
};


export interface __InternalBufferOverflowException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InternalBufferOverflowException = InternalBufferOverflowException$instance & __InternalBufferOverflowException$views;


export interface InvalidDataException$instance extends SystemException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const InvalidDataException: {
    new(): InvalidDataException$instance;
    new(message: string): InvalidDataException$instance;
    new(message: string, innerException: Exception): InvalidDataException$instance;
};


export interface __InvalidDataException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidDataException = InvalidDataException$instance & __InvalidDataException$views;


export interface IOException$instance extends SystemException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const IOException: {
    new(): IOException$instance;
    new(message: string): IOException$instance;
    new(message: string, hresult: int): IOException$instance;
    new(message: string, innerException: Exception): IOException$instance;
};


export interface __IOException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type IOException = IOException$instance & __IOException$views;


export interface MemoryStream$instance extends Stream$instance {
    readonly canRead: boolean;
    readonly canSeek: boolean;
    readonly canWrite: boolean;
    capacity: int;
    readonly length: long;
    position: long;
    copyTo(destination: Stream, bufferSize: int): void;
    copyTo(destination: Stream): void;
    copyToAsync(destination: Stream, bufferSize: int, cancellationToken: CancellationToken): Task;
    copyToAsync(destination: Stream): Task;
    copyToAsync(destination: Stream, bufferSize: int): Task;
    copyToAsync(destination: Stream, cancellationToken: CancellationToken): Task;
    dispose(): void;
    disposeAsync(): ValueTask;
    flush(): void;
    flushAsync(cancellationToken: CancellationToken): Task;
    flushAsync(): Task;
    getBuffer(): byte[];
    read(buffer: byte[], offset: int, count: int): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readByte(): int;
    seek(offset: long, loc: SeekOrigin): long;
    setLength(value: long): void;
    toArray(): byte[];
    tryGetBuffer(buffer: { value: ref<ArraySegment_1<CLROf<byte>>> }): boolean;
    write(buffer: byte[], offset: int, count: int): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    writeAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeAsync(buffer: byte[], offset: int, count: int): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeByte(value: byte): void;
    writeTo(stream: Stream): void;
}


export const MemoryStream: {
    new(): MemoryStream$instance;
    new(capacity: int): MemoryStream$instance;
    new(buffer: byte[]): MemoryStream$instance;
    new(buffer: byte[], writable: boolean): MemoryStream$instance;
    new(buffer: byte[], index: int, count: int): MemoryStream$instance;
    new(buffer: byte[], index: int, count: int, writable: boolean): MemoryStream$instance;
    new(buffer: byte[], index: int, count: int, writable: boolean, publiclyVisible: boolean): MemoryStream$instance;
};


export interface __MemoryStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type MemoryStream = MemoryStream$instance & __MemoryStream$views;


export interface PathTooLongException$instance extends IOException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const PathTooLongException: {
    new(): PathTooLongException$instance;
    new(message: string): PathTooLongException$instance;
    new(message: string, innerException: Exception): PathTooLongException$instance;
};


export interface __PathTooLongException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type PathTooLongException = PathTooLongException$instance & __PathTooLongException$views;


export interface RenamedEventArgs$instance extends FileSystemEventArgs {
    readonly oldFullPath: string;
    readonly oldName: string;
}


export const RenamedEventArgs: {
    new(changeType: WatcherChangeTypes, directory: string, name: string, oldName: string): RenamedEventArgs$instance;
};


export type RenamedEventArgs = RenamedEventArgs$instance;

export interface Stream$instance extends MarshalByRefObject {
    readonly canRead: boolean;
    readonly canSeek: boolean;
    readonly canTimeout: boolean;
    readonly canWrite: boolean;
    readonly length: long;
    position: long;
    readTimeout: int;
    writeTimeout: int;
    beginRead(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginWrite(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    close(): void;
    copyTo(destination: Stream): void;
    copyTo(destination: Stream, bufferSize: int): void;
    copyToAsync(destination: Stream): Task;
    copyToAsync(destination: Stream, bufferSize: int): Task;
    copyToAsync(destination: Stream, cancellationToken: CancellationToken): Task;
    copyToAsync(destination: Stream, bufferSize: int, cancellationToken: CancellationToken): Task;
    dispose(): void;
    disposeAsync(): ValueTask;
    endRead(asyncResult: IAsyncResult): int;
    endWrite(asyncResult: IAsyncResult): void;
    flush(): void;
    flushAsync(): Task;
    flushAsync(cancellationToken: CancellationToken): Task;
    read(buffer: byte[], offset: int, count: int): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    readAsync(buffer: byte[], offset: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readAtLeast(buffer: Span_1<CLROf<byte>>, minimumBytes: int, throwOnEndOfStream?: boolean): int;
    readAtLeastAsync(buffer: Memory_1<CLROf<byte>>, minimumBytes: int, throwOnEndOfStream?: boolean, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readByte(): int;
    readExactly(buffer: Span_1<CLROf<byte>>): void;
    readExactly(buffer: byte[], offset: int, count: int): void;
    readExactlyAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    readExactlyAsync(buffer: byte[], offset: int, count: int, cancellationToken?: CancellationToken): ValueTask;
    seek(offset: long, origin: SeekOrigin): long;
    setLength(value: long): void;
    write(buffer: byte[], offset: int, count: int): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    writeAsync(buffer: byte[], offset: int, count: int): Task;
    writeAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeByte(value: byte): void;
}


export const Stream: {
    readonly null_: Stream;
    synchronized(stream: Stream): Stream;
};


export interface __Stream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Stream$instance extends System_Internal.IAsyncDisposable$instance, System_Internal.IDisposable$instance {}

export type Stream = Stream$instance & __Stream$views;


export interface StreamReader$instance extends TextReader$instance {
    readonly baseStream: Stream;
    readonly currentEncoding: Encoding;
    readonly endOfStream: boolean;
    close(): void;
    discardBufferedData(): void;
    dispose(): void;
    peek(): int;
    read(): int;
    read(buffer: char[], index: int, count: int): int;
    read(buffer: Span_1<CLROf<char>>): int;
    read(buffer: Span_1<CLROf<char>>): int;
    readAsync(buffer: char[], index: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<char>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readAsync(buffer: char[], index: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<char>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readBlock(buffer: char[], index: int, count: int): int;
    readBlock(buffer: Span_1<CLROf<char>>): int;
    readBlock(buffer: Span_1<CLROf<char>>): int;
    readBlockAsync(buffer: char[], index: int, count: int): Task_1<CLROf<int>>;
    readBlockAsync(buffer: Memory_1<CLROf<char>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readBlockAsync(buffer: char[], index: int, count: int): Task_1<CLROf<int>>;
    readBlockAsync(buffer: Memory_1<CLROf<char>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readLine(): string;
    readLineAsync(): Task_1<CLROf<string>>;
    readLineAsync(cancellationToken: CancellationToken): ValueTask_1<CLROf<string>>;
    readLineAsync(): Task_1<CLROf<string>>;
    readLineAsync(cancellationToken: CancellationToken): ValueTask_1<CLROf<string>>;
    readToEnd(): string;
    readToEndAsync(): Task_1<CLROf<string>>;
    readToEndAsync(cancellationToken: CancellationToken): Task_1<CLROf<string>>;
    readToEndAsync(): Task_1<CLROf<string>>;
    readToEndAsync(cancellationToken: CancellationToken): Task_1<CLROf<string>>;
}


export const StreamReader: {
    new(stream: Stream): StreamReader$instance;
    new(stream: Stream, detectEncodingFromByteOrderMarks: boolean): StreamReader$instance;
    new(stream: Stream, encoding: Encoding): StreamReader$instance;
    new(stream: Stream, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean): StreamReader$instance;
    new(stream: Stream, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean, bufferSize: int): StreamReader$instance;
    new(stream: Stream, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean, bufferSize: int, leaveOpen: boolean): StreamReader$instance;
    new(path: string): StreamReader$instance;
    new(path: string, detectEncodingFromByteOrderMarks: boolean): StreamReader$instance;
    new(path: string, encoding: Encoding): StreamReader$instance;
    new(path: string, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean): StreamReader$instance;
    new(path: string, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean, bufferSize: int): StreamReader$instance;
    new(path: string, options: FileStreamOptions): StreamReader$instance;
    new(path: string, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean, options: FileStreamOptions): StreamReader$instance;
};


export interface __StreamReader$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type StreamReader = StreamReader$instance & __StreamReader$views;


export interface StreamWriter$instance extends TextWriter$instance {
    autoFlush: boolean;
    readonly baseStream: Stream;
    readonly encoding: Encoding;
    close(): void;
    dispose(): void;
    disposeAsync(): ValueTask;
    flush(): void;
    flushAsync(): Task;
    flushAsync(cancellationToken: CancellationToken): Task;
    write(value: char): void;
    write(buffer: char[]): void;
    write(buffer: char[], index: int, count: int): void;
    write(buffer: ReadOnlySpan_1<CLROf<char>>): void;
    write(value: string): void;
    write(format: string, arg0: unknown): void;
    write(format: string, arg0: unknown, arg1: unknown): void;
    write(format: string, arg0: unknown, arg1: unknown, arg2: unknown): void;
    write(format: string, arg: unknown[]): void;
    write(format: string, arg: ReadOnlySpan_1<unknown>): void;
    write(buffer: ReadOnlySpan_1<CLROf<char>>): void;
    write(value: boolean): void;
    write(value: int): void;
    write(value: uint): void;
    write(value: long): void;
    write(value: ulong): void;
    write(value: float): void;
    write(value: double): void;
    write(value: decimal): void;
    write(value: unknown): void;
    write(value: StringBuilder): void;
    write(format: string, arg: ReadOnlySpan_1<unknown>): void;
    writeAsync(value: char): Task;
    writeAsync(value: string): Task;
    writeAsync(buffer: char[], index: int, count: int): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<char>>, cancellationToken?: CancellationToken): Task;
    writeAsync(value: StringBuilder, cancellationToken?: CancellationToken): Task;
    writeAsync(buffer: char[]): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<char>>, cancellationToken?: CancellationToken): Task;
    writeLine(value: string): void;
    writeLine(buffer: ReadOnlySpan_1<CLROf<char>>): void;
    writeLine(format: string, arg0: unknown): void;
    writeLine(format: string, arg0: unknown, arg1: unknown): void;
    writeLine(format: string, arg0: unknown, arg1: unknown, arg2: unknown): void;
    writeLine(format: string, arg: unknown[]): void;
    writeLine(format: string, arg: ReadOnlySpan_1<unknown>): void;
    writeLine(): void;
    writeLine(value: char): void;
    writeLine(buffer: char[]): void;
    writeLine(buffer: char[], index: int, count: int): void;
    writeLine(buffer: ReadOnlySpan_1<CLROf<char>>): void;
    writeLine(value: boolean): void;
    writeLine(value: int): void;
    writeLine(value: uint): void;
    writeLine(value: long): void;
    writeLine(value: ulong): void;
    writeLine(value: float): void;
    writeLine(value: double): void;
    writeLine(value: decimal): void;
    writeLine(value: StringBuilder): void;
    writeLine(value: unknown): void;
    writeLine(format: string, arg: ReadOnlySpan_1<unknown>): void;
    writeLineAsync(): Task;
    writeLineAsync(value: char): Task;
    writeLineAsync(value: string): Task;
    writeLineAsync(buffer: char[], index: int, count: int): Task;
    writeLineAsync(buffer: ReadOnlyMemory_1<CLROf<char>>, cancellationToken?: CancellationToken): Task;
    writeLineAsync(value: StringBuilder, cancellationToken?: CancellationToken): Task;
    writeLineAsync(buffer: char[]): Task;
    writeLineAsync(buffer: ReadOnlyMemory_1<CLROf<char>>, cancellationToken?: CancellationToken): Task;
}


export const StreamWriter: {
    new(stream: Stream): StreamWriter$instance;
    new(stream: Stream, encoding: Encoding): StreamWriter$instance;
    new(stream: Stream, encoding: Encoding, bufferSize: int): StreamWriter$instance;
    new(stream: Stream, encoding: Encoding, bufferSize: int, leaveOpen: boolean): StreamWriter$instance;
    new(path: string): StreamWriter$instance;
    new(path: string, append: boolean): StreamWriter$instance;
    new(path: string, append: boolean, encoding: Encoding): StreamWriter$instance;
    new(path: string, append: boolean, encoding: Encoding, bufferSize: int): StreamWriter$instance;
    new(path: string, options: FileStreamOptions): StreamWriter$instance;
    new(path: string, encoding: Encoding, options: FileStreamOptions): StreamWriter$instance;
};


export interface __StreamWriter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type StreamWriter = StreamWriter$instance & __StreamWriter$views;


export interface StringReader$instance extends TextReader$instance {
    close(): void;
    dispose(): void;
    peek(): int;
    read(): int;
    read(buffer: char[], index: int, count: int): int;
    read(buffer: Span_1<CLROf<char>>): int;
    read(buffer: Span_1<CLROf<char>>): int;
    readAsync(buffer: char[], index: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<char>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readAsync(buffer: char[], index: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<char>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readBlock(buffer: Span_1<CLROf<char>>): int;
    readBlock(buffer: char[], index: int, count: int): int;
    readBlock(buffer: Span_1<CLROf<char>>): int;
    readBlockAsync(buffer: char[], index: int, count: int): Task_1<CLROf<int>>;
    readBlockAsync(buffer: Memory_1<CLROf<char>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readBlockAsync(buffer: char[], index: int, count: int): Task_1<CLROf<int>>;
    readBlockAsync(buffer: Memory_1<CLROf<char>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readLine(): string;
    readLineAsync(): Task_1<CLROf<string>>;
    readLineAsync(cancellationToken: CancellationToken): ValueTask_1<CLROf<string>>;
    readLineAsync(): Task_1<CLROf<string>>;
    readLineAsync(cancellationToken: CancellationToken): ValueTask_1<CLROf<string>>;
    readToEnd(): string;
    readToEndAsync(): Task_1<CLROf<string>>;
    readToEndAsync(cancellationToken: CancellationToken): Task_1<CLROf<string>>;
    readToEndAsync(): Task_1<CLROf<string>>;
    readToEndAsync(cancellationToken: CancellationToken): Task_1<CLROf<string>>;
}


export const StringReader: {
    new(s: string): StringReader$instance;
};


export interface __StringReader$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type StringReader = StringReader$instance & __StringReader$views;


export interface StringWriter$instance extends TextWriter$instance {
    readonly encoding: Encoding;
    close(): void;
    dispose(): void;
    disposeAsync(): ValueTask;
    flushAsync(): Task;
    flushAsync(cancellationToken: CancellationToken): Task;
    getStringBuilder(): StringBuilder;
    toString(): string;
    write(value: char): void;
    write(buffer: char[], index: int, count: int): void;
    write(buffer: ReadOnlySpan_1<CLROf<char>>): void;
    write(value: string): void;
    write(value: StringBuilder): void;
    write(buffer: char[]): void;
    write(buffer: ReadOnlySpan_1<CLROf<char>>): void;
    write(value: boolean): void;
    write(value: int): void;
    write(value: uint): void;
    write(value: long): void;
    write(value: ulong): void;
    write(value: float): void;
    write(value: double): void;
    write(value: decimal): void;
    write(value: unknown): void;
    write(format: string, arg0: unknown): void;
    write(format: string, arg0: unknown, arg1: unknown): void;
    write(format: string, arg0: unknown, arg1: unknown, arg2: unknown): void;
    write(format: string, arg: unknown[]): void;
    write(format: string, arg: ReadOnlySpan_1<unknown>): void;
    writeAsync(value: char): Task;
    writeAsync(value: string): Task;
    writeAsync(buffer: char[], index: int, count: int): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<char>>, cancellationToken?: CancellationToken): Task;
    writeAsync(value: StringBuilder, cancellationToken?: CancellationToken): Task;
    writeAsync(buffer: char[]): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<char>>, cancellationToken?: CancellationToken): Task;
    writeLine(buffer: ReadOnlySpan_1<CLROf<char>>): void;
    writeLine(value: StringBuilder): void;
    writeLine(): void;
    writeLine(value: char): void;
    writeLine(buffer: char[]): void;
    writeLine(buffer: char[], index: int, count: int): void;
    writeLine(buffer: ReadOnlySpan_1<CLROf<char>>): void;
    writeLine(value: boolean): void;
    writeLine(value: int): void;
    writeLine(value: uint): void;
    writeLine(value: long): void;
    writeLine(value: ulong): void;
    writeLine(value: float): void;
    writeLine(value: double): void;
    writeLine(value: decimal): void;
    writeLine(value: string): void;
    writeLine(value: unknown): void;
    writeLine(format: string, arg0: unknown): void;
    writeLine(format: string, arg0: unknown, arg1: unknown): void;
    writeLine(format: string, arg0: unknown, arg1: unknown, arg2: unknown): void;
    writeLine(format: string, arg: unknown[]): void;
    writeLine(format: string, arg: ReadOnlySpan_1<unknown>): void;
    writeLineAsync(value: char): Task;
    writeLineAsync(value: string): Task;
    writeLineAsync(value: StringBuilder, cancellationToken?: CancellationToken): Task;
    writeLineAsync(buffer: char[], index: int, count: int): Task;
    writeLineAsync(buffer: ReadOnlyMemory_1<CLROf<char>>, cancellationToken?: CancellationToken): Task;
    writeLineAsync(buffer: char[]): Task;
    writeLineAsync(buffer: ReadOnlyMemory_1<CLROf<char>>, cancellationToken?: CancellationToken): Task;
    writeLineAsync(): Task;
}


export const StringWriter: {
    new(): StringWriter$instance;
    new(formatProvider: IFormatProvider): StringWriter$instance;
    new(sb: StringBuilder): StringWriter$instance;
    new(sb: StringBuilder, formatProvider: IFormatProvider): StringWriter$instance;
};


export interface __StringWriter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type StringWriter = StringWriter$instance & __StringWriter$views;


export interface TextReader$instance extends MarshalByRefObject {
    close(): void;
    dispose(): void;
    peek(): int;
    read(): int;
    read(buffer: char[], index: int, count: int): int;
    read(buffer: Span_1<CLROf<char>>): int;
    readAsync(buffer: char[], index: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<char>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readBlock(buffer: char[], index: int, count: int): int;
    readBlock(buffer: Span_1<CLROf<char>>): int;
    readBlockAsync(buffer: char[], index: int, count: int): Task_1<CLROf<int>>;
    readBlockAsync(buffer: Memory_1<CLROf<char>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readLine(): string;
    readLineAsync(): Task_1<CLROf<string>>;
    readLineAsync(cancellationToken: CancellationToken): ValueTask_1<CLROf<string>>;
    readToEnd(): string;
    readToEndAsync(): Task_1<CLROf<string>>;
    readToEndAsync(cancellationToken: CancellationToken): Task_1<CLROf<string>>;
}


export const TextReader: {
    readonly null_: TextReader;
    synchronized(reader: TextReader): TextReader;
};


export interface __TextReader$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface TextReader$instance extends System_Internal.IDisposable$instance {}

export type TextReader = TextReader$instance & __TextReader$views;


export interface TextWriter$instance extends MarshalByRefObject {
    readonly encoding: Encoding;
    readonly formatProvider: IFormatProvider;
    newLine: string;
    close(): void;
    dispose(): void;
    disposeAsync(): ValueTask;
    flush(): void;
    flushAsync(): Task;
    flushAsync(cancellationToken: CancellationToken): Task;
    write(value: char): void;
    write(buffer: char[]): void;
    write(buffer: char[], index: int, count: int): void;
    write(buffer: ReadOnlySpan_1<CLROf<char>>): void;
    write(value: boolean): void;
    write(value: int): void;
    write(value: uint): void;
    write(value: long): void;
    write(value: ulong): void;
    write(value: float): void;
    write(value: double): void;
    write(value: decimal): void;
    write(value: string): void;
    write(value: unknown): void;
    write(value: StringBuilder): void;
    write(format: string, arg0: unknown): void;
    write(format: string, arg0: unknown, arg1: unknown): void;
    write(format: string, arg0: unknown, arg1: unknown, arg2: unknown): void;
    write(format: string, arg: unknown[]): void;
    write(format: string, arg: ReadOnlySpan_1<unknown>): void;
    writeAsync(value: char): Task;
    writeAsync(value: string): Task;
    writeAsync(value: StringBuilder, cancellationToken?: CancellationToken): Task;
    writeAsync(buffer: char[]): Task;
    writeAsync(buffer: char[], index: int, count: int): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<char>>, cancellationToken?: CancellationToken): Task;
    writeLine(): void;
    writeLine(value: char): void;
    writeLine(buffer: char[]): void;
    writeLine(buffer: char[], index: int, count: int): void;
    writeLine(buffer: ReadOnlySpan_1<CLROf<char>>): void;
    writeLine(value: boolean): void;
    writeLine(value: int): void;
    writeLine(value: uint): void;
    writeLine(value: long): void;
    writeLine(value: ulong): void;
    writeLine(value: float): void;
    writeLine(value: double): void;
    writeLine(value: decimal): void;
    writeLine(value: string): void;
    writeLine(value: StringBuilder): void;
    writeLine(value: unknown): void;
    writeLine(format: string, arg0: unknown): void;
    writeLine(format: string, arg0: unknown, arg1: unknown): void;
    writeLine(format: string, arg0: unknown, arg1: unknown, arg2: unknown): void;
    writeLine(format: string, arg: unknown[]): void;
    writeLine(format: string, arg: ReadOnlySpan_1<unknown>): void;
    writeLineAsync(value: char): Task;
    writeLineAsync(value: string): Task;
    writeLineAsync(value: StringBuilder, cancellationToken?: CancellationToken): Task;
    writeLineAsync(buffer: char[]): Task;
    writeLineAsync(buffer: char[], index: int, count: int): Task;
    writeLineAsync(buffer: ReadOnlyMemory_1<CLROf<char>>, cancellationToken?: CancellationToken): Task;
    writeLineAsync(): Task;
}


export const TextWriter: {
    readonly null_: TextWriter;
    createBroadcasting(writers: TextWriter[]): TextWriter;
    synchronized(writer: TextWriter): TextWriter;
};


export interface __TextWriter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface TextWriter$instance extends System_Internal.IAsyncDisposable$instance, System_Internal.IDisposable$instance {}

export type TextWriter = TextWriter$instance & __TextWriter$views;


export interface UnmanagedMemoryAccessor$instance {
    readonly canRead: boolean;
    readonly canWrite: boolean;
    readonly capacity: long;
    dispose(): void;
    read<T extends unknown>(position: long, structure: { value: ref<T> }): void;
    readArray<T extends unknown>(position: long, array: T[], offset: int, count: int): int;
    readBoolean(position: long): boolean;
    readByte(position: long): byte;
    readChar(position: long): char;
    readDecimal(position: long): decimal;
    readDouble(position: long): double;
    readInt16(position: long): short;
    readInt32(position: long): int;
    readInt64(position: long): long;
    readSByte(position: long): sbyte;
    readSingle(position: long): float;
    readUInt16(position: long): ushort;
    readUInt32(position: long): uint;
    readUInt64(position: long): ulong;
    write(position: long, value: boolean): void;
    write(position: long, value: byte): void;
    write(position: long, value: char): void;
    write(position: long, value: short): void;
    write(position: long, value: int): void;
    write(position: long, value: long): void;
    write(position: long, value: decimal): void;
    write(position: long, value: float): void;
    write(position: long, value: double): void;
    write(position: long, value: sbyte): void;
    write(position: long, value: ushort): void;
    write(position: long, value: uint): void;
    write(position: long, value: ulong): void;
    write<T extends unknown>(position: long, structure: { value: ref<T> }): void;
    writeArray<T extends unknown>(position: long, array: T[], offset: int, count: int): void;
}


export const UnmanagedMemoryAccessor: {
    new(buffer: SafeBuffer, offset: long, capacity: long): UnmanagedMemoryAccessor$instance;
    new(buffer: SafeBuffer, offset: long, capacity: long, access: FileAccess): UnmanagedMemoryAccessor$instance;
};


export interface __UnmanagedMemoryAccessor$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface UnmanagedMemoryAccessor$instance extends System_Internal.IDisposable$instance {}

export type UnmanagedMemoryAccessor = UnmanagedMemoryAccessor$instance & __UnmanagedMemoryAccessor$views;


export interface UnmanagedMemoryStream$instance extends Stream$instance {
    readonly canRead: boolean;
    readonly canSeek: boolean;
    readonly canWrite: boolean;
    readonly capacity: long;
    readonly length: long;
    position: long;
    positionPointer: ptr<byte>;
    dispose(): void;
    disposeAsync(): ValueTask;
    flush(): void;
    flushAsync(cancellationToken: CancellationToken): Task;
    flushAsync(): Task;
    read(buffer: byte[], offset: int, count: int): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readByte(): int;
    seek(offset: long, loc: SeekOrigin): long;
    setLength(value: long): void;
    write(buffer: byte[], offset: int, count: int): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    writeAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeAsync(buffer: byte[], offset: int, count: int): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeByte(value: byte): void;
}


export const UnmanagedMemoryStream: {
    new(buffer: SafeBuffer, offset: long, length: long): UnmanagedMemoryStream$instance;
    new(buffer: SafeBuffer, offset: long, length: long, access: FileAccess): UnmanagedMemoryStream$instance;
    new(pointer: ptr<byte>, length: long): UnmanagedMemoryStream$instance;
    new(pointer: ptr<byte>, length: long, capacity: long, access: FileAccess): UnmanagedMemoryStream$instance;
};


export interface __UnmanagedMemoryStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type UnmanagedMemoryStream = UnmanagedMemoryStream$instance & __UnmanagedMemoryStream$views;


export abstract class Directory$instance {
    static createDirectory(path: string, unixCreateMode: UnixFileMode): DirectoryInfo;
    static createDirectory(path: string): DirectoryInfo;
    static createSymbolicLink(path: string, pathToTarget: string): FileSystemInfo;
    static createTempSubdirectory(prefix?: string): DirectoryInfo;
    static delete_(path: string, recursive: boolean): void;
    static delete_(path: string): void;
    static enumerateDirectories(path: string, searchPattern: string, enumerationOptions: EnumerationOptions): IEnumerable_1<CLROf<string>>;
    static enumerateDirectories(path: string, searchPattern: string, searchOption: SearchOption): IEnumerable_1<CLROf<string>>;
    static enumerateDirectories(path: string, searchPattern: string): IEnumerable_1<CLROf<string>>;
    static enumerateDirectories(path: string): IEnumerable_1<CLROf<string>>;
    static enumerateFiles(path: string, searchPattern: string, enumerationOptions: EnumerationOptions): IEnumerable_1<CLROf<string>>;
    static enumerateFiles(path: string, searchPattern: string, searchOption: SearchOption): IEnumerable_1<CLROf<string>>;
    static enumerateFiles(path: string, searchPattern: string): IEnumerable_1<CLROf<string>>;
    static enumerateFiles(path: string): IEnumerable_1<CLROf<string>>;
    static enumerateFileSystemEntries(path: string, searchPattern: string, enumerationOptions: EnumerationOptions): IEnumerable_1<CLROf<string>>;
    static enumerateFileSystemEntries(path: string, searchPattern: string, searchOption: SearchOption): IEnumerable_1<CLROf<string>>;
    static enumerateFileSystemEntries(path: string, searchPattern: string): IEnumerable_1<CLROf<string>>;
    static enumerateFileSystemEntries(path: string): IEnumerable_1<CLROf<string>>;
    static exists(path: string): boolean;
    static getCreationTime(path: string): DateTime;
    static getCreationTimeUtc(path: string): DateTime;
    static getCurrentDirectory(): string;
    static getDirectories(path: string, searchPattern: string, enumerationOptions: EnumerationOptions): string[];
    static getDirectories(path: string, searchPattern: string, searchOption: SearchOption): string[];
    static getDirectories(path: string, searchPattern: string): string[];
    static getDirectories(path: string): string[];
    static getDirectoryRoot(path: string): string;
    static getFiles(path: string, searchPattern: string, enumerationOptions: EnumerationOptions): string[];
    static getFiles(path: string, searchPattern: string, searchOption: SearchOption): string[];
    static getFiles(path: string, searchPattern: string): string[];
    static getFiles(path: string): string[];
    static getFileSystemEntries(path: string, searchPattern: string, enumerationOptions: EnumerationOptions): string[];
    static getFileSystemEntries(path: string, searchPattern: string, searchOption: SearchOption): string[];
    static getFileSystemEntries(path: string, searchPattern: string): string[];
    static getFileSystemEntries(path: string): string[];
    static getLastAccessTime(path: string): DateTime;
    static getLastAccessTimeUtc(path: string): DateTime;
    static getLastWriteTime(path: string): DateTime;
    static getLastWriteTimeUtc(path: string): DateTime;
    static getLogicalDrives(): string[];
    static getParent(path: string): DirectoryInfo;
    static move(sourceDirName: string, destDirName: string): void;
    static resolveLinkTarget(linkPath: string, returnFinalTarget: boolean): FileSystemInfo;
    static setCreationTime(path: string, creationTime: DateTime): void;
    static setCreationTimeUtc(path: string, creationTimeUtc: DateTime): void;
    static setCurrentDirectory(path: string): void;
    static setLastAccessTime(path: string, lastAccessTime: DateTime): void;
    static setLastAccessTimeUtc(path: string, lastAccessTimeUtc: DateTime): void;
    static setLastWriteTime(path: string, lastWriteTime: DateTime): void;
    static setLastWriteTimeUtc(path: string, lastWriteTimeUtc: DateTime): void;
}


export type Directory = Directory$instance;

export abstract class File$instance {
    static appendAllBytes(path: string, bytes: byte[]): void;
    static appendAllBytes(path: string, bytes: ReadOnlySpan_1<CLROf<byte>>): void;
    static appendAllBytesAsync(path: string, bytes: byte[], cancellationToken?: CancellationToken): Task;
    static appendAllBytesAsync(path: string, bytes: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): Task;
    static appendAllLines(path: string, contents: IEnumerable_1<CLROf<string>>, encoding: Encoding): void;
    static appendAllLines(path: string, contents: IEnumerable_1<CLROf<string>>): void;
    static appendAllLinesAsync(path: string, contents: IEnumerable_1<CLROf<string>>, encoding: Encoding, cancellationToken?: CancellationToken): Task;
    static appendAllLinesAsync(path: string, contents: IEnumerable_1<CLROf<string>>, cancellationToken?: CancellationToken): Task;
    static appendAllText(path: string, contents: ReadOnlySpan_1<CLROf<char>>, encoding: Encoding): void;
    static appendAllText(path: string, contents: ReadOnlySpan_1<CLROf<char>>): void;
    static appendAllText(path: string, contents: string, encoding: Encoding): void;
    static appendAllText(path: string, contents: string): void;
    static appendAllTextAsync(path: string, contents: ReadOnlyMemory_1<CLROf<char>>, encoding: Encoding, cancellationToken?: CancellationToken): Task;
    static appendAllTextAsync(path: string, contents: ReadOnlyMemory_1<CLROf<char>>, cancellationToken?: CancellationToken): Task;
    static appendAllTextAsync(path: string, contents: string, encoding: Encoding, cancellationToken?: CancellationToken): Task;
    static appendAllTextAsync(path: string, contents: string, cancellationToken?: CancellationToken): Task;
    static appendText(path: string): StreamWriter;
    static copy(sourceFileName: string, destFileName: string, overwrite: boolean): void;
    static copy(sourceFileName: string, destFileName: string): void;
    static create(path: string, bufferSize: int, options: FileOptions): FileStream;
    static create(path: string, bufferSize: int): FileStream;
    static create(path: string): FileStream;
    static createSymbolicLink(path: string, pathToTarget: string): FileSystemInfo;
    static createText(path: string): StreamWriter;
    static decrypt(path: string): void;
    static delete_(path: string): void;
    static encrypt(path: string): void;
    static exists(path: string): boolean;
    static getAttributes(fileHandle: SafeFileHandle): FileAttributes;
    static getAttributes(path: string): FileAttributes;
    static getCreationTime(fileHandle: SafeFileHandle): DateTime;
    static getCreationTime(path: string): DateTime;
    static getCreationTimeUtc(fileHandle: SafeFileHandle): DateTime;
    static getCreationTimeUtc(path: string): DateTime;
    static getLastAccessTime(fileHandle: SafeFileHandle): DateTime;
    static getLastAccessTime(path: string): DateTime;
    static getLastAccessTimeUtc(fileHandle: SafeFileHandle): DateTime;
    static getLastAccessTimeUtc(path: string): DateTime;
    static getLastWriteTime(fileHandle: SafeFileHandle): DateTime;
    static getLastWriteTime(path: string): DateTime;
    static getLastWriteTimeUtc(fileHandle: SafeFileHandle): DateTime;
    static getLastWriteTimeUtc(path: string): DateTime;
    static getUnixFileMode(fileHandle: SafeFileHandle): UnixFileMode;
    static getUnixFileMode(path: string): UnixFileMode;
    static move(sourceFileName: string, destFileName: string, overwrite: boolean): void;
    static move(sourceFileName: string, destFileName: string): void;
    static open(path: string, mode: FileMode, access: FileAccess, share: FileShare): FileStream;
    static open(path: string, mode: FileMode, access: FileAccess): FileStream;
    static open(path: string, mode: FileMode): FileStream;
    static open(path: string, options: FileStreamOptions): FileStream;
    static openHandle(path: string, mode?: FileMode, access?: FileAccess, share?: FileShare, options?: FileOptions, preallocationSize?: long): SafeFileHandle;
    static openRead(path: string): FileStream;
    static openText(path: string): StreamReader;
    static openWrite(path: string): FileStream;
    static readAllBytes(path: string): byte[];
    static readAllBytesAsync(path: string, cancellationToken?: CancellationToken): Task_1<byte[]>;
    static readAllLines(path: string, encoding: Encoding): string[];
    static readAllLines(path: string): string[];
    static readAllLinesAsync(path: string, encoding: Encoding, cancellationToken?: CancellationToken): Task_1<string[]>;
    static readAllLinesAsync(path: string, cancellationToken?: CancellationToken): Task_1<string[]>;
    static readAllText(path: string, encoding: Encoding): string;
    static readAllText(path: string): string;
    static readAllTextAsync(path: string, encoding: Encoding, cancellationToken?: CancellationToken): Task_1<CLROf<string>>;
    static readAllTextAsync(path: string, cancellationToken?: CancellationToken): Task_1<CLROf<string>>;
    static readLines(path: string, encoding: Encoding): IEnumerable_1<CLROf<string>>;
    static readLines(path: string): IEnumerable_1<CLROf<string>>;
    static readLinesAsync(path: string, encoding: Encoding, cancellationToken?: CancellationToken): IAsyncEnumerable_1<CLROf<string>>;
    static readLinesAsync(path: string, cancellationToken?: CancellationToken): IAsyncEnumerable_1<CLROf<string>>;
    static replace(sourceFileName: string, destinationFileName: string, destinationBackupFileName: string, ignoreMetadataErrors: boolean): void;
    static replace(sourceFileName: string, destinationFileName: string, destinationBackupFileName: string): void;
    static resolveLinkTarget(linkPath: string, returnFinalTarget: boolean): FileSystemInfo;
    static setAttributes(fileHandle: SafeFileHandle, fileAttributes: FileAttributes): void;
    static setAttributes(path: string, fileAttributes: FileAttributes): void;
    static setCreationTime(fileHandle: SafeFileHandle, creationTime: DateTime): void;
    static setCreationTime(path: string, creationTime: DateTime): void;
    static setCreationTimeUtc(fileHandle: SafeFileHandle, creationTimeUtc: DateTime): void;
    static setCreationTimeUtc(path: string, creationTimeUtc: DateTime): void;
    static setLastAccessTime(fileHandle: SafeFileHandle, lastAccessTime: DateTime): void;
    static setLastAccessTime(path: string, lastAccessTime: DateTime): void;
    static setLastAccessTimeUtc(fileHandle: SafeFileHandle, lastAccessTimeUtc: DateTime): void;
    static setLastAccessTimeUtc(path: string, lastAccessTimeUtc: DateTime): void;
    static setLastWriteTime(fileHandle: SafeFileHandle, lastWriteTime: DateTime): void;
    static setLastWriteTime(path: string, lastWriteTime: DateTime): void;
    static setLastWriteTimeUtc(fileHandle: SafeFileHandle, lastWriteTimeUtc: DateTime): void;
    static setLastWriteTimeUtc(path: string, lastWriteTimeUtc: DateTime): void;
    static setUnixFileMode(fileHandle: SafeFileHandle, mode: UnixFileMode): void;
    static setUnixFileMode(path: string, mode: UnixFileMode): void;
    static writeAllBytes(path: string, bytes: byte[]): void;
    static writeAllBytes(path: string, bytes: ReadOnlySpan_1<CLROf<byte>>): void;
    static writeAllBytesAsync(path: string, bytes: byte[], cancellationToken?: CancellationToken): Task;
    static writeAllBytesAsync(path: string, bytes: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): Task;
    static writeAllLines(path: string, contents: IEnumerable_1<CLROf<string>>, encoding: Encoding): void;
    static writeAllLines(path: string, contents: IEnumerable_1<CLROf<string>>): void;
    static writeAllLines(path: string, contents: string[], encoding: Encoding): void;
    static writeAllLines(path: string, contents: string[]): void;
    static writeAllLinesAsync(path: string, contents: IEnumerable_1<CLROf<string>>, encoding: Encoding, cancellationToken?: CancellationToken): Task;
    static writeAllLinesAsync(path: string, contents: IEnumerable_1<CLROf<string>>, cancellationToken?: CancellationToken): Task;
    static writeAllText(path: string, contents: ReadOnlySpan_1<CLROf<char>>, encoding: Encoding): void;
    static writeAllText(path: string, contents: ReadOnlySpan_1<CLROf<char>>): void;
    static writeAllText(path: string, contents: string, encoding: Encoding): void;
    static writeAllText(path: string, contents: string): void;
    static writeAllTextAsync(path: string, contents: ReadOnlyMemory_1<CLROf<char>>, encoding: Encoding, cancellationToken?: CancellationToken): Task;
    static writeAllTextAsync(path: string, contents: ReadOnlyMemory_1<CLROf<char>>, cancellationToken?: CancellationToken): Task;
    static writeAllTextAsync(path: string, contents: string, encoding: Encoding, cancellationToken?: CancellationToken): Task;
    static writeAllTextAsync(path: string, contents: string, cancellationToken?: CancellationToken): Task;
}


export type File = File$instance;

export abstract class FileSystemAclExtensions$instance {
    static create(directoryInfo: DirectoryInfo, directorySecurity: DirectorySecurity): void;
    static create(fileInfo: FileInfo, mode: FileMode, rights: FileSystemRights, share: FileShare, bufferSize: int, options: FileOptions, fileSecurity: FileSecurity): FileStream;
    static createDirectory(directorySecurity: DirectorySecurity, path: string): DirectoryInfo;
    static getAccessControl(directoryInfo: DirectoryInfo, includeSections: AccessControlSections): DirectorySecurity;
    static getAccessControl(directoryInfo: DirectoryInfo): DirectorySecurity;
    static getAccessControl(fileInfo: FileInfo, includeSections: AccessControlSections): FileSecurity;
    static getAccessControl(fileInfo: FileInfo): FileSecurity;
    static getAccessControl(fileStream: FileStream): FileSecurity;
    static setAccessControl(directoryInfo: DirectoryInfo, directorySecurity: DirectorySecurity): void;
    static setAccessControl(fileInfo: FileInfo, fileSecurity: FileSecurity): void;
    static setAccessControl(fileStream: FileStream, fileSecurity: FileSecurity): void;
}


export type FileSystemAclExtensions = FileSystemAclExtensions$instance;

export abstract class Path$instance {
    static readonly directorySeparatorChar: char;
    static readonly altDirectorySeparatorChar: char;
    static readonly volumeSeparatorChar: char;
    static readonly pathSeparator: char;
    static readonly invalidPathChars: char[];
    static changeExtension(path: string, extension: string): string;
    static combine(paths: ReadOnlySpan_1<CLROf<string>>): string;
    static combine(path1: string, path2: string, path3: string, path4: string): string;
    static combine(path1: string, path2: string, path3: string): string;
    static combine(path1: string, path2: string): string;
    static combine(paths: string[]): string;
    static endsInDirectorySeparator(path: ReadOnlySpan_1<CLROf<char>>): boolean;
    static endsInDirectorySeparator(path: string): boolean;
    static exists(path: string): boolean;
    static getDirectoryName(path: ReadOnlySpan_1<CLROf<char>>): ReadOnlySpan_1<CLROf<char>>;
    static getDirectoryName(path: string): string;
    static getExtension(path: ReadOnlySpan_1<CLROf<char>>): ReadOnlySpan_1<CLROf<char>>;
    static getExtension(path: string): string;
    static getFileName(path: ReadOnlySpan_1<CLROf<char>>): ReadOnlySpan_1<CLROf<char>>;
    static getFileName(path: string): string;
    static getFileNameWithoutExtension(path: ReadOnlySpan_1<CLROf<char>>): ReadOnlySpan_1<CLROf<char>>;
    static getFileNameWithoutExtension(path: string): string;
    static getFullPath(path: string, basePath: string): string;
    static getFullPath(path: string): string;
    static getInvalidFileNameChars(): char[];
    static getInvalidPathChars(): char[];
    static getPathRoot(path: ReadOnlySpan_1<CLROf<char>>): ReadOnlySpan_1<CLROf<char>>;
    static getPathRoot(path: string): string;
    static getRandomFileName(): string;
    static getRelativePath(relativeTo: string, path: string): string;
    static getTempFileName(): string;
    static getTempPath(): string;
    static hasExtension(path: ReadOnlySpan_1<CLROf<char>>): boolean;
    static hasExtension(path: string): boolean;
    static isPathFullyQualified(path: ReadOnlySpan_1<CLROf<char>>): boolean;
    static isPathFullyQualified(path: string): boolean;
    static isPathRooted(path: ReadOnlySpan_1<CLROf<char>>): boolean;
    static isPathRooted(path: string): boolean;
    static join(path1: ReadOnlySpan_1<CLROf<char>>, path2: ReadOnlySpan_1<CLROf<char>>, path3: ReadOnlySpan_1<CLROf<char>>, path4: ReadOnlySpan_1<CLROf<char>>): string;
    static join(path1: ReadOnlySpan_1<CLROf<char>>, path2: ReadOnlySpan_1<CLROf<char>>, path3: ReadOnlySpan_1<CLROf<char>>): string;
    static join(path1: ReadOnlySpan_1<CLROf<char>>, path2: ReadOnlySpan_1<CLROf<char>>): string;
    static join(paths: ReadOnlySpan_1<CLROf<string>>): string;
    static join(path1: string, path2: string, path3: string, path4: string): string;
    static join(path1: string, path2: string, path3: string): string;
    static join(path1: string, path2: string): string;
    static join(paths: string[]): string;
    static trimEndingDirectorySeparator(path: ReadOnlySpan_1<CLROf<char>>): ReadOnlySpan_1<CLROf<char>>;
    static trimEndingDirectorySeparator(path: string): string;
    static tryJoin(path1: ReadOnlySpan_1<CLROf<char>>, path2: ReadOnlySpan_1<CLROf<char>>, path3: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    static tryJoin(path1: ReadOnlySpan_1<CLROf<char>>, path2: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
}


export type Path = Path$instance;

export abstract class RandomAccess$instance {
    static flushToDisk(handle: SafeFileHandle): void;
    static getLength(handle: SafeFileHandle): long;
    static read(handle: SafeFileHandle, buffers: IReadOnlyList_1<Memory_1<CLROf<byte>>>, fileOffset: long): long;
    static read(handle: SafeFileHandle, buffer: Span_1<CLROf<byte>>, fileOffset: long): int;
    static readAsync(handle: SafeFileHandle, buffers: IReadOnlyList_1<Memory_1<CLROf<byte>>>, fileOffset: long, cancellationToken?: CancellationToken): ValueTask_1<CLROf<long>>;
    static readAsync(handle: SafeFileHandle, buffer: Memory_1<CLROf<byte>>, fileOffset: long, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static setLength(handle: SafeFileHandle, length: long): void;
    static write(handle: SafeFileHandle, buffers: IReadOnlyList_1<ReadOnlyMemory_1<CLROf<byte>>>, fileOffset: long): void;
    static write(handle: SafeFileHandle, buffer: ReadOnlySpan_1<CLROf<byte>>, fileOffset: long): void;
    static writeAsync(handle: SafeFileHandle, buffers: IReadOnlyList_1<ReadOnlyMemory_1<CLROf<byte>>>, fileOffset: long, cancellationToken?: CancellationToken): ValueTask;
    static writeAsync(handle: SafeFileHandle, buffer: ReadOnlyMemory_1<CLROf<byte>>, fileOffset: long, cancellationToken?: CancellationToken): ValueTask;
}


export type RandomAccess = RandomAccess$instance;

