// Generated by tsbindgen - Architecture
// Namespace: System.Transactions
// Assembly: System.Transactions.Local

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { WaitHandle } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { AsyncCallback, Boolean as ClrBoolean, Byte, DateTime, Delegate, Enum, EventArgs, Exception, Guid, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, MulticastDelegate, Object as ClrObject, String as ClrString, SystemException, TimeSpan, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum DependentCloneOption {
    blockCommitUntilComplete = 0,
    rollbackIfNotComplete = 1
}


export enum EnlistmentOptions {
    none = 0,
    enlistDuringPrepareRequired = 1
}


export enum EnterpriseServicesInteropOption {
    none = 0,
    automatic = 1,
    full = 2
}


export enum IsolationLevel {
    serializable = 0,
    repeatableRead = 1,
    readCommitted = 2,
    readUncommitted = 3,
    snapshot = 4,
    chaos = 5,
    unspecified = 6
}


export enum TransactionScopeAsyncFlowOption {
    suppress = 0,
    enabled = 1
}


export enum TransactionScopeOption {
    required = 0,
    requiresNew = 1,
    suppress = 2
}


export enum TransactionStatus {
    active = 0,
    committed = 1,
    aborted = 2,
    inDoubt = 3
}


export type HostCurrentTransactionCallback = () => Transaction;


export type TransactionCompletedEventHandler = (sender: unknown, e: TransactionEventArgs) => void;


export type TransactionStartedEventHandler = (sender: unknown, e: TransactionEventArgs) => void;


export interface IDtcTransaction$instance {
    abort(reason: nint, retaining: int, async_: int): void;
    commit(retaining: int, commitType: int, reserved: int): void;
    getTransactionInfo(transactionInformation: nint): void;
}


export type IDtcTransaction = IDtcTransaction$instance;

export interface IEnlistmentNotification$instance {
    commit(enlistment: Enlistment): void;
    prepare(preparingEnlistment: PreparingEnlistment): void;
}


export type IEnlistmentNotification = IEnlistmentNotification$instance;

export interface IPromotableSinglePhaseNotification$instance extends ITransactionPromoter {
    initialize(): void;
    promote(): byte[];
    singlePhaseCommit(singlePhaseEnlistment: SinglePhaseEnlistment): void;
}


export interface IPromotableSinglePhaseNotification$instance extends ITransactionPromoter$instance {}

export type IPromotableSinglePhaseNotification = IPromotableSinglePhaseNotification$instance;

export interface ISimpleTransactionSuperior$instance extends ITransactionPromoter {
    promote(): byte[];
    rollback(): void;
}


export interface ISimpleTransactionSuperior$instance extends ITransactionPromoter$instance {}

export type ISimpleTransactionSuperior = ISimpleTransactionSuperior$instance;

export interface ISinglePhaseNotification$instance extends IEnlistmentNotification {
    commit(enlistment: Enlistment): void;
    prepare(preparingEnlistment: PreparingEnlistment): void;
    singlePhaseCommit(singlePhaseEnlistment: SinglePhaseEnlistment): void;
}


export interface ISinglePhaseNotification$instance extends IEnlistmentNotification$instance {}

export type ISinglePhaseNotification = ISinglePhaseNotification$instance;

export interface ITransactionPromoter$instance {
    promote(): byte[];
}


export type ITransactionPromoter = ITransactionPromoter$instance;

export interface TransactionOptions$instance {
    isolationLevel: IsolationLevel;
    timeout: TimeSpan;
    equals(obj: unknown): boolean;
    equals(other: TransactionOptions): boolean;
    getHashCode(): int;
}


export const TransactionOptions: {
    new(): TransactionOptions$instance;
};


export interface __TransactionOptions$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<TransactionOptions>;

    // Structural method bridges for numeric interface constraints
    Equals(other: TransactionOptions): boolean;
}

export type TransactionOptions = TransactionOptions$instance & __TransactionOptions$views;


export interface CommittableTransaction$instance extends Transaction$instance {
    beginCommit(asyncCallback: AsyncCallback, asyncState: unknown): IAsyncResult;
    commit(): void;
    dispose(): void;
    endCommit(asyncResult: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const CommittableTransaction: {
    new(): CommittableTransaction$instance;
    new(timeout: TimeSpan): CommittableTransaction$instance;
    new(options: TransactionOptions): CommittableTransaction$instance;
};


export interface __CommittableTransaction$views {
    As_IAsyncResult(): System_Internal.IAsyncResult$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface CommittableTransaction$instance extends System_Internal.IAsyncResult$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type CommittableTransaction = CommittableTransaction$instance & __CommittableTransaction$views;


export interface DependentTransaction$instance extends Transaction$instance {
    complete(): void;
    dispose(): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const DependentTransaction: {
    new(): DependentTransaction$instance;
};


export interface __DependentTransaction$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface DependentTransaction$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type DependentTransaction = DependentTransaction$instance & __DependentTransaction$views;


export interface Enlistment$instance {
    done(): void;
}


export const Enlistment: {
    new(): Enlistment$instance;
};


export type Enlistment = Enlistment$instance;

export interface PreparingEnlistment$instance extends Enlistment {
    forceRollback(): void;
    forceRollback(e: Exception): void;
    prepared(): void;
    recoveryInformation(): byte[];
}


export const PreparingEnlistment: {
    new(): PreparingEnlistment$instance;
};


export type PreparingEnlistment = PreparingEnlistment$instance;

export interface SinglePhaseEnlistment$instance extends Enlistment {
    aborted(): void;
    aborted(e: Exception): void;
    committed(): void;
    inDoubt(): void;
    inDoubt(e: Exception): void;
}


export const SinglePhaseEnlistment: {
    new(): SinglePhaseEnlistment$instance;
};


export type SinglePhaseEnlistment = SinglePhaseEnlistment$instance;

export interface SubordinateTransaction$instance extends Transaction$instance {
    dispose(): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SubordinateTransaction: {
    new(isoLevel: IsolationLevel, superior: ISimpleTransactionSuperior): SubordinateTransaction$instance;
};


export interface __SubordinateTransaction$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface SubordinateTransaction$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type SubordinateTransaction = SubordinateTransaction$instance & __SubordinateTransaction$views;


export interface Transaction$instance {
    readonly isolationLevel: IsolationLevel;
    readonly promoterType: Guid;
    readonly transactionInformation: TransactionInformation;
    clone(): Transaction;
    dependentClone(cloneOption: DependentCloneOption): DependentTransaction;
    dispose(): void;
    enlistDurable(resourceManagerIdentifier: Guid, enlistmentNotification: IEnlistmentNotification, enlistmentOptions: EnlistmentOptions): Enlistment;
    enlistDurable(resourceManagerIdentifier: Guid, singlePhaseNotification: ISinglePhaseNotification, enlistmentOptions: EnlistmentOptions): Enlistment;
    enlistPromotableSinglePhase(promotableSinglePhaseNotification: IPromotableSinglePhaseNotification): boolean;
    enlistPromotableSinglePhase(promotableSinglePhaseNotification: IPromotableSinglePhaseNotification, promoterType: Guid): boolean;
    enlistVolatile(enlistmentNotification: IEnlistmentNotification, enlistmentOptions: EnlistmentOptions): Enlistment;
    enlistVolatile(singlePhaseNotification: ISinglePhaseNotification, enlistmentOptions: EnlistmentOptions): Enlistment;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    getPromotedToken(): byte[];
    promoteAndEnlistDurable(resourceManagerIdentifier: Guid, promotableNotification: IPromotableSinglePhaseNotification, enlistmentNotification: ISinglePhaseNotification, enlistmentOptions: EnlistmentOptions): Enlistment;
    rollback(): void;
    rollback(e: Exception): void;
    setDistributedTransactionIdentifier(promotableNotification: IPromotableSinglePhaseNotification, distributedTransactionIdentifier: Guid): void;
}


export const Transaction: {
    new(): Transaction$instance;
    current: Transaction;
};


export interface __Transaction$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Transaction$instance extends System_Internal.IDisposable$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Transaction = Transaction$instance & __Transaction$views;


export interface TransactionAbortedException$instance extends TransactionException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TransactionAbortedException: {
    new(): TransactionAbortedException$instance;
    new(message: string): TransactionAbortedException$instance;
    new(message: string, innerException: Exception): TransactionAbortedException$instance;
};


export interface __TransactionAbortedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionAbortedException = TransactionAbortedException$instance & __TransactionAbortedException$views;


export interface TransactionEventArgs$instance extends EventArgs {
    readonly transaction: Transaction;
}


export const TransactionEventArgs: {
    new(): TransactionEventArgs$instance;
};


export type TransactionEventArgs = TransactionEventArgs$instance;

export interface TransactionException$instance extends SystemException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TransactionException: {
    new(): TransactionException$instance;
    new(message: string): TransactionException$instance;
    new(message: string, innerException: Exception): TransactionException$instance;
};


export interface __TransactionException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionException = TransactionException$instance & __TransactionException$views;


export interface TransactionInDoubtException$instance extends TransactionException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TransactionInDoubtException: {
    new(): TransactionInDoubtException$instance;
    new(message: string): TransactionInDoubtException$instance;
    new(message: string, innerException: Exception): TransactionInDoubtException$instance;
};


export interface __TransactionInDoubtException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionInDoubtException = TransactionInDoubtException$instance & __TransactionInDoubtException$views;


export interface TransactionInformation$instance {
    readonly creationTime: DateTime;
    readonly distributedIdentifier: Guid;
    readonly localIdentifier: string;
    readonly status: TransactionStatus;
}


export const TransactionInformation: {
    new(): TransactionInformation$instance;
};


export type TransactionInformation = TransactionInformation$instance;

export interface TransactionManagerCommunicationException$instance extends TransactionException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TransactionManagerCommunicationException: {
    new(): TransactionManagerCommunicationException$instance;
    new(message: string): TransactionManagerCommunicationException$instance;
    new(message: string, innerException: Exception): TransactionManagerCommunicationException$instance;
};


export interface __TransactionManagerCommunicationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionManagerCommunicationException = TransactionManagerCommunicationException$instance & __TransactionManagerCommunicationException$views;


export interface TransactionPromotionException$instance extends TransactionException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TransactionPromotionException: {
    new(): TransactionPromotionException$instance;
    new(message: string): TransactionPromotionException$instance;
    new(message: string, innerException: Exception): TransactionPromotionException$instance;
};


export interface __TransactionPromotionException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionPromotionException = TransactionPromotionException$instance & __TransactionPromotionException$views;


export interface TransactionScope$instance {
    complete(): void;
    dispose(): void;
}


export const TransactionScope: {
    new(): TransactionScope$instance;
    new(scopeOption: TransactionScopeOption): TransactionScope$instance;
    new(asyncFlowOption: TransactionScopeAsyncFlowOption): TransactionScope$instance;
    new(scopeOption: TransactionScopeOption, asyncFlowOption: TransactionScopeAsyncFlowOption): TransactionScope$instance;
    new(scopeOption: TransactionScopeOption, scopeTimeout: TimeSpan): TransactionScope$instance;
    new(scopeOption: TransactionScopeOption, scopeTimeout: TimeSpan, asyncFlowOption: TransactionScopeAsyncFlowOption): TransactionScope$instance;
    new(scopeOption: TransactionScopeOption, transactionOptions: TransactionOptions): TransactionScope$instance;
    new(scopeOption: TransactionScopeOption, transactionOptions: TransactionOptions, asyncFlowOption: TransactionScopeAsyncFlowOption): TransactionScope$instance;
    new(scopeOption: TransactionScopeOption, transactionOptions: TransactionOptions, interopOption: EnterpriseServicesInteropOption): TransactionScope$instance;
    new(transactionToUse: Transaction): TransactionScope$instance;
    new(transactionToUse: Transaction, asyncFlowOption: TransactionScopeAsyncFlowOption): TransactionScope$instance;
    new(transactionToUse: Transaction, scopeTimeout: TimeSpan): TransactionScope$instance;
    new(transactionToUse: Transaction, scopeTimeout: TimeSpan, asyncFlowOption: TransactionScopeAsyncFlowOption): TransactionScope$instance;
    new(transactionToUse: Transaction, scopeTimeout: TimeSpan, interopOption: EnterpriseServicesInteropOption): TransactionScope$instance;
};


export interface __TransactionScope$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface TransactionScope$instance extends System_Internal.IDisposable$instance {}

export type TransactionScope = TransactionScope$instance & __TransactionScope$views;


export abstract class TransactionInterop$instance {
    static readonly promoterTypeDtc: Guid;
    static getDtcTransaction(transaction: Transaction): IDtcTransaction;
    static getExportCookie(transaction: Transaction, whereabouts: byte[]): byte[];
    static getTransactionFromDtcTransaction(transactionNative: IDtcTransaction): Transaction;
    static getTransactionFromExportCookie(cookie: byte[]): Transaction;
    static getTransactionFromTransmitterPropagationToken(propagationToken: byte[]): Transaction;
    static getTransmitterPropagationToken(transaction: Transaction): byte[];
    static getWhereabouts(): byte[];
}


export type TransactionInterop = TransactionInterop$instance;

export abstract class TransactionManager$instance {
    static hostCurrentCallback: HostCurrentTransactionCallback;
    static defaultTimeout: TimeSpan;
    static maximumTimeout: TimeSpan;
    static implicitDistributedTransactions: boolean;
    static recoveryComplete(resourceManagerIdentifier: Guid): void;
    static reenlist(resourceManagerIdentifier: Guid, recoveryInformation: byte[], enlistmentNotification: IEnlistmentNotification): Enlistment;
}


export type TransactionManager = TransactionManager$instance;

