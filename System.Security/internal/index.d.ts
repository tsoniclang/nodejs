// Generated by tsbindgen - Architecture
// Namespace: System.Security
// Assembly: System.Private.CoreLib, System.Runtime.InteropServices

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ArrayList, Hashtable, ICollection, IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { AssemblyName, MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { PermissionState } from "../../System.Security.Permissions/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Attribute, Boolean as ClrBoolean, Byte, Char, Enum, Exception, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, Object as ClrObject, String as ClrString, SystemException, Type, TypeCode, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum PartialTrustVisibilityLevel {
    visibleToAllHosts = 0,
    notVisibleByDefault = 1
}


export enum SecurityCriticalScope {
    explicit = 0,
    everything = 1
}


export enum SecurityRuleSet {
    none = 0,
    level1 = 1,
    level2 = 2
}


export interface IPermission$instance extends ISecurityEncodable {
    copy(): IPermission;
    demand(): void;
    fromXml(e: SecurityElement): void;
    intersect(target: IPermission): IPermission;
    isSubsetOf(target: IPermission): boolean;
    toXml(): SecurityElement;
}


export interface IPermission$instance extends ISecurityEncodable$instance {}

export type IPermission = IPermission$instance;

export interface ISecurityEncodable$instance {
    fromXml(e: SecurityElement): void;
    toXml(): SecurityElement;
}


export type ISecurityEncodable = ISecurityEncodable$instance;

export interface IStackWalk$instance {
    assert(): void;
}


export type IStackWalk = IStackWalk$instance;

export interface AllowPartiallyTrustedCallersAttribute$instance extends Attribute {
    partialTrustVisibilityLevel: PartialTrustVisibilityLevel;
}


export const AllowPartiallyTrustedCallersAttribute: {
    new(): AllowPartiallyTrustedCallersAttribute$instance;
};


export type AllowPartiallyTrustedCallersAttribute = AllowPartiallyTrustedCallersAttribute$instance;

export interface PermissionSet$instance {
    readonly count: int;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    readonly syncRoot: unknown;
    addPermission(perm: IPermission): IPermission;
    assert(): void;
    containsNonCodeAccessPermissions(): boolean;
    copy(): PermissionSet;
    copyTo(array: ClrArray, index: int): void;
    demand(): void;
    deny(): void;
    equals(o: unknown): boolean;
    fromXml(et: SecurityElement): void;
    getEnumerator(): IEnumerator;
    getHashCode(): int;
    getPermission(permClass: Type): IPermission;
    intersect(other: PermissionSet): PermissionSet;
    isEmpty(): boolean;
    isSubsetOf(target: PermissionSet): boolean;
    isUnrestricted(): boolean;
    permitOnly(): void;
    removePermission(permClass: Type): IPermission;
    setPermission(perm: IPermission): IPermission;
    toString(): string;
    toXml(): SecurityElement;
    union(other: PermissionSet): PermissionSet;
}


export const PermissionSet: {
    new(state: PermissionState): PermissionSet$instance;
    new(permSet: PermissionSet): PermissionSet$instance;
    convertPermissionSet(inFormat: string, inData: byte[], outFormat: string): byte[];
    revertAssert(): void;
};


export interface __PermissionSet$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISecurityEncodable(): ISecurityEncodable$instance;
    As_IStackWalk(): IStackWalk$instance;
}

export interface PermissionSet$instance extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, ISecurityEncodable$instance, IStackWalk$instance {}

export type PermissionSet = PermissionSet$instance & __PermissionSet$views;


export interface SecureString$instance {
    readonly length: int;
    appendChar(c: char): void;
    clear(): void;
    copy(): SecureString;
    dispose(): void;
    insertAt(index: int, c: char): void;
    isReadOnly(): boolean;
    makeReadOnly(): void;
    removeAt(index: int): void;
    setAt(index: int, c: char): void;
}


export const SecureString: {
    new(): SecureString$instance;
    new(value: ptr<char>, length: int): SecureString$instance;
};


export interface __SecureString$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface SecureString$instance extends System_Internal.IDisposable$instance {}

export type SecureString = SecureString$instance & __SecureString$views;


export interface SecurityCriticalAttribute$instance extends Attribute {
    readonly scope: SecurityCriticalScope;
}


export const SecurityCriticalAttribute: {
    new(): SecurityCriticalAttribute$instance;
    new(scope: SecurityCriticalScope): SecurityCriticalAttribute$instance;
};


export type SecurityCriticalAttribute = SecurityCriticalAttribute$instance;

export interface SecurityElement$instance {
    attributes: Hashtable;
    children: ArrayList;
    tag: string;
    text: string;
    addAttribute(name: string, value: string): void;
    addChild(child: SecurityElement): void;
    attribute(name: string): string;
    copy(): SecurityElement;
    equal(other: SecurityElement): boolean;
    searchForChildByTag(tag: string): SecurityElement;
    searchForTextOfTag(tag: string): string;
    toString(): string;
}


export const SecurityElement: {
    new(tag: string): SecurityElement$instance;
    new(tag: string, text: string): SecurityElement$instance;
    escape(str: string): string;
    fromString(xml: string): SecurityElement;
    isValidAttributeName(name: string): boolean;
    isValidAttributeValue(value: string): boolean;
    isValidTag(tag: string): boolean;
    isValidText(text: string): boolean;
};


export type SecurityElement = SecurityElement$instance;

export interface SecurityException$instance extends SystemException {
    demanded: unknown;
    denySetInstance: unknown;
    failedAssemblyInfo: AssemblyName;
    grantedSet: string;
    method: MethodInfo;
    permissionState: string;
    permissionType: Type;
    permitOnlySetInstance: unknown;
    refusedSet: string;
    url: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    toString(): string;
}


export const SecurityException: {
    new(): SecurityException$instance;
    new(message: string): SecurityException$instance;
    new(message: string, inner: Exception): SecurityException$instance;
    new(message: string, type_: Type): SecurityException$instance;
    new(message: string, type_: Type, state: string): SecurityException$instance;
};


export interface __SecurityException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SecurityException = SecurityException$instance & __SecurityException$views;


export interface SecurityRulesAttribute$instance extends Attribute {
    readonly ruleSet: SecurityRuleSet;
    skipVerificationInFullTrust: boolean;
}


export const SecurityRulesAttribute: {
    new(ruleSet: SecurityRuleSet): SecurityRulesAttribute$instance;
};


export type SecurityRulesAttribute = SecurityRulesAttribute$instance;

export interface SecuritySafeCriticalAttribute$instance extends Attribute {
}


export const SecuritySafeCriticalAttribute: {
    new(): SecuritySafeCriticalAttribute$instance;
};


export type SecuritySafeCriticalAttribute = SecuritySafeCriticalAttribute$instance;

export interface SecurityTransparentAttribute$instance extends Attribute {
}


export const SecurityTransparentAttribute: {
    new(): SecurityTransparentAttribute$instance;
};


export type SecurityTransparentAttribute = SecurityTransparentAttribute$instance;

export interface SecurityTreatAsSafeAttribute$instance extends Attribute {
}


export const SecurityTreatAsSafeAttribute: {
    new(): SecurityTreatAsSafeAttribute$instance;
};


export type SecurityTreatAsSafeAttribute = SecurityTreatAsSafeAttribute$instance;

export interface SuppressUnmanagedCodeSecurityAttribute$instance extends Attribute {
}


export const SuppressUnmanagedCodeSecurityAttribute: {
    new(): SuppressUnmanagedCodeSecurityAttribute$instance;
};


export type SuppressUnmanagedCodeSecurityAttribute = SuppressUnmanagedCodeSecurityAttribute$instance;

export interface UnverifiableCodeAttribute$instance extends Attribute {
}


export const UnverifiableCodeAttribute: {
    new(): UnverifiableCodeAttribute$instance;
};


export type UnverifiableCodeAttribute = UnverifiableCodeAttribute$instance;

export interface VerificationException$instance extends SystemException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const VerificationException: {
    new(): VerificationException$instance;
    new(message: string): VerificationException$instance;
    new(message: string, innerException: Exception): VerificationException$instance;
};


export interface __VerificationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type VerificationException = VerificationException$instance & __VerificationException$views;


export abstract class SecureStringMarshal$instance {
    static secureStringToCoTaskMemAnsi(s: SecureString): nint;
    static secureStringToCoTaskMemUnicode(s: SecureString): nint;
    static secureStringToGlobalAllocAnsi(s: SecureString): nint;
    static secureStringToGlobalAllocUnicode(s: SecureString): nint;
}


export type SecureStringMarshal = SecureStringMarshal$instance;

