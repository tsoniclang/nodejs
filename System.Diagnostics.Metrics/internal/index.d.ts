// Generated by tsbindgen - Architecture
// Namespace: System.Diagnostics.Metrics
// Assembly: System.Diagnostics.DiagnosticSource

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { IEnumerable_1, IReadOnlyList_1, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import type { TagList } from "../../System.Diagnostics/internal/index.js";
import type { MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_2, AsyncCallback, Boolean as ClrBoolean, Delegate, Func_1, IAsyncResult, ICloneable, IDisposable, Int32, IntPtr, MulticastDelegate, Object as ClrObject, ReadOnlySpan_1, String as ClrString, Type, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export type MeasurementCallback_1<T extends unknown> = (instrument: Instrument, measurement: T, tags: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, unknown>>, state: unknown) => void;


export interface IMeterFactory$instance extends IDisposable {
    create(options: MeterOptions): Meter;
    dispose(): void;
}


export interface IMeterFactory$instance extends System_Internal.IDisposable$instance {}

export type IMeterFactory = IMeterFactory$instance;

export interface Measurement_1$instance<T extends unknown> {
    readonly tags: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, unknown>>;
    readonly value: T;
}


export const Measurement_1: {
    new<T extends unknown>(value: T): Measurement_1$instance<T>;
    new<T extends unknown>(value: T, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>): Measurement_1$instance<T>;
    new<T extends unknown>(value: T, tags: KeyValuePair_2<CLROf<string>, unknown>[]): Measurement_1$instance<T>;
    new<T extends unknown>(value: T, tags: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, unknown>>): Measurement_1$instance<T>;
    new<T extends unknown>(value: T, tags: ref<TagList>): Measurement_1$instance<T>;
};


export type Measurement_1<T> = Measurement_1$instance<T>;

export interface Counter_1$instance<T extends unknown> extends Instrument_1<T> {
    add(delta: T): void;
    add(delta: T, tag: KeyValuePair_2<CLROf<string>, unknown>): void;
    add(delta: T, tag1: KeyValuePair_2<CLROf<string>, unknown>, tag2: KeyValuePair_2<CLROf<string>, unknown>): void;
    add(delta: T, tag1: KeyValuePair_2<CLROf<string>, unknown>, tag2: KeyValuePair_2<CLROf<string>, unknown>, tag3: KeyValuePair_2<CLROf<string>, unknown>): void;
    add(delta: T, tags: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, unknown>>): void;
    add(delta: T, tags: KeyValuePair_2<CLROf<string>, unknown>[]): void;
    add(delta: T, tagList: { value: ref<TagList> }): void;
}


export const Counter_1: {
    new<T extends unknown>(): Counter_1$instance<T>;
};


export type Counter_1<T> = Counter_1$instance<T>;

export interface Gauge_1$instance<T extends unknown> extends Instrument_1<T> {
    record(value: T): void;
    record(value: T, tag: KeyValuePair_2<CLROf<string>, unknown>): void;
    record(value: T, tag1: KeyValuePair_2<CLROf<string>, unknown>, tag2: KeyValuePair_2<CLROf<string>, unknown>): void;
    record(value: T, tag1: KeyValuePair_2<CLROf<string>, unknown>, tag2: KeyValuePair_2<CLROf<string>, unknown>, tag3: KeyValuePair_2<CLROf<string>, unknown>): void;
    record(value: T, tags: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, unknown>>): void;
    record(value: T, tags: KeyValuePair_2<CLROf<string>, unknown>[]): void;
    record(value: T, tagList: { value: ref<TagList> }): void;
}


export const Gauge_1: {
    new<T extends unknown>(): Gauge_1$instance<T>;
};


export type Gauge_1<T> = Gauge_1$instance<T>;

export interface Histogram_1$instance<T extends unknown> extends Instrument_1<T> {
    record(value: T): void;
    record(value: T, tag: KeyValuePair_2<CLROf<string>, unknown>): void;
    record(value: T, tag1: KeyValuePair_2<CLROf<string>, unknown>, tag2: KeyValuePair_2<CLROf<string>, unknown>): void;
    record(value: T, tag1: KeyValuePair_2<CLROf<string>, unknown>, tag2: KeyValuePair_2<CLROf<string>, unknown>, tag3: KeyValuePair_2<CLROf<string>, unknown>): void;
    record(value: T, tags: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, unknown>>): void;
    record(value: T, tags: KeyValuePair_2<CLROf<string>, unknown>[]): void;
    record(value: T, tagList: { value: ref<TagList> }): void;
}


export const Histogram_1: {
    new<T extends unknown>(): Histogram_1$instance<T>;
};


export type Histogram_1<T> = Histogram_1$instance<T>;

export interface Instrument$instance {
    readonly description: string;
    readonly enabled: boolean;
    readonly isObservable: boolean;
    readonly meter: Meter;
    readonly name: string;
    readonly tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>;
    readonly unit: string;
}


export const Instrument: {
};


export type Instrument = Instrument$instance;

export interface Instrument_1$instance<T extends unknown> extends Instrument {
    readonly advice: InstrumentAdvice_1<T>;
}


export const Instrument_1: {
};


export type Instrument_1<T> = Instrument_1$instance<T>;

export interface InstrumentAdvice_1$instance<T extends unknown> {
    histogramBucketBoundaries: IReadOnlyList_1<T>;
}


export const InstrumentAdvice_1: {
    new<T extends unknown>(): InstrumentAdvice_1$instance<T>;
};


export type InstrumentAdvice_1<T> = InstrumentAdvice_1$instance<T>;

export interface Meter$instance {
    readonly name: string;
    readonly scope: unknown;
    readonly tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>;
    readonly telemetrySchemaUrl: string;
    readonly version: string;
    createCounter<T extends unknown>(name: string, unit?: string, description?: string): Counter_1<T>;
    createCounter<T extends unknown>(name: string, unit: string, description: string, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>): Counter_1<T>;
    createGauge<T extends unknown>(name: string): Gauge_1<T>;
    createGauge<T extends unknown>(name: string, unit?: string, description?: string, tags?: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>): Gauge_1<T>;
    createHistogram<T extends unknown>(name: string): Histogram_1<T>;
    createHistogram<T extends unknown>(name: string, unit: string, description: string): Histogram_1<T>;
    createHistogram<T extends unknown>(name: string, unit: string, description: string, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>): Histogram_1<T>;
    createHistogram<T extends unknown>(name: string, unit?: string, description?: string, tags?: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>, advice?: InstrumentAdvice_1<T>): Histogram_1<T>;
    createObservableCounter<T extends unknown>(name: string, observeValue: Func_1<T>, unit?: string, description?: string): ObservableCounter_1<T>;
    createObservableCounter<T extends unknown>(name: string, observeValue: Func_1<T>, unit: string, description: string, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>): ObservableCounter_1<T>;
    createObservableGauge<T extends unknown>(name: string, observeValue: Func_1<T>, unit?: string, description?: string): ObservableGauge_1<T>;
    createObservableGauge<T extends unknown>(name: string, observeValue: Func_1<T>, unit: string, description: string, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>): ObservableGauge_1<T>;
    createObservableUpDownCounter<T extends unknown>(name: string, observeValue: Func_1<T>, unit?: string, description?: string): ObservableUpDownCounter_1<T>;
    createObservableUpDownCounter<T extends unknown>(name: string, observeValue: Func_1<T>, unit: string, description: string, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>): ObservableUpDownCounter_1<T>;
    createUpDownCounter<T extends unknown>(name: string, unit?: string, description?: string): UpDownCounter_1<T>;
    createUpDownCounter<T extends unknown>(name: string, unit: string, description: string, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>): UpDownCounter_1<T>;
    dispose(): void;
}


export const Meter: {
    new(options: MeterOptions): Meter$instance;
    new(name: string): Meter$instance;
    new(name: string, version: string): Meter$instance;
    new(name: string, version: string, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>, scope: unknown): Meter$instance;
};


export interface __Meter$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Meter$instance extends System_Internal.IDisposable$instance {}

export type Meter = Meter$instance & __Meter$views;


export interface MeterListener$instance {
    instrumentPublished: Action_2<Instrument, MeterListener>;
    measurementsCompleted: Action_2<Instrument, unknown>;
    disableMeasurementEvents(instrument: Instrument): unknown;
    dispose(): void;
    enableMeasurementEvents(instrument: Instrument, state?: unknown): void;
    recordObservableInstruments(): void;
    setMeasurementEventCallback<T extends unknown>(measurementCallback: MeasurementCallback_1<T>): void;
    start(): void;
}


export const MeterListener: {
    new(): MeterListener$instance;
};


export interface __MeterListener$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MeterListener$instance extends System_Internal.IDisposable$instance {}

export type MeterListener = MeterListener$instance & __MeterListener$views;


export interface MeterOptions$instance {
    name: string;
    scope: unknown;
    tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>;
    telemetrySchemaUrl: string;
    version: string;
}


export const MeterOptions: {
    new(name: string): MeterOptions$instance;
};


export type MeterOptions = MeterOptions$instance;

export interface ObservableCounter_1$instance<T extends unknown> extends ObservableInstrument_1<T> {
}


export const ObservableCounter_1: {
    new<T extends unknown>(): ObservableCounter_1$instance<T>;
};


export type ObservableCounter_1<T> = ObservableCounter_1$instance<T>;

export interface ObservableGauge_1$instance<T extends unknown> extends ObservableInstrument_1<T> {
}


export const ObservableGauge_1: {
    new<T extends unknown>(): ObservableGauge_1$instance<T>;
};


export type ObservableGauge_1<T> = ObservableGauge_1$instance<T>;

export interface ObservableInstrument_1$instance<T extends unknown> extends Instrument {
    readonly isObservable: boolean;
}


export const ObservableInstrument_1: {
};


export type ObservableInstrument_1<T> = ObservableInstrument_1$instance<T>;

export interface ObservableUpDownCounter_1$instance<T extends unknown> extends ObservableInstrument_1<T> {
}


export const ObservableUpDownCounter_1: {
    new<T extends unknown>(): ObservableUpDownCounter_1$instance<T>;
};


export type ObservableUpDownCounter_1<T> = ObservableUpDownCounter_1$instance<T>;

export interface UpDownCounter_1$instance<T extends unknown> extends Instrument_1<T> {
    add(delta: T): void;
    add(delta: T, tag: KeyValuePair_2<CLROf<string>, unknown>): void;
    add(delta: T, tag1: KeyValuePair_2<CLROf<string>, unknown>, tag2: KeyValuePair_2<CLROf<string>, unknown>): void;
    add(delta: T, tag1: KeyValuePair_2<CLROf<string>, unknown>, tag2: KeyValuePair_2<CLROf<string>, unknown>, tag3: KeyValuePair_2<CLROf<string>, unknown>): void;
    add(delta: T, tags: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, unknown>>): void;
    add(delta: T, tags: KeyValuePair_2<CLROf<string>, unknown>[]): void;
    add(delta: T, tagList: { value: ref<TagList> }): void;
}


export const UpDownCounter_1: {
    new<T extends unknown>(): UpDownCounter_1$instance<T>;
};


export type UpDownCounter_1<T> = UpDownCounter_1$instance<T>;

export abstract class MeterFactoryExtensions$instance {
    static create(meterFactory: IMeterFactory, name: string, version?: string, tags?: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>): Meter;
}


export type MeterFactoryExtensions = MeterFactoryExtensions$instance;

