// Generated by tsbindgen - Architecture
// Namespace: System.Collections.Concurrent
// Assembly: System.Collections.Concurrent, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IDictionary_2, IEnumerable_1, IEnumerator_1, IEqualityComparer_1, IList_1, IReadOnlyCollection_1, IReadOnlyDictionary_2, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Boolean as ClrBoolean, Enum, Func_2, Func_3, Func_4, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, Int64, ISpanFormattable, Object as ClrObject, String as ClrString, TimeSpan, Tuple_2, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum EnumerablePartitionerOptions {
    none = 0,
    noBuffering = 1
}


export interface IProducerConsumerCollection_1$instance<T> extends IEnumerable_1<T>, IEnumerable, ICollection {
    readonly count: int;
    readonly syncRoot: unknown;
    readonly isSynchronized: boolean;
    copyTo(array: T[], index: int): void;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator_1<T>;
    getEnumerator(): IEnumerator;
    toArray(): T[];
    tryAdd(item: T): boolean;
    tryTake(item: { value: ref<T> }): boolean;
}


export type IProducerConsumerCollection_1<T> = IProducerConsumerCollection_1$instance<T>;

export interface ConcurrentDictionary_2_AlternateLookup_1$instance<TKey, TValue, TAlternateKey> {
    readonly dictionary: ConcurrentDictionary_2<TKey, TValue>;
    item: TValue;
    containsKey(key: TAlternateKey): boolean;
    tryAdd(key: TAlternateKey, value: TValue): boolean;
    tryGetValue(key: TAlternateKey, value: { value: ref<TValue> }): boolean;
    tryGetValue(key: TAlternateKey, actualKey: { value: ref<TKey> }, value: { value: ref<TValue> }): boolean;
    tryRemove(key: TAlternateKey, value: { value: ref<TValue> }): boolean;
    tryRemove(key: TAlternateKey, actualKey: { value: ref<TKey> }, value: { value: ref<TValue> }): boolean;
}


export const ConcurrentDictionary_2_AlternateLookup_1: {
    new<TKey, TValue, TAlternateKey>(): ConcurrentDictionary_2_AlternateLookup_1$instance<TKey, TValue, TAlternateKey>;
};


export type ConcurrentDictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey> = ConcurrentDictionary_2_AlternateLookup_1$instance<TKey, TValue, TAlternateKey>;

export interface BlockingCollection_1$instance<T> {
    readonly boundedCapacity: int;
    readonly count: int;
    readonly isAddingCompleted: boolean;
    readonly isCompleted: boolean;
    add(item: T): void;
    add(item: T, cancellationToken: CancellationToken): void;
    completeAdding(): void;
    copyTo(array: T[], index: int): void;
    dispose(): void;
    getConsumingEnumerable(): IEnumerable_1<T>;
    getConsumingEnumerable(cancellationToken: CancellationToken): IEnumerable_1<T>;
    take(): T;
    take(cancellationToken: CancellationToken): T;
    toArray(): T[];
    tryAdd(item: T): boolean;
    tryAdd(item: T, timeout: TimeSpan): boolean;
    tryAdd(item: T, millisecondsTimeout: int): boolean;
    tryAdd(item: T, millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
    tryTake(item: { value: ref<T> }): boolean;
    tryTake(item: { value: ref<T> }, timeout: TimeSpan): boolean;
    tryTake(item: { value: ref<T> }, millisecondsTimeout: int): boolean;
    tryTake(item: { value: ref<T> }, millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
}


export const BlockingCollection_1: {
    new<T>(): BlockingCollection_1$instance<T>;
    new<T>(boundedCapacity: int): BlockingCollection_1$instance<T>;
    new<T>(collection: IProducerConsumerCollection_1<T>, boundedCapacity: int): BlockingCollection_1$instance<T>;
    new<T>(collection: IProducerConsumerCollection_1<T>): BlockingCollection_1$instance<T>;
    addToAny<T>(collections: BlockingCollection_1<T>[], item: T, cancellationToken: CancellationToken): int;
    addToAny<T>(collections: BlockingCollection_1<T>[], item: T): int;
    takeFromAny<T>(collections: BlockingCollection_1<T>[], item: { value: ref<T> }, cancellationToken: CancellationToken): int;
    takeFromAny<T>(collections: BlockingCollection_1<T>[], item: { value: ref<T> }): int;
    tryAddToAny<T>(collections: BlockingCollection_1<T>[], item: T, millisecondsTimeout: int, cancellationToken: CancellationToken): int;
    tryAddToAny<T>(collections: BlockingCollection_1<T>[], item: T, millisecondsTimeout: int): int;
    tryAddToAny<T>(collections: BlockingCollection_1<T>[], item: T, timeout: TimeSpan): int;
    tryAddToAny<T>(collections: BlockingCollection_1<T>[], item: T): int;
    tryTakeFromAny<T>(collections: BlockingCollection_1<T>[], item: { value: ref<T> }, millisecondsTimeout: int, cancellationToken: CancellationToken): int;
    tryTakeFromAny<T>(collections: BlockingCollection_1<T>[], item: { value: ref<T> }, millisecondsTimeout: int): int;
    tryTakeFromAny<T>(collections: BlockingCollection_1<T>[], item: { value: ref<T> }, timeout: TimeSpan): int;
    tryTakeFromAny<T>(collections: BlockingCollection_1<T>[], item: { value: ref<T> }): int;
};


export interface __BlockingCollection_1$views<T> {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface BlockingCollection_1$instance<T> extends System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>, System_Internal.IDisposable$instance {}

export type BlockingCollection_1<T> = BlockingCollection_1$instance<T> & __BlockingCollection_1$views<T>;


export interface ConcurrentBag_1$instance<T> {
    readonly count: int;
    readonly isEmpty: boolean;
    add(item: T): void;
    clear(): void;
    copyTo(array: T[], index: int): void;
    getEnumerator(): IEnumerator_1<T>;
    toArray(): T[];
    tryPeek(result: { value: ref<T> }): boolean;
    tryTake(result: { value: ref<T> }): boolean;
}


export const ConcurrentBag_1: {
    new<T>(): ConcurrentBag_1$instance<T>;
    new<T>(collection: IEnumerable_1<T>): ConcurrentBag_1$instance<T>;
};


export interface __ConcurrentBag_1$views<T> {
    As_IProducerConsumerCollection_1(): IProducerConsumerCollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ConcurrentBag_1<T> = ConcurrentBag_1$instance<T> & __ConcurrentBag_1$views<T>;


export interface ConcurrentDictionary_2$instance<TKey, TValue> {
    readonly comparer: IEqualityComparer_1<TKey>;
    readonly count: int;
    readonly isEmpty: boolean;
    item: TValue;
    readonly keys: ICollection_1<TKey>;
    readonly values: ICollection_1<TValue>;
    addOrUpdate<TArg>(key: TKey, addValueFactory: Func_3<TKey, TArg, TValue>, updateValueFactory: Func_4<TKey, TValue, TArg, TValue>, factoryArgument: TArg): TValue;
    addOrUpdate(key: TKey, addValueFactory: Func_2<TKey, TValue>, updateValueFactory: Func_3<TKey, TValue, TValue>): TValue;
    addOrUpdate(key: TKey, addValue: TValue, updateValueFactory: Func_3<TKey, TValue, TValue>): TValue;
    clear(): void;
    containsKey(key: TKey): boolean;
    getAlternateLookup<TAlternateKey>(): ConcurrentDictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>;
    getEnumerator(): IEnumerator_1<KeyValuePair_2<TKey, TValue>>;
    getOrAdd(key: TKey, valueFactory: Func_2<TKey, TValue>): TValue;
    getOrAdd<TArg>(key: TKey, valueFactory: Func_3<TKey, TArg, TValue>, factoryArgument: TArg): TValue;
    getOrAdd(key: TKey, value: TValue): TValue;
    toArray(): KeyValuePair_2<TKey, TValue>[];
    tryAdd(key: TKey, value: TValue): boolean;
    tryGetAlternateLookup<TAlternateKey>(lookup: { value: ref<ConcurrentDictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>> }): boolean;
    tryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
    tryRemove(key: TKey, value: { value: ref<TValue> }): boolean;
    tryRemove(item: KeyValuePair_2<TKey, TValue>): boolean;
    tryUpdate(key: TKey, newValue: TValue, comparisonValue: TValue): boolean;
}


export const ConcurrentDictionary_2: {
    new<TKey, TValue>(): ConcurrentDictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(concurrencyLevel: int, capacity: int): ConcurrentDictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(collection: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ConcurrentDictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(comparer: IEqualityComparer_1<TKey>): ConcurrentDictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(collection: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, comparer: IEqualityComparer_1<TKey>): ConcurrentDictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(concurrencyLevel: int, collection: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, comparer: IEqualityComparer_1<TKey>): ConcurrentDictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(concurrencyLevel: int, capacity: int, comparer: IEqualityComparer_1<TKey>): ConcurrentDictionary_2$instance<TKey, TValue>;
};


export interface __ConcurrentDictionary_2$views<TKey, TValue> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionary_2(): System_Collections_Generic_Internal.IDictionary_2$instance<TKey, TValue>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyDictionary_2(): System_Collections_Generic_Internal.IReadOnlyDictionary_2$instance<TKey, TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ConcurrentDictionary_2<TKey, TValue> = ConcurrentDictionary_2$instance<TKey, TValue> & __ConcurrentDictionary_2$views<TKey, TValue>;


export interface ConcurrentQueue_1$instance<T> {
    readonly count: int;
    readonly isEmpty: boolean;
    clear(): void;
    copyTo(array: T[], index: int): void;
    enqueue(item: T): void;
    getEnumerator(): IEnumerator_1<T>;
    toArray(): T[];
    tryDequeue(result: { value: ref<T> }): boolean;
    tryPeek(result: { value: ref<T> }): boolean;
}


export const ConcurrentQueue_1: {
    new<T>(): ConcurrentQueue_1$instance<T>;
    new<T>(collection: IEnumerable_1<T>): ConcurrentQueue_1$instance<T>;
};


export interface __ConcurrentQueue_1$views<T> {
    As_IProducerConsumerCollection_1(): IProducerConsumerCollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ConcurrentQueue_1<T> = ConcurrentQueue_1$instance<T> & __ConcurrentQueue_1$views<T>;


export interface ConcurrentStack_1$instance<T> {
    readonly count: int;
    readonly isEmpty: boolean;
    clear(): void;
    copyTo(array: T[], index: int): void;
    getEnumerator(): IEnumerator_1<T>;
    push(item: T): void;
    pushRange(items: T[]): void;
    pushRange(items: T[], startIndex: int, count: int): void;
    toArray(): T[];
    tryPeek(result: { value: ref<T> }): boolean;
    tryPop(result: { value: ref<T> }): boolean;
    tryPopRange(items: T[]): int;
    tryPopRange(items: T[], startIndex: int, count: int): int;
}


export const ConcurrentStack_1: {
    new<T>(): ConcurrentStack_1$instance<T>;
    new<T>(collection: IEnumerable_1<T>): ConcurrentStack_1$instance<T>;
};


export interface __ConcurrentStack_1$views<T> {
    As_IProducerConsumerCollection_1(): IProducerConsumerCollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ConcurrentStack_1<T> = ConcurrentStack_1$instance<T> & __ConcurrentStack_1$views<T>;


export interface OrderablePartitioner_1$instance<TSource> extends Partitioner_1<TSource> {
    readonly keysNormalized: boolean;
    readonly keysOrderedAcrossPartitions: boolean;
    readonly keysOrderedInEachPartition: boolean;
    getDynamicPartitions(): IEnumerable_1<TSource>;
    getDynamicPartitions(): IEnumerable_1<TSource>;
    getOrderableDynamicPartitions(): IEnumerable_1<KeyValuePair_2<CLROf<long>, TSource>>;
    getOrderablePartitions(partitionCount: int): IList_1<IEnumerator_1<KeyValuePair_2<CLROf<long>, TSource>>>;
    getPartitions(partitionCount: int): IList_1<IEnumerator_1<TSource>>;
    getPartitions(partitionCount: int): IList_1<IEnumerator_1<TSource>>;
}


export const OrderablePartitioner_1: {
};


export type OrderablePartitioner_1<TSource> = OrderablePartitioner_1$instance<TSource>;

export interface Partitioner_1$instance<TSource> {
    readonly supportsDynamicPartitions: boolean;
    getDynamicPartitions(): IEnumerable_1<TSource>;
    getPartitions(partitionCount: int): IList_1<IEnumerator_1<TSource>>;
}


export const Partitioner_1: {
};


export type Partitioner_1<TSource> = Partitioner_1$instance<TSource>;

export abstract class Partitioner$instance {
    static create<TSource>(source: IEnumerable_1<TSource>, partitionerOptions: EnumerablePartitionerOptions): OrderablePartitioner_1<TSource>;
    static create<TSource>(source: IEnumerable_1<TSource>): OrderablePartitioner_1<TSource>;
    static create<TSource>(list: IList_1<TSource>, loadBalance: boolean): OrderablePartitioner_1<TSource>;
    static create(fromInclusive: int, toExclusive: int, rangeSize: int): OrderablePartitioner_1<Tuple_2<CLROf<int>, CLROf<int>>>;
    static create(fromInclusive: int, toExclusive: int): OrderablePartitioner_1<Tuple_2<CLROf<int>, CLROf<int>>>;
    static create(fromInclusive: long, toExclusive: long, rangeSize: long): OrderablePartitioner_1<Tuple_2<CLROf<long>, CLROf<long>>>;
    static create(fromInclusive: long, toExclusive: long): OrderablePartitioner_1<Tuple_2<CLROf<long>, CLROf<long>>>;
    static create<TSource>(array: TSource[], loadBalance: boolean): OrderablePartitioner_1<TSource>;
}


export type Partitioner = Partitioner$instance;

