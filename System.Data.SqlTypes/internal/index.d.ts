// Generated by tsbindgen - Architecture
// Namespace: System.Data.SqlTypes
// Assembly: System.Data.Common

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { CompareInfo, CompareOptions, CultureInfo } from "../../System.Globalization/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { XmlSchema, XmlSchemaSet } from "../../System.Xml.Schema/internal/index.js";
import * as System_Xml_Serialization_Internal from "../../System.Xml.Serialization/internal/index.js";
import type { IXmlSerializable } from "../../System.Xml.Serialization/internal/index.js";
import type { XmlQualifiedName, XmlReader, XmlWriter } from "../../System.Xml/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Byte, Char, DateTime, Decimal, Double, Enum, Exception, Guid, IComparable, IConvertible, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, ISpanFormattable, Object as ClrObject, Single, Span_1, String as ClrString, SystemException, TimeSpan, Type, TypeCode, UInt32, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum SqlCompareOptions {
    none = 0,
    ignoreCase = 1,
    ignoreNonSpace = 2,
    ignoreKanaType = 8,
    ignoreWidth = 16,
    binarySort = 32768,
    binarySort2 = 16384
}


export enum StorageState {
    buffer = 0,
    stream = 1,
    unmanagedBuffer = 2
}


export interface INullable$instance {
    readonly isNull: boolean;
}


export type INullable = INullable$instance;

export interface SqlBinary$instance {
    readonly isNull: boolean;
    readonly item: byte;
    readonly length: int;
    readonly value: byte[];
    compareTo(value: unknown): int;
    compareTo(value: SqlBinary): int;
    equals(value: unknown): boolean;
    equals(other: SqlBinary): boolean;
    getHashCode(): int;
    toSqlGuid(): SqlGuid;
    toString(): string;
}


export const SqlBinary: {
    new(value: byte[]): SqlBinary$instance;
    readonly null_: SqlBinary;
    add(x: SqlBinary, y: SqlBinary): SqlBinary;
    concat(x: SqlBinary, y: SqlBinary): SqlBinary;
    equals(x: SqlBinary, y: SqlBinary): SqlBoolean;
    getXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    greaterThan(x: SqlBinary, y: SqlBinary): SqlBoolean;
    greaterThanOrEqual(x: SqlBinary, y: SqlBinary): SqlBoolean;
    lessThan(x: SqlBinary, y: SqlBinary): SqlBoolean;
    lessThanOrEqual(x: SqlBinary, y: SqlBinary): SqlBoolean;
    notEquals(x: SqlBinary, y: SqlBinary): SqlBoolean;
    wrapBytes(bytes: byte[]): SqlBinary;
};


export interface __SqlBinary$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlBinary>;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlBinary): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlBinary$instance extends INullable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlBinary = SqlBinary$instance & __SqlBinary$views;


export interface SqlBoolean$instance {
    readonly byteValue: byte;
    readonly isFalse: boolean;
    readonly isNull: boolean;
    readonly isTrue: boolean;
    readonly value: boolean;
    compareTo(value: unknown): int;
    compareTo(value: SqlBoolean): int;
    equals(value: unknown): boolean;
    equals(other: SqlBoolean): boolean;
    getHashCode(): int;
    toSqlByte(): SqlByte;
    toSqlDecimal(): SqlDecimal;
    toSqlDouble(): SqlDouble;
    toSqlInt16(): SqlInt16;
    toSqlInt32(): SqlInt32;
    toSqlInt64(): SqlInt64;
    toSqlMoney(): SqlMoney;
    toSqlSingle(): SqlSingle;
    toSqlString(): SqlString;
    toString(): string;
}


export const SqlBoolean: {
    new(value: boolean): SqlBoolean$instance;
    new(value: int): SqlBoolean$instance;
    readonly true_: SqlBoolean;
    readonly false_: SqlBoolean;
    readonly null_: SqlBoolean;
    readonly zero: SqlBoolean;
    readonly one: SqlBoolean;
    and(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
    equals(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
    getXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    greaterThan(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
    greaterThanOrEquals(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
    lessThan(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
    lessThanOrEquals(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
    notEquals(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
    onesComplement(x: SqlBoolean): SqlBoolean;
    or(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
    parse(s: string): SqlBoolean;
    xor(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
};


export interface __SqlBoolean$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlBoolean>;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlBoolean): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlBoolean$instance extends INullable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlBoolean = SqlBoolean$instance & __SqlBoolean$views;


export interface SqlByte$instance {
    readonly isNull: boolean;
    readonly value: byte;
    compareTo(value: unknown): int;
    compareTo(value: SqlByte): int;
    equals(value: unknown): boolean;
    equals(other: SqlByte): boolean;
    getHashCode(): int;
    toSqlBoolean(): SqlBoolean;
    toSqlDecimal(): SqlDecimal;
    toSqlDouble(): SqlDouble;
    toSqlInt16(): SqlInt16;
    toSqlInt32(): SqlInt32;
    toSqlInt64(): SqlInt64;
    toSqlMoney(): SqlMoney;
    toSqlSingle(): SqlSingle;
    toSqlString(): SqlString;
    toString(): string;
}


export const SqlByte: {
    new(value: byte): SqlByte$instance;
    readonly null_: SqlByte;
    readonly zero: SqlByte;
    readonly minValue: SqlByte;
    readonly maxValue: SqlByte;
    add(x: SqlByte, y: SqlByte): SqlByte;
    bitwiseAnd(x: SqlByte, y: SqlByte): SqlByte;
    bitwiseOr(x: SqlByte, y: SqlByte): SqlByte;
    divide(x: SqlByte, y: SqlByte): SqlByte;
    equals(x: SqlByte, y: SqlByte): SqlBoolean;
    getXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    greaterThan(x: SqlByte, y: SqlByte): SqlBoolean;
    greaterThanOrEqual(x: SqlByte, y: SqlByte): SqlBoolean;
    lessThan(x: SqlByte, y: SqlByte): SqlBoolean;
    lessThanOrEqual(x: SqlByte, y: SqlByte): SqlBoolean;
    mod(x: SqlByte, y: SqlByte): SqlByte;
    modulus(x: SqlByte, y: SqlByte): SqlByte;
    multiply(x: SqlByte, y: SqlByte): SqlByte;
    notEquals(x: SqlByte, y: SqlByte): SqlBoolean;
    onesComplement(x: SqlByte): SqlByte;
    parse(s: string): SqlByte;
    subtract(x: SqlByte, y: SqlByte): SqlByte;
    xor(x: SqlByte, y: SqlByte): SqlByte;
};


export interface __SqlByte$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlByte>;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlByte): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlByte$instance extends INullable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlByte = SqlByte$instance & __SqlByte$views;


export interface SqlDateTime$instance {
    readonly dayTicks: int;
    readonly isNull: boolean;
    readonly timeTicks: int;
    readonly value: DateTime;
    compareTo(value: unknown): int;
    compareTo(value: SqlDateTime): int;
    equals(value: unknown): boolean;
    equals(other: SqlDateTime): boolean;
    getHashCode(): int;
    toSqlString(): SqlString;
    toString(): string;
}


export const SqlDateTime: {
    new(value: DateTime): SqlDateTime$instance;
    new(year: int, month: int, day: int): SqlDateTime$instance;
    new(year: int, month: int, day: int, hour: int, minute: int, second: int): SqlDateTime$instance;
    new(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: double): SqlDateTime$instance;
    new(year: int, month: int, day: int, hour: int, minute: int, second: int, bilisecond: int): SqlDateTime$instance;
    new(dayTicks: int, timeTicks: int): SqlDateTime$instance;
    readonly sqlTicksPerSecond: int;
    readonly sqlTicksPerMinute: int;
    readonly sqlTicksPerHour: int;
    readonly minValue: SqlDateTime;
    readonly maxValue: SqlDateTime;
    readonly null_: SqlDateTime;
    add(x: SqlDateTime, t: TimeSpan): SqlDateTime;
    equals(x: SqlDateTime, y: SqlDateTime): SqlBoolean;
    getXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    greaterThan(x: SqlDateTime, y: SqlDateTime): SqlBoolean;
    greaterThanOrEqual(x: SqlDateTime, y: SqlDateTime): SqlBoolean;
    lessThan(x: SqlDateTime, y: SqlDateTime): SqlBoolean;
    lessThanOrEqual(x: SqlDateTime, y: SqlDateTime): SqlBoolean;
    notEquals(x: SqlDateTime, y: SqlDateTime): SqlBoolean;
    parse(s: string): SqlDateTime;
    subtract(x: SqlDateTime, t: TimeSpan): SqlDateTime;
};


export interface __SqlDateTime$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlDateTime>;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlDateTime): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlDateTime$instance extends INullable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlDateTime = SqlDateTime$instance & __SqlDateTime$views;


export interface SqlDecimal$instance {
    readonly binData: byte[];
    readonly data: int[];
    readonly isNull: boolean;
    readonly isPositive: boolean;
    readonly precision: byte;
    readonly scale: byte;
    readonly value: decimal;
    compareTo(value: unknown): int;
    compareTo(value: SqlDecimal): int;
    equals(value: unknown): boolean;
    equals(other: SqlDecimal): boolean;
    getHashCode(): int;
    toDouble(): double;
    toSqlBoolean(): SqlBoolean;
    toSqlByte(): SqlByte;
    toSqlDouble(): SqlDouble;
    toSqlInt16(): SqlInt16;
    toSqlInt32(): SqlInt32;
    toSqlInt64(): SqlInt64;
    toSqlMoney(): SqlMoney;
    toSqlSingle(): SqlSingle;
    toSqlString(): SqlString;
    toString(): string;
    writeTdsValue(destination: Span_1<CLROf<uint>>): int;
}


export const SqlDecimal: {
    new(value: decimal): SqlDecimal$instance;
    new(value: int): SqlDecimal$instance;
    new(value: long): SqlDecimal$instance;
    new(bPrecision: byte, bScale: byte, fPositive: boolean, bits: int[]): SqlDecimal$instance;
    new(bPrecision: byte, bScale: byte, fPositive: boolean, data1: int, data2: int, data3: int, data4: int): SqlDecimal$instance;
    new(dVal: double): SqlDecimal$instance;
    readonly maxPrecision: byte;
    readonly maxScale: byte;
    readonly null_: SqlDecimal;
    readonly minValue: SqlDecimal;
    readonly maxValue: SqlDecimal;
    abs(n: SqlDecimal): SqlDecimal;
    add(x: SqlDecimal, y: SqlDecimal): SqlDecimal;
    adjustScale(n: SqlDecimal, digits: int, fRound: boolean): SqlDecimal;
    ceiling(n: SqlDecimal): SqlDecimal;
    convertToPrecScale(n: SqlDecimal, precision: int, scale: int): SqlDecimal;
    divide(x: SqlDecimal, y: SqlDecimal): SqlDecimal;
    equals(x: SqlDecimal, y: SqlDecimal): SqlBoolean;
    floor(n: SqlDecimal): SqlDecimal;
    getXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    greaterThan(x: SqlDecimal, y: SqlDecimal): SqlBoolean;
    greaterThanOrEqual(x: SqlDecimal, y: SqlDecimal): SqlBoolean;
    lessThan(x: SqlDecimal, y: SqlDecimal): SqlBoolean;
    lessThanOrEqual(x: SqlDecimal, y: SqlDecimal): SqlBoolean;
    multiply(x: SqlDecimal, y: SqlDecimal): SqlDecimal;
    notEquals(x: SqlDecimal, y: SqlDecimal): SqlBoolean;
    parse(s: string): SqlDecimal;
    power(n: SqlDecimal, exp: double): SqlDecimal;
    round(n: SqlDecimal, position: int): SqlDecimal;
    sign(n: SqlDecimal): SqlInt32;
    subtract(x: SqlDecimal, y: SqlDecimal): SqlDecimal;
    truncate(n: SqlDecimal, position: int): SqlDecimal;
};


export interface __SqlDecimal$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlDecimal>;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlDecimal): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlDecimal$instance extends INullable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlDecimal = SqlDecimal$instance & __SqlDecimal$views;


export interface SqlDouble$instance {
    readonly isNull: boolean;
    readonly value: double;
    compareTo(value: unknown): int;
    compareTo(value: SqlDouble): int;
    equals(value: unknown): boolean;
    equals(other: SqlDouble): boolean;
    getHashCode(): int;
    toSqlBoolean(): SqlBoolean;
    toSqlByte(): SqlByte;
    toSqlDecimal(): SqlDecimal;
    toSqlInt16(): SqlInt16;
    toSqlInt32(): SqlInt32;
    toSqlInt64(): SqlInt64;
    toSqlMoney(): SqlMoney;
    toSqlSingle(): SqlSingle;
    toSqlString(): SqlString;
    toString(): string;
}


export const SqlDouble: {
    new(value: double): SqlDouble$instance;
    readonly null_: SqlDouble;
    readonly zero: SqlDouble;
    readonly minValue: SqlDouble;
    readonly maxValue: SqlDouble;
    add(x: SqlDouble, y: SqlDouble): SqlDouble;
    divide(x: SqlDouble, y: SqlDouble): SqlDouble;
    equals(x: SqlDouble, y: SqlDouble): SqlBoolean;
    getXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    greaterThan(x: SqlDouble, y: SqlDouble): SqlBoolean;
    greaterThanOrEqual(x: SqlDouble, y: SqlDouble): SqlBoolean;
    lessThan(x: SqlDouble, y: SqlDouble): SqlBoolean;
    lessThanOrEqual(x: SqlDouble, y: SqlDouble): SqlBoolean;
    multiply(x: SqlDouble, y: SqlDouble): SqlDouble;
    notEquals(x: SqlDouble, y: SqlDouble): SqlBoolean;
    parse(s: string): SqlDouble;
    subtract(x: SqlDouble, y: SqlDouble): SqlDouble;
};


export interface __SqlDouble$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlDouble>;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlDouble): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlDouble$instance extends INullable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlDouble = SqlDouble$instance & __SqlDouble$views;


export interface SqlGuid$instance {
    readonly isNull: boolean;
    readonly value: Guid;
    compareTo(value: unknown): int;
    compareTo(value: SqlGuid): int;
    equals(value: unknown): boolean;
    equals(other: SqlGuid): boolean;
    getHashCode(): int;
    toByteArray(): byte[];
    toSqlBinary(): SqlBinary;
    toSqlString(): SqlString;
    toString(): string;
}


export const SqlGuid: {
    new(value: byte[]): SqlGuid$instance;
    new(s: string): SqlGuid$instance;
    new(g: Guid): SqlGuid$instance;
    new(a: int, b: short, c: short, d: byte, e: byte, f: byte, g: byte, h: byte, i: byte, j: byte, k: byte): SqlGuid$instance;
    readonly null_: SqlGuid;
    equals(x: SqlGuid, y: SqlGuid): SqlBoolean;
    getXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    greaterThan(x: SqlGuid, y: SqlGuid): SqlBoolean;
    greaterThanOrEqual(x: SqlGuid, y: SqlGuid): SqlBoolean;
    lessThan(x: SqlGuid, y: SqlGuid): SqlBoolean;
    lessThanOrEqual(x: SqlGuid, y: SqlGuid): SqlBoolean;
    notEquals(x: SqlGuid, y: SqlGuid): SqlBoolean;
    parse(s: string): SqlGuid;
};


export interface __SqlGuid$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlGuid>;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlGuid): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlGuid$instance extends INullable$instance, System_Runtime_Serialization_Internal.ISerializable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlGuid = SqlGuid$instance & __SqlGuid$views;


export interface SqlInt16$instance {
    readonly isNull: boolean;
    readonly value: short;
    compareTo(value: unknown): int;
    compareTo(value: SqlInt16): int;
    equals(value: unknown): boolean;
    equals(other: SqlInt16): boolean;
    getHashCode(): int;
    toSqlBoolean(): SqlBoolean;
    toSqlByte(): SqlByte;
    toSqlDecimal(): SqlDecimal;
    toSqlDouble(): SqlDouble;
    toSqlInt32(): SqlInt32;
    toSqlInt64(): SqlInt64;
    toSqlMoney(): SqlMoney;
    toSqlSingle(): SqlSingle;
    toSqlString(): SqlString;
    toString(): string;
}


export const SqlInt16: {
    new(value: short): SqlInt16$instance;
    readonly null_: SqlInt16;
    readonly zero: SqlInt16;
    readonly minValue: SqlInt16;
    readonly maxValue: SqlInt16;
    add(x: SqlInt16, y: SqlInt16): SqlInt16;
    bitwiseAnd(x: SqlInt16, y: SqlInt16): SqlInt16;
    bitwiseOr(x: SqlInt16, y: SqlInt16): SqlInt16;
    divide(x: SqlInt16, y: SqlInt16): SqlInt16;
    equals(x: SqlInt16, y: SqlInt16): SqlBoolean;
    getXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    greaterThan(x: SqlInt16, y: SqlInt16): SqlBoolean;
    greaterThanOrEqual(x: SqlInt16, y: SqlInt16): SqlBoolean;
    lessThan(x: SqlInt16, y: SqlInt16): SqlBoolean;
    lessThanOrEqual(x: SqlInt16, y: SqlInt16): SqlBoolean;
    mod(x: SqlInt16, y: SqlInt16): SqlInt16;
    modulus(x: SqlInt16, y: SqlInt16): SqlInt16;
    multiply(x: SqlInt16, y: SqlInt16): SqlInt16;
    notEquals(x: SqlInt16, y: SqlInt16): SqlBoolean;
    onesComplement(x: SqlInt16): SqlInt16;
    parse(s: string): SqlInt16;
    subtract(x: SqlInt16, y: SqlInt16): SqlInt16;
    xor(x: SqlInt16, y: SqlInt16): SqlInt16;
};


export interface __SqlInt16$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlInt16>;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlInt16): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlInt16$instance extends INullable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlInt16 = SqlInt16$instance & __SqlInt16$views;


export interface SqlInt32$instance {
    readonly isNull: boolean;
    readonly value: int;
    compareTo(value: unknown): int;
    compareTo(value: SqlInt32): int;
    equals(value: unknown): boolean;
    equals(other: SqlInt32): boolean;
    getHashCode(): int;
    toSqlBoolean(): SqlBoolean;
    toSqlByte(): SqlByte;
    toSqlDecimal(): SqlDecimal;
    toSqlDouble(): SqlDouble;
    toSqlInt16(): SqlInt16;
    toSqlInt64(): SqlInt64;
    toSqlMoney(): SqlMoney;
    toSqlSingle(): SqlSingle;
    toSqlString(): SqlString;
    toString(): string;
}


export const SqlInt32: {
    new(value: int): SqlInt32$instance;
    readonly null_: SqlInt32;
    readonly zero: SqlInt32;
    readonly minValue: SqlInt32;
    readonly maxValue: SqlInt32;
    add(x: SqlInt32, y: SqlInt32): SqlInt32;
    bitwiseAnd(x: SqlInt32, y: SqlInt32): SqlInt32;
    bitwiseOr(x: SqlInt32, y: SqlInt32): SqlInt32;
    divide(x: SqlInt32, y: SqlInt32): SqlInt32;
    equals(x: SqlInt32, y: SqlInt32): SqlBoolean;
    getXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    greaterThan(x: SqlInt32, y: SqlInt32): SqlBoolean;
    greaterThanOrEqual(x: SqlInt32, y: SqlInt32): SqlBoolean;
    lessThan(x: SqlInt32, y: SqlInt32): SqlBoolean;
    lessThanOrEqual(x: SqlInt32, y: SqlInt32): SqlBoolean;
    mod(x: SqlInt32, y: SqlInt32): SqlInt32;
    modulus(x: SqlInt32, y: SqlInt32): SqlInt32;
    multiply(x: SqlInt32, y: SqlInt32): SqlInt32;
    notEquals(x: SqlInt32, y: SqlInt32): SqlBoolean;
    onesComplement(x: SqlInt32): SqlInt32;
    parse(s: string): SqlInt32;
    subtract(x: SqlInt32, y: SqlInt32): SqlInt32;
    xor(x: SqlInt32, y: SqlInt32): SqlInt32;
};


export interface __SqlInt32$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlInt32>;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlInt32): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlInt32$instance extends INullable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlInt32 = SqlInt32$instance & __SqlInt32$views;


export interface SqlInt64$instance {
    readonly isNull: boolean;
    readonly value: long;
    compareTo(value: unknown): int;
    compareTo(value: SqlInt64): int;
    equals(value: unknown): boolean;
    equals(other: SqlInt64): boolean;
    getHashCode(): int;
    toSqlBoolean(): SqlBoolean;
    toSqlByte(): SqlByte;
    toSqlDecimal(): SqlDecimal;
    toSqlDouble(): SqlDouble;
    toSqlInt16(): SqlInt16;
    toSqlInt32(): SqlInt32;
    toSqlMoney(): SqlMoney;
    toSqlSingle(): SqlSingle;
    toSqlString(): SqlString;
    toString(): string;
}


export const SqlInt64: {
    new(value: long): SqlInt64$instance;
    readonly null_: SqlInt64;
    readonly zero: SqlInt64;
    readonly minValue: SqlInt64;
    readonly maxValue: SqlInt64;
    add(x: SqlInt64, y: SqlInt64): SqlInt64;
    bitwiseAnd(x: SqlInt64, y: SqlInt64): SqlInt64;
    bitwiseOr(x: SqlInt64, y: SqlInt64): SqlInt64;
    divide(x: SqlInt64, y: SqlInt64): SqlInt64;
    equals(x: SqlInt64, y: SqlInt64): SqlBoolean;
    getXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    greaterThan(x: SqlInt64, y: SqlInt64): SqlBoolean;
    greaterThanOrEqual(x: SqlInt64, y: SqlInt64): SqlBoolean;
    lessThan(x: SqlInt64, y: SqlInt64): SqlBoolean;
    lessThanOrEqual(x: SqlInt64, y: SqlInt64): SqlBoolean;
    mod(x: SqlInt64, y: SqlInt64): SqlInt64;
    modulus(x: SqlInt64, y: SqlInt64): SqlInt64;
    multiply(x: SqlInt64, y: SqlInt64): SqlInt64;
    notEquals(x: SqlInt64, y: SqlInt64): SqlBoolean;
    onesComplement(x: SqlInt64): SqlInt64;
    parse(s: string): SqlInt64;
    subtract(x: SqlInt64, y: SqlInt64): SqlInt64;
    xor(x: SqlInt64, y: SqlInt64): SqlInt64;
};


export interface __SqlInt64$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlInt64>;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlInt64): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlInt64$instance extends INullable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlInt64 = SqlInt64$instance & __SqlInt64$views;


export interface SqlMoney$instance {
    readonly isNull: boolean;
    readonly value: decimal;
    compareTo(value: unknown): int;
    compareTo(value: SqlMoney): int;
    equals(value: unknown): boolean;
    equals(other: SqlMoney): boolean;
    getHashCode(): int;
    getTdsValue(): long;
    toDecimal(): decimal;
    toDouble(): double;
    toInt32(): int;
    toInt64(): long;
    toSqlBoolean(): SqlBoolean;
    toSqlByte(): SqlByte;
    toSqlDecimal(): SqlDecimal;
    toSqlDouble(): SqlDouble;
    toSqlInt16(): SqlInt16;
    toSqlInt32(): SqlInt32;
    toSqlInt64(): SqlInt64;
    toSqlSingle(): SqlSingle;
    toSqlString(): SqlString;
    toString(): string;
}


export const SqlMoney: {
    new(value: int): SqlMoney$instance;
    new(value: long): SqlMoney$instance;
    new(value: decimal): SqlMoney$instance;
    new(value: double): SqlMoney$instance;
    readonly null_: SqlMoney;
    readonly zero: SqlMoney;
    readonly minValue: SqlMoney;
    readonly maxValue: SqlMoney;
    add(x: SqlMoney, y: SqlMoney): SqlMoney;
    divide(x: SqlMoney, y: SqlMoney): SqlMoney;
    equals(x: SqlMoney, y: SqlMoney): SqlBoolean;
    fromTdsValue(value: long): SqlMoney;
    getXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    greaterThan(x: SqlMoney, y: SqlMoney): SqlBoolean;
    greaterThanOrEqual(x: SqlMoney, y: SqlMoney): SqlBoolean;
    lessThan(x: SqlMoney, y: SqlMoney): SqlBoolean;
    lessThanOrEqual(x: SqlMoney, y: SqlMoney): SqlBoolean;
    multiply(x: SqlMoney, y: SqlMoney): SqlMoney;
    notEquals(x: SqlMoney, y: SqlMoney): SqlBoolean;
    parse(s: string): SqlMoney;
    subtract(x: SqlMoney, y: SqlMoney): SqlMoney;
};


export interface __SqlMoney$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlMoney>;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlMoney): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlMoney$instance extends INullable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlMoney = SqlMoney$instance & __SqlMoney$views;


export interface SqlSingle$instance {
    readonly isNull: boolean;
    readonly value: float;
    compareTo(value: unknown): int;
    compareTo(value: SqlSingle): int;
    equals(value: unknown): boolean;
    equals(other: SqlSingle): boolean;
    getHashCode(): int;
    toSqlBoolean(): SqlBoolean;
    toSqlByte(): SqlByte;
    toSqlDecimal(): SqlDecimal;
    toSqlDouble(): SqlDouble;
    toSqlInt16(): SqlInt16;
    toSqlInt32(): SqlInt32;
    toSqlInt64(): SqlInt64;
    toSqlMoney(): SqlMoney;
    toSqlString(): SqlString;
    toString(): string;
}


export const SqlSingle: {
    new(value: float): SqlSingle$instance;
    new(value: double): SqlSingle$instance;
    readonly null_: SqlSingle;
    readonly zero: SqlSingle;
    readonly minValue: SqlSingle;
    readonly maxValue: SqlSingle;
    add(x: SqlSingle, y: SqlSingle): SqlSingle;
    divide(x: SqlSingle, y: SqlSingle): SqlSingle;
    equals(x: SqlSingle, y: SqlSingle): SqlBoolean;
    getXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    greaterThan(x: SqlSingle, y: SqlSingle): SqlBoolean;
    greaterThanOrEqual(x: SqlSingle, y: SqlSingle): SqlBoolean;
    lessThan(x: SqlSingle, y: SqlSingle): SqlBoolean;
    lessThanOrEqual(x: SqlSingle, y: SqlSingle): SqlBoolean;
    multiply(x: SqlSingle, y: SqlSingle): SqlSingle;
    notEquals(x: SqlSingle, y: SqlSingle): SqlBoolean;
    parse(s: string): SqlSingle;
    subtract(x: SqlSingle, y: SqlSingle): SqlSingle;
};


export interface __SqlSingle$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlSingle>;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlSingle): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlSingle$instance extends INullable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlSingle = SqlSingle$instance & __SqlSingle$views;


export interface SqlString$instance {
    readonly compareInfo: CompareInfo;
    readonly cultureInfo: CultureInfo;
    readonly isNull: boolean;
    readonly LCID: int;
    readonly sqlCompareOptions: SqlCompareOptions;
    readonly value: string;
    clone(): SqlString;
    compareTo(value: unknown): int;
    compareTo(value: SqlString): int;
    equals(value: unknown): boolean;
    equals(other: SqlString): boolean;
    getHashCode(): int;
    getNonUnicodeBytes(): byte[];
    getUnicodeBytes(): byte[];
    toSqlBoolean(): SqlBoolean;
    toSqlByte(): SqlByte;
    toSqlDateTime(): SqlDateTime;
    toSqlDecimal(): SqlDecimal;
    toSqlDouble(): SqlDouble;
    toSqlGuid(): SqlGuid;
    toSqlInt16(): SqlInt16;
    toSqlInt32(): SqlInt32;
    toSqlInt64(): SqlInt64;
    toSqlMoney(): SqlMoney;
    toSqlSingle(): SqlSingle;
    toString(): string;
}


export const SqlString: {
    new(lcid: int, compareOptions: SqlCompareOptions, data: byte[], index: int, count: int, fUnicode: boolean): SqlString$instance;
    new(lcid: int, compareOptions: SqlCompareOptions, data: byte[], fUnicode: boolean): SqlString$instance;
    new(lcid: int, compareOptions: SqlCompareOptions, data: byte[], index: int, count: int): SqlString$instance;
    new(lcid: int, compareOptions: SqlCompareOptions, data: byte[]): SqlString$instance;
    new(data: string, lcid: int, compareOptions: SqlCompareOptions): SqlString$instance;
    new(data: string, lcid: int): SqlString$instance;
    new(data: string): SqlString$instance;
    readonly null_: SqlString;
    readonly ignoreCase: int;
    readonly ignoreWidth: int;
    readonly ignoreNonSpace: int;
    readonly ignoreKanaType: int;
    readonly binarySort: int;
    readonly binarySort2: int;
    add(x: SqlString, y: SqlString): SqlString;
    compareOptionsFromSqlCompareOptions(compareOptions: SqlCompareOptions): CompareOptions;
    concat(x: SqlString, y: SqlString): SqlString;
    equals(x: SqlString, y: SqlString): SqlBoolean;
    getXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    greaterThan(x: SqlString, y: SqlString): SqlBoolean;
    greaterThanOrEqual(x: SqlString, y: SqlString): SqlBoolean;
    lessThan(x: SqlString, y: SqlString): SqlBoolean;
    lessThanOrEqual(x: SqlString, y: SqlString): SqlBoolean;
    notEquals(x: SqlString, y: SqlString): SqlBoolean;
};


export interface __SqlString$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlString>;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlString): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlString$instance extends INullable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlString = SqlString$instance & __SqlString$views;


export interface SqlAlreadyFilledException$instance extends SqlTypeException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SqlAlreadyFilledException: {
    new(): SqlAlreadyFilledException$instance;
    new(message: string): SqlAlreadyFilledException$instance;
    new(message: string, e: Exception): SqlAlreadyFilledException$instance;
};


export interface __SqlAlreadyFilledException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SqlAlreadyFilledException = SqlAlreadyFilledException$instance & __SqlAlreadyFilledException$views;


export interface SqlBytes$instance {
    readonly buffer: byte[];
    readonly isNull: boolean;
    item: byte;
    readonly length: long;
    readonly maxLength: long;
    readonly storage: StorageState;
    stream: Stream;
    readonly value: byte[];
    read(offset: long, buffer: byte[], offsetInBuffer: int, count: int): long;
    setLength(value: long): void;
    setNull(): void;
    toSqlBinary(): SqlBinary;
    write(offset: long, buffer: byte[], offsetInBuffer: int, count: int): void;
}


export const SqlBytes: {
    new(): SqlBytes$instance;
    new(buffer: byte[]): SqlBytes$instance;
    new(value: SqlBinary): SqlBytes$instance;
    new(s: Stream): SqlBytes$instance;
    readonly null_: SqlBytes;
    getXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
};


export interface __SqlBytes$views {
    As_INullable(): INullable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;
}

export interface SqlBytes$instance extends INullable$instance, System_Runtime_Serialization_Internal.ISerializable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlBytes = SqlBytes$instance & __SqlBytes$views;


export interface SqlChars$instance {
    readonly buffer: char[];
    readonly isNull: boolean;
    item: char;
    readonly length: long;
    readonly maxLength: long;
    readonly storage: StorageState;
    readonly value: char[];
    read(offset: long, buffer: char[], offsetInBuffer: int, count: int): long;
    setLength(value: long): void;
    setNull(): void;
    toSqlString(): SqlString;
    write(offset: long, buffer: char[], offsetInBuffer: int, count: int): void;
}


export const SqlChars: {
    new(): SqlChars$instance;
    new(buffer: char[]): SqlChars$instance;
    new(value: SqlString): SqlChars$instance;
    readonly null_: SqlChars;
    getXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
};


export interface __SqlChars$views {
    As_INullable(): INullable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;
}

export interface SqlChars$instance extends INullable$instance, System_Runtime_Serialization_Internal.ISerializable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlChars = SqlChars$instance & __SqlChars$views;


export interface SqlNotFilledException$instance extends SqlTypeException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SqlNotFilledException: {
    new(): SqlNotFilledException$instance;
    new(message: string): SqlNotFilledException$instance;
    new(message: string, e: Exception): SqlNotFilledException$instance;
};


export interface __SqlNotFilledException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SqlNotFilledException = SqlNotFilledException$instance & __SqlNotFilledException$views;


export interface SqlNullValueException$instance extends SqlTypeException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SqlNullValueException: {
    new(): SqlNullValueException$instance;
    new(message: string): SqlNullValueException$instance;
    new(message: string, e: Exception): SqlNullValueException$instance;
};


export interface __SqlNullValueException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SqlNullValueException = SqlNullValueException$instance & __SqlNullValueException$views;


export interface SqlTruncateException$instance extends SqlTypeException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SqlTruncateException: {
    new(): SqlTruncateException$instance;
    new(message: string): SqlTruncateException$instance;
    new(message: string, e: Exception): SqlTruncateException$instance;
};


export interface __SqlTruncateException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SqlTruncateException = SqlTruncateException$instance & __SqlTruncateException$views;


export interface SqlTypeException$instance extends SystemException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SqlTypeException: {
    new(): SqlTypeException$instance;
    new(message: string): SqlTypeException$instance;
    new(message: string, e: Exception): SqlTypeException$instance;
};


export interface __SqlTypeException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SqlTypeException = SqlTypeException$instance & __SqlTypeException$views;


export interface SqlXml$instance {
    readonly isNull: boolean;
    readonly value: string;
    createReader(): XmlReader;
}


export const SqlXml: {
    new(): SqlXml$instance;
    new(value: XmlReader): SqlXml$instance;
    new(value: Stream): SqlXml$instance;
    readonly null_: SqlXml;
    getXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
};


export interface __SqlXml$views {
    As_INullable(): INullable$instance;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;
}

export interface SqlXml$instance extends INullable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlXml = SqlXml$instance & __SqlXml$views;


