// Generated by tsbindgen - Architecture
// Namespace: System.Text
// Assembly: System.Memory, System.Private.CoreLib, System.Text.Encoding.CodePages

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { IBufferWriter_1, OperationStatus, ReadOnlySequence_1 } from "../../System.Buffers/internal/index.js";
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { IEnumerable_1, IEnumerator_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { CultureInfo, UnicodeCategory } from "../../System.Globalization/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ArgumentException, Boolean as ClrBoolean, Byte, Char, Decimal, Double, Enum, Exception, ICloneable, IComparable, IComparable_1, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, ISpanFormattable, IUtf8SpanFormattable, IUtf8SpanParsable_1, Object as ClrObject, Range, ReadOnlyMemory_1, ReadOnlySpan_1, SByte, Single, Span_1, String as ClrString, Type, TypeCode, UInt16, UInt32, UInt64, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum NormalizationForm {
    formC = 1,
    formD = 2,
    formKC = 5,
    formKD = 6
}


export interface Rune$instance {
    readonly isAscii: boolean;
    readonly isBmp: boolean;
    readonly plane: int;
    readonly utf16SequenceLength: int;
    readonly utf8SequenceLength: int;
    readonly value: int;
    compareTo(other: Rune): int;
    encodeToUtf16(destination: Span_1<CLROf<char>>): int;
    encodeToUtf8(destination: Span_1<CLROf<byte>>): int;
    equals(obj: unknown): boolean;
    equals(other: Rune): boolean;
    getHashCode(): int;
    toString(): string;
    tryEncodeToUtf16(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    tryEncodeToUtf8(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export const Rune: {
    new(ch: char): Rune$instance;
    new(highSurrogate: char, lowSurrogate: char): Rune$instance;
    new(value: int): Rune$instance;
    new(value: uint): Rune$instance;
    readonly replacementChar: Rune;
    decodeFromUtf16(source: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<Rune> }, charsConsumed: { value: ref<int> }): OperationStatus;
    decodeFromUtf8(source: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<Rune> }, bytesConsumed: { value: ref<int> }): OperationStatus;
    decodeLastFromUtf16(source: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<Rune> }, charsConsumed: { value: ref<int> }): OperationStatus;
    decodeLastFromUtf8(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: ref<Rune> }, bytesConsumed: { value: ref<int> }): OperationStatus;
    getNumericValue(value: Rune): double;
    getRuneAt(input: string, index: int): Rune;
    getUnicodeCategory(value: Rune): UnicodeCategory;
    isControl(value: Rune): boolean;
    isDigit(value: Rune): boolean;
    isLetter(value: Rune): boolean;
    isLetterOrDigit(value: Rune): boolean;
    isLower(value: Rune): boolean;
    isNumber(value: Rune): boolean;
    isPunctuation(value: Rune): boolean;
    isSeparator(value: Rune): boolean;
    isSymbol(value: Rune): boolean;
    isUpper(value: Rune): boolean;
    isValid(value: int): boolean;
    isValid(value: uint): boolean;
    isWhiteSpace(value: Rune): boolean;
    toLower(value: Rune, culture: CultureInfo): Rune;
    toLowerInvariant(value: Rune): Rune;
    toUpper(value: Rune, culture: CultureInfo): Rune;
    toUpperInvariant(value: Rune): Rune;
    tryCreate(highSurrogate: char, lowSurrogate: char, result: { value: ref<Rune> }): boolean;
    tryCreate(ch: char, result: { value: ref<Rune> }): boolean;
    tryCreate(value: int, result: { value: ref<Rune> }): boolean;
    tryCreate(value: uint, result: { value: ref<Rune> }): boolean;
    tryGetRuneAt(input: string, index: int, value: { value: ref<Rune> }): boolean;
};


export interface __Rune$views {
    As_IComparable(): System_Internal.IComparable$instance;
    As_IComparable_1(): System_Internal.IComparable_1$instance<Rune>;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Rune>;
    As_IFormattable(): System_Internal.IFormattable$instance;
    As_ISpanFormattable(): System_Internal.ISpanFormattable$instance;
    As_IUtf8SpanFormattable(): System_Internal.IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): System_Internal.IUtf8SpanParsable_1$instance<Rune>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Rune): boolean;
    CompareTo(obj: unknown): int;
}

export interface Rune$instance extends System_Internal.IComparable_1$instance<Rune>, System_Internal.IUtf8SpanFormattable$instance, System_Internal.IUtf8SpanParsable_1$instance<Rune> {}

export type Rune = Rune$instance & __Rune$views;


export interface SpanLineEnumerator$instance {
    readonly current: ReadOnlySpan_1<CLROf<char>>;
    getEnumerator(): SpanLineEnumerator;
    moveNext(): boolean;
    reset(): void;
}


export const SpanLineEnumerator: {
    new(): SpanLineEnumerator$instance;
};


export interface __SpanLineEnumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<ReadOnlySpan_1<CLROf<char>>>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type SpanLineEnumerator = SpanLineEnumerator$instance & __SpanLineEnumerator$views;


export interface SpanRuneEnumerator$instance {
    readonly current: Rune;
    getEnumerator(): SpanRuneEnumerator;
    moveNext(): boolean;
    reset(): void;
}


export const SpanRuneEnumerator: {
    new(): SpanRuneEnumerator$instance;
};


export interface __SpanRuneEnumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<Rune>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type SpanRuneEnumerator = SpanRuneEnumerator$instance & __SpanRuneEnumerator$views;


export interface StringBuilder_AppendInterpolatedStringHandler$instance {
    appendFormatted<T>(value: T): void;
    appendFormatted<T>(value: T, format: string): void;
    appendFormatted<T>(value: T, alignment: int): void;
    appendFormatted<T>(value: T, alignment: int, format: string): void;
    appendFormatted(value: ReadOnlySpan_1<CLROf<char>>): void;
    appendFormatted(value: ReadOnlySpan_1<CLROf<char>>, alignment?: int, format?: string): void;
    appendFormatted(value: string): void;
    appendFormatted(value: string, alignment?: int, format?: string): void;
    appendFormatted(value: unknown, alignment?: int, format?: string): void;
    appendLiteral(value: string): void;
}


export const StringBuilder_AppendInterpolatedStringHandler: {
    new(literalLength: int, formattedCount: int, stringBuilder: StringBuilder): StringBuilder_AppendInterpolatedStringHandler$instance;
    new(literalLength: int, formattedCount: int, stringBuilder: StringBuilder, provider: IFormatProvider): StringBuilder_AppendInterpolatedStringHandler$instance;
};


export type StringBuilder_AppendInterpolatedStringHandler = StringBuilder_AppendInterpolatedStringHandler$instance;

export interface StringBuilder_ChunkEnumerator$instance {
    readonly current: ReadOnlyMemory_1<CLROf<char>>;
    getEnumerator(): StringBuilder_ChunkEnumerator;
    moveNext(): boolean;
}


export const StringBuilder_ChunkEnumerator: {
    new(): StringBuilder_ChunkEnumerator$instance;
};


export type StringBuilder_ChunkEnumerator = StringBuilder_ChunkEnumerator$instance;

export interface StringRuneEnumerator$instance {
    readonly current: Rune;
    getEnumerator(): StringRuneEnumerator;
    moveNext(): boolean;
    reset(): void;
}


export const StringRuneEnumerator: {
    new(): StringRuneEnumerator$instance;
};


export interface __StringRuneEnumerator$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<Rune>;
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<Rune>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type StringRuneEnumerator = StringRuneEnumerator$instance & __StringRuneEnumerator$views;


export interface ASCIIEncoding$instance extends Encoding$instance {
    readonly isSingleByte: boolean;
    clone(): unknown;
    getByteCount(chars: char[], index: int, count: int): int;
    getByteCount(chars: string): int;
    getByteCount(chars: ptr<char>, count: int): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<char>>): int;
    getByteCount(chars: char[]): int;
    getByteCount(s: string, index: int, count: int): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<char>>): int;
    getBytes(chars: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: char[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: ptr<char>, charCount: int, bytes: ptr<byte>, byteCount: int): int;
    getBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>): int;
    getBytes(chars: char[]): byte[];
    getBytes(chars: char[], index: int, count: int): byte[];
    getBytes(s: string): byte[];
    getBytes(s: string, index: int, count: int): byte[];
    getBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>): int;
    getCharCount(bytes: byte[], index: int, count: int): int;
    getCharCount(bytes: ptr<byte>, count: int): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    getCharCount(bytes: byte[]): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    getChars(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int): int;
    getChars(bytes: ptr<byte>, byteCount: int, chars: ptr<char>, charCount: int): int;
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>): int;
    getChars(bytes: byte[]): char[];
    getChars(bytes: byte[], index: int, count: int): char[];
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>): int;
    getDecoder(): Decoder;
    getEncoder(): Encoder;
    getMaxByteCount(charCount: int): int;
    getMaxCharCount(byteCount: int): int;
    getString(bytes: byte[], byteIndex: int, byteCount: int): string;
    getString(bytes: ptr<byte>, byteCount: int): string;
    getString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    getString(bytes: byte[]): string;
    tryGetBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryGetBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryGetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    tryGetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
}


export const ASCIIEncoding: {
    new(): ASCIIEncoding$instance;
};


export interface __ASCIIEncoding$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type ASCIIEncoding = ASCIIEncoding$instance & __ASCIIEncoding$views;


export interface CodePagesEncodingProvider$instance extends EncodingProvider {
    getEncoding(codepage: int): Encoding;
    getEncoding(name: string): Encoding;
    getEncoding(name: string, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    getEncoding(codepage: int, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    getEncodings(): IEnumerable_1<EncodingInfo>;
    getEncodings(): IEnumerable_1<EncodingInfo>;
}


export const CodePagesEncodingProvider: {
    new(): CodePagesEncodingProvider$instance;
    readonly instance: EncodingProvider;
};


export type CodePagesEncodingProvider = CodePagesEncodingProvider$instance;

export interface CompositeFormat$instance {
    readonly format: string;
    readonly minimumArgumentCount: int;
}


export const CompositeFormat: {
    new(): CompositeFormat$instance;
    parse(format: string): CompositeFormat;
};


export type CompositeFormat = CompositeFormat$instance;

export interface Decoder$instance {
    fallback: DecoderFallback;
    readonly fallbackBuffer: DecoderFallbackBuffer;
    convert(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int, charCount: int, flush: boolean, bytesUsed: { value: ref<int> }, charsUsed: { value: ref<int> }, completed: { value: ref<boolean> }): void;
    convert(bytes: ptr<byte>, byteCount: int, chars: ptr<char>, charCount: int, flush: boolean, bytesUsed: { value: ref<int> }, charsUsed: { value: ref<int> }, completed: { value: ref<boolean> }): void;
    convert(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>, flush: boolean, bytesUsed: { value: ref<int> }, charsUsed: { value: ref<int> }, completed: { value: ref<boolean> }): void;
    getCharCount(bytes: byte[], index: int, count: int): int;
    getCharCount(bytes: byte[], index: int, count: int, flush: boolean): int;
    getCharCount(bytes: ptr<byte>, count: int, flush: boolean): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>, flush: boolean): int;
    getChars(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int): int;
    getChars(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int, flush: boolean): int;
    getChars(bytes: ptr<byte>, byteCount: int, chars: ptr<char>, charCount: int, flush: boolean): int;
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>, flush: boolean): int;
    reset(): void;
}


export const Decoder: {
};


export type Decoder = Decoder$instance;

export interface DecoderExceptionFallback$instance extends DecoderFallback {
    readonly maxCharCount: int;
    createFallbackBuffer(): DecoderFallbackBuffer;
    equals(value: unknown): boolean;
    getHashCode(): int;
}


export const DecoderExceptionFallback: {
    new(): DecoderExceptionFallback$instance;
};


export type DecoderExceptionFallback = DecoderExceptionFallback$instance;

export interface DecoderExceptionFallbackBuffer$instance extends DecoderFallbackBuffer {
    readonly remaining: int;
    fallback(bytesUnknown: byte[], index: int): boolean;
    getNextChar(): char;
    movePrevious(): boolean;
}


export const DecoderExceptionFallbackBuffer: {
    new(): DecoderExceptionFallbackBuffer$instance;
};


export type DecoderExceptionFallbackBuffer = DecoderExceptionFallbackBuffer$instance;

export interface DecoderFallback$instance {
    readonly maxCharCount: int;
    createFallbackBuffer(): DecoderFallbackBuffer;
}


export const DecoderFallback: {
    readonly replacementFallback: DecoderFallback;
    readonly exceptionFallback: DecoderFallback;
};


export type DecoderFallback = DecoderFallback$instance;

export interface DecoderFallbackBuffer$instance {
    readonly remaining: int;
    fallback(bytesUnknown: byte[], index: int): boolean;
    getNextChar(): char;
    movePrevious(): boolean;
    reset(): void;
}


export const DecoderFallbackBuffer: {
};


export type DecoderFallbackBuffer = DecoderFallbackBuffer$instance;

export interface DecoderFallbackException$instance extends ArgumentException {
    readonly bytesUnknown: byte[];
    readonly index: int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const DecoderFallbackException: {
    new(): DecoderFallbackException$instance;
    new(message: string): DecoderFallbackException$instance;
    new(message: string, innerException: Exception): DecoderFallbackException$instance;
    new(message: string, bytesUnknown: byte[], index: int): DecoderFallbackException$instance;
};


export interface __DecoderFallbackException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DecoderFallbackException = DecoderFallbackException$instance & __DecoderFallbackException$views;


export interface DecoderReplacementFallback$instance extends DecoderFallback {
    readonly defaultString: string;
    readonly maxCharCount: int;
    createFallbackBuffer(): DecoderFallbackBuffer;
    equals(value: unknown): boolean;
    getHashCode(): int;
}


export const DecoderReplacementFallback: {
    new(): DecoderReplacementFallback$instance;
    new(replacement: string): DecoderReplacementFallback$instance;
};


export type DecoderReplacementFallback = DecoderReplacementFallback$instance;

export interface DecoderReplacementFallbackBuffer$instance extends DecoderFallbackBuffer {
    readonly remaining: int;
    fallback(bytesUnknown: byte[], index: int): boolean;
    getNextChar(): char;
    movePrevious(): boolean;
    reset(): void;
}


export const DecoderReplacementFallbackBuffer: {
    new(fallback: DecoderReplacementFallback): DecoderReplacementFallbackBuffer$instance;
};


export type DecoderReplacementFallbackBuffer = DecoderReplacementFallbackBuffer$instance;

export interface Encoder$instance {
    fallback: EncoderFallback;
    readonly fallbackBuffer: EncoderFallbackBuffer;
    convert(chars: char[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int, byteCount: int, flush: boolean, charsUsed: { value: ref<int> }, bytesUsed: { value: ref<int> }, completed: { value: ref<boolean> }): void;
    convert(chars: ptr<char>, charCount: int, bytes: ptr<byte>, byteCount: int, flush: boolean, charsUsed: { value: ref<int> }, bytesUsed: { value: ref<int> }, completed: { value: ref<boolean> }): void;
    convert(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>, flush: boolean, charsUsed: { value: ref<int> }, bytesUsed: { value: ref<int> }, completed: { value: ref<boolean> }): void;
    getByteCount(chars: char[], index: int, count: int, flush: boolean): int;
    getByteCount(chars: ptr<char>, count: int, flush: boolean): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<char>>, flush: boolean): int;
    getBytes(chars: char[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int, flush: boolean): int;
    getBytes(chars: ptr<char>, charCount: int, bytes: ptr<byte>, byteCount: int, flush: boolean): int;
    getBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>, flush: boolean): int;
    reset(): void;
}


export const Encoder: {
};


export type Encoder = Encoder$instance;

export interface EncoderExceptionFallback$instance extends EncoderFallback {
    readonly maxCharCount: int;
    createFallbackBuffer(): EncoderFallbackBuffer;
    equals(value: unknown): boolean;
    getHashCode(): int;
}


export const EncoderExceptionFallback: {
    new(): EncoderExceptionFallback$instance;
};


export type EncoderExceptionFallback = EncoderExceptionFallback$instance;

export interface EncoderExceptionFallbackBuffer$instance extends EncoderFallbackBuffer {
    readonly remaining: int;
    fallback(charUnknown: char, index: int): boolean;
    fallback(charUnknownHigh: char, charUnknownLow: char, index: int): boolean;
    getNextChar(): char;
    movePrevious(): boolean;
}


export const EncoderExceptionFallbackBuffer: {
    new(): EncoderExceptionFallbackBuffer$instance;
};


export type EncoderExceptionFallbackBuffer = EncoderExceptionFallbackBuffer$instance;

export interface EncoderFallback$instance {
    readonly maxCharCount: int;
    createFallbackBuffer(): EncoderFallbackBuffer;
}


export const EncoderFallback: {
    readonly replacementFallback: EncoderFallback;
    readonly exceptionFallback: EncoderFallback;
};


export type EncoderFallback = EncoderFallback$instance;

export interface EncoderFallbackBuffer$instance {
    readonly remaining: int;
    fallback(charUnknown: char, index: int): boolean;
    fallback(charUnknownHigh: char, charUnknownLow: char, index: int): boolean;
    getNextChar(): char;
    movePrevious(): boolean;
    reset(): void;
}


export const EncoderFallbackBuffer: {
};


export type EncoderFallbackBuffer = EncoderFallbackBuffer$instance;

export interface EncoderFallbackException$instance extends ArgumentException {
    readonly charUnknown: char;
    readonly charUnknownHigh: char;
    readonly charUnknownLow: char;
    readonly index: int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    isUnknownSurrogate(): boolean;
}


export const EncoderFallbackException: {
    new(): EncoderFallbackException$instance;
    new(message: string): EncoderFallbackException$instance;
    new(message: string, innerException: Exception): EncoderFallbackException$instance;
};


export interface __EncoderFallbackException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type EncoderFallbackException = EncoderFallbackException$instance & __EncoderFallbackException$views;


export interface EncoderReplacementFallback$instance extends EncoderFallback {
    readonly defaultString: string;
    readonly maxCharCount: int;
    createFallbackBuffer(): EncoderFallbackBuffer;
    equals(value: unknown): boolean;
    getHashCode(): int;
}


export const EncoderReplacementFallback: {
    new(): EncoderReplacementFallback$instance;
    new(replacement: string): EncoderReplacementFallback$instance;
};


export type EncoderReplacementFallback = EncoderReplacementFallback$instance;

export interface EncoderReplacementFallbackBuffer$instance extends EncoderFallbackBuffer {
    readonly remaining: int;
    fallback(charUnknown: char, index: int): boolean;
    fallback(charUnknownHigh: char, charUnknownLow: char, index: int): boolean;
    getNextChar(): char;
    movePrevious(): boolean;
    reset(): void;
}


export const EncoderReplacementFallbackBuffer: {
    new(fallback: EncoderReplacementFallback): EncoderReplacementFallbackBuffer$instance;
};


export type EncoderReplacementFallbackBuffer = EncoderReplacementFallbackBuffer$instance;

export interface Encoding$instance {
    readonly bodyName: string;
    readonly codePage: int;
    decoderFallback: DecoderFallback;
    encoderFallback: EncoderFallback;
    readonly encodingName: string;
    readonly headerName: string;
    readonly isBrowserDisplay: boolean;
    readonly isBrowserSave: boolean;
    readonly isMailNewsDisplay: boolean;
    readonly isMailNewsSave: boolean;
    readonly isReadOnly: boolean;
    readonly isSingleByte: boolean;
    readonly preamble: ReadOnlySpan_1<CLROf<byte>>;
    readonly webName: string;
    readonly windowsCodePage: int;
    clone(): unknown;
    equals(value: unknown): boolean;
    getByteCount(chars: char[]): int;
    getByteCount(s: string): int;
    getByteCount(chars: char[], index: int, count: int): int;
    getByteCount(s: string, index: int, count: int): int;
    getByteCount(chars: ptr<char>, count: int): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<char>>): int;
    getBytes(chars: char[]): byte[];
    getBytes(chars: char[], index: int, count: int): byte[];
    getBytes(chars: char[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(s: string): byte[];
    getBytes(s: string, index: int, count: int): byte[];
    getBytes(s: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: ptr<char>, charCount: int, bytes: ptr<byte>, byteCount: int): int;
    getBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>): int;
    getCharCount(bytes: byte[]): int;
    getCharCount(bytes: byte[], index: int, count: int): int;
    getCharCount(bytes: ptr<byte>, count: int): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    getChars(bytes: byte[]): char[];
    getChars(bytes: byte[], index: int, count: int): char[];
    getChars(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int): int;
    getChars(bytes: ptr<byte>, byteCount: int, chars: ptr<char>, charCount: int): int;
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>): int;
    getDecoder(): Decoder;
    getEncoder(): Encoder;
    getHashCode(): int;
    getMaxByteCount(charCount: int): int;
    getMaxCharCount(byteCount: int): int;
    getPreamble(): byte[];
    getString(bytes: ptr<byte>, byteCount: int): string;
    getString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    getString(bytes: byte[]): string;
    getString(bytes: byte[], index: int, count: int): string;
    isAlwaysNormalized(): boolean;
    isAlwaysNormalized(form: NormalizationForm): boolean;
    tryGetBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryGetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
}


export const Encoding: {
    readonly default_: Encoding;
    readonly ASCII: Encoding;
    readonly latin1: Encoding;
    readonly unicode: Encoding;
    readonly bigEndianUnicode: Encoding;
    readonly UTF7: Encoding;
    readonly UTF8: Encoding;
    readonly UTF32: Encoding;
    convert(srcEncoding: Encoding, dstEncoding: Encoding, bytes: byte[], index: int, count: int): byte[];
    convert(srcEncoding: Encoding, dstEncoding: Encoding, bytes: byte[]): byte[];
    createTranscodingStream(innerStream: Stream, innerStreamEncoding: Encoding, outerStreamEncoding: Encoding, leaveOpen?: boolean): Stream;
    getEncoding(codepage: int, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    getEncoding(codepage: int): Encoding;
    getEncoding(name: string, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    getEncoding(name: string): Encoding;
    getEncodings(): EncodingInfo[];
    registerProvider(provider: EncodingProvider): void;
};


export interface __Encoding$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface Encoding$instance extends System_Internal.ICloneable$instance {}

export type Encoding = Encoding$instance & __Encoding$views;


export interface EncodingInfo$instance {
    readonly codePage: int;
    readonly displayName: string;
    readonly name: string;
    equals(value: unknown): boolean;
    getEncoding(): Encoding;
    getHashCode(): int;
}


export const EncodingInfo: {
    new(provider: EncodingProvider, codePage: int, name: string, displayName: string): EncodingInfo$instance;
};


export type EncodingInfo = EncodingInfo$instance;

export interface EncodingProvider$instance {
    getEncoding(name: string): Encoding;
    getEncoding(codepage: int): Encoding;
    getEncoding(name: string, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    getEncoding(codepage: int, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    getEncodings(): IEnumerable_1<EncodingInfo>;
}


export const EncodingProvider: {
    new(): EncodingProvider$instance;
};


export type EncodingProvider = EncodingProvider$instance;

export interface StringBuilder$instance {
    capacity: int;
    chars: char;
    length: int;
    readonly maxCapacity: int;
    append(value: char, repeatCount: int): StringBuilder;
    append(value: char[], startIndex: int, charCount: int): StringBuilder;
    append(value: string): StringBuilder;
    append(value: string, startIndex: int, count: int): StringBuilder;
    append(value: StringBuilder): StringBuilder;
    append(value: StringBuilder, startIndex: int, count: int): StringBuilder;
    append(value: boolean): StringBuilder;
    append(value: char): StringBuilder;
    append(value: sbyte): StringBuilder;
    append(value: byte): StringBuilder;
    append(value: short): StringBuilder;
    append(value: int): StringBuilder;
    append(value: long): StringBuilder;
    append(value: float): StringBuilder;
    append(value: double): StringBuilder;
    append(value: decimal): StringBuilder;
    append(value: ushort): StringBuilder;
    append(value: uint): StringBuilder;
    append(value: ulong): StringBuilder;
    append(value: unknown): StringBuilder;
    append(value: char[]): StringBuilder;
    append(value: ReadOnlySpan_1<CLROf<char>>): StringBuilder;
    append(value: ReadOnlyMemory_1<CLROf<char>>): StringBuilder;
    append(handler: { value: ref<StringBuilder_AppendInterpolatedStringHandler> }): StringBuilder;
    append(provider: IFormatProvider, handler: { value: ref<StringBuilder_AppendInterpolatedStringHandler> }): StringBuilder;
    append(value: ptr<char>, valueCount: int): StringBuilder;
    appendFormat(format: string, arg0: unknown): StringBuilder;
    appendFormat(format: string, arg0: unknown, arg1: unknown): StringBuilder;
    appendFormat(format: string, arg0: unknown, arg1: unknown, arg2: unknown): StringBuilder;
    appendFormat(format: string, args: unknown[]): StringBuilder;
    appendFormat(format: string, args: ReadOnlySpan_1<unknown>): StringBuilder;
    appendFormat(provider: IFormatProvider, format: string, arg0: unknown): StringBuilder;
    appendFormat(provider: IFormatProvider, format: string, arg0: unknown, arg1: unknown): StringBuilder;
    appendFormat(provider: IFormatProvider, format: string, arg0: unknown, arg1: unknown, arg2: unknown): StringBuilder;
    appendFormat(provider: IFormatProvider, format: string, args: unknown[]): StringBuilder;
    appendFormat(provider: IFormatProvider, format: string, args: ReadOnlySpan_1<unknown>): StringBuilder;
    appendFormat<TArg0>(provider: IFormatProvider, format: CompositeFormat, arg0: TArg0): StringBuilder;
    appendFormat<TArg0, TArg1>(provider: IFormatProvider, format: CompositeFormat, arg0: TArg0, arg1: TArg1): StringBuilder;
    appendFormat<TArg0, TArg1, TArg2>(provider: IFormatProvider, format: CompositeFormat, arg0: TArg0, arg1: TArg1, arg2: TArg2): StringBuilder;
    appendFormat(provider: IFormatProvider, format: CompositeFormat, args: unknown[]): StringBuilder;
    appendFormat(provider: IFormatProvider, format: CompositeFormat, args: ReadOnlySpan_1<unknown>): StringBuilder;
    appendJoin(separator: string, values: unknown[]): StringBuilder;
    appendJoin(separator: string, values: ReadOnlySpan_1<unknown>): StringBuilder;
    appendJoin<T>(separator: string, values: IEnumerable_1<T>): StringBuilder;
    appendJoin(separator: string, values: string[]): StringBuilder;
    appendJoin(separator: string, values: ReadOnlySpan_1<CLROf<string>>): StringBuilder;
    appendJoin(separator: char, values: unknown[]): StringBuilder;
    appendJoin(separator: char, values: ReadOnlySpan_1<unknown>): StringBuilder;
    appendJoin<T>(separator: char, values: IEnumerable_1<T>): StringBuilder;
    appendJoin(separator: char, values: string[]): StringBuilder;
    appendJoin(separator: char, values: ReadOnlySpan_1<CLROf<string>>): StringBuilder;
    appendLine(): StringBuilder;
    appendLine(value: string): StringBuilder;
    appendLine(handler: { value: ref<StringBuilder_AppendInterpolatedStringHandler> }): StringBuilder;
    appendLine(provider: IFormatProvider, handler: { value: ref<StringBuilder_AppendInterpolatedStringHandler> }): StringBuilder;
    clear(): StringBuilder;
    copyTo(sourceIndex: int, destination: char[], destinationIndex: int, count: int): void;
    copyTo(sourceIndex: int, destination: Span_1<CLROf<char>>, count: int): void;
    ensureCapacity(capacity: int): int;
    equals(sb: StringBuilder): boolean;
    equals(span: ReadOnlySpan_1<CLROf<char>>): boolean;
    getChunks(): StringBuilder_ChunkEnumerator;
    insert(index: int, value: string, count: int): StringBuilder;
    insert(index: int, value: string): StringBuilder;
    insert(index: int, value: boolean): StringBuilder;
    insert(index: int, value: sbyte): StringBuilder;
    insert(index: int, value: byte): StringBuilder;
    insert(index: int, value: short): StringBuilder;
    insert(index: int, value: char): StringBuilder;
    insert(index: int, value: char[]): StringBuilder;
    insert(index: int, value: char[], startIndex: int, charCount: int): StringBuilder;
    insert(index: int, value: int): StringBuilder;
    insert(index: int, value: long): StringBuilder;
    insert(index: int, value: float): StringBuilder;
    insert(index: int, value: double): StringBuilder;
    insert(index: int, value: decimal): StringBuilder;
    insert(index: int, value: ushort): StringBuilder;
    insert(index: int, value: uint): StringBuilder;
    insert(index: int, value: ulong): StringBuilder;
    insert(index: int, value: unknown): StringBuilder;
    insert(index: int, value: ReadOnlySpan_1<CLROf<char>>): StringBuilder;
    remove(startIndex: int, length: int): StringBuilder;
    replace(oldValue: string, newValue: string): StringBuilder;
    replace(oldValue: ReadOnlySpan_1<CLROf<char>>, newValue: ReadOnlySpan_1<CLROf<char>>): StringBuilder;
    replace(oldValue: string, newValue: string, startIndex: int, count: int): StringBuilder;
    replace(oldValue: ReadOnlySpan_1<CLROf<char>>, newValue: ReadOnlySpan_1<CLROf<char>>, startIndex: int, count: int): StringBuilder;
    replace(oldChar: char, newChar: char): StringBuilder;
    replace(oldChar: char, newChar: char, startIndex: int, count: int): StringBuilder;
    toString(): string;
    toString(startIndex: int, length: int): string;
}


export const StringBuilder: {
    new(): StringBuilder$instance;
    new(capacity: int): StringBuilder$instance;
    new(value: string): StringBuilder$instance;
    new(value: string, capacity: int): StringBuilder$instance;
    new(value: string, startIndex: int, length: int, capacity: int): StringBuilder$instance;
    new(capacity: int, maxCapacity: int): StringBuilder$instance;
};


export interface __StringBuilder$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface StringBuilder$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type StringBuilder = StringBuilder$instance & __StringBuilder$views;


export interface UnicodeEncoding$instance extends Encoding$instance {
    readonly preamble: ReadOnlySpan_1<CLROf<byte>>;
    clone(): unknown;
    equals(value: unknown): boolean;
    getByteCount(chars: char[], index: int, count: int): int;
    getByteCount(s: string): int;
    getByteCount(chars: ptr<char>, count: int): int;
    getByteCount(chars: char[]): int;
    getByteCount(s: string, index: int, count: int): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<char>>): int;
    getBytes(s: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: char[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: ptr<char>, charCount: int, bytes: ptr<byte>, byteCount: int): int;
    getBytes(chars: char[]): byte[];
    getBytes(chars: char[], index: int, count: int): byte[];
    getBytes(s: string): byte[];
    getBytes(s: string, index: int, count: int): byte[];
    getBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>): int;
    getCharCount(bytes: byte[], index: int, count: int): int;
    getCharCount(bytes: ptr<byte>, count: int): int;
    getCharCount(bytes: byte[]): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    getChars(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int): int;
    getChars(bytes: ptr<byte>, byteCount: int, chars: ptr<char>, charCount: int): int;
    getChars(bytes: byte[]): char[];
    getChars(bytes: byte[], index: int, count: int): char[];
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>): int;
    getDecoder(): Decoder;
    getEncoder(): Encoder;
    getHashCode(): int;
    getMaxByteCount(charCount: int): int;
    getMaxCharCount(byteCount: int): int;
    getPreamble(): byte[];
    getString(bytes: byte[], index: int, count: int): string;
    getString(bytes: ptr<byte>, byteCount: int): string;
    getString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    getString(bytes: byte[]): string;
}


export const UnicodeEncoding: {
    new(): UnicodeEncoding$instance;
    new(bigEndian: boolean, byteOrderMark: boolean): UnicodeEncoding$instance;
    new(bigEndian: boolean, byteOrderMark: boolean, throwOnInvalidBytes: boolean): UnicodeEncoding$instance;
    readonly charSize: int;
};


export interface __UnicodeEncoding$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type UnicodeEncoding = UnicodeEncoding$instance & __UnicodeEncoding$views;


export interface UTF32Encoding$instance extends Encoding$instance {
    readonly preamble: ReadOnlySpan_1<CLROf<byte>>;
    clone(): unknown;
    equals(value: unknown): boolean;
    getByteCount(chars: char[], index: int, count: int): int;
    getByteCount(s: string): int;
    getByteCount(chars: ptr<char>, count: int): int;
    getByteCount(chars: char[]): int;
    getByteCount(s: string, index: int, count: int): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<char>>): int;
    getBytes(s: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: char[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: ptr<char>, charCount: int, bytes: ptr<byte>, byteCount: int): int;
    getBytes(chars: char[]): byte[];
    getBytes(chars: char[], index: int, count: int): byte[];
    getBytes(s: string): byte[];
    getBytes(s: string, index: int, count: int): byte[];
    getBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>): int;
    getCharCount(bytes: byte[], index: int, count: int): int;
    getCharCount(bytes: ptr<byte>, count: int): int;
    getCharCount(bytes: byte[]): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    getChars(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int): int;
    getChars(bytes: ptr<byte>, byteCount: int, chars: ptr<char>, charCount: int): int;
    getChars(bytes: byte[]): char[];
    getChars(bytes: byte[], index: int, count: int): char[];
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>): int;
    getDecoder(): Decoder;
    getEncoder(): Encoder;
    getHashCode(): int;
    getMaxByteCount(charCount: int): int;
    getMaxCharCount(byteCount: int): int;
    getPreamble(): byte[];
    getString(bytes: byte[], index: int, count: int): string;
    getString(bytes: ptr<byte>, byteCount: int): string;
    getString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    getString(bytes: byte[]): string;
}


export const UTF32Encoding: {
    new(): UTF32Encoding$instance;
    new(bigEndian: boolean, byteOrderMark: boolean): UTF32Encoding$instance;
    new(bigEndian: boolean, byteOrderMark: boolean, throwOnInvalidCharacters: boolean): UTF32Encoding$instance;
};


export interface __UTF32Encoding$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type UTF32Encoding = UTF32Encoding$instance & __UTF32Encoding$views;


export interface UTF7Encoding$instance extends Encoding$instance {
    clone(): unknown;
    equals(value: unknown): boolean;
    getByteCount(chars: char[], index: int, count: int): int;
    getByteCount(s: string): int;
    getByteCount(chars: ptr<char>, count: int): int;
    getByteCount(chars: char[]): int;
    getByteCount(s: string, index: int, count: int): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<char>>): int;
    getBytes(s: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: char[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: ptr<char>, charCount: int, bytes: ptr<byte>, byteCount: int): int;
    getBytes(chars: char[]): byte[];
    getBytes(chars: char[], index: int, count: int): byte[];
    getBytes(s: string): byte[];
    getBytes(s: string, index: int, count: int): byte[];
    getBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>): int;
    getCharCount(bytes: byte[], index: int, count: int): int;
    getCharCount(bytes: ptr<byte>, count: int): int;
    getCharCount(bytes: byte[]): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    getChars(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int): int;
    getChars(bytes: ptr<byte>, byteCount: int, chars: ptr<char>, charCount: int): int;
    getChars(bytes: byte[]): char[];
    getChars(bytes: byte[], index: int, count: int): char[];
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>): int;
    getDecoder(): Decoder;
    getEncoder(): Encoder;
    getHashCode(): int;
    getMaxByteCount(charCount: int): int;
    getMaxCharCount(byteCount: int): int;
    getString(bytes: byte[], index: int, count: int): string;
    getString(bytes: ptr<byte>, byteCount: int): string;
    getString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    getString(bytes: byte[]): string;
}


export const UTF7Encoding: {
    new(): UTF7Encoding$instance;
    new(allowOptionals: boolean): UTF7Encoding$instance;
};


export interface __UTF7Encoding$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type UTF7Encoding = UTF7Encoding$instance & __UTF7Encoding$views;


export interface UTF8Encoding$instance extends Encoding$instance {
    readonly preamble: ReadOnlySpan_1<CLROf<byte>>;
    clone(): unknown;
    equals(value: unknown): boolean;
    getByteCount(chars: char[], index: int, count: int): int;
    getByteCount(chars: string): int;
    getByteCount(chars: ptr<char>, count: int): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<char>>): int;
    getByteCount(chars: char[]): int;
    getByteCount(s: string, index: int, count: int): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<char>>): int;
    getBytes(s: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: char[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: ptr<char>, charCount: int, bytes: ptr<byte>, byteCount: int): int;
    getBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>): int;
    getBytes(chars: char[]): byte[];
    getBytes(chars: char[], index: int, count: int): byte[];
    getBytes(s: string): byte[];
    getBytes(s: string, index: int, count: int): byte[];
    getBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>): int;
    getCharCount(bytes: byte[], index: int, count: int): int;
    getCharCount(bytes: ptr<byte>, count: int): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    getCharCount(bytes: byte[]): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    getChars(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int): int;
    getChars(bytes: ptr<byte>, byteCount: int, chars: ptr<char>, charCount: int): int;
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>): int;
    getChars(bytes: byte[]): char[];
    getChars(bytes: byte[], index: int, count: int): char[];
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>): int;
    getDecoder(): Decoder;
    getEncoder(): Encoder;
    getHashCode(): int;
    getMaxByteCount(charCount: int): int;
    getMaxCharCount(byteCount: int): int;
    getPreamble(): byte[];
    getString(bytes: byte[], index: int, count: int): string;
    getString(bytes: ptr<byte>, byteCount: int): string;
    getString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    getString(bytes: byte[]): string;
    tryGetBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryGetBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryGetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    tryGetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
}


export const UTF8Encoding: {
    new(): UTF8Encoding$instance;
    new(encoderShouldEmitUTF8Identifier: boolean): UTF8Encoding$instance;
    new(encoderShouldEmitUTF8Identifier: boolean, throwOnInvalidBytes: boolean): UTF8Encoding$instance;
};


export interface __UTF8Encoding$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type UTF8Encoding = UTF8Encoding$instance & __UTF8Encoding$views;


export abstract class Ascii$instance {
    static equals(left: ReadOnlySpan_1<CLROf<byte>>, right: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static equals(left: ReadOnlySpan_1<CLROf<byte>>, right: ReadOnlySpan_1<CLROf<char>>): boolean;
    static equals(left: ReadOnlySpan_1<CLROf<char>>, right: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static equals(left: ReadOnlySpan_1<CLROf<char>>, right: ReadOnlySpan_1<CLROf<char>>): boolean;
    static equalsIgnoreCase(left: ReadOnlySpan_1<CLROf<byte>>, right: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static equalsIgnoreCase(left: ReadOnlySpan_1<CLROf<byte>>, right: ReadOnlySpan_1<CLROf<char>>): boolean;
    static equalsIgnoreCase(left: ReadOnlySpan_1<CLROf<char>>, right: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static equalsIgnoreCase(left: ReadOnlySpan_1<CLROf<char>>, right: ReadOnlySpan_1<CLROf<char>>): boolean;
    static fromUtf16(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static isValid(value: byte): boolean;
    static isValid(value: char): boolean;
    static isValid(value: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static isValid(value: ReadOnlySpan_1<CLROf<char>>): boolean;
    static toLower(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static toLower(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): OperationStatus;
    static toLower(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static toLower(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): OperationStatus;
    static toLowerInPlace(value: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static toLowerInPlace(value: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): OperationStatus;
    static toUpper(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static toUpper(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): OperationStatus;
    static toUpper(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static toUpper(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): OperationStatus;
    static toUpperInPlace(value: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static toUpperInPlace(value: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): OperationStatus;
    static toUtf16(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): OperationStatus;
    static trim(value: ReadOnlySpan_1<CLROf<byte>>): Range;
    static trim(value: ReadOnlySpan_1<CLROf<char>>): Range;
    static trimEnd(value: ReadOnlySpan_1<CLROf<byte>>): Range;
    static trimEnd(value: ReadOnlySpan_1<CLROf<char>>): Range;
    static trimStart(value: ReadOnlySpan_1<CLROf<byte>>): Range;
    static trimStart(value: ReadOnlySpan_1<CLROf<char>>): Range;
}


export type Ascii = Ascii$instance;

export abstract class EncodingExtensions$instance {
    static convert(decoder: Decoder, bytes: { value: ref<ReadOnlySequence_1<CLROf<byte>>> }, writer: IBufferWriter_1<CLROf<char>>, flush: boolean, charsUsed: { value: ref<long> }, completed: { value: ref<boolean> }): void;
    static convert(decoder: Decoder, bytes: ReadOnlySpan_1<CLROf<byte>>, writer: IBufferWriter_1<CLROf<char>>, flush: boolean, charsUsed: { value: ref<long> }, completed: { value: ref<boolean> }): void;
    static convert(encoder: Encoder, chars: { value: ref<ReadOnlySequence_1<CLROf<char>>> }, writer: IBufferWriter_1<CLROf<byte>>, flush: boolean, bytesUsed: { value: ref<long> }, completed: { value: ref<boolean> }): void;
    static convert(encoder: Encoder, chars: ReadOnlySpan_1<CLROf<char>>, writer: IBufferWriter_1<CLROf<byte>>, flush: boolean, bytesUsed: { value: ref<long> }, completed: { value: ref<boolean> }): void;
    static getBytes(encoding: Encoding, chars: { value: ref<ReadOnlySequence_1<CLROf<char>>> }, writer: IBufferWriter_1<CLROf<byte>>): long;
    static getBytes(encoding: Encoding, chars: { value: ref<ReadOnlySequence_1<CLROf<char>>> }, bytes: Span_1<CLROf<byte>>): int;
    static getBytes(encoding: Encoding, chars: { value: ref<ReadOnlySequence_1<CLROf<char>>> }): byte[];
    static getBytes(encoding: Encoding, chars: ReadOnlySpan_1<CLROf<char>>, writer: IBufferWriter_1<CLROf<byte>>): long;
    static getChars(encoding: Encoding, bytes: { value: ref<ReadOnlySequence_1<CLROf<byte>>> }, writer: IBufferWriter_1<CLROf<char>>): long;
    static getChars(encoding: Encoding, bytes: { value: ref<ReadOnlySequence_1<CLROf<byte>>> }, chars: Span_1<CLROf<char>>): int;
    static getChars(encoding: Encoding, bytes: ReadOnlySpan_1<CLROf<byte>>, writer: IBufferWriter_1<CLROf<char>>): long;
    static getString(encoding: Encoding, bytes: { value: ref<ReadOnlySequence_1<CLROf<byte>>> }): string;
}


export type EncodingExtensions = EncodingExtensions$instance;

