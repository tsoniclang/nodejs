// Generated by tsbindgen - Architecture
// Namespace: System.Threading.Tasks.Dataflow
// Assembly: System.Threading.Tasks.Dataflow

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { IAsyncEnumerable_1, IEnumerable_1, IList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { Task, Task_1, TaskScheduler } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Boolean as ClrBoolean, Enum, Exception, Func_2, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int32, Int64, IObservable_1, IObserver_1, ISpanFormattable, Object as ClrObject, Predicate_1, String as ClrString, TimeSpan, Tuple_2, Tuple_3, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum DataflowMessageStatus {
    accepted = 0,
    declined = 1,
    postponed = 2,
    notAvailable = 3,
    decliningPermanently = 4
}


export interface IDataflowBlock$instance {
    readonly completion: Task;
    complete(): void;
    fault(exception: Exception): void;
}


export type IDataflowBlock = IDataflowBlock$instance;

export interface IPropagatorBlock_2$instance<TInput, TOutput> extends ITargetBlock_1<TInput>, IDataflowBlock, ISourceBlock_1<TOutput> {
    readonly completion: Task;
    complete(): void;
    consumeMessage(messageHeader: DataflowMessageHeader, target: ITargetBlock_1<TOutput>, messageConsumed: { value: ref<boolean> }): TOutput;
    fault(exception: Exception): void;
    linkTo(target: ITargetBlock_1<TOutput>, linkOptions: DataflowLinkOptions): IDisposable;
    offerMessage(messageHeader: DataflowMessageHeader, messageValue: TInput, source: ISourceBlock_1<TInput>, consumeToAccept: boolean): DataflowMessageStatus;
    releaseReservation(messageHeader: DataflowMessageHeader, target: ITargetBlock_1<TOutput>): void;
    reserveMessage(messageHeader: DataflowMessageHeader, target: ITargetBlock_1<TOutput>): boolean;
}


export type IPropagatorBlock_2<TInput, TOutput> = IPropagatorBlock_2$instance<TInput, TOutput>;

export interface IReceivableSourceBlock_1$instance<TOutput> extends ISourceBlock_1<TOutput>, IDataflowBlock {
    readonly completion: Task;
    complete(): void;
    consumeMessage(messageHeader: DataflowMessageHeader, target: ITargetBlock_1<TOutput>, messageConsumed: { value: ref<boolean> }): TOutput;
    fault(exception: Exception): void;
    linkTo(target: ITargetBlock_1<TOutput>, linkOptions: DataflowLinkOptions): IDisposable;
    releaseReservation(messageHeader: DataflowMessageHeader, target: ITargetBlock_1<TOutput>): void;
    reserveMessage(messageHeader: DataflowMessageHeader, target: ITargetBlock_1<TOutput>): boolean;
    tryReceive(filter: Predicate_1<TOutput>, item: { value: ref<TOutput> }): boolean;
    tryReceiveAll(items: { value: ref<IList_1<TOutput>> }): boolean;
}


export type IReceivableSourceBlock_1<TOutput> = IReceivableSourceBlock_1$instance<TOutput>;

export interface ISourceBlock_1$instance<TOutput> extends IDataflowBlock {
    readonly completion: Task;
    complete(): void;
    consumeMessage(messageHeader: DataflowMessageHeader, target: ITargetBlock_1<TOutput>, messageConsumed: { value: ref<boolean> }): TOutput;
    fault(exception: Exception): void;
    linkTo(target: ITargetBlock_1<TOutput>, linkOptions: DataflowLinkOptions): IDisposable;
    releaseReservation(messageHeader: DataflowMessageHeader, target: ITargetBlock_1<TOutput>): void;
    reserveMessage(messageHeader: DataflowMessageHeader, target: ITargetBlock_1<TOutput>): boolean;
}


export interface ISourceBlock_1$instance<TOutput> extends IDataflowBlock$instance {}

export type ISourceBlock_1<TOutput> = ISourceBlock_1$instance<TOutput>;

export interface ITargetBlock_1$instance<TInput> extends IDataflowBlock {
    readonly completion: Task;
    complete(): void;
    fault(exception: Exception): void;
    offerMessage(messageHeader: DataflowMessageHeader, messageValue: TInput, source: ISourceBlock_1<TInput>, consumeToAccept: boolean): DataflowMessageStatus;
}


export interface ITargetBlock_1$instance<TInput> extends IDataflowBlock$instance {}

export type ITargetBlock_1<TInput> = ITargetBlock_1$instance<TInput>;

export interface DataflowMessageHeader$instance {
    readonly id: long;
    readonly isValid: boolean;
    equals(other: DataflowMessageHeader): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const DataflowMessageHeader: {
    new(id: long): DataflowMessageHeader$instance;
};


export interface __DataflowMessageHeader$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<DataflowMessageHeader>;

    // Structural method bridges for numeric interface constraints
    Equals(other: DataflowMessageHeader): boolean;
}

export type DataflowMessageHeader = DataflowMessageHeader$instance & __DataflowMessageHeader$views;


export interface ActionBlock_1$instance<TInput> {
    readonly completion: Task;
    readonly inputCount: int;
    complete(): void;
    post(item: TInput): boolean;
    toString(): string;
}


export const ActionBlock_1: {
    new<TInput>(action: Action_1<TInput>): ActionBlock_1$instance<TInput>;
    new<TInput>(action: Action_1<TInput>, dataflowBlockOptions: ExecutionDataflowBlockOptions): ActionBlock_1$instance<TInput>;
    new<TInput>(action: Func_2<TInput, Task>): ActionBlock_1$instance<TInput>;
    new<TInput>(action: Func_2<TInput, Task>, dataflowBlockOptions: ExecutionDataflowBlockOptions): ActionBlock_1$instance<TInput>;
};


export interface __ActionBlock_1$views<TInput> {
    As_IDataflowBlock(): IDataflowBlock$instance;
    As_ITargetBlock_1(): ITargetBlock_1$instance<TInput>;
}

export type ActionBlock_1<TInput> = ActionBlock_1$instance<TInput> & __ActionBlock_1$views<TInput>;


export interface BatchBlock_1$instance<T> {
    readonly batchSize: int;
    readonly completion: Task;
    readonly outputCount: int;
    complete(): void;
    linkTo(target: ITargetBlock_1<T[]>, linkOptions: DataflowLinkOptions): IDisposable;
    toString(): string;
    triggerBatch(): void;
    tryReceive(filter: Predicate_1<T[]>, item: { value: ref<T[]> }): boolean;
    tryReceiveAll(items: { value: ref<IList_1<T[]>> }): boolean;
}


export const BatchBlock_1: {
    new<T>(batchSize: int): BatchBlock_1$instance<T>;
    new<T>(batchSize: int, dataflowBlockOptions: GroupingDataflowBlockOptions): BatchBlock_1$instance<T>;
};


export interface __BatchBlock_1$views<T> {
    As_IDataflowBlock(): IDataflowBlock$instance;
    As_IReceivableSourceBlock_1(): IReceivableSourceBlock_1$instance<T[]>;
    As_ISourceBlock_1(): ISourceBlock_1$instance<T[]>;
    As_ITargetBlock_1(): ITargetBlock_1$instance<T>;
}

export type BatchBlock_1<T> = BatchBlock_1$instance<T> & __BatchBlock_1$views<T>;


export interface BatchedJoinBlock_2$instance<T1, T2> {
    readonly batchSize: int;
    readonly completion: Task;
    readonly outputCount: int;
    readonly target1: ITargetBlock_1<T1>;
    readonly target2: ITargetBlock_1<T2>;
    complete(): void;
    linkTo(target: ITargetBlock_1<Tuple_2<IList_1<T1>, IList_1<T2>>>, linkOptions: DataflowLinkOptions): IDisposable;
    toString(): string;
    tryReceive(filter: Predicate_1<Tuple_2<IList_1<T1>, IList_1<T2>>>, item: { value: ref<Tuple_2<IList_1<T1>, IList_1<T2>>> }): boolean;
    tryReceiveAll(items: { value: ref<IList_1<Tuple_2<IList_1<T1>, IList_1<T2>>>> }): boolean;
}


export const BatchedJoinBlock_2: {
    new<T1, T2>(batchSize: int): BatchedJoinBlock_2$instance<T1, T2>;
    new<T1, T2>(batchSize: int, dataflowBlockOptions: GroupingDataflowBlockOptions): BatchedJoinBlock_2$instance<T1, T2>;
};


export interface __BatchedJoinBlock_2$views<T1, T2> {
    As_IDataflowBlock(): IDataflowBlock$instance;
    As_IReceivableSourceBlock_1(): IReceivableSourceBlock_1$instance<Tuple_2<IList_1<T1>, IList_1<T2>>>;
    As_ISourceBlock_1(): ISourceBlock_1$instance<Tuple_2<IList_1<T1>, IList_1<T2>>>;
}

export type BatchedJoinBlock_2<T1, T2> = BatchedJoinBlock_2$instance<T1, T2> & __BatchedJoinBlock_2$views<T1, T2>;


export interface BatchedJoinBlock_3$instance<T1, T2, T3> {
    readonly batchSize: int;
    readonly completion: Task;
    readonly outputCount: int;
    readonly target1: ITargetBlock_1<T1>;
    readonly target2: ITargetBlock_1<T2>;
    readonly target3: ITargetBlock_1<T3>;
    complete(): void;
    linkTo(target: ITargetBlock_1<Tuple_3<IList_1<T1>, IList_1<T2>, IList_1<T3>>>, linkOptions: DataflowLinkOptions): IDisposable;
    toString(): string;
    tryReceive(filter: Predicate_1<Tuple_3<IList_1<T1>, IList_1<T2>, IList_1<T3>>>, item: { value: ref<Tuple_3<IList_1<T1>, IList_1<T2>, IList_1<T3>>> }): boolean;
    tryReceiveAll(items: { value: ref<IList_1<Tuple_3<IList_1<T1>, IList_1<T2>, IList_1<T3>>>> }): boolean;
}


export const BatchedJoinBlock_3: {
    new<T1, T2, T3>(batchSize: int): BatchedJoinBlock_3$instance<T1, T2, T3>;
    new<T1, T2, T3>(batchSize: int, dataflowBlockOptions: GroupingDataflowBlockOptions): BatchedJoinBlock_3$instance<T1, T2, T3>;
};


export interface __BatchedJoinBlock_3$views<T1, T2, T3> {
    As_IDataflowBlock(): IDataflowBlock$instance;
    As_IReceivableSourceBlock_1(): IReceivableSourceBlock_1$instance<Tuple_3<IList_1<T1>, IList_1<T2>, IList_1<T3>>>;
    As_ISourceBlock_1(): ISourceBlock_1$instance<Tuple_3<IList_1<T1>, IList_1<T2>, IList_1<T3>>>;
}

export type BatchedJoinBlock_3<T1, T2, T3> = BatchedJoinBlock_3$instance<T1, T2, T3> & __BatchedJoinBlock_3$views<T1, T2, T3>;


export interface BroadcastBlock_1$instance<T> {
    readonly completion: Task;
    complete(): void;
    linkTo(target: ITargetBlock_1<T>, linkOptions: DataflowLinkOptions): IDisposable;
    toString(): string;
    tryReceive(filter: Predicate_1<T>, item: { value: ref<T> }): boolean;
}


export const BroadcastBlock_1: {
    new<T>(cloningFunction: Func_2<T, T>): BroadcastBlock_1$instance<T>;
    new<T>(cloningFunction: Func_2<T, T>, dataflowBlockOptions: DataflowBlockOptions): BroadcastBlock_1$instance<T>;
};


export interface __BroadcastBlock_1$views<T> {
    As_IDataflowBlock(): IDataflowBlock$instance;
    As_IReceivableSourceBlock_1(): IReceivableSourceBlock_1$instance<T>;
    As_ISourceBlock_1(): ISourceBlock_1$instance<T>;
    As_ITargetBlock_1(): ITargetBlock_1$instance<T>;
}

export type BroadcastBlock_1<T> = BroadcastBlock_1$instance<T> & __BroadcastBlock_1$views<T>;


export interface BufferBlock_1$instance<T> {
    readonly completion: Task;
    readonly count: int;
    complete(): void;
    linkTo(target: ITargetBlock_1<T>, linkOptions: DataflowLinkOptions): IDisposable;
    toString(): string;
    tryReceive(filter: Predicate_1<T>, item: { value: ref<T> }): boolean;
    tryReceiveAll(items: { value: ref<IList_1<T>> }): boolean;
}


export const BufferBlock_1: {
    new<T>(): BufferBlock_1$instance<T>;
    new<T>(dataflowBlockOptions: DataflowBlockOptions): BufferBlock_1$instance<T>;
};


export interface __BufferBlock_1$views<T> {
    As_IDataflowBlock(): IDataflowBlock$instance;
    As_IReceivableSourceBlock_1(): IReceivableSourceBlock_1$instance<T>;
    As_ISourceBlock_1(): ISourceBlock_1$instance<T>;
    As_ITargetBlock_1(): ITargetBlock_1$instance<T>;
}

export type BufferBlock_1<T> = BufferBlock_1$instance<T> & __BufferBlock_1$views<T>;


export interface DataflowBlockOptions$instance {
    boundedCapacity: int;
    cancellationToken: CancellationToken;
    ensureOrdered: boolean;
    maxMessagesPerTask: int;
    nameFormat: string;
    taskScheduler: TaskScheduler;
}


export const DataflowBlockOptions: {
    new(): DataflowBlockOptions$instance;
    readonly unbounded: int;
};


export type DataflowBlockOptions = DataflowBlockOptions$instance;

export interface DataflowLinkOptions$instance {
    append: boolean;
    maxMessages: int;
    propagateCompletion: boolean;
}


export const DataflowLinkOptions: {
    new(): DataflowLinkOptions$instance;
};


export type DataflowLinkOptions = DataflowLinkOptions$instance;

export interface ExecutionDataflowBlockOptions$instance extends DataflowBlockOptions {
    maxDegreeOfParallelism: int;
    singleProducerConstrained: boolean;
}


export const ExecutionDataflowBlockOptions: {
    new(): ExecutionDataflowBlockOptions$instance;
};


export type ExecutionDataflowBlockOptions = ExecutionDataflowBlockOptions$instance;

export interface GroupingDataflowBlockOptions$instance extends DataflowBlockOptions {
    greedy: boolean;
    maxNumberOfGroups: long;
}


export const GroupingDataflowBlockOptions: {
    new(): GroupingDataflowBlockOptions$instance;
};


export type GroupingDataflowBlockOptions = GroupingDataflowBlockOptions$instance;

export interface JoinBlock_2$instance<T1, T2> {
    readonly completion: Task;
    readonly outputCount: int;
    readonly target1: ITargetBlock_1<T1>;
    readonly target2: ITargetBlock_1<T2>;
    complete(): void;
    linkTo(target: ITargetBlock_1<Tuple_2<T1, T2>>, linkOptions: DataflowLinkOptions): IDisposable;
    toString(): string;
    tryReceive(filter: Predicate_1<Tuple_2<T1, T2>>, item: { value: ref<Tuple_2<T1, T2>> }): boolean;
    tryReceiveAll(items: { value: ref<IList_1<Tuple_2<T1, T2>>> }): boolean;
}


export const JoinBlock_2: {
    new<T1, T2>(): JoinBlock_2$instance<T1, T2>;
    new<T1, T2>(dataflowBlockOptions: GroupingDataflowBlockOptions): JoinBlock_2$instance<T1, T2>;
};


export interface __JoinBlock_2$views<T1, T2> {
    As_IDataflowBlock(): IDataflowBlock$instance;
    As_IReceivableSourceBlock_1(): IReceivableSourceBlock_1$instance<Tuple_2<T1, T2>>;
    As_ISourceBlock_1(): ISourceBlock_1$instance<Tuple_2<T1, T2>>;
}

export type JoinBlock_2<T1, T2> = JoinBlock_2$instance<T1, T2> & __JoinBlock_2$views<T1, T2>;


export interface JoinBlock_3$instance<T1, T2, T3> {
    readonly completion: Task;
    readonly outputCount: int;
    readonly target1: ITargetBlock_1<T1>;
    readonly target2: ITargetBlock_1<T2>;
    readonly target3: ITargetBlock_1<T3>;
    complete(): void;
    linkTo(target: ITargetBlock_1<Tuple_3<T1, T2, T3>>, linkOptions: DataflowLinkOptions): IDisposable;
    toString(): string;
    tryReceive(filter: Predicate_1<Tuple_3<T1, T2, T3>>, item: { value: ref<Tuple_3<T1, T2, T3>> }): boolean;
    tryReceiveAll(items: { value: ref<IList_1<Tuple_3<T1, T2, T3>>> }): boolean;
}


export const JoinBlock_3: {
    new<T1, T2, T3>(): JoinBlock_3$instance<T1, T2, T3>;
    new<T1, T2, T3>(dataflowBlockOptions: GroupingDataflowBlockOptions): JoinBlock_3$instance<T1, T2, T3>;
};


export interface __JoinBlock_3$views<T1, T2, T3> {
    As_IDataflowBlock(): IDataflowBlock$instance;
    As_IReceivableSourceBlock_1(): IReceivableSourceBlock_1$instance<Tuple_3<T1, T2, T3>>;
    As_ISourceBlock_1(): ISourceBlock_1$instance<Tuple_3<T1, T2, T3>>;
}

export type JoinBlock_3<T1, T2, T3> = JoinBlock_3$instance<T1, T2, T3> & __JoinBlock_3$views<T1, T2, T3>;


export interface TransformBlock_2$instance<TInput, TOutput> {
    readonly completion: Task;
    readonly inputCount: int;
    readonly outputCount: int;
    complete(): void;
    linkTo(target: ITargetBlock_1<TOutput>, linkOptions: DataflowLinkOptions): IDisposable;
    toString(): string;
    tryReceive(filter: Predicate_1<TOutput>, item: { value: ref<TOutput> }): boolean;
    tryReceiveAll(items: { value: ref<IList_1<TOutput>> }): boolean;
}


export const TransformBlock_2: {
    new<TInput, TOutput>(transform: Func_2<TInput, TOutput>): TransformBlock_2$instance<TInput, TOutput>;
    new<TInput, TOutput>(transform: Func_2<TInput, TOutput>, dataflowBlockOptions: ExecutionDataflowBlockOptions): TransformBlock_2$instance<TInput, TOutput>;
};


export interface __TransformBlock_2$views<TInput, TOutput> {
    As_IDataflowBlock(): IDataflowBlock$instance;
    As_IReceivableSourceBlock_1(): IReceivableSourceBlock_1$instance<TOutput>;
    As_ISourceBlock_1(): ISourceBlock_1$instance<TOutput>;
    As_ITargetBlock_1(): ITargetBlock_1$instance<TInput>;
}

export type TransformBlock_2<TInput, TOutput> = TransformBlock_2$instance<TInput, TOutput> & __TransformBlock_2$views<TInput, TOutput>;


export interface TransformManyBlock_2$instance<TInput, TOutput> {
    readonly completion: Task;
    readonly inputCount: int;
    readonly outputCount: int;
    complete(): void;
    linkTo(target: ITargetBlock_1<TOutput>, linkOptions: DataflowLinkOptions): IDisposable;
    toString(): string;
    tryReceive(filter: Predicate_1<TOutput>, item: { value: ref<TOutput> }): boolean;
    tryReceiveAll(items: { value: ref<IList_1<TOutput>> }): boolean;
}


export const TransformManyBlock_2: {
    new<TInput, TOutput>(transform: Func_2<TInput, IEnumerable_1<TOutput>>): TransformManyBlock_2$instance<TInput, TOutput>;
    new<TInput, TOutput>(transform: Func_2<TInput, IEnumerable_1<TOutput>>, dataflowBlockOptions: ExecutionDataflowBlockOptions): TransformManyBlock_2$instance<TInput, TOutput>;
};


export interface __TransformManyBlock_2$views<TInput, TOutput> {
    As_IDataflowBlock(): IDataflowBlock$instance;
    As_IReceivableSourceBlock_1(): IReceivableSourceBlock_1$instance<TOutput>;
    As_ISourceBlock_1(): ISourceBlock_1$instance<TOutput>;
    As_ITargetBlock_1(): ITargetBlock_1$instance<TInput>;
}

export type TransformManyBlock_2<TInput, TOutput> = TransformManyBlock_2$instance<TInput, TOutput> & __TransformManyBlock_2$views<TInput, TOutput>;


export interface WriteOnceBlock_1$instance<T> {
    readonly completion: Task;
    complete(): void;
    linkTo(target: ITargetBlock_1<T>, linkOptions: DataflowLinkOptions): IDisposable;
    toString(): string;
    tryReceive(filter: Predicate_1<T>, item: { value: ref<T> }): boolean;
}


export const WriteOnceBlock_1: {
    new<T>(cloningFunction: Func_2<T, T>): WriteOnceBlock_1$instance<T>;
    new<T>(cloningFunction: Func_2<T, T>, dataflowBlockOptions: DataflowBlockOptions): WriteOnceBlock_1$instance<T>;
};


export interface __WriteOnceBlock_1$views<T> {
    As_IDataflowBlock(): IDataflowBlock$instance;
    As_IReceivableSourceBlock_1(): IReceivableSourceBlock_1$instance<T>;
    As_ISourceBlock_1(): ISourceBlock_1$instance<T>;
    As_ITargetBlock_1(): ITargetBlock_1$instance<T>;
}

export type WriteOnceBlock_1<T> = WriteOnceBlock_1$instance<T> & __WriteOnceBlock_1$views<T>;


export abstract class DataflowBlock$instance {
    static asObservable<TOutput>(source: ISourceBlock_1<TOutput>): IObservable_1<TOutput>;
    static asObserver<TInput>(target: ITargetBlock_1<TInput>): IObserver_1<TInput>;
    static choose<T1, T2, T3>(source1: ISourceBlock_1<T1>, action1: Action_1<T1>, source2: ISourceBlock_1<T2>, action2: Action_1<T2>, source3: ISourceBlock_1<T3>, action3: Action_1<T3>, dataflowBlockOptions: DataflowBlockOptions): Task_1<CLROf<int>>;
    static choose<T1, T2, T3>(source1: ISourceBlock_1<T1>, action1: Action_1<T1>, source2: ISourceBlock_1<T2>, action2: Action_1<T2>, source3: ISourceBlock_1<T3>, action3: Action_1<T3>): Task_1<CLROf<int>>;
    static choose<T1, T2>(source1: ISourceBlock_1<T1>, action1: Action_1<T1>, source2: ISourceBlock_1<T2>, action2: Action_1<T2>, dataflowBlockOptions: DataflowBlockOptions): Task_1<CLROf<int>>;
    static choose<T1, T2>(source1: ISourceBlock_1<T1>, action1: Action_1<T1>, source2: ISourceBlock_1<T2>, action2: Action_1<T2>): Task_1<CLROf<int>>;
    static encapsulate<TInput, TOutput>(target: ITargetBlock_1<TInput>, source: ISourceBlock_1<TOutput>): IPropagatorBlock_2<TInput, TOutput>;
    static linkTo<TOutput>(source: ISourceBlock_1<TOutput>, target: ITargetBlock_1<TOutput>, predicate: Predicate_1<TOutput>): IDisposable;
    static linkTo<TOutput>(source: ISourceBlock_1<TOutput>, target: ITargetBlock_1<TOutput>, linkOptions: DataflowLinkOptions, predicate: Predicate_1<TOutput>): IDisposable;
    static linkTo<TOutput>(source: ISourceBlock_1<TOutput>, target: ITargetBlock_1<TOutput>): IDisposable;
    static nullTarget<TInput>(): ITargetBlock_1<TInput>;
    static outputAvailableAsync<TOutput>(source: ISourceBlock_1<TOutput>, cancellationToken: CancellationToken): Task_1<CLROf<boolean>>;
    static outputAvailableAsync<TOutput>(source: ISourceBlock_1<TOutput>): Task_1<CLROf<boolean>>;
    static post<TInput>(target: ITargetBlock_1<TInput>, item: TInput): boolean;
    static receive<TOutput>(source: ISourceBlock_1<TOutput>, cancellationToken: CancellationToken): TOutput;
    static receive<TOutput>(source: ISourceBlock_1<TOutput>, timeout: TimeSpan, cancellationToken: CancellationToken): TOutput;
    static receive<TOutput>(source: ISourceBlock_1<TOutput>, timeout: TimeSpan): TOutput;
    static receive<TOutput>(source: ISourceBlock_1<TOutput>): TOutput;
    static receiveAllAsync<TOutput>(source: IReceivableSourceBlock_1<TOutput>, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TOutput>;
    static receiveAsync<TOutput>(source: ISourceBlock_1<TOutput>, cancellationToken: CancellationToken): Task_1<TOutput>;
    static receiveAsync<TOutput>(source: ISourceBlock_1<TOutput>, timeout: TimeSpan, cancellationToken: CancellationToken): Task_1<TOutput>;
    static receiveAsync<TOutput>(source: ISourceBlock_1<TOutput>, timeout: TimeSpan): Task_1<TOutput>;
    static receiveAsync<TOutput>(source: ISourceBlock_1<TOutput>): Task_1<TOutput>;
    static sendAsync<TInput>(target: ITargetBlock_1<TInput>, item: TInput, cancellationToken: CancellationToken): Task_1<CLROf<boolean>>;
    static sendAsync<TInput>(target: ITargetBlock_1<TInput>, item: TInput): Task_1<CLROf<boolean>>;
    static tryReceive<TOutput>(source: IReceivableSourceBlock_1<TOutput>, item: { value: ref<TOutput> }): boolean;
}


export type DataflowBlock = DataflowBlock$instance;

