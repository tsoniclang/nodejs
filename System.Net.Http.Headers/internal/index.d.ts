// Generated by tsbindgen - Architecture
// Namespace: System.Net.Http.Headers
// Assembly: System.Net.Http

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IReadOnlyCollection_1, IReadOnlyDictionary_2, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Byte, DateTimeOffset, Double, ICloneable, IDisposable, Int32, Int64, Nullable_1, Object as ClrObject, String as ClrString, TimeSpan, Type, Uri, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface HeaderStringValues$instance {
    readonly count: int;
    getEnumerator(): HeaderStringValues_Enumerator;
    toString(): string;
}


export const HeaderStringValues: {
    new(): HeaderStringValues$instance;
};


export interface __HeaderStringValues$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<CLROf<string>>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<CLROf<string>>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type HeaderStringValues = HeaderStringValues$instance & __HeaderStringValues$views;


export interface HeaderStringValues_Enumerator$instance extends IDisposable {
    readonly current: string;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const HeaderStringValues_Enumerator: {
    new(): HeaderStringValues_Enumerator$instance;
};


export interface __HeaderStringValues_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<CLROf<string>>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type HeaderStringValues_Enumerator = HeaderStringValues_Enumerator$instance & __HeaderStringValues_Enumerator$views;


export interface HttpHeadersNonValidated$instance {
    readonly count: int;
    readonly item: HeaderStringValues;
    contains(headerName: string): boolean;
    getEnumerator(): HttpHeadersNonValidated_Enumerator;
    tryGetValues(headerName: string, values: { value: ref<HeaderStringValues> }): boolean;
}


export const HttpHeadersNonValidated: {
    new(): HttpHeadersNonValidated$instance;
};


export interface __HttpHeadersNonValidated$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<CLROf<string>, HeaderStringValues>>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<KeyValuePair_2<CLROf<string>, HeaderStringValues>>;
    As_IReadOnlyDictionary_2(): System_Collections_Generic_Internal.IReadOnlyDictionary_2$instance<CLROf<string>, HeaderStringValues>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type HttpHeadersNonValidated = HttpHeadersNonValidated$instance & __HttpHeadersNonValidated$views;


export interface HttpHeadersNonValidated_Enumerator$instance extends IDisposable {
    readonly current: KeyValuePair_2<CLROf<string>, HeaderStringValues>;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const HttpHeadersNonValidated_Enumerator: {
    new(): HttpHeadersNonValidated_Enumerator$instance;
};


export interface __HttpHeadersNonValidated_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<KeyValuePair_2<CLROf<string>, HeaderStringValues>>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type HttpHeadersNonValidated_Enumerator = HttpHeadersNonValidated_Enumerator$instance & __HttpHeadersNonValidated_Enumerator$views;


export interface AuthenticationHeaderValue$instance {
    readonly parameter: string;
    readonly scheme: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const AuthenticationHeaderValue: {
    new(scheme: string): AuthenticationHeaderValue$instance;
    new(scheme: string, parameter: string): AuthenticationHeaderValue$instance;
    parse(input: string): AuthenticationHeaderValue;
    tryParse(input: string, parsedValue: { value: ref<AuthenticationHeaderValue> }): boolean;
};


export interface __AuthenticationHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface AuthenticationHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type AuthenticationHeaderValue = AuthenticationHeaderValue$instance & __AuthenticationHeaderValue$views;


export interface CacheControlHeaderValue$instance {
    readonly extensions: ICollection_1<NameValueHeaderValue>;
    maxAge: Nullable_1<TimeSpan>;
    maxStale: boolean;
    maxStaleLimit: Nullable_1<TimeSpan>;
    minFresh: Nullable_1<TimeSpan>;
    mustRevalidate: boolean;
    noCache: boolean;
    readonly noCacheHeaders: ICollection_1<CLROf<string>>;
    noStore: boolean;
    noTransform: boolean;
    onlyIfCached: boolean;
    private_: boolean;
    readonly privateHeaders: ICollection_1<CLROf<string>>;
    proxyRevalidate: boolean;
    public_: boolean;
    sharedMaxAge: Nullable_1<TimeSpan>;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const CacheControlHeaderValue: {
    new(): CacheControlHeaderValue$instance;
    parse(input: string): CacheControlHeaderValue;
    tryParse(input: string, parsedValue: { value: ref<CacheControlHeaderValue> }): boolean;
};


export interface __CacheControlHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface CacheControlHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type CacheControlHeaderValue = CacheControlHeaderValue$instance & __CacheControlHeaderValue$views;


export interface ContentDispositionHeaderValue$instance {
    creationDate: Nullable_1<DateTimeOffset>;
    dispositionType: string;
    fileName: string;
    fileNameStar: string;
    modificationDate: Nullable_1<DateTimeOffset>;
    name: string;
    readonly parameters: ICollection_1<NameValueHeaderValue>;
    readDate: Nullable_1<DateTimeOffset>;
    size: Nullable_1<CLROf<long>>;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const ContentDispositionHeaderValue: {
    new(dispositionType: string): ContentDispositionHeaderValue$instance;
    parse(input: string): ContentDispositionHeaderValue;
    tryParse(input: string, parsedValue: { value: ref<ContentDispositionHeaderValue> }): boolean;
};


export interface __ContentDispositionHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface ContentDispositionHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type ContentDispositionHeaderValue = ContentDispositionHeaderValue$instance & __ContentDispositionHeaderValue$views;


export interface ContentRangeHeaderValue$instance {
    readonly from_: Nullable_1<CLROf<long>>;
    readonly hasLength: boolean;
    readonly hasRange: boolean;
    readonly length: Nullable_1<CLROf<long>>;
    readonly to: Nullable_1<CLROf<long>>;
    unit: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const ContentRangeHeaderValue: {
    new(from_: long, to: long, length: long): ContentRangeHeaderValue$instance;
    new(length: long): ContentRangeHeaderValue$instance;
    new(from_: long, to: long): ContentRangeHeaderValue$instance;
    parse(input: string): ContentRangeHeaderValue;
    tryParse(input: string, parsedValue: { value: ref<ContentRangeHeaderValue> }): boolean;
};


export interface __ContentRangeHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface ContentRangeHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type ContentRangeHeaderValue = ContentRangeHeaderValue$instance & __ContentRangeHeaderValue$views;


export interface EntityTagHeaderValue$instance {
    readonly isWeak: boolean;
    readonly tag: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const EntityTagHeaderValue: {
    new(tag: string): EntityTagHeaderValue$instance;
    new(tag: string, isWeak: boolean): EntityTagHeaderValue$instance;
    readonly any_: EntityTagHeaderValue;
    parse(input: string): EntityTagHeaderValue;
    tryParse(input: string, parsedValue: { value: ref<EntityTagHeaderValue> }): boolean;
};


export interface __EntityTagHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface EntityTagHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type EntityTagHeaderValue = EntityTagHeaderValue$instance & __EntityTagHeaderValue$views;


export interface HttpContentHeaders$instance extends HttpHeaders$instance {
    readonly allow: ICollection_1<CLROf<string>>;
    contentDisposition: ContentDispositionHeaderValue;
    readonly contentEncoding: ICollection_1<CLROf<string>>;
    readonly contentLanguage: ICollection_1<CLROf<string>>;
    contentLength: Nullable_1<CLROf<long>>;
    contentLocation: Uri;
    contentMD5: byte[];
    contentRange: ContentRangeHeaderValue;
    contentType: MediaTypeHeaderValue;
    expires: Nullable_1<DateTimeOffset>;
    lastModified: Nullable_1<DateTimeOffset>;
    getEnumerator(): IEnumerator_1<KeyValuePair_2<CLROf<string>, IEnumerable_1<CLROf<string>>>>;
    getEnumerator(): IEnumerator;
}


export const HttpContentHeaders: {
    new(): HttpContentHeaders$instance;
};


export interface __HttpContentHeaders$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<CLROf<string>, IEnumerable_1<CLROf<string>>>>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type HttpContentHeaders = HttpContentHeaders$instance & __HttpContentHeaders$views;


export interface HttpHeaders$instance {
    readonly nonValidated: HttpHeadersNonValidated;
    add(name: string, value: string): void;
    add(name: string, values: IEnumerable_1<CLROf<string>>): void;
    clear(): void;
    contains(name: string): boolean;
    getEnumerator(): IEnumerator_1<KeyValuePair_2<CLROf<string>, IEnumerable_1<CLROf<string>>>>;
    getValues(name: string): IEnumerable_1<CLROf<string>>;
    remove(name: string): boolean;
    toString(): string;
    tryAddWithoutValidation(name: string, value: string): boolean;
    tryAddWithoutValidation(name: string, values: IEnumerable_1<CLROf<string>>): boolean;
    tryGetValues(name: string, values: { value: ref<IEnumerable_1<CLROf<string>>> }): boolean;
}


export const HttpHeaders: {
};


export interface __HttpHeaders$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<CLROf<string>, IEnumerable_1<CLROf<string>>>>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type HttpHeaders = HttpHeaders$instance & __HttpHeaders$views;


export interface HttpHeaderValueCollection_1$instance<T> {
    readonly count: int;
    readonly isReadOnly: boolean;
    add(item: T): void;
    clear(): void;
    contains(item: T): boolean;
    copyTo(array: T[], arrayIndex: int): void;
    getEnumerator(): IEnumerator_1<T>;
    parseAdd(input: string): void;
    remove(item: T): boolean;
    toString(): string;
    tryParseAdd(input: string): boolean;
}


export const HttpHeaderValueCollection_1: {
    new<T>(): HttpHeaderValueCollection_1$instance<T>;
};


export interface __HttpHeaderValueCollection_1$views<T> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type HttpHeaderValueCollection_1<T> = HttpHeaderValueCollection_1$instance<T> & __HttpHeaderValueCollection_1$views<T>;


export interface HttpRequestHeaders$instance extends HttpHeaders$instance {
    readonly accept: HttpHeaderValueCollection_1<MediaTypeWithQualityHeaderValue>;
    readonly acceptCharset: HttpHeaderValueCollection_1<StringWithQualityHeaderValue>;
    readonly acceptEncoding: HttpHeaderValueCollection_1<StringWithQualityHeaderValue>;
    readonly acceptLanguage: HttpHeaderValueCollection_1<StringWithQualityHeaderValue>;
    authorization: AuthenticationHeaderValue;
    cacheControl: CacheControlHeaderValue;
    readonly connection: HttpHeaderValueCollection_1<CLROf<string>>;
    connectionClose: Nullable_1<CLROf<boolean>>;
    date: Nullable_1<DateTimeOffset>;
    readonly expect: HttpHeaderValueCollection_1<NameValueWithParametersHeaderValue>;
    expectContinue: Nullable_1<CLROf<boolean>>;
    from_: string;
    host: string;
    readonly ifMatch: HttpHeaderValueCollection_1<EntityTagHeaderValue>;
    ifModifiedSince: Nullable_1<DateTimeOffset>;
    readonly ifNoneMatch: HttpHeaderValueCollection_1<EntityTagHeaderValue>;
    ifRange: RangeConditionHeaderValue;
    ifUnmodifiedSince: Nullable_1<DateTimeOffset>;
    maxForwards: Nullable_1<CLROf<int>>;
    readonly pragma: HttpHeaderValueCollection_1<NameValueHeaderValue>;
    protocol: string;
    proxyAuthorization: AuthenticationHeaderValue;
    range: RangeHeaderValue;
    referrer: Uri;
    readonly TE: HttpHeaderValueCollection_1<TransferCodingWithQualityHeaderValue>;
    readonly trailer: HttpHeaderValueCollection_1<CLROf<string>>;
    readonly transferEncoding: HttpHeaderValueCollection_1<TransferCodingHeaderValue>;
    transferEncodingChunked: Nullable_1<CLROf<boolean>>;
    readonly upgrade: HttpHeaderValueCollection_1<ProductHeaderValue>;
    readonly userAgent: HttpHeaderValueCollection_1<ProductInfoHeaderValue>;
    readonly via: HttpHeaderValueCollection_1<ViaHeaderValue>;
    readonly warning: HttpHeaderValueCollection_1<WarningHeaderValue>;
    getEnumerator(): IEnumerator_1<KeyValuePair_2<CLROf<string>, IEnumerable_1<CLROf<string>>>>;
    getEnumerator(): IEnumerator;
}


export const HttpRequestHeaders: {
    new(): HttpRequestHeaders$instance;
};


export interface __HttpRequestHeaders$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<CLROf<string>, IEnumerable_1<CLROf<string>>>>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type HttpRequestHeaders = HttpRequestHeaders$instance & __HttpRequestHeaders$views;


export interface HttpResponseHeaders$instance extends HttpHeaders$instance {
    readonly acceptRanges: HttpHeaderValueCollection_1<CLROf<string>>;
    age: Nullable_1<TimeSpan>;
    cacheControl: CacheControlHeaderValue;
    readonly connection: HttpHeaderValueCollection_1<CLROf<string>>;
    connectionClose: Nullable_1<CLROf<boolean>>;
    date: Nullable_1<DateTimeOffset>;
    eTag: EntityTagHeaderValue;
    location: Uri;
    readonly pragma: HttpHeaderValueCollection_1<NameValueHeaderValue>;
    readonly proxyAuthenticate: HttpHeaderValueCollection_1<AuthenticationHeaderValue>;
    retryAfter: RetryConditionHeaderValue;
    readonly server: HttpHeaderValueCollection_1<ProductInfoHeaderValue>;
    readonly trailer: HttpHeaderValueCollection_1<CLROf<string>>;
    readonly transferEncoding: HttpHeaderValueCollection_1<TransferCodingHeaderValue>;
    transferEncodingChunked: Nullable_1<CLROf<boolean>>;
    readonly upgrade: HttpHeaderValueCollection_1<ProductHeaderValue>;
    readonly vary: HttpHeaderValueCollection_1<CLROf<string>>;
    readonly via: HttpHeaderValueCollection_1<ViaHeaderValue>;
    readonly warning: HttpHeaderValueCollection_1<WarningHeaderValue>;
    readonly wwwAuthenticate: HttpHeaderValueCollection_1<AuthenticationHeaderValue>;
    getEnumerator(): IEnumerator_1<KeyValuePair_2<CLROf<string>, IEnumerable_1<CLROf<string>>>>;
    getEnumerator(): IEnumerator;
}


export const HttpResponseHeaders: {
    new(): HttpResponseHeaders$instance;
};


export interface __HttpResponseHeaders$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<CLROf<string>, IEnumerable_1<CLROf<string>>>>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type HttpResponseHeaders = HttpResponseHeaders$instance & __HttpResponseHeaders$views;


export interface MediaTypeHeaderValue$instance {
    charSet: string;
    mediaType: string;
    readonly parameters: ICollection_1<NameValueHeaderValue>;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const MediaTypeHeaderValue: {
    new(mediaType: string): MediaTypeHeaderValue$instance;
    new(mediaType: string, charSet: string): MediaTypeHeaderValue$instance;
    parse(input: string): MediaTypeHeaderValue;
    tryParse(input: string, parsedValue: { value: ref<MediaTypeHeaderValue> }): boolean;
};


export interface __MediaTypeHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface MediaTypeHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type MediaTypeHeaderValue = MediaTypeHeaderValue$instance & __MediaTypeHeaderValue$views;


export interface MediaTypeWithQualityHeaderValue$instance extends MediaTypeHeaderValue$instance {
    quality: Nullable_1<CLROf<double>>;
    clone(): unknown;
}


export const MediaTypeWithQualityHeaderValue: {
    new(mediaType: string): MediaTypeWithQualityHeaderValue$instance;
    new(mediaType: string, quality: double): MediaTypeWithQualityHeaderValue$instance;
};


export interface __MediaTypeWithQualityHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface MediaTypeWithQualityHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type MediaTypeWithQualityHeaderValue = MediaTypeWithQualityHeaderValue$instance & __MediaTypeWithQualityHeaderValue$views;


export interface NameValueHeaderValue$instance {
    readonly name: string;
    value: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const NameValueHeaderValue: {
    new(name: string): NameValueHeaderValue$instance;
    new(name: string, value: string): NameValueHeaderValue$instance;
    parse(input: string): NameValueHeaderValue;
    tryParse(input: string, parsedValue: { value: ref<NameValueHeaderValue> }): boolean;
};


export interface __NameValueHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface NameValueHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type NameValueHeaderValue = NameValueHeaderValue$instance & __NameValueHeaderValue$views;


export interface NameValueWithParametersHeaderValue$instance extends NameValueHeaderValue$instance {
    readonly parameters: ICollection_1<NameValueHeaderValue>;
    clone(): unknown;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const NameValueWithParametersHeaderValue: {
    new(name: string): NameValueWithParametersHeaderValue$instance;
    new(name: string, value: string): NameValueWithParametersHeaderValue$instance;
};


export interface __NameValueWithParametersHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface NameValueWithParametersHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type NameValueWithParametersHeaderValue = NameValueWithParametersHeaderValue$instance & __NameValueWithParametersHeaderValue$views;


export interface ProductHeaderValue$instance {
    readonly name: string;
    readonly version: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const ProductHeaderValue: {
    new(name: string): ProductHeaderValue$instance;
    new(name: string, version: string): ProductHeaderValue$instance;
    parse(input: string): ProductHeaderValue;
    tryParse(input: string, parsedValue: { value: ref<ProductHeaderValue> }): boolean;
};


export interface __ProductHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface ProductHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type ProductHeaderValue = ProductHeaderValue$instance & __ProductHeaderValue$views;


export interface ProductInfoHeaderValue$instance {
    readonly comment: string;
    readonly product: ProductHeaderValue;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const ProductInfoHeaderValue: {
    new(productName: string, productVersion: string): ProductInfoHeaderValue$instance;
    new(product: ProductHeaderValue): ProductInfoHeaderValue$instance;
    new(comment: string): ProductInfoHeaderValue$instance;
    parse(input: string): ProductInfoHeaderValue;
    tryParse(input: string, parsedValue: { value: ref<ProductInfoHeaderValue> }): boolean;
};


export interface __ProductInfoHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface ProductInfoHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type ProductInfoHeaderValue = ProductInfoHeaderValue$instance & __ProductInfoHeaderValue$views;


export interface RangeConditionHeaderValue$instance {
    readonly date: Nullable_1<DateTimeOffset>;
    readonly entityTag: EntityTagHeaderValue;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RangeConditionHeaderValue: {
    new(date: DateTimeOffset): RangeConditionHeaderValue$instance;
    new(entityTag: EntityTagHeaderValue): RangeConditionHeaderValue$instance;
    new(entityTag: string): RangeConditionHeaderValue$instance;
    parse(input: string): RangeConditionHeaderValue;
    tryParse(input: string, parsedValue: { value: ref<RangeConditionHeaderValue> }): boolean;
};


export interface __RangeConditionHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface RangeConditionHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type RangeConditionHeaderValue = RangeConditionHeaderValue$instance & __RangeConditionHeaderValue$views;


export interface RangeHeaderValue$instance {
    readonly ranges: ICollection_1<RangeItemHeaderValue>;
    unit: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RangeHeaderValue: {
    new(): RangeHeaderValue$instance;
    new(from_: Nullable_1<CLROf<long>>, to: Nullable_1<CLROf<long>>): RangeHeaderValue$instance;
    parse(input: string): RangeHeaderValue;
    tryParse(input: string, parsedValue: { value: ref<RangeHeaderValue> }): boolean;
};


export interface __RangeHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface RangeHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type RangeHeaderValue = RangeHeaderValue$instance & __RangeHeaderValue$views;


export interface RangeItemHeaderValue$instance {
    readonly from_: Nullable_1<CLROf<long>>;
    readonly to: Nullable_1<CLROf<long>>;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RangeItemHeaderValue: {
    new(from_: Nullable_1<CLROf<long>>, to: Nullable_1<CLROf<long>>): RangeItemHeaderValue$instance;
};


export interface __RangeItemHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface RangeItemHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type RangeItemHeaderValue = RangeItemHeaderValue$instance & __RangeItemHeaderValue$views;


export interface RetryConditionHeaderValue$instance {
    readonly date: Nullable_1<DateTimeOffset>;
    readonly delta: Nullable_1<TimeSpan>;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RetryConditionHeaderValue: {
    new(date: DateTimeOffset): RetryConditionHeaderValue$instance;
    new(delta: TimeSpan): RetryConditionHeaderValue$instance;
    parse(input: string): RetryConditionHeaderValue;
    tryParse(input: string, parsedValue: { value: ref<RetryConditionHeaderValue> }): boolean;
};


export interface __RetryConditionHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface RetryConditionHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type RetryConditionHeaderValue = RetryConditionHeaderValue$instance & __RetryConditionHeaderValue$views;


export interface StringWithQualityHeaderValue$instance {
    readonly quality: Nullable_1<CLROf<double>>;
    readonly value: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const StringWithQualityHeaderValue: {
    new(value: string): StringWithQualityHeaderValue$instance;
    new(value: string, quality: double): StringWithQualityHeaderValue$instance;
    parse(input: string): StringWithQualityHeaderValue;
    tryParse(input: string, parsedValue: { value: ref<StringWithQualityHeaderValue> }): boolean;
};


export interface __StringWithQualityHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface StringWithQualityHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type StringWithQualityHeaderValue = StringWithQualityHeaderValue$instance & __StringWithQualityHeaderValue$views;


export interface TransferCodingHeaderValue$instance {
    readonly parameters: ICollection_1<NameValueHeaderValue>;
    readonly value: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const TransferCodingHeaderValue: {
    new(value: string): TransferCodingHeaderValue$instance;
    parse(input: string): TransferCodingHeaderValue;
    tryParse(input: string, parsedValue: { value: ref<TransferCodingHeaderValue> }): boolean;
};


export interface __TransferCodingHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface TransferCodingHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type TransferCodingHeaderValue = TransferCodingHeaderValue$instance & __TransferCodingHeaderValue$views;


export interface TransferCodingWithQualityHeaderValue$instance extends TransferCodingHeaderValue$instance {
    quality: Nullable_1<CLROf<double>>;
    clone(): unknown;
}


export const TransferCodingWithQualityHeaderValue: {
    new(value: string): TransferCodingWithQualityHeaderValue$instance;
    new(value: string, quality: double): TransferCodingWithQualityHeaderValue$instance;
};


export interface __TransferCodingWithQualityHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface TransferCodingWithQualityHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type TransferCodingWithQualityHeaderValue = TransferCodingWithQualityHeaderValue$instance & __TransferCodingWithQualityHeaderValue$views;


export interface ViaHeaderValue$instance {
    readonly comment: string;
    readonly protocolName: string;
    readonly protocolVersion: string;
    readonly receivedBy: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const ViaHeaderValue: {
    new(protocolVersion: string, receivedBy: string): ViaHeaderValue$instance;
    new(protocolVersion: string, receivedBy: string, protocolName: string): ViaHeaderValue$instance;
    new(protocolVersion: string, receivedBy: string, protocolName: string, comment: string): ViaHeaderValue$instance;
    parse(input: string): ViaHeaderValue;
    tryParse(input: string, parsedValue: { value: ref<ViaHeaderValue> }): boolean;
};


export interface __ViaHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface ViaHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type ViaHeaderValue = ViaHeaderValue$instance & __ViaHeaderValue$views;


export interface WarningHeaderValue$instance {
    readonly agent: string;
    readonly code: int;
    readonly date: Nullable_1<DateTimeOffset>;
    readonly text: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const WarningHeaderValue: {
    new(code: int, agent: string, text: string): WarningHeaderValue$instance;
    new(code: int, agent: string, text: string, date: DateTimeOffset): WarningHeaderValue$instance;
    parse(input: string): WarningHeaderValue;
    tryParse(input: string, parsedValue: { value: ref<WarningHeaderValue> }): boolean;
};


export interface __WarningHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface WarningHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type WarningHeaderValue = WarningHeaderValue$instance & __WarningHeaderValue$views;


