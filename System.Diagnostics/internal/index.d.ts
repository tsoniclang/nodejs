// Generated by tsbindgen - Architecture
// Namespace: System.Diagnostics
// Assembly: System.Diagnostics.DiagnosticSource, System.Diagnostics.FileVersionInfo, System.Diagnostics.Process, System.Diagnostics.TextWriterTraceListener, System.Diagnostics.TraceSource, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { SafeProcessHandle } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IDictionary_2, IEnumerable_1, IEnumerator_1, IList_1, IReadOnlyCollection_1, IReadOnlyList_1, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import type { Collection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import type { StringDictionary } from "../../System.Collections.Specialized/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IEnumerable, IEnumerator, IList, ReadOnlyCollectionBase, Stack } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { Component, DescriptionAttribute, IComponent, IContainer, ISite, ISynchronizeInvoke } from "../../System.ComponentModel/internal/index.js";
import type { Stream, StreamReader, StreamWriter, TextWriter } from "../../System.IO/internal/index.js";
import type { Assembly, MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { SecureString } from "../../System.Security/internal/index.js";
import type { Encoding } from "../../System.Text/internal/index.js";
import type { Task } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Action_2, Array as ClrArray, AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Char, DateTime, DateTimeOffset, Delegate, Enum, EventArgs, EventHandler, EventHandler_1, Exception, Func_1, Func_2, Func_4, Guid, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int32, Int64, IntPtr, IObservable_1, IObserver_1, ISpanFormattable, MarshalByRefObject, MulticastDelegate, Object as ClrObject, Predicate_1, ReadOnlySpan_1, Span_1, String as ClrString, TimeSpan, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum ActivityIdFormat {
    unknown_ = 0,
    hierarchical = 1,
    W3C = 2
}


export enum ActivityKind {
    internal = 0,
    server = 1,
    client = 2,
    producer = 3,
    consumer = 4
}


export enum ActivitySamplingResult {
    none = 0,
    propagationData = 1,
    allData = 2,
    allDataAndRecorded = 3
}


export enum ActivityStatusCode {
    unset = 0,
    ok = 1,
    error = 2
}


export enum ActivityTraceFlags {
    none = 0,
    recorded = 1
}


export enum DebuggableAttribute_DebuggingModes {
    none = 0,
    default_ = 1,
    disableOptimizations = 256,
    ignoreSymbolStoreSequencePoints = 2,
    enableEditAndContinue = 4
}


export enum DebuggerBrowsableState {
    never_ = 0,
    collapsed = 2,
    rootHidden = 3
}


export enum ProcessPriorityClass {
    normal = 32,
    idle = 64,
    high = 128,
    realTime = 256,
    belowNormal = 16384,
    aboveNormal = 32768
}


export enum ProcessWindowStyle {
    normal = 0,
    hidden = 1,
    minimized = 2,
    maximized = 3
}


export enum SourceLevels {
    off = 0,
    critical = 1,
    error = 3,
    warning = 7,
    information = 15,
    verbose = 31,
    activityTracing = 65280,
    all = -1
}


export enum ThreadPriorityLevel {
    idle = -15,
    lowest = -2,
    belowNormal = -1,
    normal = 0,
    aboveNormal = 1,
    highest = 2,
    timeCritical = 15
}


export enum ThreadState {
    initialized = 0,
    ready = 1,
    running = 2,
    standby = 3,
    terminated = 4,
    wait = 5,
    transition = 6,
    unknown_ = 7
}


export enum ThreadWaitReason {
    executive = 0,
    freePage = 1,
    pageIn = 2,
    systemAllocation = 3,
    executionDelay = 4,
    suspended = 5,
    userRequest = 6,
    eventPairHigh = 7,
    eventPairLow = 8,
    lpcReceive = 9,
    lpcReply = 10,
    virtualMemory = 11,
    pageOut = 12,
    unknown_ = 13
}


export enum TraceEventType {
    critical = 1,
    error = 2,
    warning = 4,
    information = 8,
    verbose = 16,
    start = 256,
    stop = 512,
    suspend = 1024,
    resume = 2048,
    transfer = 4096
}


export enum TraceLevel {
    off = 0,
    error = 1,
    warning = 2,
    info = 3,
    verbose = 4
}


export enum TraceOptions {
    none = 0,
    logicalOperationStack = 1,
    dateTime = 2,
    timestamp = 4,
    processId = 8,
    threadId = 16,
    callstack = 32
}


export type DataReceivedEventHandler = (sender: unknown, e: DataReceivedEventArgs) => void;


export type DistributedContextPropagator_PropagatorGetterCallback = (carrier: unknown, fieldName: string, fieldValue: ref<string>, fieldValues: ref<IEnumerable_1<CLROf<string>>>) => void;


export type DistributedContextPropagator_PropagatorSetterCallback = (carrier: unknown, fieldName: string, fieldValue: string) => void;


export type ExceptionRecorder = (activity: Activity, exception: Exception, tags: ref<TagList>) => void;


export type SampleActivity_1<T> = (options: ref<ActivityCreationOptions_1<T>>) => ActivitySamplingResult;


export interface Activity_Enumerator_1$instance<T> {
    readonly current: ref<T>;
    getEnumerator(): Activity_Enumerator_1<T>;
    moveNext(): boolean;
}


export const Activity_Enumerator_1: {
    new<T>(): Activity_Enumerator_1$instance<T>;
};


export type Activity_Enumerator_1<T> = Activity_Enumerator_1$instance<T>;

export interface ActivityChangedEventArgs$instance {
    current: Activity;
    previous: Activity;
}


export const ActivityChangedEventArgs: {
    new(): ActivityChangedEventArgs$instance;
};


export type ActivityChangedEventArgs = ActivityChangedEventArgs$instance;

export interface ActivityContext$instance {
    readonly isRemote: boolean;
    readonly spanId: ActivitySpanId;
    readonly traceFlags: ActivityTraceFlags;
    readonly traceId: ActivityTraceId;
    readonly traceState: string;
    equals(value: ActivityContext): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const ActivityContext: {
    new(traceId: ActivityTraceId, spanId: ActivitySpanId, traceFlags: ActivityTraceFlags, traceState: string, isRemote: boolean): ActivityContext$instance;
    parse(traceParent: string, traceState: string): ActivityContext;
    tryParse(traceParent: string, traceState: string, isRemote: boolean, context: { value: ref<ActivityContext> }): boolean;
    tryParse(traceParent: string, traceState: string, context: { value: ref<ActivityContext> }): boolean;
};


export interface __ActivityContext$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<ActivityContext>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ActivityContext): boolean;
}

export type ActivityContext = ActivityContext$instance & __ActivityContext$views;


export interface ActivityCreationOptions_1$instance<T> {
    readonly kind: ActivityKind;
    readonly links: IEnumerable_1<ActivityLink>;
    readonly name: string;
    readonly parent: T;
    readonly samplingTags: ActivityTagsCollection;
    readonly source: ActivitySource;
    readonly tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>;
    readonly traceId: ActivityTraceId;
    traceState: string;
}


export const ActivityCreationOptions_1: {
    new<T>(): ActivityCreationOptions_1$instance<T>;
};


export type ActivityCreationOptions_1<T> = ActivityCreationOptions_1$instance<T>;

export interface ActivityEvent$instance {
    readonly name: string;
    readonly tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>;
    readonly timestamp: DateTimeOffset;
    enumerateTagObjects(): Activity_Enumerator_1<KeyValuePair_2<CLROf<string>, unknown>>;
}


export const ActivityEvent: {
    new(name: string): ActivityEvent$instance;
    new(name: string, timestamp: DateTimeOffset, tags: ActivityTagsCollection): ActivityEvent$instance;
};


export type ActivityEvent = ActivityEvent$instance;

export interface ActivityLink$instance {
    readonly context: ActivityContext;
    readonly tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>;
    enumerateTagObjects(): Activity_Enumerator_1<KeyValuePair_2<CLROf<string>, unknown>>;
    equals(obj: unknown): boolean;
    equals(value: ActivityLink): boolean;
    getHashCode(): int;
}


export const ActivityLink: {
    new(context: ActivityContext, tags: ActivityTagsCollection): ActivityLink$instance;
};


export interface __ActivityLink$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<ActivityLink>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ActivityLink): boolean;
}

export type ActivityLink = ActivityLink$instance & __ActivityLink$views;


export interface ActivitySpanId$instance {
    copyTo(destination: Span_1<CLROf<byte>>): void;
    equals(spanId: ActivitySpanId): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toHexString(): string;
    toString(): string;
}


export const ActivitySpanId: {
    new(): ActivitySpanId$instance;
    createFromBytes(idData: ReadOnlySpan_1<CLROf<byte>>): ActivitySpanId;
    createFromString(idData: ReadOnlySpan_1<CLROf<char>>): ActivitySpanId;
    createFromUtf8String(idData: ReadOnlySpan_1<CLROf<byte>>): ActivitySpanId;
    createRandom(): ActivitySpanId;
};


export interface __ActivitySpanId$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<ActivitySpanId>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ActivitySpanId): boolean;
}

export type ActivitySpanId = ActivitySpanId$instance & __ActivitySpanId$views;


export interface ActivityTagsCollection_Enumerator$instance extends IDisposable {
    readonly current: KeyValuePair_2<CLROf<string>, unknown>;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const ActivityTagsCollection_Enumerator: {
    new(): ActivityTagsCollection_Enumerator$instance;
};


export interface __ActivityTagsCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<KeyValuePair_2<CLROf<string>, unknown>>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type ActivityTagsCollection_Enumerator = ActivityTagsCollection_Enumerator$instance & __ActivityTagsCollection_Enumerator$views;


export interface ActivityTraceId$instance {
    copyTo(destination: Span_1<CLROf<byte>>): void;
    equals(traceId: ActivityTraceId): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toHexString(): string;
    toString(): string;
}


export const ActivityTraceId: {
    new(): ActivityTraceId$instance;
    createFromBytes(idData: ReadOnlySpan_1<CLROf<byte>>): ActivityTraceId;
    createFromString(idData: ReadOnlySpan_1<CLROf<char>>): ActivityTraceId;
    createFromUtf8String(idData: ReadOnlySpan_1<CLROf<byte>>): ActivityTraceId;
    createRandom(): ActivityTraceId;
};


export interface __ActivityTraceId$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<ActivityTraceId>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ActivityTraceId): boolean;
}

export type ActivityTraceId = ActivityTraceId$instance & __ActivityTraceId$views;


export interface Debug_AssertInterpolatedStringHandler$instance {
    appendFormatted<T>(value: T): void;
    appendFormatted<T>(value: T, format: string): void;
    appendFormatted<T>(value: T, alignment: int): void;
    appendFormatted<T>(value: T, alignment: int, format: string): void;
    appendFormatted(value: ReadOnlySpan_1<CLROf<char>>): void;
    appendFormatted(value: ReadOnlySpan_1<CLROf<char>>, alignment?: int, format?: string): void;
    appendFormatted(value: string): void;
    appendFormatted(value: string, alignment?: int, format?: string): void;
    appendFormatted(value: unknown, alignment?: int, format?: string): void;
    appendLiteral(value: string): void;
}


export const Debug_AssertInterpolatedStringHandler: {
    new(literalLength: int, formattedCount: int, condition: boolean, shouldAppend: ref<boolean>): Debug_AssertInterpolatedStringHandler$instance;
};


export type Debug_AssertInterpolatedStringHandler = Debug_AssertInterpolatedStringHandler$instance;

export interface Debug_WriteIfInterpolatedStringHandler$instance {
    appendFormatted<T>(value: T): void;
    appendFormatted<T>(value: T, format: string): void;
    appendFormatted<T>(value: T, alignment: int): void;
    appendFormatted<T>(value: T, alignment: int, format: string): void;
    appendFormatted(value: ReadOnlySpan_1<CLROf<char>>): void;
    appendFormatted(value: ReadOnlySpan_1<CLROf<char>>, alignment?: int, format?: string): void;
    appendFormatted(value: string): void;
    appendFormatted(value: string, alignment?: int, format?: string): void;
    appendFormatted(value: unknown, alignment?: int, format?: string): void;
    appendLiteral(value: string): void;
}


export const Debug_WriteIfInterpolatedStringHandler: {
    new(literalLength: int, formattedCount: int, condition: boolean, shouldAppend: ref<boolean>): Debug_WriteIfInterpolatedStringHandler$instance;
};


export type Debug_WriteIfInterpolatedStringHandler = Debug_WriteIfInterpolatedStringHandler$instance;

export interface TagList$instance {
    readonly count: int;
    readonly isReadOnly: boolean;
    item: KeyValuePair_2<CLROf<string>, unknown>;
    add(key: string, value: unknown): void;
    add(tag: KeyValuePair_2<CLROf<string>, unknown>): void;
    clear(): void;
    contains(item: KeyValuePair_2<CLROf<string>, unknown>): boolean;
    copyTo(tags: Span_1<KeyValuePair_2<CLROf<string>, unknown>>): void;
    copyTo(array: KeyValuePair_2<CLROf<string>, unknown>[], arrayIndex: int): void;
    getEnumerator(): IEnumerator_1<KeyValuePair_2<CLROf<string>, unknown>>;
    indexOf(item: KeyValuePair_2<CLROf<string>, unknown>): int;
    insert(index: int, item: KeyValuePair_2<CLROf<string>, unknown>): void;
    remove(item: KeyValuePair_2<CLROf<string>, unknown>): boolean;
    removeAt(index: int): void;
}


export const TagList: {
    new(tagList: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, unknown>>): TagList$instance;
};


export interface __TagList$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<CLROf<string>, unknown>>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<CLROf<string>, unknown>>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<KeyValuePair_2<CLROf<string>, unknown>>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<KeyValuePair_2<CLROf<string>, unknown>>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type TagList = TagList$instance & __TagList$views;


export interface TagList_Enumerator$instance extends IDisposable {
    readonly current: KeyValuePair_2<CLROf<string>, unknown>;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const TagList_Enumerator: {
    new(): TagList_Enumerator$instance;
};


export interface __TagList_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<KeyValuePair_2<CLROf<string>, unknown>>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type TagList_Enumerator = TagList_Enumerator$instance & __TagList_Enumerator$views;


export interface Activity$instance {
    activityTraceFlags: ActivityTraceFlags;
    readonly baggage: IEnumerable_1<KeyValuePair_2<CLROf<string>, CLROf<string>>>;
    readonly context: ActivityContext;
    displayName: string;
    readonly duration: TimeSpan;
    readonly events: IEnumerable_1<ActivityEvent>;
    readonly hasRemoteParent: boolean;
    readonly id: string;
    readonly idFormat: ActivityIdFormat;
    isAllDataRequested: boolean;
    readonly isStopped: boolean;
    readonly kind: ActivityKind;
    readonly links: IEnumerable_1<ActivityLink>;
    readonly operationName: string;
    readonly parent: Activity;
    readonly parentId: string;
    readonly parentSpanId: ActivitySpanId;
    readonly recorded: boolean;
    readonly rootId: string;
    readonly source: ActivitySource;
    readonly spanId: ActivitySpanId;
    readonly startTimeUtc: DateTime;
    readonly status: ActivityStatusCode;
    readonly statusDescription: string;
    readonly tagObjects: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>;
    readonly tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, CLROf<string>>>;
    readonly traceId: ActivityTraceId;
    traceStateString: string;
    addBaggage(key: string, value: string): Activity;
    addEvent(e: ActivityEvent): Activity;
    addException(exception: Exception, tags?: { value: ref<TagList> }, timestamp?: DateTimeOffset): Activity;
    addLink(link: ActivityLink): Activity;
    addTag(key: string, value: string): Activity;
    addTag(key: string, value: unknown): Activity;
    dispose(): void;
    enumerateEvents(): Activity_Enumerator_1<ActivityEvent>;
    enumerateLinks(): Activity_Enumerator_1<ActivityLink>;
    enumerateTagObjects(): Activity_Enumerator_1<KeyValuePair_2<CLROf<string>, unknown>>;
    getBaggageItem(key: string): string;
    getCustomProperty(propertyName: string): unknown;
    getTagItem(key: string): unknown;
    setBaggage(key: string, value: string): Activity;
    setCustomProperty(propertyName: string, propertyValue: unknown): void;
    setEndTime(endTimeUtc: DateTime): Activity;
    setIdFormat(format: ActivityIdFormat): Activity;
    setParentId(parentId: string): Activity;
    setParentId(traceId: ActivityTraceId, spanId: ActivitySpanId, activityTraceFlags?: ActivityTraceFlags): Activity;
    setStartTime(startTimeUtc: DateTime): Activity;
    setStatus(code: ActivityStatusCode, description?: string): Activity;
    setTag(key: string, value: unknown): Activity;
    start(): Activity;
    stop(): void;
}


export const Activity: {
    new(operationName: string): Activity$instance;
    forceDefaultIdFormat: boolean;
    current: Activity;
    traceIdGenerator: Func_1<ActivityTraceId>;
    defaultIdFormat: ActivityIdFormat;
};


export interface __Activity$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Activity$instance extends System_Internal.IDisposable$instance {}

export type Activity = Activity$instance & __Activity$views;


export interface ActivityListener$instance {
    activityStarted: Action_1<Activity>;
    activityStopped: Action_1<Activity>;
    exceptionRecorder: ExceptionRecorder;
    sample: SampleActivity_1<ActivityContext>;
    sampleUsingParentId: SampleActivity_1<CLROf<string>>;
    shouldListenTo: Func_2<ActivitySource, CLROf<boolean>>;
    dispose(): void;
}


export const ActivityListener: {
    new(): ActivityListener$instance;
};


export interface __ActivityListener$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ActivityListener$instance extends System_Internal.IDisposable$instance {}

export type ActivityListener = ActivityListener$instance & __ActivityListener$views;


export interface ActivitySource$instance {
    readonly name: string;
    readonly tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>;
    readonly telemetrySchemaUrl: string;
    readonly version: string;
    createActivity(name: string, kind: ActivityKind): Activity;
    createActivity(name: string, kind: ActivityKind, parentContext: ActivityContext, tags?: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>, links?: IEnumerable_1<ActivityLink>, idFormat?: ActivityIdFormat): Activity;
    createActivity(name: string, kind: ActivityKind, parentId: string, tags?: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>, links?: IEnumerable_1<ActivityLink>, idFormat?: ActivityIdFormat): Activity;
    dispose(): void;
    hasListeners(): boolean;
    startActivity(name?: string, kind?: ActivityKind): Activity;
    startActivity(name: string, kind: ActivityKind, parentContext: ActivityContext, tags?: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>, links?: IEnumerable_1<ActivityLink>, startTime?: DateTimeOffset): Activity;
    startActivity(name: string, kind: ActivityKind, parentId: string, tags?: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>, links?: IEnumerable_1<ActivityLink>, startTime?: DateTimeOffset): Activity;
    startActivity(kind: ActivityKind, parentContext?: ActivityContext, tags?: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>, links?: IEnumerable_1<ActivityLink>, startTime?: DateTimeOffset, name?: string): Activity;
}


export const ActivitySource: {
    new(name: string): ActivitySource$instance;
    new(name: string, version: string): ActivitySource$instance;
    new(name: string, version: string, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>): ActivitySource$instance;
    new(options: ActivitySourceOptions): ActivitySource$instance;
    addActivityListener(listener: ActivityListener): void;
};


export interface __ActivitySource$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ActivitySource$instance extends System_Internal.IDisposable$instance {}

export type ActivitySource = ActivitySource$instance & __ActivitySource$views;


export interface ActivitySourceOptions$instance {
    name: string;
    tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>;
    telemetrySchemaUrl: string;
    version: string;
}


export const ActivitySourceOptions: {
    new(name: string): ActivitySourceOptions$instance;
};


export type ActivitySourceOptions = ActivitySourceOptions$instance;

export interface ActivityTagsCollection$instance {
    readonly count: int;
    readonly isReadOnly: boolean;
    item: unknown;
    readonly keys: ICollection_1<CLROf<string>>;
    readonly values: ICollection_1<unknown>;
    add(key: string, value: unknown): void;
    add(item: KeyValuePair_2<CLROf<string>, unknown>): void;
    clear(): void;
    contains(item: KeyValuePair_2<CLROf<string>, unknown>): boolean;
    containsKey(key: string): boolean;
    copyTo(array: KeyValuePair_2<CLROf<string>, unknown>[], arrayIndex: int): void;
    getEnumerator(): ActivityTagsCollection_Enumerator;
    remove(key: string): boolean;
    remove(item: KeyValuePair_2<CLROf<string>, unknown>): boolean;
    tryGetValue(key: string, value: { value: ref<unknown> }): boolean;
}


export const ActivityTagsCollection: {
    new(): ActivityTagsCollection$instance;
    new(list: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>): ActivityTagsCollection$instance;
};


export interface __ActivityTagsCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<CLROf<string>, unknown>>;
    As_IDictionary_2(): System_Collections_Generic_Internal.IDictionary_2$instance<CLROf<string>, unknown>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<CLROf<string>, unknown>>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ActivityTagsCollection = ActivityTagsCollection$instance & __ActivityTagsCollection$views;


export interface BooleanSwitch$instance extends Switch {
    enabled: boolean;
}


export const BooleanSwitch: {
    new(displayName: string, description: string): BooleanSwitch$instance;
    new(displayName: string, description: string, defaultSwitchValue: string): BooleanSwitch$instance;
};


export type BooleanSwitch = BooleanSwitch$instance;

export interface ConditionalAttribute$instance extends Attribute {
    readonly conditionString: string;
}


export const ConditionalAttribute: {
    new(conditionString: string): ConditionalAttribute$instance;
};


export type ConditionalAttribute = ConditionalAttribute$instance;

export interface ConsoleTraceListener$instance extends TextWriterTraceListener$instance {
    close(): void;
    dispose(): void;
}


export const ConsoleTraceListener: {
    new(): ConsoleTraceListener$instance;
    new(useErrorStream: boolean): ConsoleTraceListener$instance;
};


export interface __ConsoleTraceListener$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ConsoleTraceListener = ConsoleTraceListener$instance & __ConsoleTraceListener$views;


export interface CorrelationManager$instance {
    activityId: Guid;
    readonly logicalOperationStack: Stack;
    startLogicalOperation(): void;
    startLogicalOperation(operationId: unknown): void;
    stopLogicalOperation(): void;
}


export const CorrelationManager: {
    new(): CorrelationManager$instance;
};


export type CorrelationManager = CorrelationManager$instance;

export interface DataReceivedEventArgs$instance extends EventArgs {
    readonly data: string;
}


export const DataReceivedEventArgs: {
    new(): DataReceivedEventArgs$instance;
};


export type DataReceivedEventArgs = DataReceivedEventArgs$instance;

export interface DebuggableAttribute$instance extends Attribute {
    readonly debuggingFlags: DebuggableAttribute_DebuggingModes;
    readonly isJITOptimizerDisabled: boolean;
    readonly isJITTrackingEnabled: boolean;
}


export const DebuggableAttribute: {
    new(isJITTrackingEnabled: boolean, isJITOptimizerDisabled: boolean): DebuggableAttribute$instance;
    new(modes: DebuggableAttribute_DebuggingModes): DebuggableAttribute$instance;
};


export type DebuggableAttribute = DebuggableAttribute$instance;

export interface DebuggerBrowsableAttribute$instance extends Attribute {
    readonly state: DebuggerBrowsableState;
}


export const DebuggerBrowsableAttribute: {
    new(state: DebuggerBrowsableState): DebuggerBrowsableAttribute$instance;
};


export type DebuggerBrowsableAttribute = DebuggerBrowsableAttribute$instance;

export interface DebuggerDisableUserUnhandledExceptionsAttribute$instance extends Attribute {
}


export const DebuggerDisableUserUnhandledExceptionsAttribute: {
    new(): DebuggerDisableUserUnhandledExceptionsAttribute$instance;
};


export type DebuggerDisableUserUnhandledExceptionsAttribute = DebuggerDisableUserUnhandledExceptionsAttribute$instance;

export interface DebuggerDisplayAttribute$instance extends Attribute {
    name: string;
    target: Type;
    targetTypeName: string;
    type_: string;
    readonly value: string;
}


export const DebuggerDisplayAttribute: {
    new(value: string): DebuggerDisplayAttribute$instance;
};


export type DebuggerDisplayAttribute = DebuggerDisplayAttribute$instance;

export interface DebuggerHiddenAttribute$instance extends Attribute {
}


export const DebuggerHiddenAttribute: {
    new(): DebuggerHiddenAttribute$instance;
};


export type DebuggerHiddenAttribute = DebuggerHiddenAttribute$instance;

export interface DebuggerNonUserCodeAttribute$instance extends Attribute {
}


export const DebuggerNonUserCodeAttribute: {
    new(): DebuggerNonUserCodeAttribute$instance;
};


export type DebuggerNonUserCodeAttribute = DebuggerNonUserCodeAttribute$instance;

export interface DebuggerStepperBoundaryAttribute$instance extends Attribute {
}


export const DebuggerStepperBoundaryAttribute: {
    new(): DebuggerStepperBoundaryAttribute$instance;
};


export type DebuggerStepperBoundaryAttribute = DebuggerStepperBoundaryAttribute$instance;

export interface DebuggerStepThroughAttribute$instance extends Attribute {
}


export const DebuggerStepThroughAttribute: {
    new(): DebuggerStepThroughAttribute$instance;
};


export type DebuggerStepThroughAttribute = DebuggerStepThroughAttribute$instance;

export interface DebuggerTypeProxyAttribute$instance extends Attribute {
    readonly proxyTypeName: string;
    target: Type;
    targetTypeName: string;
}


export const DebuggerTypeProxyAttribute: {
    new(type_: Type): DebuggerTypeProxyAttribute$instance;
    new(typeName: string): DebuggerTypeProxyAttribute$instance;
};


export type DebuggerTypeProxyAttribute = DebuggerTypeProxyAttribute$instance;

export interface DebuggerVisualizerAttribute$instance extends Attribute {
    description: string;
    target: Type;
    targetTypeName: string;
    readonly visualizerObjectSourceTypeName: string;
    readonly visualizerTypeName: string;
}


export const DebuggerVisualizerAttribute: {
    new(visualizerTypeName: string): DebuggerVisualizerAttribute$instance;
    new(visualizerTypeName: string, visualizerObjectSourceTypeName: string): DebuggerVisualizerAttribute$instance;
    new(visualizerTypeName: string, visualizerObjectSource: Type): DebuggerVisualizerAttribute$instance;
    new(visualizer: Type): DebuggerVisualizerAttribute$instance;
    new(visualizer: Type, visualizerObjectSource: Type): DebuggerVisualizerAttribute$instance;
    new(visualizer: Type, visualizerObjectSourceTypeName: string): DebuggerVisualizerAttribute$instance;
};


export type DebuggerVisualizerAttribute = DebuggerVisualizerAttribute$instance;

export interface DebugProvider$instance {
    fail(message: string, detailMessage: string): void;
    onIndentLevelChanged(indentLevel: int): void;
    onIndentSizeChanged(indentSize: int): void;
    write(message: string): void;
    writeLine(message: string): void;
}


export const DebugProvider: {
    new(): DebugProvider$instance;
    failCore(stackTrace: string, message: string, detailMessage: string, errorSource: string): void;
    writeCore(message: string): void;
};


export type DebugProvider = DebugProvider$instance;

export interface DefaultTraceListener$instance extends TraceListener$instance {
    assertUiEnabled: boolean;
    logFileName: string;
    dispose(): void;
    fail(message: string): void;
    fail(message: string, detailMessage: string): void;
    write(message: string): void;
    write(o: unknown): void;
    write(message: string, category: string): void;
    write(o: unknown, category: string): void;
    writeLine(message: string): void;
    writeLine(o: unknown): void;
    writeLine(message: string, category: string): void;
    writeLine(o: unknown, category: string): void;
}


export const DefaultTraceListener: {
    new(): DefaultTraceListener$instance;
};


export interface __DefaultTraceListener$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type DefaultTraceListener = DefaultTraceListener$instance & __DefaultTraceListener$views;


export interface DelimitedListTraceListener$instance extends TextWriterTraceListener$instance {
    delimiter: string;
    dispose(): void;
    traceData(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, data: unknown): void;
    traceData(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, data: unknown[]): void;
    traceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, format: string, args: unknown[]): void;
    traceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, message: string): void;
    traceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int): void;
}


export const DelimitedListTraceListener: {
    new(stream: Stream): DelimitedListTraceListener$instance;
    new(stream: Stream, name: string): DelimitedListTraceListener$instance;
    new(writer: TextWriter): DelimitedListTraceListener$instance;
    new(writer: TextWriter, name: string): DelimitedListTraceListener$instance;
    new(fileName: string): DelimitedListTraceListener$instance;
    new(fileName: string, name: string): DelimitedListTraceListener$instance;
};


export interface __DelimitedListTraceListener$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type DelimitedListTraceListener = DelimitedListTraceListener$instance & __DelimitedListTraceListener$views;


export interface DiagnosticListener$instance extends DiagnosticSource {
    readonly name: string;
    dispose(): void;
    isEnabled(name: string): boolean;
    isEnabled(name: string, arg1: unknown, arg2?: unknown): boolean;
    onActivityExport(activity: Activity, payload: unknown): void;
    onActivityImport(activity: Activity, payload: unknown): void;
    subscribe(observer: IObserver_1<KeyValuePair_2<CLROf<string>, unknown>>, isEnabled: Func_4<CLROf<string>, unknown, unknown, CLROf<boolean>>, onActivityImport?: Action_2<Activity, unknown>, onActivityExport?: Action_2<Activity, unknown>): IDisposable;
    subscribe(observer: IObserver_1<KeyValuePair_2<CLROf<string>, unknown>>, isEnabled: Predicate_1<CLROf<string>>): IDisposable;
    subscribe(observer: IObserver_1<KeyValuePair_2<CLROf<string>, unknown>>, isEnabled: Func_4<CLROf<string>, unknown, unknown, CLROf<boolean>>): IDisposable;
    subscribe(observer: IObserver_1<KeyValuePair_2<CLROf<string>, unknown>>): IDisposable;
    toString(): string;
    write(name: string, value: unknown): void;
    write<T>(name: string, value: T): void;
}


export const DiagnosticListener: {
    new(name: string): DiagnosticListener$instance;
    readonly allListeners: IObservable_1<DiagnosticListener>;
};


export interface __DiagnosticListener$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IObservable_1(): System_Internal.IObservable_1$instance<KeyValuePair_2<CLROf<string>, unknown>>;
}

export interface DiagnosticListener$instance extends System_Internal.IDisposable$instance {}

export type DiagnosticListener = DiagnosticListener$instance & __DiagnosticListener$views;


export interface DiagnosticMethodInfo$instance {
    readonly declaringAssemblyName: string;
    readonly declaringTypeName: string;
    readonly name: string;
}


export const DiagnosticMethodInfo: {
    new(): DiagnosticMethodInfo$instance;
    create(delegate: Function): DiagnosticMethodInfo;
    create(frame: StackFrame): DiagnosticMethodInfo;
};


export type DiagnosticMethodInfo = DiagnosticMethodInfo$instance;

export interface DiagnosticSource$instance {
    isEnabled(name: string): boolean;
    isEnabled(name: string, arg1: unknown, arg2?: unknown): boolean;
    onActivityExport(activity: Activity, payload: unknown): void;
    onActivityImport(activity: Activity, payload: unknown): void;
    startActivity(activity: Activity, args: unknown): Activity;
    startActivity<T>(activity: Activity, args: T): Activity;
    stopActivity(activity: Activity, args: unknown): void;
    stopActivity<T>(activity: Activity, args: T): void;
    write(name: string, value: unknown): void;
    write<T>(name: string, value: T): void;
}


export const DiagnosticSource: {
};


export type DiagnosticSource = DiagnosticSource$instance;

export interface DistributedContextPropagator$instance {
    readonly fields: IReadOnlyCollection_1<CLROf<string>>;
    extractBaggage(carrier: unknown, getter: DistributedContextPropagator_PropagatorGetterCallback): IEnumerable_1<KeyValuePair_2<CLROf<string>, CLROf<string>>>;
    extractTraceIdAndState(carrier: unknown, getter: DistributedContextPropagator_PropagatorGetterCallback, traceId: { value: ref<string> }, traceState: { value: ref<string> }): void;
    inject(activity: Activity, carrier: unknown, setter: DistributedContextPropagator_PropagatorSetterCallback): void;
}


export const DistributedContextPropagator: {
    current: DistributedContextPropagator;
    createDefaultPropagator(): DistributedContextPropagator;
    createNoOutputPropagator(): DistributedContextPropagator;
    createPassThroughPropagator(): DistributedContextPropagator;
    createPreW3CPropagator(): DistributedContextPropagator;
    createW3CPropagator(): DistributedContextPropagator;
};


export type DistributedContextPropagator = DistributedContextPropagator$instance;

export interface EventTypeFilter$instance extends TraceFilter {
    eventType: SourceLevels;
    shouldTrace(cache: TraceEventCache, source: string, eventType: TraceEventType, id: int, formatOrMessage: string, args: unknown[], data1: unknown, data: unknown[]): boolean;
}


export const EventTypeFilter: {
    new(level: SourceLevels): EventTypeFilter$instance;
};


export type EventTypeFilter = EventTypeFilter$instance;

export interface FileVersionInfo$instance {
    readonly comments: string;
    readonly companyName: string;
    readonly fileBuildPart: int;
    readonly fileDescription: string;
    readonly fileMajorPart: int;
    readonly fileMinorPart: int;
    readonly fileName: string;
    readonly filePrivatePart: int;
    readonly fileVersion: string;
    readonly internalName: string;
    readonly isDebug: boolean;
    readonly isPatched: boolean;
    readonly isPreRelease: boolean;
    readonly isPrivateBuild: boolean;
    readonly isSpecialBuild: boolean;
    readonly language: string;
    readonly legalCopyright: string;
    readonly legalTrademarks: string;
    readonly originalFilename: string;
    readonly privateBuild: string;
    readonly productBuildPart: int;
    readonly productMajorPart: int;
    readonly productMinorPart: int;
    readonly productName: string;
    readonly productPrivatePart: int;
    readonly productVersion: string;
    readonly specialBuild: string;
    toString(): string;
}


export const FileVersionInfo: {
    new(): FileVersionInfo$instance;
    getVersionInfo(fileName: string): FileVersionInfo;
};


export type FileVersionInfo = FileVersionInfo$instance;

export interface InitializingSwitchEventArgs$instance extends EventArgs {
    readonly switch_: Switch;
}


export const InitializingSwitchEventArgs: {
    new(switch_: Switch): InitializingSwitchEventArgs$instance;
};


export type InitializingSwitchEventArgs = InitializingSwitchEventArgs$instance;

export interface InitializingTraceSourceEventArgs$instance extends EventArgs {
    readonly traceSource: TraceSource;
    wasInitialized: boolean;
}


export const InitializingTraceSourceEventArgs: {
    new(traceSource: TraceSource): InitializingTraceSourceEventArgs$instance;
};


export type InitializingTraceSourceEventArgs = InitializingTraceSourceEventArgs$instance;

export interface MonitoringDescriptionAttribute$instance extends DescriptionAttribute {
    readonly description: string;
}


export const MonitoringDescriptionAttribute: {
    new(description: string): MonitoringDescriptionAttribute$instance;
};


export type MonitoringDescriptionAttribute = MonitoringDescriptionAttribute$instance;

export interface Process$instance extends Component {
    readonly basePriority: int;
    enableRaisingEvents: boolean;
    readonly exitCode: int;
    readonly exitTime: DateTime;
    readonly handle: nint;
    readonly handleCount: int;
    readonly hasExited: boolean;
    readonly id: int;
    readonly machineName: string;
    readonly mainModule: ProcessModule;
    readonly mainWindowHandle: nint;
    readonly mainWindowTitle: string;
    maxWorkingSet: nint;
    minWorkingSet: nint;
    readonly modules: ProcessModuleCollection;
    readonly nonpagedSystemMemorySize: int;
    readonly nonpagedSystemMemorySize64: long;
    readonly pagedMemorySize: int;
    readonly pagedMemorySize64: long;
    readonly pagedSystemMemorySize: int;
    readonly pagedSystemMemorySize64: long;
    readonly peakPagedMemorySize: int;
    readonly peakPagedMemorySize64: long;
    readonly peakVirtualMemorySize: int;
    readonly peakVirtualMemorySize64: long;
    readonly peakWorkingSet: int;
    readonly peakWorkingSet64: long;
    priorityBoostEnabled: boolean;
    priorityClass: ProcessPriorityClass;
    readonly privateMemorySize: int;
    readonly privateMemorySize64: long;
    readonly privilegedProcessorTime: TimeSpan;
    readonly processName: string;
    processorAffinity: nint;
    readonly responding: boolean;
    readonly safeHandle: SafeProcessHandle;
    readonly sessionId: int;
    readonly standardError: StreamReader;
    readonly standardInput: StreamWriter;
    readonly standardOutput: StreamReader;
    startInfo: ProcessStartInfo;
    readonly startTime: DateTime;
    synchronizingObject: ISynchronizeInvoke;
    readonly threads: ProcessThreadCollection;
    readonly totalProcessorTime: TimeSpan;
    readonly userProcessorTime: TimeSpan;
    readonly virtualMemorySize: int;
    readonly virtualMemorySize64: long;
    readonly workingSet: int;
    readonly workingSet64: long;
    beginErrorReadLine(): void;
    beginOutputReadLine(): void;
    cancelErrorRead(): void;
    cancelOutputRead(): void;
    close(): void;
    closeMainWindow(): boolean;
    dispose(): void;
    kill(): void;
    kill(entireProcessTree: boolean): void;
    refresh(): void;
    start(): boolean;
    toString(): string;
    waitForExit(): void;
    waitForExit(milliseconds: int): boolean;
    waitForExit(timeout: TimeSpan): boolean;
    waitForExitAsync(cancellationToken?: CancellationToken): Task;
    waitForInputIdle(): boolean;
    waitForInputIdle(milliseconds: int): boolean;
    waitForInputIdle(timeout: TimeSpan): boolean;
}


export const Process: {
    new(): Process$instance;
    enterDebugMode(): void;
    getCurrentProcess(): Process;
    getProcessById(processId: int, machineName: string): Process;
    getProcessById(processId: int): Process;
    getProcesses(): Process[];
    getProcesses(machineName: string): Process[];
    getProcessesByName(processName: string, machineName: string): Process[];
    getProcessesByName(processName: string): Process[];
    leaveDebugMode(): void;
    start(startInfo: ProcessStartInfo): Process;
    start(fileName: string, arguments: IEnumerable_1<CLROf<string>>): Process;
    start(fileName: string, userName: string, password: SecureString, domain: string): Process;
    start(fileName: string, arguments: string, userName: string, password: SecureString, domain: string): Process;
    start(fileName: string, arguments: string): Process;
    start(fileName: string): Process;
};


export interface __Process$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Process$instance extends System_ComponentModel_Internal.IComponent$instance {}

export type Process = Process$instance & __Process$views;


export interface ProcessModule$instance extends Component {
    readonly baseAddress: nint;
    readonly entryPointAddress: nint;
    readonly fileName: string;
    readonly fileVersionInfo: FileVersionInfo;
    readonly moduleMemorySize: int;
    readonly moduleName: string;
    dispose(): void;
    toString(): string;
}


export const ProcessModule: {
    new(): ProcessModule$instance;
};


export interface __ProcessModule$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ProcessModule$instance extends System_ComponentModel_Internal.IComponent$instance {}

export type ProcessModule = ProcessModule$instance & __ProcessModule$views;


export interface ProcessModuleCollection$instance extends ReadOnlyCollectionBase {
    readonly item: ProcessModule;
    contains(module_: ProcessModule): boolean;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator;
    indexOf(module_: ProcessModule): int;
}


export const ProcessModuleCollection: {
    new(processModules: ProcessModule[]): ProcessModuleCollection$instance;
};


export interface __ProcessModuleCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export interface ProcessModuleCollection$instance extends System_Collections_Internal.ICollection$instance {}

export type ProcessModuleCollection = ProcessModuleCollection$instance & __ProcessModuleCollection$views;


export interface ProcessStartInfo$instance {
    readonly argumentList: Collection_1<CLROf<string>>;
    arguments: string;
    createNewProcessGroup: boolean;
    createNoWindow: boolean;
    domain: string;
    readonly environment: IDictionary_2<CLROf<string>, CLROf<string>>;
    readonly environmentVariables: StringDictionary;
    errorDialog: boolean;
    errorDialogParentHandle: nint;
    fileName: string;
    loadUserProfile: boolean;
    password: SecureString;
    passwordInClearText: string;
    redirectStandardError: boolean;
    redirectStandardInput: boolean;
    redirectStandardOutput: boolean;
    standardErrorEncoding: Encoding;
    standardInputEncoding: Encoding;
    standardOutputEncoding: Encoding;
    useCredentialsForNetworkingOnly: boolean;
    userName: string;
    useShellExecute: boolean;
    verb: string;
    readonly verbs: string[];
    windowStyle: ProcessWindowStyle;
    workingDirectory: string;
}


export const ProcessStartInfo: {
    new(): ProcessStartInfo$instance;
    new(fileName: string): ProcessStartInfo$instance;
    new(fileName: string, arguments: string): ProcessStartInfo$instance;
    new(fileName: string, arguments: IEnumerable_1<CLROf<string>>): ProcessStartInfo$instance;
};


export type ProcessStartInfo = ProcessStartInfo$instance;

export interface ProcessThread$instance extends Component {
    readonly basePriority: int;
    readonly currentPriority: int;
    readonly id: int;
    idealProcessor: int;
    priorityBoostEnabled: boolean;
    priorityLevel: ThreadPriorityLevel;
    readonly privilegedProcessorTime: TimeSpan;
    processorAffinity: nint;
    readonly startAddress: nint;
    readonly startTime: DateTime;
    readonly threadState: ThreadState;
    readonly totalProcessorTime: TimeSpan;
    readonly userProcessorTime: TimeSpan;
    readonly waitReason: ThreadWaitReason;
    dispose(): void;
    resetIdealProcessor(): void;
}


export const ProcessThread: {
    new(): ProcessThread$instance;
};


export interface __ProcessThread$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ProcessThread$instance extends System_ComponentModel_Internal.IComponent$instance {}

export type ProcessThread = ProcessThread$instance & __ProcessThread$views;


export interface ProcessThreadCollection$instance extends ReadOnlyCollectionBase {
    readonly item: ProcessThread;
    add(thread: ProcessThread): int;
    contains(thread: ProcessThread): boolean;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator;
    indexOf(thread: ProcessThread): int;
    insert(index: int, thread: ProcessThread): void;
    remove(thread: ProcessThread): void;
}


export const ProcessThreadCollection: {
    new(processThreads: ProcessThread[]): ProcessThreadCollection$instance;
};


export interface __ProcessThreadCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export interface ProcessThreadCollection$instance extends System_Collections_Internal.ICollection$instance {}

export type ProcessThreadCollection = ProcessThreadCollection$instance & __ProcessThreadCollection$views;


export interface SourceFilter$instance extends TraceFilter {
    source: string;
    shouldTrace(cache: TraceEventCache, source: string, eventType: TraceEventType, id: int, formatOrMessage: string, args: unknown[], data1: unknown, data: unknown[]): boolean;
}


export const SourceFilter: {
    new(source: string): SourceFilter$instance;
};


export type SourceFilter = SourceFilter$instance;

export interface SourceSwitch$instance extends Switch {
    level: SourceLevels;
    shouldTrace(eventType: TraceEventType): boolean;
}


export const SourceSwitch: {
    new(name: string): SourceSwitch$instance;
    new(displayName: string, defaultSwitchValue: string): SourceSwitch$instance;
};


export type SourceSwitch = SourceSwitch$instance;

export interface StackFrame$instance {
    getFileColumnNumber(): int;
    getFileLineNumber(): int;
    getFileName(): string;
    getILOffset(): int;
    getMethod(): MethodBase;
    getNativeOffset(): int;
    toString(): string;
}


export const StackFrame: {
    new(): StackFrame$instance;
    new(needFileInfo: boolean): StackFrame$instance;
    new(skipFrames: int): StackFrame$instance;
    new(skipFrames: int, needFileInfo: boolean): StackFrame$instance;
    new(fileName: string, lineNumber: int): StackFrame$instance;
    new(fileName: string, lineNumber: int, colNumber: int): StackFrame$instance;
    readonly OFFSET_UNKNOWN: int;
};


export type StackFrame = StackFrame$instance;

export interface StackTrace$instance {
    readonly frameCount: int;
    getFrame(index: int): StackFrame;
    getFrames(): StackFrame[];
    toString(): string;
}


export const StackTrace: {
    new(): StackTrace$instance;
    new(fNeedFileInfo: boolean): StackTrace$instance;
    new(skipFrames: int): StackTrace$instance;
    new(skipFrames: int, fNeedFileInfo: boolean): StackTrace$instance;
    new(e: Exception): StackTrace$instance;
    new(e: Exception, fNeedFileInfo: boolean): StackTrace$instance;
    new(e: Exception, skipFrames: int): StackTrace$instance;
    new(e: Exception, skipFrames: int, fNeedFileInfo: boolean): StackTrace$instance;
    new(frame: StackFrame): StackTrace$instance;
    new(frames: IEnumerable_1<StackFrame>): StackTrace$instance;
    readonly METHODS_TO_SKIP: int;
};


export type StackTrace = StackTrace$instance;

export interface StackTraceHiddenAttribute$instance extends Attribute {
}


export const StackTraceHiddenAttribute: {
    new(): StackTraceHiddenAttribute$instance;
};


export type StackTraceHiddenAttribute = StackTraceHiddenAttribute$instance;

export interface Stopwatch$instance {
    readonly elapsed: TimeSpan;
    readonly elapsedMilliseconds: long;
    readonly elapsedTicks: long;
    readonly isRunning: boolean;
    reset(): void;
    restart(): void;
    start(): void;
    stop(): void;
    toString(): string;
}


export const Stopwatch: {
    new(): Stopwatch$instance;
    readonly frequency: long;
    readonly isHighResolution: boolean;
    getElapsedTime(startingTimestamp: long, endingTimestamp: long): TimeSpan;
    getElapsedTime(startingTimestamp: long): TimeSpan;
    getTimestamp(): long;
    startNew(): Stopwatch;
};


export type Stopwatch = Stopwatch$instance;

export interface Switch$instance {
    readonly attributes: StringDictionary;
    readonly defaultValue: string;
    readonly description: string;
    readonly displayName: string;
    value: string;
    refresh(): void;
}


export const Switch: {
};


export type Switch = Switch$instance;

export interface SwitchAttribute$instance extends Attribute {
    switchDescription: string;
    switchName: string;
    switchType: Type;
}


export const SwitchAttribute: {
    new(switchName: string, switchType: Type): SwitchAttribute$instance;
    getAll(assembly: Assembly): SwitchAttribute[];
};


export type SwitchAttribute = SwitchAttribute$instance;

export interface SwitchLevelAttribute$instance extends Attribute {
    switchLevelType: Type;
}


export const SwitchLevelAttribute: {
    new(switchLevelType: Type): SwitchLevelAttribute$instance;
};


export type SwitchLevelAttribute = SwitchLevelAttribute$instance;

export interface TextWriterTraceListener$instance extends TraceListener$instance {
    writer: TextWriter;
    close(): void;
    dispose(): void;
    flush(): void;
    write(message: string): void;
    write(o: unknown): void;
    write(message: string, category: string): void;
    write(o: unknown, category: string): void;
    writeLine(message: string): void;
    writeLine(o: unknown): void;
    writeLine(message: string, category: string): void;
    writeLine(o: unknown, category: string): void;
}


export const TextWriterTraceListener: {
    new(): TextWriterTraceListener$instance;
    new(stream: Stream): TextWriterTraceListener$instance;
    new(stream: Stream, name: string): TextWriterTraceListener$instance;
    new(writer: TextWriter): TextWriterTraceListener$instance;
    new(writer: TextWriter, name: string): TextWriterTraceListener$instance;
    new(fileName: string): TextWriterTraceListener$instance;
    new(fileName: string, name: string): TextWriterTraceListener$instance;
};


export interface __TextWriterTraceListener$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type TextWriterTraceListener = TextWriterTraceListener$instance & __TextWriterTraceListener$views;


export interface Trace$instance {
}


export const Trace: {
    new(): Trace$instance;
    readonly correlationManager: CorrelationManager;
    readonly listeners: TraceListenerCollection;
    autoFlush: boolean;
    useGlobalLock: boolean;
    indentLevel: int;
    indentSize: int;
    assert(condition: boolean, message: string, detailMessage: string): void;
    assert(condition: boolean, message?: string): void;
    assert(condition: boolean): void;
    close(): void;
    fail(message: string, detailMessage: string): void;
    fail(message: string): void;
    flush(): void;
    indent(): void;
    refresh(): void;
    traceError(format: string, args: unknown[]): void;
    traceError(message: string): void;
    traceInformation(format: string, args: unknown[]): void;
    traceInformation(message: string): void;
    traceWarning(format: string, args: unknown[]): void;
    traceWarning(message: string): void;
    unindent(): void;
    write(value: unknown, category: string): void;
    write(value: unknown): void;
    write(message: string, category: string): void;
    write(message: string): void;
    writeIf(condition: boolean, value: unknown, category: string): void;
    writeIf(condition: boolean, value: unknown): void;
    writeIf(condition: boolean, message: string, category: string): void;
    writeIf(condition: boolean, message: string): void;
    writeLine(value: unknown, category: string): void;
    writeLine(value: unknown): void;
    writeLine(message: string, category: string): void;
    writeLine(message: string): void;
    writeLineIf(condition: boolean, value: unknown, category: string): void;
    writeLineIf(condition: boolean, value: unknown): void;
    writeLineIf(condition: boolean, message: string, category: string): void;
    writeLineIf(condition: boolean, message: string): void;
};


export type Trace = Trace$instance;

export interface TraceEventCache$instance {
    readonly callstack: string;
    readonly dateTime: DateTime;
    readonly logicalOperationStack: Stack;
    readonly processId: int;
    readonly threadId: string;
    readonly timestamp: long;
}


export const TraceEventCache: {
    new(): TraceEventCache$instance;
};


export type TraceEventCache = TraceEventCache$instance;

export interface TraceFilter$instance {
    shouldTrace(cache: TraceEventCache, source: string, eventType: TraceEventType, id: int, formatOrMessage: string, args: unknown[], data1: unknown, data: unknown[]): boolean;
}


export const TraceFilter: {
};


export type TraceFilter = TraceFilter$instance;

export interface TraceListener$instance extends MarshalByRefObject {
    readonly attributes: StringDictionary;
    filter: TraceFilter;
    indentLevel: int;
    indentSize: int;
    readonly isThreadSafe: boolean;
    name: string;
    traceOutputOptions: TraceOptions;
    close(): void;
    dispose(): void;
    fail(message: string): void;
    fail(message: string, detailMessage: string): void;
    flush(): void;
    traceData(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, data: unknown): void;
    traceData(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, data: unknown[]): void;
    traceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int): void;
    traceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, message: string): void;
    traceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, format: string, args: unknown[]): void;
    traceTransfer(eventCache: TraceEventCache, source: string, id: int, message: string, relatedActivityId: Guid): void;
    write(message: string): void;
    write(o: unknown): void;
    write(message: string, category: string): void;
    write(o: unknown, category: string): void;
    writeLine(message: string): void;
    writeLine(o: unknown): void;
    writeLine(message: string, category: string): void;
    writeLine(o: unknown, category: string): void;
}


export const TraceListener: {
};


export interface __TraceListener$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface TraceListener$instance extends System_Internal.IDisposable$instance {}

export type TraceListener = TraceListener$instance & __TraceListener$views;


export interface TraceListenerCollection$instance {
    readonly count: int;
    add(listener: TraceListener): int;
    addRange(value: TraceListener[]): void;
    addRange(value: TraceListenerCollection): void;
    clear(): void;
    contains(listener: TraceListener): boolean;
    copyTo(listeners: TraceListener[], index: int): void;
    get_Item(i: int): TraceListener;
    get_Item(name: string): TraceListener;
    getEnumerator(): IEnumerator;
    indexOf(listener: TraceListener): int;
    insert(index: int, listener: TraceListener): void;
    remove(listener: TraceListener): void;
    remove(name: string): void;
    removeAt(index: int): void;
    set_Item(i: int, value: TraceListener): void;
}


export const TraceListenerCollection: {
    new(): TraceListenerCollection$instance;
};


export interface __TraceListenerCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type TraceListenerCollection = TraceListenerCollection$instance & __TraceListenerCollection$views;


export interface TraceSource$instance {
    readonly attributes: StringDictionary;
    readonly defaultLevel: SourceLevels;
    readonly listeners: TraceListenerCollection;
    readonly name: string;
    switch_: SourceSwitch;
    close(): void;
    flush(): void;
    traceData(eventType: TraceEventType, id: int, data: unknown): void;
    traceData(eventType: TraceEventType, id: int, data: unknown[]): void;
    traceEvent(eventType: TraceEventType, id: int): void;
    traceEvent(eventType: TraceEventType, id: int, message: string): void;
    traceEvent(eventType: TraceEventType, id: int, format: string, args: unknown[]): void;
    traceInformation(message: string): void;
    traceInformation(format: string, args: unknown[]): void;
    traceTransfer(id: int, message: string, relatedActivityId: Guid): void;
}


export const TraceSource: {
    new(name: string): TraceSource$instance;
    new(name: string, defaultLevel: SourceLevels): TraceSource$instance;
};


export type TraceSource = TraceSource$instance;

export interface TraceSwitch$instance extends Switch {
    level: TraceLevel;
    readonly traceError: boolean;
    readonly traceInfo: boolean;
    readonly traceVerbose: boolean;
    readonly traceWarning: boolean;
}


export const TraceSwitch: {
    new(displayName: string, description: string): TraceSwitch$instance;
    new(displayName: string, description: string, defaultSwitchValue: string): TraceSwitch$instance;
};


export type TraceSwitch = TraceSwitch$instance;

export interface UnreachableException$instance extends Exception {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const UnreachableException: {
    new(): UnreachableException$instance;
    new(message: string): UnreachableException$instance;
    new(message: string, innerException: Exception): UnreachableException$instance;
};


export interface __UnreachableException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type UnreachableException = UnreachableException$instance & __UnreachableException$views;


export interface XmlWriterTraceListener$instance extends TextWriterTraceListener$instance {
    close(): void;
    dispose(): void;
    fail(message: string, detailMessage: string): void;
    fail(message: string): void;
    traceData(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, data: unknown): void;
    traceData(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, data: unknown[]): void;
    traceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, format: string, args: unknown[]): void;
    traceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, message: string): void;
    traceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int): void;
    traceTransfer(eventCache: TraceEventCache, source: string, id: int, message: string, relatedActivityId: Guid): void;
    write(message: string): void;
    write(o: unknown): void;
    write(message: string, category: string): void;
    write(o: unknown, category: string): void;
    writeLine(message: string): void;
    writeLine(o: unknown): void;
    writeLine(message: string, category: string): void;
    writeLine(o: unknown, category: string): void;
}


export const XmlWriterTraceListener: {
    new(stream: Stream): XmlWriterTraceListener$instance;
    new(stream: Stream, name: string): XmlWriterTraceListener$instance;
    new(writer: TextWriter): XmlWriterTraceListener$instance;
    new(writer: TextWriter, name: string): XmlWriterTraceListener$instance;
    new(filename: string): XmlWriterTraceListener$instance;
    new(filename: string, name: string): XmlWriterTraceListener$instance;
};


export interface __XmlWriterTraceListener$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type XmlWriterTraceListener = XmlWriterTraceListener$instance & __XmlWriterTraceListener$views;


export abstract class Debug$instance {
    static autoFlush: boolean;
    static indentLevel: int;
    static indentSize: int;
    static assert(condition: boolean, message: { value: ref<Debug_AssertInterpolatedStringHandler> }, detailMessage: { value: ref<Debug_AssertInterpolatedStringHandler> }): void;
    static assert(condition: boolean, message: { value: ref<Debug_AssertInterpolatedStringHandler> }): void;
    static assert(condition: boolean, message: string, detailMessageFormat: string, args: unknown[]): void;
    static assert(condition: boolean, message: string, detailMessage: string): void;
    static assert(condition: boolean, message?: string): void;
    static assert(condition: boolean): void;
    static close(): void;
    static fail(message: string, detailMessage: string): void;
    static fail(message: string): void;
    static flush(): void;
    static indent(): void;
    static print(format: string, args: unknown[]): void;
    static print(message: string): void;
    static setProvider(provider: DebugProvider): DebugProvider;
    static unindent(): void;
    static write(value: unknown, category: string): void;
    static write(value: unknown): void;
    static write(message: string, category: string): void;
    static write(message: string): void;
    static writeIf(condition: boolean, message: { value: ref<Debug_WriteIfInterpolatedStringHandler> }, category: string): void;
    static writeIf(condition: boolean, message: { value: ref<Debug_WriteIfInterpolatedStringHandler> }): void;
    static writeIf(condition: boolean, value: unknown, category: string): void;
    static writeIf(condition: boolean, value: unknown): void;
    static writeIf(condition: boolean, message: string, category: string): void;
    static writeIf(condition: boolean, message: string): void;
    static writeLine(value: unknown, category: string): void;
    static writeLine(value: unknown): void;
    static writeLine(format: string, args: unknown[]): void;
    static writeLine(message: string, category: string): void;
    static writeLine(message: string): void;
    static writeLineIf(condition: boolean, message: { value: ref<Debug_WriteIfInterpolatedStringHandler> }, category: string): void;
    static writeLineIf(condition: boolean, message: { value: ref<Debug_WriteIfInterpolatedStringHandler> }): void;
    static writeLineIf(condition: boolean, value: unknown, category: string): void;
    static writeLineIf(condition: boolean, value: unknown): void;
    static writeLineIf(condition: boolean, message: string, category: string): void;
    static writeLineIf(condition: boolean, message: string): void;
}


export type Debug = Debug$instance;

export abstract class Debugger$instance {
    static readonly defaultCategory: string;
    static readonly isAttached: boolean;
    static break_(): void;
    static breakForUserUnhandledException(exception: Exception): void;
    static isLogging(): boolean;
    static launch(): boolean;
    static log(level: int, category: string, message: string): void;
    static notifyOfCrossThreadDependency(): void;
}


export type Debugger = Debugger$instance;

export abstract class StackFrameExtensions$instance {
    static getNativeImageBase(stackFrame: StackFrame): nint;
    static getNativeIP(stackFrame: StackFrame): nint;
    static hasILOffset(stackFrame: StackFrame): boolean;
    static hasMethod(stackFrame: StackFrame): boolean;
    static hasNativeImage(stackFrame: StackFrame): boolean;
    static hasSource(stackFrame: StackFrame): boolean;
}


export type StackFrameExtensions = StackFrameExtensions$instance;

