// Generated by tsbindgen - Architecture
// Namespace: System.Net.Mail
// Assembly: System.Net.Mail

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IList_1, IReadOnlyCollection_1, IReadOnlyList_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_ObjectModel_Internal from "../../System.Collections.ObjectModel/internal/index.js";
import type { Collection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import type { NameValueCollection } from "../../System.Collections.Specialized/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import type { AsyncCompletedEventArgs } from "../../System.ComponentModel/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { ContentDisposition, ContentType, TransferEncoding } from "../../System.Net.Mime/internal/index.js";
import type { ICredentialsByHost, ServicePoint } from "../../System.Net/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { X509CertificateCollection } from "../../System.Security.Cryptography.X509Certificates/internal/index.js";
import type { Encoding } from "../../System.Text/internal/index.js";
import type { Task } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, AsyncCallback, Boolean as ClrBoolean, Delegate, Enum, Exception, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, MulticastDelegate, Object as ClrObject, String as ClrString, Type, TypeCode, Uri, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum DeliveryNotificationOptions {
    none = 0,
    onSuccess = 1,
    onFailure = 2,
    delay = 4,
    never_ = 134217728
}


export enum MailPriority {
    normal = 0,
    low = 1,
    high = 2
}


export enum SmtpDeliveryFormat {
    sevenBit = 0,
    international = 1
}


export enum SmtpDeliveryMethod {
    network = 0,
    specifiedPickupDirectory = 1,
    pickupDirectoryFromIis = 2
}


export enum SmtpStatusCode {
    systemStatus = 211,
    helpMessage = 214,
    serviceReady = 220,
    serviceClosingTransmissionChannel = 221,
    ok = 250,
    userNotLocalWillForward = 251,
    cannotVerifyUserWillAttemptDelivery = 252,
    startMailInput = 354,
    serviceNotAvailable = 421,
    mailboxBusy = 450,
    localErrorInProcessing = 451,
    insufficientStorage = 452,
    clientNotPermitted = 454,
    commandUnrecognized = 500,
    syntaxError = 501,
    commandNotImplemented = 502,
    badCommandSequence = 503,
    mustIssueStartTlsFirst = 530,
    commandParameterNotImplemented = 504,
    mailboxUnavailable = 550,
    userNotLocalTryAlternatePath = 551,
    exceededStorageAllocation = 552,
    mailboxNameNotAllowed = 553,
    transactionFailed = 554,
    generalFailure = -1
}


export type SendCompletedEventHandler = (sender: unknown, e: AsyncCompletedEventArgs) => void;


export interface AlternateView$instance extends AttachmentBase$instance {
    baseUri: Uri;
    readonly linkedResources: LinkedResourceCollection;
    dispose(): void;
}


export const AlternateView: {
    new(fileName: string): AlternateView$instance;
    new(fileName: string, mediaType: string): AlternateView$instance;
    new(fileName: string, contentType: ContentType): AlternateView$instance;
    new(contentStream: Stream): AlternateView$instance;
    new(contentStream: Stream, mediaType: string): AlternateView$instance;
    new(contentStream: Stream, contentType: ContentType): AlternateView$instance;
    createAlternateViewFromString(content: string, contentType: ContentType): AlternateView;
    createAlternateViewFromString(content: string, contentEncoding: Encoding, mediaType: string): AlternateView;
    createAlternateViewFromString(content: string): AlternateView;
};


export interface __AlternateView$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type AlternateView = AlternateView$instance & __AlternateView$views;


export interface AlternateViewCollection$instance extends Collection_1<AlternateView> {
    add(item: AlternateView): void;
    add(value: unknown): int;
    clear(): void;
    contains(item: AlternateView): boolean;
    contains(value: unknown): boolean;
    copyTo(array: AlternateView[], index: int): void;
    copyTo(array: ClrArray, index: int): void;
    dispose(): void;
    getEnumerator(): IEnumerator_1<AlternateView>;
    getEnumerator(): IEnumerator;
    indexOf(item: AlternateView): int;
    insert(index: int, item: AlternateView): void;
    insert(index: int, value: unknown): void;
    remove(item: AlternateView): boolean;
    remove(value: unknown): void;
    removeAt(index: int): void;
}


export const AlternateViewCollection: {
    new(): AlternateViewCollection$instance;
};


export interface __AlternateViewCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<AlternateView>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<AlternateView>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<AlternateView>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<AlternateView>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface AlternateViewCollection$instance extends System_Internal.IDisposable$instance {}

export type AlternateViewCollection = AlternateViewCollection$instance & __AlternateViewCollection$views;


export interface Attachment$instance extends AttachmentBase$instance {
    readonly contentDisposition: ContentDisposition;
    name: string;
    nameEncoding: Encoding;
    dispose(): void;
}


export const Attachment: {
    new(fileName: string): Attachment$instance;
    new(fileName: string, mediaType: string): Attachment$instance;
    new(fileName: string, contentType: ContentType): Attachment$instance;
    new(contentStream: Stream, name: string): Attachment$instance;
    new(contentStream: Stream, name: string, mediaType: string): Attachment$instance;
    new(contentStream: Stream, contentType: ContentType): Attachment$instance;
    createAttachmentFromString(content: string, contentType: ContentType): Attachment;
    createAttachmentFromString(content: string, name: string, contentEncoding: Encoding, mediaType: string): Attachment;
    createAttachmentFromString(content: string, name: string): Attachment;
};


export interface __Attachment$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type Attachment = Attachment$instance & __Attachment$views;


export interface AttachmentBase$instance {
    contentId: string;
    readonly contentStream: Stream;
    contentType: ContentType;
    transferEncoding: TransferEncoding;
    dispose(): void;
}


export const AttachmentBase: {
};


export interface __AttachmentBase$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface AttachmentBase$instance extends System_Internal.IDisposable$instance {}

export type AttachmentBase = AttachmentBase$instance & __AttachmentBase$views;


export interface AttachmentCollection$instance extends Collection_1<Attachment> {
    add(item: Attachment): void;
    add(value: unknown): int;
    clear(): void;
    contains(item: Attachment): boolean;
    contains(value: unknown): boolean;
    copyTo(array: Attachment[], index: int): void;
    copyTo(array: ClrArray, index: int): void;
    dispose(): void;
    getEnumerator(): IEnumerator_1<Attachment>;
    getEnumerator(): IEnumerator;
    indexOf(item: Attachment): int;
    insert(index: int, item: Attachment): void;
    insert(index: int, value: unknown): void;
    remove(item: Attachment): boolean;
    remove(value: unknown): void;
    removeAt(index: int): void;
}


export const AttachmentCollection: {
    new(): AttachmentCollection$instance;
};


export interface __AttachmentCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<Attachment>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<Attachment>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<Attachment>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<Attachment>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface AttachmentCollection$instance extends System_Internal.IDisposable$instance {}

export type AttachmentCollection = AttachmentCollection$instance & __AttachmentCollection$views;


export interface LinkedResource$instance extends AttachmentBase$instance {
    contentLink: Uri;
    dispose(): void;
}


export const LinkedResource: {
    new(fileName: string): LinkedResource$instance;
    new(fileName: string, mediaType: string): LinkedResource$instance;
    new(fileName: string, contentType: ContentType): LinkedResource$instance;
    new(contentStream: Stream): LinkedResource$instance;
    new(contentStream: Stream, mediaType: string): LinkedResource$instance;
    new(contentStream: Stream, contentType: ContentType): LinkedResource$instance;
    createLinkedResourceFromString(content: string, contentType: ContentType): LinkedResource;
    createLinkedResourceFromString(content: string, contentEncoding: Encoding, mediaType: string): LinkedResource;
    createLinkedResourceFromString(content: string): LinkedResource;
};


export interface __LinkedResource$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type LinkedResource = LinkedResource$instance & __LinkedResource$views;


export interface LinkedResourceCollection$instance extends Collection_1<LinkedResource> {
    add(item: LinkedResource): void;
    add(value: unknown): int;
    clear(): void;
    contains(item: LinkedResource): boolean;
    contains(value: unknown): boolean;
    copyTo(array: LinkedResource[], index: int): void;
    copyTo(array: ClrArray, index: int): void;
    dispose(): void;
    getEnumerator(): IEnumerator_1<LinkedResource>;
    getEnumerator(): IEnumerator;
    indexOf(item: LinkedResource): int;
    insert(index: int, item: LinkedResource): void;
    insert(index: int, value: unknown): void;
    remove(item: LinkedResource): boolean;
    remove(value: unknown): void;
    removeAt(index: int): void;
}


export const LinkedResourceCollection: {
    new(): LinkedResourceCollection$instance;
};


export interface __LinkedResourceCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<LinkedResource>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<LinkedResource>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<LinkedResource>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<LinkedResource>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface LinkedResourceCollection$instance extends System_Internal.IDisposable$instance {}

export type LinkedResourceCollection = LinkedResourceCollection$instance & __LinkedResourceCollection$views;


export interface MailAddress$instance {
    readonly address: string;
    readonly displayName: string;
    readonly host: string;
    readonly user: string;
    equals(value: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const MailAddress: {
    new(address: string): MailAddress$instance;
    new(address: string, displayName: string): MailAddress$instance;
    new(address: string, displayName: string, displayNameEncoding: Encoding): MailAddress$instance;
    tryCreate(address: string, result: { value: ref<MailAddress> }): boolean;
    tryCreate(address: string, displayName: string, result: { value: ref<MailAddress> }): boolean;
    tryCreate(address: string, displayName: string, displayNameEncoding: Encoding, result: { value: ref<MailAddress> }): boolean;
};


export type MailAddress = MailAddress$instance;

export interface MailAddressCollection$instance extends Collection_1<MailAddress> {
    add(item: MailAddress): void;
    add(value: unknown): int;
    clear(): void;
    contains(item: MailAddress): boolean;
    contains(value: unknown): boolean;
    copyTo(array: MailAddress[], index: int): void;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator_1<MailAddress>;
    getEnumerator(): IEnumerator;
    indexOf(item: MailAddress): int;
    insert(index: int, item: MailAddress): void;
    insert(index: int, value: unknown): void;
    remove(item: MailAddress): boolean;
    remove(value: unknown): void;
    removeAt(index: int): void;
    toString(): string;
}


export const MailAddressCollection: {
    new(): MailAddressCollection$instance;
};


export interface __MailAddressCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<MailAddress>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<MailAddress>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<MailAddress>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<MailAddress>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type MailAddressCollection = MailAddressCollection$instance & __MailAddressCollection$views;


export interface MailMessage$instance {
    readonly alternateViews: AlternateViewCollection;
    readonly attachments: AttachmentCollection;
    readonly bcc: MailAddressCollection;
    body: string;
    bodyEncoding: Encoding;
    bodyTransferEncoding: TransferEncoding;
    readonly CC: MailAddressCollection;
    deliveryNotificationOptions: DeliveryNotificationOptions;
    from_: MailAddress;
    readonly headers: NameValueCollection;
    headersEncoding: Encoding;
    isBodyHtml: boolean;
    priority: MailPriority;
    replyTo: MailAddress;
    readonly replyToList: MailAddressCollection;
    sender: MailAddress;
    subject: string;
    subjectEncoding: Encoding;
    readonly to: MailAddressCollection;
    dispose(): void;
}


export const MailMessage: {
    new(): MailMessage$instance;
    new(from_: string, to: string): MailMessage$instance;
    new(from_: string, to: string, subject: string, body: string): MailMessage$instance;
    new(from_: MailAddress, to: MailAddress): MailMessage$instance;
};


export interface __MailMessage$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MailMessage$instance extends System_Internal.IDisposable$instance {}

export type MailMessage = MailMessage$instance & __MailMessage$views;


export interface SmtpClient$instance {
    readonly clientCertificates: X509CertificateCollection;
    credentials: ICredentialsByHost;
    deliveryFormat: SmtpDeliveryFormat;
    deliveryMethod: SmtpDeliveryMethod;
    enableSsl: boolean;
    host: string;
    pickupDirectoryLocation: string;
    port: int;
    readonly servicePoint: ServicePoint;
    targetName: string;
    timeout: int;
    useDefaultCredentials: boolean;
    dispose(): void;
    send(from_: string, recipients: string, subject: string, body: string): void;
    send(message: MailMessage): void;
    sendAsync(from_: string, recipients: string, subject: string, body: string, userToken: unknown): void;
    sendAsync(message: MailMessage, userToken: unknown): void;
    sendAsyncCancel(): void;
    sendMailAsync(from_: string, recipients: string, subject: string, body: string): Task;
    sendMailAsync(message: MailMessage): Task;
    sendMailAsync(from_: string, recipients: string, subject: string, body: string, cancellationToken: CancellationToken): Task;
    sendMailAsync(message: MailMessage, cancellationToken: CancellationToken): Task;
}


export const SmtpClient: {
    new(): SmtpClient$instance;
    new(host: string): SmtpClient$instance;
    new(host: string, port: int): SmtpClient$instance;
};


export interface __SmtpClient$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface SmtpClient$instance extends System_Internal.IDisposable$instance {}

export type SmtpClient = SmtpClient$instance & __SmtpClient$views;


export interface SmtpException$instance extends Exception {
    statusCode: SmtpStatusCode;
    getObjectData(serializationInfo: SerializationInfo, streamingContext: StreamingContext): void;
}


export const SmtpException: {
    new(statusCode: SmtpStatusCode): SmtpException$instance;
    new(statusCode: SmtpStatusCode, message: string): SmtpException$instance;
    new(): SmtpException$instance;
    new(message: string): SmtpException$instance;
    new(message: string, innerException: Exception): SmtpException$instance;
};


export interface __SmtpException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SmtpException = SmtpException$instance & __SmtpException$views;


export interface SmtpFailedRecipientException$instance extends SmtpException$instance {
    readonly failedRecipient: string;
    getObjectData(serializationInfo: SerializationInfo, streamingContext: StreamingContext): void;
}


export const SmtpFailedRecipientException: {
    new(): SmtpFailedRecipientException$instance;
    new(message: string): SmtpFailedRecipientException$instance;
    new(message: string, innerException: Exception): SmtpFailedRecipientException$instance;
    new(statusCode: SmtpStatusCode, failedRecipient: string): SmtpFailedRecipientException$instance;
    new(statusCode: SmtpStatusCode, failedRecipient: string, serverResponse: string): SmtpFailedRecipientException$instance;
    new(message: string, failedRecipient: string, innerException: Exception): SmtpFailedRecipientException$instance;
};


export interface __SmtpFailedRecipientException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SmtpFailedRecipientException = SmtpFailedRecipientException$instance & __SmtpFailedRecipientException$views;


export interface SmtpFailedRecipientsException$instance extends SmtpFailedRecipientException$instance {
    readonly innerExceptions: SmtpFailedRecipientException[];
    getObjectData(serializationInfo: SerializationInfo, streamingContext: StreamingContext): void;
}


export const SmtpFailedRecipientsException: {
    new(): SmtpFailedRecipientsException$instance;
    new(message: string): SmtpFailedRecipientsException$instance;
    new(message: string, innerException: Exception): SmtpFailedRecipientsException$instance;
    new(message: string, innerExceptions: SmtpFailedRecipientException[]): SmtpFailedRecipientsException$instance;
};


export interface __SmtpFailedRecipientsException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SmtpFailedRecipientsException = SmtpFailedRecipientsException$instance & __SmtpFailedRecipientsException$views;


