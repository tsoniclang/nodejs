// Generated by tsbindgen - Architecture
// Namespace: System.IO.Pipelines
// Assembly: System.IO.Pipelines

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Buffers_Internal from "../../System.Buffers/internal/index.js";
import type { IBufferWriter_1, MemoryPool_1, ReadOnlySequence_1 } from "../../System.Buffers/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { Task, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Action_2, Boolean as ClrBoolean, Byte, Exception, Int32, Int64, Memory_1, Object as ClrObject, ReadOnlyMemory_1, SequencePosition, Span_1, String as ClrString, Type, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface IDuplexPipe$instance {
    readonly input: PipeReader;
    readonly output: PipeWriter;
}


export type IDuplexPipe = IDuplexPipe$instance;

export interface FlushResult$instance {
    readonly isCanceled: boolean;
    readonly isCompleted: boolean;
}


export const FlushResult: {
    new(isCanceled: boolean, isCompleted: boolean): FlushResult$instance;
};


export type FlushResult = FlushResult$instance;

export interface ReadResult$instance {
    readonly buffer: ReadOnlySequence_1<CLROf<byte>>;
    readonly isCanceled: boolean;
    readonly isCompleted: boolean;
}


export const ReadResult: {
    new(buffer: ReadOnlySequence_1<CLROf<byte>>, isCanceled: boolean, isCompleted: boolean): ReadResult$instance;
};


export type ReadResult = ReadResult$instance;

export interface Pipe$instance {
    readonly reader: PipeReader;
    readonly writer: PipeWriter;
    reset(): void;
}


export const Pipe: {
    new(): Pipe$instance;
    new(options: PipeOptions): Pipe$instance;
};


export type Pipe = Pipe$instance;

export interface PipeOptions$instance {
    readonly minimumSegmentSize: int;
    readonly pauseWriterThreshold: long;
    readonly pool: MemoryPool_1<CLROf<byte>>;
    readonly readerScheduler: PipeScheduler;
    readonly resumeWriterThreshold: long;
    readonly useSynchronizationContext: boolean;
    readonly writerScheduler: PipeScheduler;
}


export const PipeOptions: {
    new(pool: MemoryPool_1<CLROf<byte>>, readerScheduler: PipeScheduler, writerScheduler: PipeScheduler, pauseWriterThreshold: long, resumeWriterThreshold: long, minimumSegmentSize: int, useSynchronizationContext: boolean): PipeOptions$instance;
    readonly default_: PipeOptions;
};


export type PipeOptions = PipeOptions$instance;

export interface PipeReader$instance {
    advanceTo(consumed: SequencePosition): void;
    advanceTo(consumed: SequencePosition, examined: SequencePosition): void;
    asStream(leaveOpen?: boolean): Stream;
    cancelPendingRead(): void;
    complete(exception?: Exception): void;
    completeAsync(exception?: Exception): ValueTask;
    copyToAsync(destination: PipeWriter, cancellationToken?: CancellationToken): Task;
    copyToAsync(destination: Stream, cancellationToken?: CancellationToken): Task;
    onWriterCompleted(callback: Action_2<Exception, unknown>, state: unknown): void;
    readAsync(cancellationToken?: CancellationToken): ValueTask_1<ReadResult>;
    readAtLeastAsync(minimumSize: int, cancellationToken?: CancellationToken): ValueTask_1<ReadResult>;
    tryRead(result: { value: ref<ReadResult> }): boolean;
}


export const PipeReader: {
    create(sequence: ReadOnlySequence_1<CLROf<byte>>): PipeReader;
    create(stream: Stream, readerOptions?: StreamPipeReaderOptions): PipeReader;
};


export type PipeReader = PipeReader$instance;

export interface PipeScheduler$instance {
    schedule(action: Action_1<unknown>, state: unknown): void;
}


export const PipeScheduler: {
    readonly threadPool: PipeScheduler;
    readonly inline: PipeScheduler;
};


export type PipeScheduler = PipeScheduler$instance;

export interface PipeWriter$instance {
    readonly canGetUnflushedBytes: boolean;
    readonly unflushedBytes: long;
    advance(bytes: int): void;
    asStream(leaveOpen?: boolean): Stream;
    cancelPendingFlush(): void;
    complete(exception?: Exception): void;
    completeAsync(exception?: Exception): ValueTask;
    flushAsync(cancellationToken?: CancellationToken): ValueTask_1<FlushResult>;
    getMemory(sizeHint?: int): Memory_1<CLROf<byte>>;
    getSpan(sizeHint?: int): Span_1<CLROf<byte>>;
    onReaderCompleted(callback: Action_2<Exception, unknown>, state: unknown): void;
    writeAsync(source: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<FlushResult>;
}


export const PipeWriter: {
    create(stream: Stream, writerOptions?: StreamPipeWriterOptions): PipeWriter;
};


export interface __PipeWriter$views {
    As_IBufferWriter_1(): System_Buffers_Internal.IBufferWriter_1$instance<CLROf<byte>>;
}

export interface PipeWriter$instance extends System_Buffers_Internal.IBufferWriter_1$instance<CLROf<byte>> {}

export type PipeWriter = PipeWriter$instance & __PipeWriter$views;


export interface StreamPipeReaderOptions$instance {
    readonly bufferSize: int;
    readonly leaveOpen: boolean;
    readonly minimumReadSize: int;
    readonly pool: MemoryPool_1<CLROf<byte>>;
    readonly useZeroByteReads: boolean;
}


export const StreamPipeReaderOptions: {
    new(pool: MemoryPool_1<CLROf<byte>>, bufferSize: int, minimumReadSize: int, leaveOpen: boolean): StreamPipeReaderOptions$instance;
    new(pool: MemoryPool_1<CLROf<byte>>, bufferSize: int, minimumReadSize: int, leaveOpen: boolean, useZeroByteReads: boolean): StreamPipeReaderOptions$instance;
};


export type StreamPipeReaderOptions = StreamPipeReaderOptions$instance;

export interface StreamPipeWriterOptions$instance {
    readonly leaveOpen: boolean;
    readonly minimumBufferSize: int;
    readonly pool: MemoryPool_1<CLROf<byte>>;
}


export const StreamPipeWriterOptions: {
    new(pool: MemoryPool_1<CLROf<byte>>, minimumBufferSize: int, leaveOpen: boolean): StreamPipeWriterOptions$instance;
};


export type StreamPipeWriterOptions = StreamPipeWriterOptions$instance;

export abstract class StreamPipeExtensions$instance {
    static copyToAsync(source: Stream, destination: PipeWriter, cancellationToken?: CancellationToken): Task;
}


export type StreamPipeExtensions = StreamPipeExtensions$instance;

