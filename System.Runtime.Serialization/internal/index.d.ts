// Generated by tsbindgen - Architecture
// Namespace: System.Runtime.Serialization
// Assembly: System.Private.CoreLib, System.Private.DataContractSerialization, System.Runtime.Serialization.Formatters, System.Runtime.Serialization.Primitives

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { ICollection_1, IEnumerable_1 } from "../../System.Collections.Generic/internal/index.js";
import type { Collection_1, ReadOnlyCollection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IDictionary, IEnumerator } from "../../System.Collections/internal/index.js";
import type { DateTimeStyles } from "../../System.Globalization/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { Assembly, ConstructorInfo, MemberInfo, MethodBase, MethodInfo, PropertyInfo } from "../../System.Reflection/internal/index.js";
import type { TypeFilterLevel } from "../../System.Runtime.Serialization.Formatters/internal/index.js";
import type { StringBuilder } from "../../System.Text/internal/index.js";
import type { XmlSchemaSet, XmlSchemaType } from "../../System.Xml.Schema/internal/index.js";
import type { XmlDictionaryReader, XmlDictionaryString, XmlDictionaryWriter, XmlNamespaceManager, XmlNode, XmlQualifiedName, XmlReader, XmlWriter } from "../../System.Xml/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Char, DateTime, Decimal, Delegate, Double, Enum, EventArgs, Exception, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, MulticastDelegate, Object as ClrObject, SByte, Single, String as ClrString, SystemException, Type, TypeCode, UInt16, UInt32, UInt64, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum EmitTypeInformation {
    asNeeded = 0,
    always = 1,
    never_ = 2
}


export enum StreamingContextStates {
    crossProcess = 1,
    crossMachine = 2,
    file = 4,
    persistence = 8,
    remoting = 16,
    other = 32,
    clone = 64,
    crossAppDomain = 128,
    all = 255
}


export type SerializationEventHandler = (context: StreamingContext) => void;


export interface IDeserializationCallback$instance {
    onDeserialization(sender: unknown): void;
}


export type IDeserializationCallback = IDeserializationCallback$instance;

export interface IExtensibleDataObject$instance {
    extensionData: ExtensionDataObject;
}


export type IExtensibleDataObject = IExtensibleDataObject$instance;

export interface IFormatter$instance {
    surrogateSelector: ISurrogateSelector;
    binder: SerializationBinder;
    context: StreamingContext;
    deserialize(serializationStream: Stream): unknown;
    serialize(serializationStream: Stream, graph: unknown): void;
}


export type IFormatter = IFormatter$instance;

export interface IFormatterConverter$instance {
    convert(value: unknown, type_: Type): unknown;
    convert(value: unknown, typeCode: TypeCode): unknown;
    toBoolean(value: unknown): boolean;
    toByte(value: unknown): byte;
    toChar(value: unknown): char;
    toDateTime(value: unknown): DateTime;
    toDecimal(value: unknown): decimal;
    toDouble(value: unknown): double;
    toInt16(value: unknown): short;
    toInt32(value: unknown): int;
    toInt64(value: unknown): long;
    toSByte(value: unknown): sbyte;
    toSingle(value: unknown): float;
    toString(value: unknown): string;
    toUInt16(value: unknown): ushort;
    toUInt32(value: unknown): uint;
    toUInt64(value: unknown): ulong;
}


export type IFormatterConverter = IFormatterConverter$instance;

export interface IObjectReference$instance {
    getRealObject(context: StreamingContext): unknown;
}


export type IObjectReference = IObjectReference$instance;

export interface ISafeSerializationData$instance {
    completeDeserialization(deserialized: unknown): void;
}


export type ISafeSerializationData = ISafeSerializationData$instance;

export interface ISerializable$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export type ISerializable = ISerializable$instance;

export interface ISerializationSurrogate$instance {
    getObjectData(obj: unknown, info: SerializationInfo, context: StreamingContext): void;
    setObjectData(obj: unknown, info: SerializationInfo, context: StreamingContext, selector: ISurrogateSelector): unknown;
}


export type ISerializationSurrogate = ISerializationSurrogate$instance;

export interface ISerializationSurrogateProvider$instance {
    getObjectToSerialize(obj: unknown, targetType: Type): unknown;
    getSurrogateType(type_: Type): Type;
}


export type ISerializationSurrogateProvider = ISerializationSurrogateProvider$instance;

export interface ISerializationSurrogateProvider2$instance extends ISerializationSurrogateProvider {
    getCustomDataToExport(memberInfo: MemberInfo, dataContractType: Type): unknown;
    getCustomDataToExport(runtimeType: Type, dataContractType: Type): unknown;
    getKnownCustomDataTypes(customDataTypes: Collection_1<Type>): void;
    getObjectToSerialize(obj: unknown, targetType: Type): unknown;
    getReferencedTypeOnImport(typeName: string, typeNamespace: string, customData: unknown): Type;
    getSurrogateType(type_: Type): Type;
}


export interface ISerializationSurrogateProvider2$instance extends ISerializationSurrogateProvider$instance {}

export type ISerializationSurrogateProvider2 = ISerializationSurrogateProvider2$instance;

export interface ISurrogateSelector$instance {
    chainSelector(selector: ISurrogateSelector): void;
    getNextSelector(): ISurrogateSelector;
    getSurrogate(type_: Type, context: StreamingContext, selector: { value: ref<ISurrogateSelector> }): ISerializationSurrogate;
}


export type ISurrogateSelector = ISurrogateSelector$instance;

export interface DeserializationToken$instance {
    dispose(): void;
}


export const DeserializationToken: {
    new(): DeserializationToken$instance;
};


export interface __DeserializationToken$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DeserializationToken$instance extends System_Internal.IDisposable$instance {}

export type DeserializationToken = DeserializationToken$instance & __DeserializationToken$views;


export interface SerializationEntry$instance {
    readonly name: string;
    readonly objectType: Type;
    readonly value: unknown;
}


export const SerializationEntry: {
    new(): SerializationEntry$instance;
};


export type SerializationEntry = SerializationEntry$instance;

export interface StreamingContext$instance {
    readonly context: unknown;
    readonly state: StreamingContextStates;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const StreamingContext: {
    new(state: StreamingContextStates): StreamingContext$instance;
    new(state: StreamingContextStates, additional: unknown): StreamingContext$instance;
};


export type StreamingContext = StreamingContext$instance;

export interface CollectionDataContractAttribute$instance extends Attribute {
    readonly isItemNameSetExplicitly: boolean;
    readonly isKeyNameSetExplicitly: boolean;
    readonly isNameSetExplicitly: boolean;
    readonly isNamespaceSetExplicitly: boolean;
    isReference: boolean;
    readonly isReferenceSetExplicitly: boolean;
    readonly isValueNameSetExplicitly: boolean;
    itemName: string;
    keyName: string;
    name: string;
    namespace_: string;
    valueName: string;
}


export const CollectionDataContractAttribute: {
    new(): CollectionDataContractAttribute$instance;
};


export type CollectionDataContractAttribute = CollectionDataContractAttribute$instance;

export interface ContractNamespaceAttribute$instance extends Attribute {
    clrNamespace: string;
    readonly contractNamespace: string;
}


export const ContractNamespaceAttribute: {
    new(contractNamespace: string): ContractNamespaceAttribute$instance;
};


export type ContractNamespaceAttribute = ContractNamespaceAttribute$instance;

export interface DataContractAttribute$instance extends Attribute {
    readonly isNameSetExplicitly: boolean;
    readonly isNamespaceSetExplicitly: boolean;
    isReference: boolean;
    readonly isReferenceSetExplicitly: boolean;
    name: string;
    namespace_: string;
}


export const DataContractAttribute: {
    new(): DataContractAttribute$instance;
};


export type DataContractAttribute = DataContractAttribute$instance;

export interface DataContractResolver$instance {
    resolveName(typeName: string, typeNamespace: string, declaredType: Type, knownTypeResolver: DataContractResolver): Type;
    tryResolveType(type_: Type, declaredType: Type, knownTypeResolver: DataContractResolver, typeName: { value: ref<XmlDictionaryString> }, typeNamespace: { value: ref<XmlDictionaryString> }): boolean;
}


export const DataContractResolver: {
};


export type DataContractResolver = DataContractResolver$instance;

export interface DataContractSerializer$instance extends XmlObjectSerializer {
    readonly dataContractResolver: DataContractResolver;
    readonly ignoreExtensionDataObject: boolean;
    readonly knownTypes: ReadOnlyCollection_1<Type>;
    readonly maxItemsInObjectGraph: int;
    readonly preserveObjectReferences: boolean;
    readonly serializeReadOnlyTypes: boolean;
    isStartObject(reader: XmlReader): boolean;
    isStartObject(reader: XmlDictionaryReader): boolean;
    readObject(reader: XmlReader): unknown;
    readObject(reader: XmlReader, verifyObjectName: boolean): unknown;
    readObject(reader: XmlDictionaryReader, verifyObjectName: boolean): unknown;
    readObject(reader: XmlDictionaryReader, verifyObjectName: boolean, dataContractResolver: DataContractResolver): unknown;
    readObject(stream: Stream): unknown;
    readObject(reader: XmlDictionaryReader): unknown;
    writeEndObject(writer: XmlWriter): void;
    writeEndObject(writer: XmlDictionaryWriter): void;
    writeObject(writer: XmlWriter, graph: unknown): void;
    writeObject(writer: XmlDictionaryWriter, graph: unknown, dataContractResolver: DataContractResolver): void;
    writeObject(stream: Stream, graph: unknown): void;
    writeObject(writer: XmlDictionaryWriter, graph: unknown): void;
    writeObjectContent(writer: XmlWriter, graph: unknown): void;
    writeObjectContent(writer: XmlDictionaryWriter, graph: unknown): void;
    writeStartObject(writer: XmlWriter, graph: unknown): void;
    writeStartObject(writer: XmlDictionaryWriter, graph: unknown): void;
}


export const DataContractSerializer: {
    new(type_: Type): DataContractSerializer$instance;
    new(type_: Type, knownTypes: IEnumerable_1<Type>): DataContractSerializer$instance;
    new(type_: Type, rootName: string, rootNamespace: string): DataContractSerializer$instance;
    new(type_: Type, rootName: string, rootNamespace: string, knownTypes: IEnumerable_1<Type>): DataContractSerializer$instance;
    new(type_: Type, rootName: XmlDictionaryString, rootNamespace: XmlDictionaryString): DataContractSerializer$instance;
    new(type_: Type, rootName: XmlDictionaryString, rootNamespace: XmlDictionaryString, knownTypes: IEnumerable_1<Type>): DataContractSerializer$instance;
    new(type_: Type, settings: DataContractSerializerSettings): DataContractSerializer$instance;
};


export type DataContractSerializer = DataContractSerializer$instance;

export interface DataContractSerializerSettings$instance {
    dataContractResolver: DataContractResolver;
    ignoreExtensionDataObject: boolean;
    knownTypes: IEnumerable_1<Type>;
    maxItemsInObjectGraph: int;
    preserveObjectReferences: boolean;
    rootName: XmlDictionaryString;
    rootNamespace: XmlDictionaryString;
    serializeReadOnlyTypes: boolean;
}


export const DataContractSerializerSettings: {
    new(): DataContractSerializerSettings$instance;
};


export type DataContractSerializerSettings = DataContractSerializerSettings$instance;

export interface DataMemberAttribute$instance extends Attribute {
    emitDefaultValue: boolean;
    readonly isNameSetExplicitly: boolean;
    isRequired: boolean;
    name: string;
    order: int;
}


export const DataMemberAttribute: {
    new(): DataMemberAttribute$instance;
};


export type DataMemberAttribute = DataMemberAttribute$instance;

export interface DateTimeFormat$instance {
    dateTimeStyles: DateTimeStyles;
    readonly formatProvider: IFormatProvider;
    readonly formatString: string;
}


export const DateTimeFormat: {
    new(formatString: string): DateTimeFormat$instance;
    new(formatString: string, formatProvider: IFormatProvider): DateTimeFormat$instance;
};


export type DateTimeFormat = DateTimeFormat$instance;

export interface EnumMemberAttribute$instance extends Attribute {
    readonly isValueSetExplicitly: boolean;
    value: string;
}


export const EnumMemberAttribute: {
    new(): EnumMemberAttribute$instance;
};


export type EnumMemberAttribute = EnumMemberAttribute$instance;

export interface ExportOptions$instance {
    dataContractSurrogate: ISerializationSurrogateProvider;
    readonly knownTypes: Collection_1<Type>;
}


export const ExportOptions: {
    new(): ExportOptions$instance;
};


export type ExportOptions = ExportOptions$instance;

export interface ExtensionDataObject$instance {
}


export const ExtensionDataObject: {
    new(): ExtensionDataObject$instance;
};


export type ExtensionDataObject = ExtensionDataObject$instance;

export interface Formatter$instance {
    binder: SerializationBinder;
    context: StreamingContext;
    surrogateSelector: ISurrogateSelector;
    deserialize(serializationStream: Stream): unknown;
    serialize(serializationStream: Stream, graph: unknown): void;
}


export const Formatter: {
};


export interface __Formatter$views {
    As_IFormatter(): IFormatter$instance;
}

export interface Formatter$instance extends IFormatter$instance {}

export type Formatter = Formatter$instance & __Formatter$views;


export interface FormatterConverter$instance {
    convert(value: unknown, type_: Type): unknown;
    convert(value: unknown, typeCode: TypeCode): unknown;
    toBoolean(value: unknown): boolean;
    toByte(value: unknown): byte;
    toChar(value: unknown): char;
    toDateTime(value: unknown): DateTime;
    toDecimal(value: unknown): decimal;
    toDouble(value: unknown): double;
    toInt16(value: unknown): short;
    toInt32(value: unknown): int;
    toInt64(value: unknown): long;
    toSByte(value: unknown): sbyte;
    toSingle(value: unknown): float;
    toString(value: unknown): string;
    toUInt16(value: unknown): ushort;
    toUInt32(value: unknown): uint;
    toUInt64(value: unknown): ulong;
}


export const FormatterConverter: {
    new(): FormatterConverter$instance;
};


export interface __FormatterConverter$views {
    As_IFormatterConverter(): IFormatterConverter$instance;
}

export type FormatterConverter = FormatterConverter$instance & __FormatterConverter$views;


export interface IgnoreDataMemberAttribute$instance extends Attribute {
}


export const IgnoreDataMemberAttribute: {
    new(): IgnoreDataMemberAttribute$instance;
};


export type IgnoreDataMemberAttribute = IgnoreDataMemberAttribute$instance;

export interface InvalidDataContractException$instance extends Exception {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const InvalidDataContractException: {
    new(): InvalidDataContractException$instance;
    new(message: string): InvalidDataContractException$instance;
    new(message: string, innerException: Exception): InvalidDataContractException$instance;
};


export interface __InvalidDataContractException$views {
    As_ISerializable(): ISerializable$instance;
}

export type InvalidDataContractException = InvalidDataContractException$instance & __InvalidDataContractException$views;


export interface KnownTypeAttribute$instance extends Attribute {
    readonly methodName: string;
    readonly type_: Type;
}


export const KnownTypeAttribute: {
    new(type_: Type): KnownTypeAttribute$instance;
    new(methodName: string): KnownTypeAttribute$instance;
};


export type KnownTypeAttribute = KnownTypeAttribute$instance;

export interface ObjectIDGenerator$instance {
    getId(obj: unknown, firstTime: { value: ref<boolean> }): long;
    hasId(obj: unknown, firstTime: { value: ref<boolean> }): long;
}


export const ObjectIDGenerator: {
    new(): ObjectIDGenerator$instance;
};


export type ObjectIDGenerator = ObjectIDGenerator$instance;

export interface ObjectManager$instance {
    doFixups(): void;
    getObject(objectID: long): unknown;
    raiseDeserializationEvent(): void;
    raiseOnDeserializingEvent(obj: unknown): void;
    recordArrayElementFixup(arrayToBeFixed: long, index: int, objectRequired: long): void;
    recordArrayElementFixup(arrayToBeFixed: long, indices: int[], objectRequired: long): void;
    recordDelayedFixup(objectToBeFixed: long, memberName: string, objectRequired: long): void;
    recordFixup(objectToBeFixed: long, member: MemberInfo, objectRequired: long): void;
    registerObject(obj: unknown, objectID: long): void;
    registerObject(obj: unknown, objectID: long, info: SerializationInfo): void;
    registerObject(obj: unknown, objectID: long, info: SerializationInfo, idOfContainingObj: long, member: MemberInfo): void;
    registerObject(obj: unknown, objectID: long, info: SerializationInfo, idOfContainingObj: long, member: MemberInfo, arrayIndex: int[]): void;
}


export const ObjectManager: {
    new(selector: ISurrogateSelector, context: StreamingContext): ObjectManager$instance;
};


export type ObjectManager = ObjectManager$instance;

export interface OnDeserializedAttribute$instance extends Attribute {
}


export const OnDeserializedAttribute: {
    new(): OnDeserializedAttribute$instance;
};


export type OnDeserializedAttribute = OnDeserializedAttribute$instance;

export interface OnDeserializingAttribute$instance extends Attribute {
}


export const OnDeserializingAttribute: {
    new(): OnDeserializingAttribute$instance;
};


export type OnDeserializingAttribute = OnDeserializingAttribute$instance;

export interface OnSerializedAttribute$instance extends Attribute {
}


export const OnSerializedAttribute: {
    new(): OnSerializedAttribute$instance;
};


export type OnSerializedAttribute = OnSerializedAttribute$instance;

export interface OnSerializingAttribute$instance extends Attribute {
}


export const OnSerializingAttribute: {
    new(): OnSerializingAttribute$instance;
};


export type OnSerializingAttribute = OnSerializingAttribute$instance;

export interface OptionalFieldAttribute$instance extends Attribute {
    versionAdded: int;
}


export const OptionalFieldAttribute: {
    new(): OptionalFieldAttribute$instance;
};


export type OptionalFieldAttribute = OptionalFieldAttribute$instance;

export interface SafeSerializationEventArgs$instance extends EventArgs {
    readonly streamingContext: StreamingContext;
    addSerializedState(serializedState: ISafeSerializationData): void;
}


export const SafeSerializationEventArgs: {
    new(): SafeSerializationEventArgs$instance;
};


export type SafeSerializationEventArgs = SafeSerializationEventArgs$instance;

export interface SerializationBinder$instance {
    bindToName(serializedType: Type, assemblyName: { value: ref<string> }, typeName: { value: ref<string> }): void;
    bindToType(assemblyName: string, typeName: string): Type;
}


export const SerializationBinder: {
};


export type SerializationBinder = SerializationBinder$instance;

export interface SerializationException$instance extends SystemException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SerializationException: {
    new(): SerializationException$instance;
    new(message: string): SerializationException$instance;
    new(message: string, innerException: Exception): SerializationException$instance;
};


export interface __SerializationException$views {
    As_ISerializable(): ISerializable$instance;
}

export type SerializationException = SerializationException$instance & __SerializationException$views;


export interface SerializationInfo$instance {
    assemblyName: string;
    fullTypeName: string;
    readonly isAssemblyNameSetExplicit: boolean;
    readonly isFullTypeNameSetExplicit: boolean;
    readonly memberCount: int;
    readonly objectType: Type;
    addValue(name: string, value: unknown, type_: Type): void;
    addValue(name: string, value: unknown): void;
    addValue(name: string, value: boolean): void;
    addValue(name: string, value: char): void;
    addValue(name: string, value: sbyte): void;
    addValue(name: string, value: byte): void;
    addValue(name: string, value: short): void;
    addValue(name: string, value: ushort): void;
    addValue(name: string, value: int): void;
    addValue(name: string, value: uint): void;
    addValue(name: string, value: long): void;
    addValue(name: string, value: ulong): void;
    addValue(name: string, value: float): void;
    addValue(name: string, value: double): void;
    addValue(name: string, value: decimal): void;
    addValue(name: string, value: DateTime): void;
    getBoolean(name: string): boolean;
    getByte(name: string): byte;
    getChar(name: string): char;
    getDateTime(name: string): DateTime;
    getDecimal(name: string): decimal;
    getDouble(name: string): double;
    getEnumerator(): SerializationInfoEnumerator;
    getInt16(name: string): short;
    getInt32(name: string): int;
    getInt64(name: string): long;
    getSByte(name: string): sbyte;
    getSingle(name: string): float;
    getString(name: string): string;
    getUInt16(name: string): ushort;
    getUInt32(name: string): uint;
    getUInt64(name: string): ulong;
    getValue(name: string, type_: Type): unknown;
    setType(type_: Type): void;
}


export const SerializationInfo: {
    new(type_: Type, converter: IFormatterConverter): SerializationInfo$instance;
    new(type_: Type, converter: IFormatterConverter, requireSameTokenInPartialTrust: boolean): SerializationInfo$instance;
    startDeserialization(): DeserializationToken;
};


export type SerializationInfo = SerializationInfo$instance;

export interface SerializationInfoEnumerator$instance {
    readonly current: SerializationEntry | unknown;
    readonly name: string;
    readonly objectType: Type;
    readonly value: unknown;
    moveNext(): boolean;
    reset(): void;
}


export const SerializationInfoEnumerator: {
    new(): SerializationInfoEnumerator$instance;
};


export interface __SerializationInfoEnumerator$views {
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type SerializationInfoEnumerator = SerializationInfoEnumerator$instance & __SerializationInfoEnumerator$views;


export interface SerializationObjectManager$instance {
    raiseOnSerializedEvent(): void;
    registerObject(obj: unknown): void;
}


export const SerializationObjectManager: {
    new(context: StreamingContext): SerializationObjectManager$instance;
};


export type SerializationObjectManager = SerializationObjectManager$instance;

export interface SurrogateSelector$instance {
    addSurrogate(type_: Type, context: StreamingContext, surrogate: ISerializationSurrogate): void;
    chainSelector(selector: ISurrogateSelector): void;
    getNextSelector(): ISurrogateSelector;
    getSurrogate(type_: Type, context: StreamingContext, selector: { value: ref<ISurrogateSelector> }): ISerializationSurrogate;
    removeSurrogate(type_: Type, context: StreamingContext): void;
}


export const SurrogateSelector: {
    new(): SurrogateSelector$instance;
};


export interface __SurrogateSelector$views {
    As_ISurrogateSelector(): ISurrogateSelector$instance;
}

export interface SurrogateSelector$instance extends ISurrogateSelector$instance {}

export type SurrogateSelector = SurrogateSelector$instance & __SurrogateSelector$views;


export interface TypeLoadExceptionHolder$instance {
}


export const TypeLoadExceptionHolder: {
    new(): TypeLoadExceptionHolder$instance;
};


export type TypeLoadExceptionHolder = TypeLoadExceptionHolder$instance;

export interface XmlObjectSerializer$instance {
    isStartObject(reader: XmlReader): boolean;
    isStartObject(reader: XmlDictionaryReader): boolean;
    readObject(stream: Stream): unknown;
    readObject(reader: XmlReader): unknown;
    readObject(reader: XmlDictionaryReader): unknown;
    readObject(reader: XmlReader, verifyObjectName: boolean): unknown;
    readObject(reader: XmlDictionaryReader, verifyObjectName: boolean): unknown;
    writeEndObject(writer: XmlDictionaryWriter): void;
    writeEndObject(writer: XmlWriter): void;
    writeObject(stream: Stream, graph: unknown): void;
    writeObject(writer: XmlWriter, graph: unknown): void;
    writeObject(writer: XmlDictionaryWriter, graph: unknown): void;
    writeObjectContent(writer: XmlDictionaryWriter, graph: unknown): void;
    writeObjectContent(writer: XmlWriter, graph: unknown): void;
    writeStartObject(writer: XmlDictionaryWriter, graph: unknown): void;
    writeStartObject(writer: XmlWriter, graph: unknown): void;
}


export const XmlObjectSerializer: {
};


export type XmlObjectSerializer = XmlObjectSerializer$instance;

export interface XsdDataContractExporter$instance {
    options: ExportOptions;
    readonly schemas: XmlSchemaSet;
    canExport(assemblies: ICollection_1<Assembly>): boolean;
    canExport(types: ICollection_1<Type>): boolean;
    canExport(type_: Type): boolean;
    export_(assemblies: ICollection_1<Assembly>): void;
    export_(types: ICollection_1<Type>): void;
    export_(type_: Type): void;
    getRootElementName(type_: Type): XmlQualifiedName;
    getSchemaType(type_: Type): XmlSchemaType;
    getSchemaTypeName(type_: Type): XmlQualifiedName;
}


export const XsdDataContractExporter: {
    new(): XsdDataContractExporter$instance;
    new(schemas: XmlSchemaSet): XsdDataContractExporter$instance;
};


export type XsdDataContractExporter = XsdDataContractExporter$instance;

export abstract class DataContractSerializerExtensions$instance {
    static getSerializationSurrogateProvider(serializer: DataContractSerializer): ISerializationSurrogateProvider;
    static setSerializationSurrogateProvider(serializer: DataContractSerializer, provider: ISerializationSurrogateProvider): void;
}


export type DataContractSerializerExtensions = DataContractSerializerExtensions$instance;

export abstract class FormatterServices$instance {
    static checkTypeSecurity(t: Type, securityLevel: TypeFilterLevel): void;
    static getObjectData(obj: unknown, members: MemberInfo[]): unknown[];
    static getSafeUninitializedObject(type_: Type): unknown;
    static getSerializableMembers(type_: Type, context: StreamingContext): MemberInfo[];
    static getSerializableMembers(type_: Type): MemberInfo[];
    static getSurrogateForCyclicalReference(innerSurrogate: ISerializationSurrogate): ISerializationSurrogate;
    static getTypeFromAssembly(assem: Assembly, name: string): Type;
    static getUninitializedObject(type_: Type): unknown;
    static populateObjectMembers(obj: unknown, members: MemberInfo[], data: unknown[]): unknown;
}


export type FormatterServices = FormatterServices$instance;

export abstract class JsonFormatGeneratorStatics$instance {
    static readonly boxPointer: MethodInfo;
    static readonly collectionItemNameProperty: PropertyInfo;
    static readonly extensionDataObjectCtor: ConstructorInfo;
    static readonly extensionDataProperty: PropertyInfo;
    static readonly getCurrentMethod: MethodInfo;
    static readonly getItemContractMethod: MethodInfo;
    static readonly getJsonDataContractMethod: MethodInfo;
    static readonly getJsonMemberIndexMethod: MethodInfo;
    static readonly getRevisedItemContractMethod: MethodInfo;
    static readonly getUninitializedObjectMethod: MethodInfo;
    static readonly isStartElementMethod0: MethodInfo;
    static readonly isStartElementMethod2: MethodInfo;
    static readonly localNameProperty: PropertyInfo;
    static readonly namespaceProperty: PropertyInfo;
    static readonly moveNextMethod: MethodInfo;
    static readonly moveToContentMethod: MethodInfo;
    static readonly nodeTypeProperty: PropertyInfo;
    static readonly onDeserializationMethod: MethodInfo;
    static readonly readJsonValueMethod: MethodInfo;
    static readonly serializationExceptionCtor: ConstructorInfo;
    static readonly serInfoCtorArgs: Type[];
    static readonly throwDuplicateMemberExceptionMethod: MethodInfo;
    static readonly throwMissingRequiredMembersMethod: MethodInfo;
    static readonly typeHandleProperty: PropertyInfo;
    static readonly unboxPointer: MethodInfo;
    static readonly useSimpleDictionaryFormatReadProperty: PropertyInfo;
    static readonly useSimpleDictionaryFormatWriteProperty: PropertyInfo;
    static readonly writeAttributeStringMethod: MethodInfo;
    static readonly writeEndElementMethod: MethodInfo;
    static readonly writeJsonISerializableMethod: MethodInfo;
    static readonly writeJsonNameWithMappingMethod: MethodInfo;
    static readonly writeJsonValueMethod: MethodInfo;
    static readonly writeStartElementMethod: MethodInfo;
    static readonly writeStartElementStringMethod: MethodInfo;
    static readonly parseEnumMethod: MethodInfo;
    static readonly getJsonMemberNameMethod: MethodInfo;
}


export type JsonFormatGeneratorStatics = JsonFormatGeneratorStatics$instance;

export abstract class XmlSerializableServices$instance {
    static addDefaultSchema(schemas: XmlSchemaSet, typeQName: XmlQualifiedName): void;
    static readNodes(xmlReader: XmlReader): XmlNode[];
    static writeNodes(xmlWriter: XmlWriter, nodes: XmlNode[]): void;
}


export type XmlSerializableServices = XmlSerializableServices$instance;

export abstract class XPathQueryGenerator$instance {
    static createFromDataContractSerializer(type_: Type, pathToMember: MemberInfo[], rootElementXpath: StringBuilder, namespaces: { value: ref<XmlNamespaceManager> }): string;
    static createFromDataContractSerializer(type_: Type, pathToMember: MemberInfo[], namespaces: { value: ref<XmlNamespaceManager> }): string;
}


export type XPathQueryGenerator = XPathQueryGenerator$instance;

