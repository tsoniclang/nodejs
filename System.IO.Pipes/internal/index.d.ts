// Generated by tsbindgen - Architecture
// Namespace: System.IO.Pipes
// Assembly: System.IO.Pipes, System.IO.Pipes.AccessControl

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { SafePipeHandle } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import * as System_IO_Internal from "../../System.IO/internal/index.js";
import type { HandleInheritability, SeekOrigin, Stream } from "../../System.IO/internal/index.js";
import type { MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Security_AccessControl_Internal from "../../System.Security.AccessControl/internal/index.js";
import type { AccessControlModification, AccessControlSections, AccessControlType, AccessRule, AuditFlags, AuditRule, AuthorizationRuleCollection, InheritanceFlags, NativeObjectSecurity, PropagationFlags } from "../../System.Security.AccessControl/internal/index.js";
import type { IdentityReference, TokenImpersonationLevel } from "../../System.Security.Principal/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { AsyncCallback, Boolean as ClrBoolean, Byte, Delegate, Enum, IAsyncDisposable, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, Int64, IntPtr, ISpanFormattable, Memory_1, MulticastDelegate, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, Span_1, String as ClrString, TimeSpan, Type, TypeCode, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum PipeAccessRights {
    readData = 1,
    writeData = 2,
    readAttributes = 128,
    writeAttributes = 256,
    readExtendedAttributes = 8,
    writeExtendedAttributes = 16,
    createNewInstance = 4,
    delete_ = 65536,
    readPermissions = 131072,
    changePermissions = 262144,
    takeOwnership = 524288,
    synchronize = 1048576,
    fullControl = 2032031,
    read = 131209,
    write = 274,
    readWrite = 131483,
    accessSystemSecurity = 16777216
}


export enum PipeDirection {
    in_ = 1,
    out = 2,
    inOut = 3
}


export enum PipeOptions {
    none = 0,
    writeThrough = -2147483648,
    asynchronous = 1073741824,
    currentUserOnly = 536870912,
    firstPipeInstance = 524288
}


export enum PipeTransmissionMode {
    byte = 0,
    message = 1
}


export type PipeStreamImpersonationWorker = () => void;


export interface AnonymousPipeClientStream$instance extends PipeStream$instance {
    readMode: PipeTransmissionMode;
    readonly transmissionMode: PipeTransmissionMode;
    dispose(): void;
    disposeAsync(): ValueTask;
}


export const AnonymousPipeClientStream: {
    new(pipeHandleAsString: string): AnonymousPipeClientStream$instance;
    new(direction: PipeDirection, pipeHandleAsString: string): AnonymousPipeClientStream$instance;
    new(direction: PipeDirection, safePipeHandle: SafePipeHandle): AnonymousPipeClientStream$instance;
};


export interface __AnonymousPipeClientStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type AnonymousPipeClientStream = AnonymousPipeClientStream$instance & __AnonymousPipeClientStream$views;


export interface AnonymousPipeServerStream$instance extends PipeStream$instance {
    readonly clientSafePipeHandle: SafePipeHandle;
    readMode: PipeTransmissionMode;
    readonly transmissionMode: PipeTransmissionMode;
    dispose(): void;
    disposeAsync(): ValueTask;
    disposeLocalCopyOfClientHandle(): void;
    getClientHandleAsString(): string;
}


export const AnonymousPipeServerStream: {
    new(): AnonymousPipeServerStream$instance;
    new(direction: PipeDirection): AnonymousPipeServerStream$instance;
    new(direction: PipeDirection, inheritability: HandleInheritability): AnonymousPipeServerStream$instance;
    new(direction: PipeDirection, serverSafePipeHandle: SafePipeHandle, clientSafePipeHandle: SafePipeHandle): AnonymousPipeServerStream$instance;
    new(direction: PipeDirection, inheritability: HandleInheritability, bufferSize: int): AnonymousPipeServerStream$instance;
};


export interface __AnonymousPipeServerStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type AnonymousPipeServerStream = AnonymousPipeServerStream$instance & __AnonymousPipeServerStream$views;


export interface NamedPipeClientStream$instance extends PipeStream$instance {
    readonly inBufferSize: int;
    readonly numberOfServerInstances: int;
    readonly outBufferSize: int;
    connect(): void;
    connect(timeout: int): void;
    connect(timeout: TimeSpan): void;
    connectAsync(): Task;
    connectAsync(timeout: int): Task;
    connectAsync(cancellationToken: CancellationToken): Task;
    connectAsync(timeout: int, cancellationToken: CancellationToken): Task;
    connectAsync(timeout: TimeSpan, cancellationToken?: CancellationToken): Task;
    dispose(): void;
    disposeAsync(): ValueTask;
}


export const NamedPipeClientStream: {
    new(pipeName: string): NamedPipeClientStream$instance;
    new(serverName: string, pipeName: string): NamedPipeClientStream$instance;
    new(serverName: string, pipeName: string, direction: PipeDirection): NamedPipeClientStream$instance;
    new(serverName: string, pipeName: string, direction: PipeDirection, options: PipeOptions): NamedPipeClientStream$instance;
    new(serverName: string, pipeName: string, direction: PipeDirection, options: PipeOptions, impersonationLevel: TokenImpersonationLevel): NamedPipeClientStream$instance;
    new(serverName: string, pipeName: string, direction: PipeDirection, options: PipeOptions, impersonationLevel: TokenImpersonationLevel, inheritability: HandleInheritability): NamedPipeClientStream$instance;
    new(direction: PipeDirection, isAsync: boolean, isConnected: boolean, safePipeHandle: SafePipeHandle): NamedPipeClientStream$instance;
    new(serverName: string, pipeName: string, desiredAccessRights: PipeAccessRights, options: PipeOptions, impersonationLevel: TokenImpersonationLevel, inheritability: HandleInheritability): NamedPipeClientStream$instance;
};


export interface __NamedPipeClientStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type NamedPipeClientStream = NamedPipeClientStream$instance & __NamedPipeClientStream$views;


export interface NamedPipeServerStream$instance extends PipeStream$instance {
    readonly inBufferSize: int;
    readonly outBufferSize: int;
    beginWaitForConnection(callback: AsyncCallback, state: unknown): IAsyncResult;
    disconnect(): void;
    dispose(): void;
    disposeAsync(): ValueTask;
    endWaitForConnection(asyncResult: IAsyncResult): void;
    getImpersonationUserName(): string;
    runAsClient(impersonationWorker: PipeStreamImpersonationWorker): void;
    waitForConnection(): void;
    waitForConnectionAsync(): Task;
    waitForConnectionAsync(cancellationToken: CancellationToken): Task;
}


export const NamedPipeServerStream: {
    new(pipeName: string): NamedPipeServerStream$instance;
    new(pipeName: string, direction: PipeDirection): NamedPipeServerStream$instance;
    new(pipeName: string, direction: PipeDirection, maxNumberOfServerInstances: int): NamedPipeServerStream$instance;
    new(pipeName: string, direction: PipeDirection, maxNumberOfServerInstances: int, transmissionMode: PipeTransmissionMode): NamedPipeServerStream$instance;
    new(pipeName: string, direction: PipeDirection, maxNumberOfServerInstances: int, transmissionMode: PipeTransmissionMode, options: PipeOptions): NamedPipeServerStream$instance;
    new(pipeName: string, direction: PipeDirection, maxNumberOfServerInstances: int, transmissionMode: PipeTransmissionMode, options: PipeOptions, inBufferSize: int, outBufferSize: int): NamedPipeServerStream$instance;
    new(direction: PipeDirection, isAsync: boolean, isConnected: boolean, safePipeHandle: SafePipeHandle): NamedPipeServerStream$instance;
    readonly maxAllowedServerInstances: int;
};


export interface __NamedPipeServerStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type NamedPipeServerStream = NamedPipeServerStream$instance & __NamedPipeServerStream$views;


export interface PipeAccessRule$instance extends AccessRule {
    readonly pipeAccessRights: PipeAccessRights;
}


export const PipeAccessRule: {
    new(identity: IdentityReference, rights: PipeAccessRights, type_: AccessControlType): PipeAccessRule$instance;
    new(identity: string, rights: PipeAccessRights, type_: AccessControlType): PipeAccessRule$instance;
};


export type PipeAccessRule = PipeAccessRule$instance;

export interface PipeAuditRule$instance extends AuditRule {
    readonly pipeAccessRights: PipeAccessRights;
}


export const PipeAuditRule: {
    new(identity: IdentityReference, rights: PipeAccessRights, flags: AuditFlags): PipeAuditRule$instance;
    new(identity: string, rights: PipeAccessRights, flags: AuditFlags): PipeAuditRule$instance;
};


export type PipeAuditRule = PipeAuditRule$instance;

export interface PipeSecurity$instance extends NativeObjectSecurity {
    readonly accessRightType: Type;
    readonly accessRuleType: Type;
    readonly auditRuleType: Type;
    accessRuleFactory(identityReference: IdentityReference, accessMask: int, isInherited: boolean, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, type_: AccessControlType): AccessRule;
    addAccessRule(rule: PipeAccessRule): void;
    addAuditRule(rule: PipeAuditRule): void;
    auditRuleFactory(identityReference: IdentityReference, accessMask: int, isInherited: boolean, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, flags: AuditFlags): AuditRule;
    removeAccessRule(rule: PipeAccessRule): boolean;
    removeAccessRuleSpecific(rule: PipeAccessRule): void;
    removeAuditRule(rule: PipeAuditRule): boolean;
    removeAuditRuleAll(rule: PipeAuditRule): void;
    removeAuditRuleSpecific(rule: PipeAuditRule): void;
    resetAccessRule(rule: PipeAccessRule): void;
    setAccessRule(rule: PipeAccessRule): void;
    setAuditRule(rule: PipeAuditRule): void;
}


export const PipeSecurity: {
    new(): PipeSecurity$instance;
};


export type PipeSecurity = PipeSecurity$instance;

export interface PipeStream$instance extends Stream {
    readonly canRead: boolean;
    readonly canSeek: boolean;
    readonly canWrite: boolean;
    readonly inBufferSize: int;
    readonly isAsync: boolean;
    readonly isConnected: boolean;
    readonly isMessageComplete: boolean;
    readonly length: long;
    readonly outBufferSize: int;
    position: long;
    readMode: PipeTransmissionMode;
    readonly safePipeHandle: SafePipeHandle;
    readonly transmissionMode: PipeTransmissionMode;
    beginRead(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginWrite(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    dispose(): void;
    disposeAsync(): ValueTask;
    endRead(asyncResult: IAsyncResult): int;
    endWrite(asyncResult: IAsyncResult): void;
    flush(): void;
    flushAsync(cancellationToken: CancellationToken): Task;
    flushAsync(): Task;
    read(buffer: byte[], offset: int, count: int): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readByte(): int;
    seek(offset: long, origin: SeekOrigin): long;
    setLength(value: long): void;
    waitForPipeDrain(): void;
    write(buffer: byte[], offset: int, count: int): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    writeAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeAsync(buffer: byte[], offset: int, count: int): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeByte(value: byte): void;
}


export const PipeStream: {
};


export interface __PipeStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type PipeStream = PipeStream$instance & __PipeStream$views;


export abstract class AnonymousPipeServerStreamAcl$instance {
    static create(direction: PipeDirection, inheritability: HandleInheritability, bufferSize: int, pipeSecurity: PipeSecurity): AnonymousPipeServerStream;
}


export type AnonymousPipeServerStreamAcl = AnonymousPipeServerStreamAcl$instance;

export abstract class NamedPipeServerStreamAcl$instance {
    static create(pipeName: string, direction: PipeDirection, maxNumberOfServerInstances: int, transmissionMode: PipeTransmissionMode, options: PipeOptions, inBufferSize: int, outBufferSize: int, pipeSecurity: PipeSecurity, inheritability?: HandleInheritability, additionalAccessRights?: PipeAccessRights): NamedPipeServerStream;
}


export type NamedPipeServerStreamAcl = NamedPipeServerStreamAcl$instance;

export abstract class PipesAclExtensions$instance {
    static getAccessControl(stream: PipeStream): PipeSecurity;
    static setAccessControl(stream: PipeStream, pipeSecurity: PipeSecurity): void;
}


export type PipesAclExtensions = PipesAclExtensions$instance;

