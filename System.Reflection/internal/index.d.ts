// Generated by tsbindgen - Architecture
// Namespace: System.Reflection
// Assembly: System.ObjectModel, System.Private.CoreLib, System.Reflection.DispatchProxy, System.Reflection.Metadata, System.Reflection.TypeExtensions

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { IEnumerable_1, IList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { AssemblyHashAlgorithm as AssemblyHashAlgorithm_Assemblies, AssemblyVersionCompatibility } from "../../System.Configuration.Assemblies/internal/index.js";
import type { CultureInfo } from "../../System.Globalization/internal/index.js";
import type { FileStream, Stream } from "../../System.IO/internal/index.js";
import type { StructLayoutAttribute } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, IObjectReference, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { SecurityRuleSet } from "../../System.Security/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ApplicationException, Array as ClrArray, AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Delegate, Enum, Exception, FormatException, Guid, IAsyncResult, ICloneable, IComparable, IConvertible, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, MarshalByRefObject, ModuleHandle, MulticastDelegate, Object as ClrObject, ResolveEventArgs, RuntimeFieldHandle, RuntimeMethodHandle, RuntimeTypeHandle, Span_1, String as ClrString, SystemException, Type, TypeCode, TypedReference, UInt32, ValueType, Version, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum AssemblyContentType {
    default_ = 0,
    windowsRuntime = 1
}


export enum AssemblyFlags {
    publicKey = 1,
    retargetable = 256,
    windowsRuntime = 512,
    contentTypeMask = 3584,
    disableJitCompileOptimizer = 16384,
    enableJitCompileTracking = 32768
}


export enum AssemblyHashAlgorithm {
    none = 0,
    MD5 = 32771,
    sha1 = 32772,
    sha256 = 32780,
    sha384 = 32781,
    sha512 = 32782
}


export enum AssemblyNameFlags {
    none = 0,
    publicKey = 1,
    enableJITcompileOptimizer = 16384,
    enableJITcompileTracking = 32768,
    retargetable = 256
}


export enum BindingFlags {
    default_ = 0,
    ignoreCase = 1,
    declaredOnly = 2,
    instance = 4,
    static_ = 8,
    public_ = 16,
    nonPublic = 32,
    flattenHierarchy = 64,
    invokeMethod = 256,
    createInstance = 512,
    getField = 1024,
    setField = 2048,
    getProperty = 4096,
    setProperty = 8192,
    putDispProperty = 16384,
    putRefDispProperty = 32768,
    exactBinding = 65536,
    suppressChangeType = 131072,
    optionalParamBinding = 262144,
    ignoreReturn = 16777216,
    doNotWrapExceptions = 33554432
}


export enum CallingConventions {
    standard = 1,
    varArgs = 2,
    any_ = 3,
    hasThis = 32,
    explicitThis = 64
}


export enum DeclarativeSecurityAction {
    none = 0,
    demand = 2,
    assert = 3,
    deny = 4,
    permitOnly = 5,
    linkDemand = 6,
    inheritanceDemand = 7,
    requestMinimum = 8,
    requestOptional = 9,
    requestRefuse = 10
}


export enum EventAttributes {
    none = 0,
    specialName = 512,
    rtSpecialName = 1024,
    reservedMask = 1024
}


export enum ExceptionHandlingClauseOptions {
    clause = 0,
    filter = 1,
    finally_ = 2,
    fault = 4
}


export enum FieldAttributes {
    fieldAccessMask = 7,
    privateScope = 0,
    private_ = 1,
    famANDAssem = 2,
    assembly = 3,
    family = 4,
    famORAssem = 5,
    public_ = 6,
    static_ = 16,
    initOnly = 32,
    literal = 64,
    notSerialized = 128,
    specialName = 512,
    pinvokeImpl = 8192,
    rtSpecialName = 1024,
    hasFieldMarshal = 4096,
    hasDefault = 32768,
    hasFieldRVA = 256,
    reservedMask = 38144
}


export enum GenericParameterAttributes {
    none = 0,
    varianceMask = 3,
    covariant = 1,
    contravariant = 2,
    specialConstraintMask = 28,
    referenceTypeConstraint = 4,
    notNullableValueTypeConstraint = 8,
    defaultConstructorConstraint = 16,
    allowByRefLike = 32
}


export enum ImageFileMachine {
    I386 = 332,
    IA64 = 512,
    AMD64 = 34404,
    ARM = 452
}


export enum ManifestResourceAttributes {
    public_ = 1,
    private_ = 2,
    visibilityMask = 7
}


export enum MemberTypes {
    constructor_ = 1,
    event = 2,
    field = 4,
    method = 8,
    property = 16,
    typeInfo = 32,
    custom = 64,
    nestedType = 128,
    all = 191
}


export enum MethodAttributes {
    memberAccessMask = 7,
    privateScope = 0,
    private_ = 1,
    famANDAssem = 2,
    assembly = 3,
    family = 4,
    famORAssem = 5,
    public_ = 6,
    static_ = 16,
    final = 32,
    virtual = 64,
    hideBySig = 128,
    checkAccessOnOverride = 512,
    vtableLayoutMask = 256,
    reuseSlot = 0,
    newSlot = 256,
    abstract_ = 1024,
    specialName = 2048,
    pinvokeImpl = 8192,
    unmanagedExport = 8,
    rtSpecialName = 4096,
    hasSecurity = 16384,
    requireSecObject = 32768,
    reservedMask = 53248
}


export enum MethodImplAttributes {
    codeTypeMask = 3,
    IL = 0,
    native = 1,
    OPTIL = 2,
    runtime = 3,
    managedMask = 4,
    unmanaged = 4,
    managed = 0,
    forwardRef = 16,
    preserveSig = 128,
    internalCall = 4096,
    synchronized = 32,
    noInlining = 8,
    aggressiveInlining = 256,
    noOptimization = 64,
    aggressiveOptimization = 512,
    async_ = 8192,
    maxMethodImplVal = 65535
}


export enum MethodImportAttributes {
    none = 0,
    exactSpelling = 1,
    bestFitMappingDisable = 32,
    bestFitMappingEnable = 16,
    bestFitMappingMask = 48,
    charSetAnsi = 2,
    charSetUnicode = 4,
    charSetAuto = 6,
    charSetMask = 6,
    throwOnUnmappableCharEnable = 4096,
    throwOnUnmappableCharDisable = 8192,
    throwOnUnmappableCharMask = 12288,
    setLastError = 64,
    callingConventionWinApi = 256,
    callingConventionCDecl = 512,
    callingConventionStdCall = 768,
    callingConventionThisCall = 1024,
    callingConventionFastCall = 1280,
    callingConventionMask = 1792
}


export enum MethodSemanticsAttributes {
    setter = 1,
    getter = 2,
    other = 4,
    adder = 8,
    remover = 16,
    raiser = 32
}


export enum NullabilityState {
    unknown_ = 0,
    notNull = 1,
    nullable = 2
}


export enum ParameterAttributes {
    none = 0,
    in_ = 1,
    out = 2,
    lcid = 4,
    retval = 8,
    optional = 16,
    hasDefault = 4096,
    hasFieldMarshal = 8192,
    reserved3 = 16384,
    reserved4 = 32768,
    reservedMask = 61440
}


export enum PortableExecutableKinds {
    notAPortableExecutableImage = 0,
    ilOnly = 1,
    required32Bit = 2,
    pE32Plus = 4,
    unmanaged32Bit = 8,
    preferred32Bit = 16
}


export enum ProcessorArchitecture {
    none = 0,
    MSIL = 1,
    X86 = 2,
    IA64 = 3,
    amd64 = 4,
    arm = 5
}


export enum PropertyAttributes {
    none = 0,
    specialName = 512,
    rtSpecialName = 1024,
    hasDefault = 4096,
    reserved2 = 8192,
    reserved3 = 16384,
    reserved4 = 32768,
    reservedMask = 62464
}


export enum ResourceAttributes {
    public_ = 1,
    private_ = 2
}


export enum ResourceLocation {
    containedInAnotherAssembly = 2,
    containedInManifestFile = 4,
    embedded = 1
}


export enum TypeAttributes {
    visibilityMask = 7,
    notPublic = 0,
    public_ = 1,
    nestedPublic = 2,
    nestedPrivate = 3,
    nestedFamily = 4,
    nestedAssembly = 5,
    nestedFamANDAssem = 6,
    nestedFamORAssem = 7,
    layoutMask = 24,
    autoLayout = 0,
    sequentialLayout = 8,
    explicitLayout = 16,
    classSemanticsMask = 32,
    class_ = 0,
    interface_ = 32,
    abstract_ = 128,
    sealed = 256,
    specialName = 1024,
    import_ = 4096,
    serializable = 8192,
    windowsRuntime = 16384,
    stringFormatMask = 196608,
    ansiClass = 0,
    unicodeClass = 65536,
    autoClass = 131072,
    customFormatClass = 196608,
    customFormatMask = 12582912,
    beforeFieldInit = 1048576,
    rtSpecialName = 2048,
    hasSecurity = 262144,
    reservedMask = 264192
}


export type MemberFilter = (m: MemberInfo, filterCriteria: unknown) => boolean;


export type ModuleResolveEventHandler = (sender: unknown, e: ResolveEventArgs) => Module;


export type TypeFilter = (m: Type, filterCriteria: unknown) => boolean;


export interface ICustomAttributeProvider$instance {
    getCustomAttributes(inherit: boolean): unknown[];
    getCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    isDefined(attributeType: Type, inherit: boolean): boolean;
}


export type ICustomAttributeProvider = ICustomAttributeProvider$instance;

export interface ICustomTypeProvider$instance {
    getCustomType(): Type;
}


export type ICustomTypeProvider = ICustomTypeProvider$instance;

export interface IReflect$instance {
    readonly underlyingSystemType: Type;
    getField(name: string, bindingAttr: BindingFlags): FieldInfo;
    getFields(bindingAttr: BindingFlags): FieldInfo[];
    getMember(name: string, bindingAttr: BindingFlags): MemberInfo[];
    getMembers(bindingAttr: BindingFlags): MemberInfo[];
    getMethod(name: string, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    getMethod(name: string, bindingAttr: BindingFlags): MethodInfo;
    getMethods(bindingAttr: BindingFlags): MethodInfo[];
    getProperties(bindingAttr: BindingFlags): PropertyInfo[];
    getProperty(name: string, bindingAttr: BindingFlags, binder: Binder, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
    getProperty(name: string, bindingAttr: BindingFlags): PropertyInfo;
    invokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: unknown, args: unknown[], modifiers: ParameterModifier[], culture: CultureInfo, namedParameters: string[]): unknown;
}


export type IReflect = IReflect$instance;

export interface IReflectableType$instance {
    getTypeInfo(): TypeInfo;
}


export type IReflectableType = IReflectableType$instance;

export interface CustomAttributeNamedArgument$instance {
    readonly isField: boolean;
    readonly memberInfo: MemberInfo;
    readonly memberName: string;
    readonly typedValue: CustomAttributeTypedArgument;
    equals(obj: unknown): boolean;
    equals(other: CustomAttributeNamedArgument): boolean;
    getHashCode(): int;
    toString(): string;
}


export const CustomAttributeNamedArgument: {
    new(memberInfo: MemberInfo, value: unknown): CustomAttributeNamedArgument$instance;
    new(memberInfo: MemberInfo, typedArgument: CustomAttributeTypedArgument): CustomAttributeNamedArgument$instance;
};


export interface __CustomAttributeNamedArgument$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CustomAttributeNamedArgument>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CustomAttributeNamedArgument): boolean;
}

export type CustomAttributeNamedArgument = CustomAttributeNamedArgument$instance & __CustomAttributeNamedArgument$views;


export interface CustomAttributeTypedArgument$instance {
    readonly argumentType: Type;
    readonly value: unknown;
    equals(obj: unknown): boolean;
    equals(other: CustomAttributeTypedArgument): boolean;
    getHashCode(): int;
    toString(): string;
}


export const CustomAttributeTypedArgument: {
    new(argumentType: Type, value: unknown): CustomAttributeTypedArgument$instance;
    new(value: unknown): CustomAttributeTypedArgument$instance;
};


export interface __CustomAttributeTypedArgument$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CustomAttributeTypedArgument>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CustomAttributeTypedArgument): boolean;
}

export type CustomAttributeTypedArgument = CustomAttributeTypedArgument$instance & __CustomAttributeTypedArgument$views;


export interface InterfaceMapping$instance {
    targetType: Type;
    interfaceType: Type;
    targetMethods: MethodInfo[];
    interfaceMethods: MethodInfo[];
}


export const InterfaceMapping: {
    new(): InterfaceMapping$instance;
};


export type InterfaceMapping = InterfaceMapping$instance;

export interface ParameterModifier$instance {
    item: boolean;
}


export const ParameterModifier: {
    new(parameterCount: int): ParameterModifier$instance;
};


export type ParameterModifier = ParameterModifier$instance;

export interface AmbiguousMatchException$instance extends SystemException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const AmbiguousMatchException: {
    new(): AmbiguousMatchException$instance;
    new(message: string): AmbiguousMatchException$instance;
    new(message: string, inner: Exception): AmbiguousMatchException$instance;
};


export interface __AmbiguousMatchException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AmbiguousMatchException = AmbiguousMatchException$instance & __AmbiguousMatchException$views;


export interface Assembly$instance {
    readonly codeBase: string;
    readonly customAttributes: IEnumerable_1<CustomAttributeData>;
    readonly definedTypes: IEnumerable_1<TypeInfo>;
    readonly entryPoint: MethodInfo;
    readonly escapedCodeBase: string;
    readonly exportedTypes: IEnumerable_1<Type>;
    readonly fullName: string;
    readonly globalAssemblyCache: boolean;
    readonly hostContext: long;
    readonly imageRuntimeVersion: string;
    readonly isCollectible: boolean;
    readonly isDynamic: boolean;
    readonly isFullyTrusted: boolean;
    readonly location: string;
    readonly manifestModule: Module;
    readonly modules: IEnumerable_1<Module>;
    readonly reflectionOnly: boolean;
    readonly securityRuleSet: SecurityRuleSet;
    createInstance(typeName: string): unknown;
    createInstance(typeName: string, ignoreCase: boolean): unknown;
    createInstance(typeName: string, ignoreCase: boolean, bindingAttr: BindingFlags, binder: Binder, args: unknown[], culture: CultureInfo, activationAttributes: unknown[]): unknown;
    equals(o: unknown): boolean;
    getCustomAttributes(inherit: boolean): unknown[];
    getCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getCustomAttributesData(): IList_1<CustomAttributeData>;
    getExportedTypes(): Type[];
    getFile(name: string): FileStream;
    getFiles(): FileStream[];
    getFiles(getResourceModules: boolean): FileStream[];
    getForwardedTypes(): Type[];
    getHashCode(): int;
    getLoadedModules(): Module[];
    getLoadedModules(getResourceModules: boolean): Module[];
    getManifestResourceInfo(resourceName: string): ManifestResourceInfo;
    getManifestResourceNames(): string[];
    getManifestResourceStream(name: string): Stream;
    getManifestResourceStream(type_: Type, name: string): Stream;
    getModule(name: string): Module;
    getModules(): Module[];
    getModules(getResourceModules: boolean): Module[];
    getName(): AssemblyName;
    getName(copiedName: boolean): AssemblyName;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getReferencedAssemblies(): AssemblyName[];
    getSatelliteAssembly(culture: CultureInfo): Assembly;
    getSatelliteAssembly(culture: CultureInfo, version: Version): Assembly;
    getType(name: string): Type;
    getType(name: string, throwOnError: boolean): Type;
    getType(name: string, throwOnError: boolean, ignoreCase: boolean): Type;
    getTypes(): Type[];
    isDefined(attributeType: Type, inherit: boolean): boolean;
    loadModule(moduleName: string, rawModule: byte[]): Module;
    loadModule(moduleName: string, rawModule: byte[], rawSymbolStore: byte[]): Module;
    toString(): string;
}


export const Assembly: {
    createQualifiedName(assemblyName: string, typeName: string): string;
    getAssembly(type_: Type): Assembly;
    getCallingAssembly(): Assembly;
    getEntryAssembly(): Assembly;
    getExecutingAssembly(): Assembly;
    load(rawAssembly: byte[], rawSymbolStore: byte[]): Assembly;
    load(rawAssembly: byte[]): Assembly;
    load(assemblyRef: AssemblyName): Assembly;
    load(assemblyString: string): Assembly;
    loadFile(path: string): Assembly;
    loadFrom(assemblyFile: string, hashValue: byte[], hashAlgorithm: AssemblyHashAlgorithm_Assemblies): Assembly;
    loadFrom(assemblyFile: string): Assembly;
    loadWithPartialName(partialName: string): Assembly;
    reflectionOnlyLoad(rawAssembly: byte[]): Assembly;
    reflectionOnlyLoad(assemblyString: string): Assembly;
    reflectionOnlyLoadFrom(assemblyFile: string): Assembly;
    setEntryAssembly(assembly: Assembly): void;
    unsafeLoadFrom(assemblyFile: string): Assembly;
};


export interface __Assembly$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Assembly$instance extends ICustomAttributeProvider$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Assembly = Assembly$instance & __Assembly$views;


export interface AssemblyAlgorithmIdAttribute$instance extends Attribute {
    readonly algorithmId: uint;
}


export const AssemblyAlgorithmIdAttribute: {
    new(algorithmId: AssemblyHashAlgorithm_Assemblies): AssemblyAlgorithmIdAttribute$instance;
    new(algorithmId: uint): AssemblyAlgorithmIdAttribute$instance;
};


export type AssemblyAlgorithmIdAttribute = AssemblyAlgorithmIdAttribute$instance;

export interface AssemblyCompanyAttribute$instance extends Attribute {
    readonly company: string;
}


export const AssemblyCompanyAttribute: {
    new(company: string): AssemblyCompanyAttribute$instance;
};


export type AssemblyCompanyAttribute = AssemblyCompanyAttribute$instance;

export interface AssemblyConfigurationAttribute$instance extends Attribute {
    readonly configuration: string;
}


export const AssemblyConfigurationAttribute: {
    new(configuration: string): AssemblyConfigurationAttribute$instance;
};


export type AssemblyConfigurationAttribute = AssemblyConfigurationAttribute$instance;

export interface AssemblyCopyrightAttribute$instance extends Attribute {
    readonly copyright: string;
}


export const AssemblyCopyrightAttribute: {
    new(copyright: string): AssemblyCopyrightAttribute$instance;
};


export type AssemblyCopyrightAttribute = AssemblyCopyrightAttribute$instance;

export interface AssemblyCultureAttribute$instance extends Attribute {
    readonly culture: string;
}


export const AssemblyCultureAttribute: {
    new(culture: string): AssemblyCultureAttribute$instance;
};


export type AssemblyCultureAttribute = AssemblyCultureAttribute$instance;

export interface AssemblyDefaultAliasAttribute$instance extends Attribute {
    readonly defaultAlias: string;
}


export const AssemblyDefaultAliasAttribute: {
    new(defaultAlias: string): AssemblyDefaultAliasAttribute$instance;
};


export type AssemblyDefaultAliasAttribute = AssemblyDefaultAliasAttribute$instance;

export interface AssemblyDelaySignAttribute$instance extends Attribute {
    readonly delaySign: boolean;
}


export const AssemblyDelaySignAttribute: {
    new(delaySign: boolean): AssemblyDelaySignAttribute$instance;
};


export type AssemblyDelaySignAttribute = AssemblyDelaySignAttribute$instance;

export interface AssemblyDescriptionAttribute$instance extends Attribute {
    readonly description: string;
}


export const AssemblyDescriptionAttribute: {
    new(description: string): AssemblyDescriptionAttribute$instance;
};


export type AssemblyDescriptionAttribute = AssemblyDescriptionAttribute$instance;

export interface AssemblyFileVersionAttribute$instance extends Attribute {
    readonly version: string;
}


export const AssemblyFileVersionAttribute: {
    new(version: string): AssemblyFileVersionAttribute$instance;
};


export type AssemblyFileVersionAttribute = AssemblyFileVersionAttribute$instance;

export interface AssemblyFlagsAttribute$instance extends Attribute {
    readonly assemblyFlags: int;
    readonly flags: uint;
}


export const AssemblyFlagsAttribute: {
    new(flags: uint): AssemblyFlagsAttribute$instance;
    new(assemblyFlags: int): AssemblyFlagsAttribute$instance;
    new(assemblyFlags: AssemblyNameFlags): AssemblyFlagsAttribute$instance;
};


export type AssemblyFlagsAttribute = AssemblyFlagsAttribute$instance;

export interface AssemblyInformationalVersionAttribute$instance extends Attribute {
    readonly informationalVersion: string;
}


export const AssemblyInformationalVersionAttribute: {
    new(informationalVersion: string): AssemblyInformationalVersionAttribute$instance;
};


export type AssemblyInformationalVersionAttribute = AssemblyInformationalVersionAttribute$instance;

export interface AssemblyKeyFileAttribute$instance extends Attribute {
    readonly keyFile: string;
}


export const AssemblyKeyFileAttribute: {
    new(keyFile: string): AssemblyKeyFileAttribute$instance;
};


export type AssemblyKeyFileAttribute = AssemblyKeyFileAttribute$instance;

export interface AssemblyKeyNameAttribute$instance extends Attribute {
    readonly keyName: string;
}


export const AssemblyKeyNameAttribute: {
    new(keyName: string): AssemblyKeyNameAttribute$instance;
};


export type AssemblyKeyNameAttribute = AssemblyKeyNameAttribute$instance;

export interface AssemblyMetadataAttribute$instance extends Attribute {
    readonly key: string;
    readonly value: string;
}


export const AssemblyMetadataAttribute: {
    new(key: string, value: string): AssemblyMetadataAttribute$instance;
};


export type AssemblyMetadataAttribute = AssemblyMetadataAttribute$instance;

export interface AssemblyName$instance {
    codeBase: string;
    contentType: AssemblyContentType;
    cultureInfo: CultureInfo;
    cultureName: string;
    readonly escapedCodeBase: string;
    flags: AssemblyNameFlags;
    readonly fullName: string;
    hashAlgorithm: AssemblyHashAlgorithm_Assemblies;
    keyPair: StrongNameKeyPair;
    name: string;
    processorArchitecture: ProcessorArchitecture;
    version: Version;
    versionCompatibility: AssemblyVersionCompatibility;
    clone(): unknown;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getPublicKey(): byte[];
    getPublicKeyToken(): byte[];
    onDeserialization(sender: unknown): void;
    setPublicKey(publicKey: byte[]): void;
    setPublicKeyToken(publicKeyToken: byte[]): void;
    toString(): string;
}


export const AssemblyName: {
    new(assemblyName: string): AssemblyName$instance;
    new(): AssemblyName$instance;
    getAssemblyName(assemblyFile: string): AssemblyName;
    referenceMatchesDefinition(reference: AssemblyName, definition: AssemblyName): boolean;
};


export interface __AssemblyName$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface AssemblyName$instance extends System_Internal.ICloneable$instance, System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type AssemblyName = AssemblyName$instance & __AssemblyName$views;


export interface AssemblyNameProxy$instance extends MarshalByRefObject {
    getAssemblyName(assemblyFile: string): AssemblyName;
}


export const AssemblyNameProxy: {
    new(): AssemblyNameProxy$instance;
};


export type AssemblyNameProxy = AssemblyNameProxy$instance;

export interface AssemblyProductAttribute$instance extends Attribute {
    readonly product: string;
}


export const AssemblyProductAttribute: {
    new(product: string): AssemblyProductAttribute$instance;
};


export type AssemblyProductAttribute = AssemblyProductAttribute$instance;

export interface AssemblySignatureKeyAttribute$instance extends Attribute {
    readonly countersignature: string;
    readonly publicKey: string;
}


export const AssemblySignatureKeyAttribute: {
    new(publicKey: string, countersignature: string): AssemblySignatureKeyAttribute$instance;
};


export type AssemblySignatureKeyAttribute = AssemblySignatureKeyAttribute$instance;

export interface AssemblyTitleAttribute$instance extends Attribute {
    readonly title: string;
}


export const AssemblyTitleAttribute: {
    new(title: string): AssemblyTitleAttribute$instance;
};


export type AssemblyTitleAttribute = AssemblyTitleAttribute$instance;

export interface AssemblyTrademarkAttribute$instance extends Attribute {
    readonly trademark: string;
}


export const AssemblyTrademarkAttribute: {
    new(trademark: string): AssemblyTrademarkAttribute$instance;
};


export type AssemblyTrademarkAttribute = AssemblyTrademarkAttribute$instance;

export interface AssemblyVersionAttribute$instance extends Attribute {
    readonly version: string;
}


export const AssemblyVersionAttribute: {
    new(version: string): AssemblyVersionAttribute$instance;
};


export type AssemblyVersionAttribute = AssemblyVersionAttribute$instance;

export interface Binder$instance {
    bindToField(bindingAttr: BindingFlags, match: FieldInfo[], value: unknown, culture: CultureInfo): FieldInfo;
    bindToMethod(bindingAttr: BindingFlags, match: MethodBase[], args: { value: ref<unknown[]> }, modifiers: ParameterModifier[], culture: CultureInfo, names: string[], state: { value: ref<unknown> }): MethodBase;
    changeType(value: unknown, type_: Type, culture: CultureInfo): unknown;
    reorderArgumentArray(args: { value: ref<unknown[]> }, state: unknown): void;
    selectMethod(bindingAttr: BindingFlags, match: MethodBase[], types: Type[], modifiers: ParameterModifier[]): MethodBase;
    selectProperty(bindingAttr: BindingFlags, match: PropertyInfo[], returnType: Type, indexes: Type[], modifiers: ParameterModifier[]): PropertyInfo;
}


export const Binder: {
};


export type Binder = Binder$instance;

export interface ConstructorInfo$instance extends MethodBase$instance {
    readonly memberType: MemberTypes;
    equals(obj: unknown): boolean;
    getCustomAttributes(inherit: boolean): unknown[];
    getCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getHashCode(): int;
    invoke(obj: unknown, parameters: unknown[]): unknown;
    invoke(obj: unknown, invokeAttr: BindingFlags, binder: Binder, parameters: unknown[], culture: CultureInfo): unknown;
    isDefined(attributeType: Type, inherit: boolean): boolean;
}


export const ConstructorInfo: {
    readonly constructorName: string;
    readonly typeConstructorName: string;
};


export interface __ConstructorInfo$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
}

export type ConstructorInfo = ConstructorInfo$instance & __ConstructorInfo$views;


export interface ConstructorInvoker$instance {
    invoke(): unknown;
    invoke(arg1: unknown): unknown;
    invoke(arg1: unknown, arg2: unknown): unknown;
    invoke(arg1: unknown, arg2: unknown, arg3: unknown): unknown;
    invoke(arg1: unknown, arg2: unknown, arg3: unknown, arg4: unknown): unknown;
    invoke(arguments: Span_1<unknown>): unknown;
}


export const ConstructorInvoker: {
    new(): ConstructorInvoker$instance;
    create(constructor_: ConstructorInfo): ConstructorInvoker;
};


export type ConstructorInvoker = ConstructorInvoker$instance;

export interface CustomAttributeData$instance {
    readonly attributeType: Type;
    readonly constructor_: ConstructorInfo;
    readonly constructorArguments: IList_1<CustomAttributeTypedArgument>;
    readonly namedArguments: IList_1<CustomAttributeNamedArgument>;
    toString(): string;
}


export const CustomAttributeData: {
    new(): CustomAttributeData$instance;
    getCustomAttributes(target: Assembly): IList_1<CustomAttributeData>;
    getCustomAttributes(target: MemberInfo): IList_1<CustomAttributeData>;
    getCustomAttributes(target: Module): IList_1<CustomAttributeData>;
    getCustomAttributes(target: ParameterInfo): IList_1<CustomAttributeData>;
};


export type CustomAttributeData = CustomAttributeData$instance;

export interface CustomAttributeFormatException$instance extends FormatException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const CustomAttributeFormatException: {
    new(): CustomAttributeFormatException$instance;
    new(message: string): CustomAttributeFormatException$instance;
    new(message: string, inner: Exception): CustomAttributeFormatException$instance;
};


export interface __CustomAttributeFormatException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type CustomAttributeFormatException = CustomAttributeFormatException$instance & __CustomAttributeFormatException$views;


export interface DefaultMemberAttribute$instance extends Attribute {
    readonly memberName: string;
}


export const DefaultMemberAttribute: {
    new(memberName: string): DefaultMemberAttribute$instance;
};


export type DefaultMemberAttribute = DefaultMemberAttribute$instance;

export interface DispatchProxy$instance {
}


export const DispatchProxy: {
    create<T, TProxy extends DispatchProxy>(): T;
    create(interfaceType: Type, proxyType: Type): unknown;
};


export type DispatchProxy = DispatchProxy$instance;

export interface EventInfo$instance extends MemberInfo$instance {
    readonly addMethod: MethodInfo;
    readonly attributes: EventAttributes;
    readonly eventHandlerType: Type;
    readonly isMulticast: boolean;
    readonly isSpecialName: boolean;
    readonly memberType: MemberTypes;
    readonly raiseMethod: MethodInfo;
    readonly removeMethod: MethodInfo;
    addEventHandler(target: unknown, handler: Function): void;
    equals(obj: unknown): boolean;
    getAddMethod(): MethodInfo;
    getAddMethod(nonPublic: boolean): MethodInfo;
    getCustomAttributes(inherit: boolean): unknown[];
    getCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getHashCode(): int;
    getOtherMethods(): MethodInfo[];
    getOtherMethods(nonPublic: boolean): MethodInfo[];
    getRaiseMethod(): MethodInfo;
    getRaiseMethod(nonPublic: boolean): MethodInfo;
    getRemoveMethod(): MethodInfo;
    getRemoveMethod(nonPublic: boolean): MethodInfo;
    isDefined(attributeType: Type, inherit: boolean): boolean;
    removeEventHandler(target: unknown, handler: Function): void;
}


export const EventInfo: {
};


export interface __EventInfo$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
}

export type EventInfo = EventInfo$instance & __EventInfo$views;


export interface ExceptionHandlingClause$instance {
    readonly catchType: Type;
    readonly filterOffset: int;
    readonly flags: ExceptionHandlingClauseOptions;
    readonly handlerLength: int;
    readonly handlerOffset: int;
    readonly tryLength: int;
    readonly tryOffset: int;
    toString(): string;
}


export const ExceptionHandlingClause: {
    new(): ExceptionHandlingClause$instance;
};


export type ExceptionHandlingClause = ExceptionHandlingClause$instance;

export interface FieldInfo$instance extends MemberInfo$instance {
    readonly attributes: FieldAttributes;
    readonly fieldHandle: RuntimeFieldHandle;
    readonly fieldType: Type;
    readonly isAssembly: boolean;
    readonly isFamily: boolean;
    readonly isFamilyAndAssembly: boolean;
    readonly isFamilyOrAssembly: boolean;
    readonly isInitOnly: boolean;
    readonly isLiteral: boolean;
    readonly isNotSerialized: boolean;
    readonly isPinvokeImpl: boolean;
    readonly isPrivate: boolean;
    readonly isPublic: boolean;
    readonly isSecurityCritical: boolean;
    readonly isSecuritySafeCritical: boolean;
    readonly isSecurityTransparent: boolean;
    readonly isSpecialName: boolean;
    readonly isStatic: boolean;
    readonly memberType: MemberTypes;
    equals(obj: unknown): boolean;
    getCustomAttributes(inherit: boolean): unknown[];
    getCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getHashCode(): int;
    getModifiedFieldType(): Type;
    getOptionalCustomModifiers(): Type[];
    getRawConstantValue(): unknown;
    getRequiredCustomModifiers(): Type[];
    getValue(obj: unknown): unknown;
    getValueDirect(obj: TypedReference): unknown;
    isDefined(attributeType: Type, inherit: boolean): boolean;
    setValue(obj: unknown, value: unknown): void;
    setValue(obj: unknown, value: unknown, invokeAttr: BindingFlags, binder: Binder, culture: CultureInfo): void;
    setValueDirect(obj: TypedReference, value: unknown): void;
}


export const FieldInfo: {
    getFieldFromHandle(handle: RuntimeFieldHandle, declaringType: RuntimeTypeHandle): FieldInfo;
    getFieldFromHandle(handle: RuntimeFieldHandle): FieldInfo;
};


export interface __FieldInfo$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
}

export type FieldInfo = FieldInfo$instance & __FieldInfo$views;


export interface InvalidFilterCriteriaException$instance extends ApplicationException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const InvalidFilterCriteriaException: {
    new(): InvalidFilterCriteriaException$instance;
    new(message: string): InvalidFilterCriteriaException$instance;
    new(message: string, inner: Exception): InvalidFilterCriteriaException$instance;
};


export interface __InvalidFilterCriteriaException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidFilterCriteriaException = InvalidFilterCriteriaException$instance & __InvalidFilterCriteriaException$views;


export interface LocalVariableInfo$instance {
    readonly isPinned: boolean;
    readonly localIndex: int;
    readonly localType: Type;
    toString(): string;
}


export const LocalVariableInfo: {
    new(): LocalVariableInfo$instance;
};


export type LocalVariableInfo = LocalVariableInfo$instance;

export interface ManifestResourceInfo$instance {
    readonly fileName: string;
    readonly referencedAssembly: Assembly;
    readonly resourceLocation: ResourceLocation;
}


export const ManifestResourceInfo: {
    new(containingAssembly: Assembly, containingFileName: string, resourceLocation: ResourceLocation): ManifestResourceInfo$instance;
};


export type ManifestResourceInfo = ManifestResourceInfo$instance;

export interface MemberInfo$instance {
    readonly customAttributes: IEnumerable_1<CustomAttributeData>;
    readonly declaringType: Type;
    readonly isCollectible: boolean;
    readonly memberType: MemberTypes;
    readonly metadataToken: int;
    readonly module_: Module;
    readonly name: string;
    readonly reflectedType: Type;
    equals(obj: unknown): boolean;
    getCustomAttributes(inherit: boolean): unknown[];
    getCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getCustomAttributesData(): IList_1<CustomAttributeData>;
    getHashCode(): int;
    hasSameMetadataDefinitionAs(other: MemberInfo): boolean;
    isDefined(attributeType: Type, inherit: boolean): boolean;
}


export const MemberInfo: {
};


export interface __MemberInfo$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
}

export interface MemberInfo$instance extends ICustomAttributeProvider$instance {}

export type MemberInfo = MemberInfo$instance & __MemberInfo$views;


export interface MethodBase$instance extends MemberInfo$instance {
    readonly attributes: MethodAttributes;
    readonly callingConvention: CallingConventions;
    readonly containsGenericParameters: boolean;
    readonly isAbstract: boolean;
    readonly isAssembly: boolean;
    readonly isConstructedGenericMethod: boolean;
    readonly isConstructor: boolean;
    readonly isFamily: boolean;
    readonly isFamilyAndAssembly: boolean;
    readonly isFamilyOrAssembly: boolean;
    readonly isFinal: boolean;
    readonly isGenericMethod: boolean;
    readonly isGenericMethodDefinition: boolean;
    readonly isHideBySig: boolean;
    readonly isPrivate: boolean;
    readonly isPublic: boolean;
    readonly isSecurityCritical: boolean;
    readonly isSecuritySafeCritical: boolean;
    readonly isSecurityTransparent: boolean;
    readonly isSpecialName: boolean;
    readonly isStatic: boolean;
    readonly isVirtual: boolean;
    readonly methodHandle: RuntimeMethodHandle;
    readonly methodImplementationFlags: MethodImplAttributes;
    equals(obj: unknown): boolean;
    getCustomAttributes(inherit: boolean): unknown[];
    getCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getGenericArguments(): Type[];
    getHashCode(): int;
    getMethodBody(): MethodBody;
    getMethodImplementationFlags(): MethodImplAttributes;
    getParameters(): ParameterInfo[];
    invoke(obj: unknown, parameters: unknown[]): unknown;
    invoke(obj: unknown, invokeAttr: BindingFlags, binder: Binder, parameters: unknown[], culture: CultureInfo): unknown;
    isDefined(attributeType: Type, inherit: boolean): boolean;
}


export const MethodBase: {
    getCurrentMethod(): MethodBase;
    getMethodFromHandle(handle: RuntimeMethodHandle, declaringType: RuntimeTypeHandle): MethodBase;
    getMethodFromHandle(handle: RuntimeMethodHandle): MethodBase;
};


export interface __MethodBase$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
}

export type MethodBase = MethodBase$instance & __MethodBase$views;


export interface MethodBody$instance {
    readonly exceptionHandlingClauses: IList_1<ExceptionHandlingClause>;
    readonly initLocals: boolean;
    readonly localSignatureMetadataToken: int;
    readonly localVariables: IList_1<LocalVariableInfo>;
    readonly maxStackSize: int;
    getILAsByteArray(): byte[];
}


export const MethodBody: {
    new(): MethodBody$instance;
};


export type MethodBody = MethodBody$instance;

export interface MethodInfo$instance extends MethodBase$instance {
    readonly memberType: MemberTypes;
    readonly returnParameter: ParameterInfo;
    readonly returnType: Type;
    readonly returnTypeCustomAttributes: ICustomAttributeProvider;
    createDelegate(delegateType: Type): Function;
    createDelegate(delegateType: Type, target: unknown): Function;
    createDelegate<T extends Function>(): T;
    createDelegate<T extends Function>(target: unknown): T;
    equals(obj: unknown): boolean;
    getBaseDefinition(): MethodInfo;
    getCustomAttributes(inherit: boolean): unknown[];
    getCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getGenericArguments(): Type[];
    getGenericMethodDefinition(): MethodInfo;
    getHashCode(): int;
    isDefined(attributeType: Type, inherit: boolean): boolean;
    makeGenericMethod(typeArguments: Type[]): MethodInfo;
}


export const MethodInfo: {
};


export interface __MethodInfo$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
}

export type MethodInfo = MethodInfo$instance & __MethodInfo$views;


export interface MethodInvoker$instance {
    invoke(obj: unknown): unknown;
    invoke(obj: unknown, arg1: unknown): unknown;
    invoke(obj: unknown, arg1: unknown, arg2: unknown): unknown;
    invoke(obj: unknown, arg1: unknown, arg2: unknown, arg3: unknown): unknown;
    invoke(obj: unknown, arg1: unknown, arg2: unknown, arg3: unknown, arg4: unknown): unknown;
    invoke(obj: unknown, arguments: Span_1<unknown>): unknown;
}


export const MethodInvoker: {
    new(): MethodInvoker$instance;
    create(method: MethodBase): MethodInvoker;
};


export type MethodInvoker = MethodInvoker$instance;

export interface Missing$instance {
}


export const Missing: {
    new(): Missing$instance;
    readonly value: Missing;
};


export interface __Missing$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Missing$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Missing = Missing$instance & __Missing$views;


export interface Module$instance {
    readonly assembly: Assembly;
    readonly customAttributes: IEnumerable_1<CustomAttributeData>;
    readonly fullyQualifiedName: string;
    readonly mdStreamVersion: int;
    readonly metadataToken: int;
    readonly moduleHandle: ModuleHandle;
    readonly moduleVersionId: Guid;
    readonly name: string;
    readonly scopeName: string;
    equals(o: unknown): boolean;
    findTypes(filter: TypeFilter, filterCriteria: unknown): Type[];
    getCustomAttributes(inherit: boolean): unknown[];
    getCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getCustomAttributesData(): IList_1<CustomAttributeData>;
    getField(name: string): FieldInfo;
    getField(name: string, bindingAttr: BindingFlags): FieldInfo;
    getFields(): FieldInfo[];
    getFields(bindingFlags: BindingFlags): FieldInfo[];
    getHashCode(): int;
    getMethod(name: string): MethodInfo;
    getMethod(name: string, types: Type[]): MethodInfo;
    getMethod(name: string, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    getMethods(): MethodInfo[];
    getMethods(bindingFlags: BindingFlags): MethodInfo[];
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getPEKind(peKind: { value: ref<PortableExecutableKinds> }, machine: { value: ref<ImageFileMachine> }): void;
    getType(className: string): Type;
    getType(className: string, ignoreCase: boolean): Type;
    getType(className: string, throwOnError: boolean, ignoreCase: boolean): Type;
    getTypes(): Type[];
    isDefined(attributeType: Type, inherit: boolean): boolean;
    isResource(): boolean;
    resolveField(metadataToken: int): FieldInfo;
    resolveField(metadataToken: int, genericTypeArguments: Type[], genericMethodArguments: Type[]): FieldInfo;
    resolveMember(metadataToken: int): MemberInfo;
    resolveMember(metadataToken: int, genericTypeArguments: Type[], genericMethodArguments: Type[]): MemberInfo;
    resolveMethod(metadataToken: int): MethodBase;
    resolveMethod(metadataToken: int, genericTypeArguments: Type[], genericMethodArguments: Type[]): MethodBase;
    resolveSignature(metadataToken: int): byte[];
    resolveString(metadataToken: int): string;
    resolveType(metadataToken: int): Type;
    resolveType(metadataToken: int, genericTypeArguments: Type[], genericMethodArguments: Type[]): Type;
    toString(): string;
}


export const Module: {
    readonly filterTypeName: TypeFilter;
    readonly filterTypeNameIgnoreCase: TypeFilter;
};


export interface __Module$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Module$instance extends ICustomAttributeProvider$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Module = Module$instance & __Module$views;


export interface NullabilityInfo$instance {
    readonly elementType: NullabilityInfo;
    readonly genericTypeArguments: NullabilityInfo[];
    readonly readState: NullabilityState;
    readonly type_: Type;
    readonly writeState: NullabilityState;
}


export const NullabilityInfo: {
    new(): NullabilityInfo$instance;
};


export type NullabilityInfo = NullabilityInfo$instance;

export interface NullabilityInfoContext$instance {
    create(parameterInfo: ParameterInfo): NullabilityInfo;
    create(propertyInfo: PropertyInfo): NullabilityInfo;
    create(eventInfo: EventInfo): NullabilityInfo;
    create(fieldInfo: FieldInfo): NullabilityInfo;
}


export const NullabilityInfoContext: {
    new(): NullabilityInfoContext$instance;
};


export type NullabilityInfoContext = NullabilityInfoContext$instance;

export interface ObfuscateAssemblyAttribute$instance extends Attribute {
    readonly assemblyIsPrivate: boolean;
    stripAfterObfuscation: boolean;
}


export const ObfuscateAssemblyAttribute: {
    new(assemblyIsPrivate: boolean): ObfuscateAssemblyAttribute$instance;
};


export type ObfuscateAssemblyAttribute = ObfuscateAssemblyAttribute$instance;

export interface ObfuscationAttribute$instance extends Attribute {
    applyToMembers: boolean;
    exclude: boolean;
    feature: string;
    stripAfterObfuscation: boolean;
}


export const ObfuscationAttribute: {
    new(): ObfuscationAttribute$instance;
};


export type ObfuscationAttribute = ObfuscationAttribute$instance;

export interface ParameterInfo$instance {
    readonly attributes: ParameterAttributes;
    readonly customAttributes: IEnumerable_1<CustomAttributeData>;
    readonly defaultValue: unknown;
    readonly hasDefaultValue: boolean;
    readonly isIn: boolean;
    readonly isLcid: boolean;
    readonly isOptional: boolean;
    readonly isOut: boolean;
    readonly isRetval: boolean;
    readonly member: MemberInfo;
    readonly metadataToken: int;
    readonly name: string;
    readonly parameterType: Type;
    readonly position: int;
    readonly rawDefaultValue: unknown;
    getCustomAttributes(inherit: boolean): unknown[];
    getCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getCustomAttributesData(): IList_1<CustomAttributeData>;
    getModifiedParameterType(): Type;
    getOptionalCustomModifiers(): Type[];
    getRealObject(context: StreamingContext): unknown;
    getRequiredCustomModifiers(): Type[];
    isDefined(attributeType: Type, inherit: boolean): boolean;
    toString(): string;
}


export const ParameterInfo: {
    new(): ParameterInfo$instance;
};


export interface __ParameterInfo$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
    As_IObjectReference(): System_Runtime_Serialization_Internal.IObjectReference$instance;
}

export interface ParameterInfo$instance extends ICustomAttributeProvider$instance, System_Runtime_Serialization_Internal.IObjectReference$instance {}

export type ParameterInfo = ParameterInfo$instance & __ParameterInfo$views;


export interface Pointer$instance {
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const Pointer: {
    new(): Pointer$instance;
    box(ptr: ptr<void>, type_: Type): unknown;
    unbox(ptr: unknown): ptr<void>;
};


export interface __Pointer$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Pointer$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Pointer = Pointer$instance & __Pointer$views;


export interface PropertyInfo$instance extends MemberInfo$instance {
    readonly attributes: PropertyAttributes;
    readonly canRead: boolean;
    readonly canWrite: boolean;
    readonly getMethod: MethodInfo;
    readonly isSpecialName: boolean;
    readonly memberType: MemberTypes;
    readonly propertyType: Type;
    readonly setMethod: MethodInfo;
    equals(obj: unknown): boolean;
    getAccessors(): MethodInfo[];
    getAccessors(nonPublic: boolean): MethodInfo[];
    getConstantValue(): unknown;
    getCustomAttributes(inherit: boolean): unknown[];
    getCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getGetMethod(): MethodInfo;
    getGetMethod(nonPublic: boolean): MethodInfo;
    getHashCode(): int;
    getIndexParameters(): ParameterInfo[];
    getModifiedPropertyType(): Type;
    getOptionalCustomModifiers(): Type[];
    getRawConstantValue(): unknown;
    getRequiredCustomModifiers(): Type[];
    getSetMethod(): MethodInfo;
    getSetMethod(nonPublic: boolean): MethodInfo;
    getValue(obj: unknown): unknown;
    getValue(obj: unknown, index: unknown[]): unknown;
    getValue(obj: unknown, invokeAttr: BindingFlags, binder: Binder, index: unknown[], culture: CultureInfo): unknown;
    isDefined(attributeType: Type, inherit: boolean): boolean;
    setValue(obj: unknown, value: unknown): void;
    setValue(obj: unknown, value: unknown, index: unknown[]): void;
    setValue(obj: unknown, value: unknown, invokeAttr: BindingFlags, binder: Binder, index: unknown[], culture: CultureInfo): void;
}


export const PropertyInfo: {
};


export interface __PropertyInfo$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
}

export type PropertyInfo = PropertyInfo$instance & __PropertyInfo$views;


export interface ReflectionContext$instance {
    getTypeForObject(value: unknown): TypeInfo;
    mapAssembly(assembly: Assembly): Assembly;
    mapType(type_: TypeInfo): TypeInfo;
}


export const ReflectionContext: {
};


export type ReflectionContext = ReflectionContext$instance;

export interface ReflectionTypeLoadException$instance extends SystemException {
    readonly loaderExceptions: Exception[];
    readonly message: string;
    readonly types: Type[];
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    toString(): string;
}


export const ReflectionTypeLoadException: {
    new(classes: Type[], exceptions: Exception[]): ReflectionTypeLoadException$instance;
    new(classes: Type[], exceptions: Exception[], message: string): ReflectionTypeLoadException$instance;
};


export interface __ReflectionTypeLoadException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ReflectionTypeLoadException = ReflectionTypeLoadException$instance & __ReflectionTypeLoadException$views;


export interface StrongNameKeyPair$instance {
    readonly publicKey: byte[];
}


export const StrongNameKeyPair: {
    new(keyPairFile: FileStream): StrongNameKeyPair$instance;
    new(keyPairArray: byte[]): StrongNameKeyPair$instance;
    new(keyPairContainer: string): StrongNameKeyPair$instance;
};


export interface __StrongNameKeyPair$views {
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface StrongNameKeyPair$instance extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type StrongNameKeyPair = StrongNameKeyPair$instance & __StrongNameKeyPair$views;


export interface TargetException$instance extends ApplicationException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TargetException: {
    new(): TargetException$instance;
    new(message: string): TargetException$instance;
    new(message: string, inner: Exception): TargetException$instance;
};


export interface __TargetException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TargetException = TargetException$instance & __TargetException$views;


export interface TargetInvocationException$instance extends ApplicationException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TargetInvocationException: {
    new(inner: Exception): TargetInvocationException$instance;
    new(message: string, inner: Exception): TargetInvocationException$instance;
};


export interface __TargetInvocationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TargetInvocationException = TargetInvocationException$instance & __TargetInvocationException$views;


export interface TargetParameterCountException$instance extends ApplicationException {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TargetParameterCountException: {
    new(): TargetParameterCountException$instance;
    new(message: string): TargetParameterCountException$instance;
    new(message: string, inner: Exception): TargetParameterCountException$instance;
};


export interface __TargetParameterCountException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TargetParameterCountException = TargetParameterCountException$instance & __TargetParameterCountException$views;


export interface TypeDelegator$instance extends TypeInfo$instance {
    readonly assembly: Assembly;
    readonly assemblyQualifiedName: string;
    readonly baseType: Type;
    readonly fullName: string;
    readonly GUID: Guid;
    readonly isByRefLike: boolean;
    readonly isCollectible: boolean;
    readonly isConstructedGenericType: boolean;
    readonly isFunctionPointer: boolean;
    readonly isGenericMethodParameter: boolean;
    readonly isGenericTypeParameter: boolean;
    readonly isSZArray: boolean;
    readonly isTypeDefinition: boolean;
    readonly isUnmanagedFunctionPointer: boolean;
    readonly isVariableBoundArray: boolean;
    readonly metadataToken: int;
    readonly module_: Module;
    readonly name: string;
    readonly namespace_: string;
    readonly typeHandle: RuntimeTypeHandle;
    readonly underlyingSystemType: Type;
    getArrayRank(): int;
    getConstructors(bindingAttr: BindingFlags): ConstructorInfo[];
    getConstructors(): ConstructorInfo[];
    getCustomAttributes(inherit: boolean): unknown[];
    getCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getElementType(): Type;
    getEvent(name: string, bindingAttr: BindingFlags): EventInfo;
    getEvent(name: string): EventInfo;
    getEvents(): EventInfo[];
    getEvents(bindingAttr: BindingFlags): EventInfo[];
    getField(name: string, bindingAttr: BindingFlags): FieldInfo;
    getField(name: string): FieldInfo;
    getFields(bindingAttr: BindingFlags): FieldInfo[];
    getFields(): FieldInfo[];
    getFunctionPointerCallingConventions(): Type[];
    getFunctionPointerParameterTypes(): Type[];
    getFunctionPointerReturnType(): Type;
    getInterface(name: string, ignoreCase: boolean): Type;
    getInterface(name: string): Type;
    getInterfaceMap(interfaceType: Type): InterfaceMapping;
    getInterfaces(): Type[];
    getMember(name: string, type_: MemberTypes, bindingAttr: BindingFlags): MemberInfo[];
    getMember(name: string, bindingAttr: BindingFlags): MemberInfo[];
    getMember(name: string): MemberInfo[];
    getMembers(bindingAttr: BindingFlags): MemberInfo[];
    getMembers(): MemberInfo[];
    getMemberWithSameMetadataDefinitionAs(member: MemberInfo): MemberInfo;
    getMethod(name: string, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    getMethod(name: string, bindingAttr: BindingFlags): MethodInfo;
    getMethod(name: string): MethodInfo;
    getMethod(name: string, bindingAttr: BindingFlags, types: Type[]): MethodInfo;
    getMethod(name: string, types: Type[]): MethodInfo;
    getMethod(name: string, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    getMethod(name: string, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    getMethod(name: string, genericParameterCount: int, types: Type[]): MethodInfo;
    getMethod(name: string, genericParameterCount: int, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    getMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, types: Type[]): MethodInfo;
    getMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    getMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    getMethods(bindingAttr: BindingFlags): MethodInfo[];
    getMethods(): MethodInfo[];
    getNestedType(name: string, bindingAttr: BindingFlags): Type;
    getNestedType(name: string): Type;
    getNestedTypes(bindingAttr: BindingFlags): Type[];
    getNestedTypes(): Type[];
    getProperties(bindingAttr: BindingFlags): PropertyInfo[];
    getProperties(): PropertyInfo[];
    getProperty(name: string, bindingAttr: BindingFlags): PropertyInfo;
    getProperty(name: string, bindingAttr: BindingFlags, binder: Binder, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
    getProperty(name: string): PropertyInfo;
    getProperty(name: string, returnType: Type): PropertyInfo;
    getProperty(name: string, types: Type[]): PropertyInfo;
    getProperty(name: string, returnType: Type, types: Type[]): PropertyInfo;
    getProperty(name: string, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
    getTypeInfo(): TypeInfo;
    invokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: unknown, args: unknown[], modifiers: ParameterModifier[], culture: CultureInfo, namedParameters: string[]): unknown;
    invokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: unknown, args: unknown[]): unknown;
    invokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: unknown, args: unknown[], culture: CultureInfo): unknown;
    isAssignableFrom(typeInfo: TypeInfo): boolean;
    isAssignableFrom(c: Type): boolean;
    isDefined(attributeType: Type, inherit: boolean): boolean;
}


export const TypeDelegator: {
    new(delegatingType: Type): TypeDelegator$instance;
};


export interface __TypeDelegator$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
    As_IReflect(): IReflect$instance;
    As_IReflectableType(): IReflectableType$instance;
}

export interface TypeDelegator$instance extends IReflectableType$instance {}

export type TypeDelegator = TypeDelegator$instance & __TypeDelegator$views;


export interface TypeInfo$instance extends Type {
    readonly declaredConstructors: IEnumerable_1<ConstructorInfo>;
    readonly declaredEvents: IEnumerable_1<EventInfo>;
    readonly declaredFields: IEnumerable_1<FieldInfo>;
    readonly declaredMembers: IEnumerable_1<MemberInfo>;
    readonly declaredMethods: IEnumerable_1<MethodInfo>;
    readonly declaredNestedTypes: IEnumerable_1<TypeInfo>;
    readonly declaredProperties: IEnumerable_1<PropertyInfo>;
    readonly genericTypeParameters: Type[];
    readonly implementedInterfaces: IEnumerable_1<Type>;
    asType(): Type;
    getCustomAttributes(inherit: boolean): unknown[];
    getCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getDeclaredEvent(name: string): EventInfo;
    getDeclaredField(name: string): FieldInfo;
    getDeclaredMethod(name: string): MethodInfo;
    getDeclaredMethods(name: string): IEnumerable_1<MethodInfo>;
    getDeclaredNestedType(name: string): TypeInfo;
    getDeclaredProperty(name: string): PropertyInfo;
    getField(name: string): FieldInfo;
    getField(name: string, bindingAttr: BindingFlags): FieldInfo;
    getFields(): FieldInfo[];
    getFields(bindingAttr: BindingFlags): FieldInfo[];
    getMember(name: string): MemberInfo[];
    getMember(name: string, bindingAttr: BindingFlags): MemberInfo[];
    getMember(name: string, type_: MemberTypes, bindingAttr: BindingFlags): MemberInfo[];
    getMembers(): MemberInfo[];
    getMembers(bindingAttr: BindingFlags): MemberInfo[];
    getMethod(name: string): MethodInfo;
    getMethod(name: string, bindingAttr: BindingFlags): MethodInfo;
    getMethod(name: string, bindingAttr: BindingFlags, types: Type[]): MethodInfo;
    getMethod(name: string, types: Type[]): MethodInfo;
    getMethod(name: string, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    getMethod(name: string, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    getMethod(name: string, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    getMethod(name: string, genericParameterCount: int, types: Type[]): MethodInfo;
    getMethod(name: string, genericParameterCount: int, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    getMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, types: Type[]): MethodInfo;
    getMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    getMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    getMethods(): MethodInfo[];
    getMethods(bindingAttr: BindingFlags): MethodInfo[];
    getProperties(): PropertyInfo[];
    getProperties(bindingAttr: BindingFlags): PropertyInfo[];
    getProperty(name: string): PropertyInfo;
    getProperty(name: string, bindingAttr: BindingFlags): PropertyInfo;
    getProperty(name: string, returnType: Type): PropertyInfo;
    getProperty(name: string, types: Type[]): PropertyInfo;
    getProperty(name: string, returnType: Type, types: Type[]): PropertyInfo;
    getProperty(name: string, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
    getProperty(name: string, bindingAttr: BindingFlags, binder: Binder, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
    invokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: unknown, args: unknown[]): unknown;
    invokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: unknown, args: unknown[], culture: CultureInfo): unknown;
    invokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: unknown, args: unknown[], modifiers: ParameterModifier[], culture: CultureInfo, namedParameters: string[]): unknown;
    isAssignableFrom(c: Type): boolean;
    isDefined(attributeType: Type, inherit: boolean): boolean;
}


export const TypeInfo: {
};


export interface __TypeInfo$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
    As_IReflect(): IReflect$instance;
    As_IReflectableType(): IReflectableType$instance;
}

export interface TypeInfo$instance extends IReflectableType$instance {}

export type TypeInfo = TypeInfo$instance & __TypeInfo$views;


export abstract class AssemblyExtensions$instance {
    static getExportedTypes(assembly: Assembly): Type[];
    static getModules(assembly: Assembly): Module[];
    static getTypes(assembly: Assembly): Type[];
}


export type AssemblyExtensions = AssemblyExtensions$instance;

export abstract class CustomAttributeExtensions$instance {
    static getCustomAttribute(element: Assembly, attributeType: Type): Attribute;
    static getCustomAttribute<T extends Attribute>(element: Assembly): T;
    static getCustomAttribute<T extends Attribute>(element: MemberInfo, inherit: boolean): T;
    static getCustomAttribute(element: MemberInfo, attributeType: Type, inherit: boolean): Attribute;
    static getCustomAttribute(element: MemberInfo, attributeType: Type): Attribute;
    static getCustomAttribute<T extends Attribute>(element: MemberInfo): T;
    static getCustomAttribute(element: Module, attributeType: Type): Attribute;
    static getCustomAttribute<T extends Attribute>(element: Module): T;
    static getCustomAttribute<T extends Attribute>(element: ParameterInfo, inherit: boolean): T;
    static getCustomAttribute(element: ParameterInfo, attributeType: Type, inherit: boolean): Attribute;
    static getCustomAttribute(element: ParameterInfo, attributeType: Type): Attribute;
    static getCustomAttribute<T extends Attribute>(element: ParameterInfo): T;
    static getCustomAttributes(element: Assembly, attributeType: Type): IEnumerable_1<Attribute>;
    static getCustomAttributes<T extends Attribute>(element: Assembly): IEnumerable_1<T>;
    static getCustomAttributes(element: Assembly): IEnumerable_1<Attribute>;
    static getCustomAttributes<T extends Attribute>(element: MemberInfo, inherit: boolean): IEnumerable_1<T>;
    static getCustomAttributes(element: MemberInfo, inherit: boolean): IEnumerable_1<Attribute>;
    static getCustomAttributes(element: MemberInfo, attributeType: Type, inherit: boolean): IEnumerable_1<Attribute>;
    static getCustomAttributes(element: MemberInfo, attributeType: Type): IEnumerable_1<Attribute>;
    static getCustomAttributes<T extends Attribute>(element: MemberInfo): IEnumerable_1<T>;
    static getCustomAttributes(element: MemberInfo): IEnumerable_1<Attribute>;
    static getCustomAttributes(element: Module, attributeType: Type): IEnumerable_1<Attribute>;
    static getCustomAttributes<T extends Attribute>(element: Module): IEnumerable_1<T>;
    static getCustomAttributes(element: Module): IEnumerable_1<Attribute>;
    static getCustomAttributes<T extends Attribute>(element: ParameterInfo, inherit: boolean): IEnumerable_1<T>;
    static getCustomAttributes(element: ParameterInfo, inherit: boolean): IEnumerable_1<Attribute>;
    static getCustomAttributes(element: ParameterInfo, attributeType: Type, inherit: boolean): IEnumerable_1<Attribute>;
    static getCustomAttributes(element: ParameterInfo, attributeType: Type): IEnumerable_1<Attribute>;
    static getCustomAttributes<T extends Attribute>(element: ParameterInfo): IEnumerable_1<T>;
    static getCustomAttributes(element: ParameterInfo): IEnumerable_1<Attribute>;
    static isDefined(element: Assembly, attributeType: Type): boolean;
    static isDefined(element: MemberInfo, attributeType: Type, inherit: boolean): boolean;
    static isDefined(element: MemberInfo, attributeType: Type): boolean;
    static isDefined(element: Module, attributeType: Type): boolean;
    static isDefined(element: ParameterInfo, attributeType: Type, inherit: boolean): boolean;
    static isDefined(element: ParameterInfo, attributeType: Type): boolean;
}


export type CustomAttributeExtensions = CustomAttributeExtensions$instance;

export abstract class EventInfoExtensions$instance {
    static getAddMethod(eventInfo: EventInfo, nonPublic: boolean): MethodInfo;
    static getAddMethod(eventInfo: EventInfo): MethodInfo;
    static getRaiseMethod(eventInfo: EventInfo, nonPublic: boolean): MethodInfo;
    static getRaiseMethod(eventInfo: EventInfo): MethodInfo;
    static getRemoveMethod(eventInfo: EventInfo, nonPublic: boolean): MethodInfo;
    static getRemoveMethod(eventInfo: EventInfo): MethodInfo;
}


export type EventInfoExtensions = EventInfoExtensions$instance;

export abstract class IntrospectionExtensions$instance {
    static getTypeInfo(type_: Type): TypeInfo;
}


export type IntrospectionExtensions = IntrospectionExtensions$instance;

export abstract class MemberInfoExtensions$instance {
    static getMetadataToken(member: MemberInfo): int;
    static hasMetadataToken(member: MemberInfo): boolean;
}


export type MemberInfoExtensions = MemberInfoExtensions$instance;

export abstract class MethodInfoExtensions$instance {
    static getBaseDefinition(method: MethodInfo): MethodInfo;
}


export type MethodInfoExtensions = MethodInfoExtensions$instance;

export abstract class ModuleExtensions$instance {
    static getModuleVersionId(module_: Module): Guid;
    static hasModuleVersionId(module_: Module): boolean;
}


export type ModuleExtensions = ModuleExtensions$instance;

export abstract class PropertyInfoExtensions$instance {
    static getAccessors(property: PropertyInfo, nonPublic: boolean): MethodInfo[];
    static getAccessors(property: PropertyInfo): MethodInfo[];
    static getGetMethod(property: PropertyInfo, nonPublic: boolean): MethodInfo;
    static getGetMethod(property: PropertyInfo): MethodInfo;
    static getSetMethod(property: PropertyInfo, nonPublic: boolean): MethodInfo;
    static getSetMethod(property: PropertyInfo): MethodInfo;
}


export type PropertyInfoExtensions = PropertyInfoExtensions$instance;

export abstract class RuntimeReflectionExtensions$instance {
    static getMethodInfo(del: Function): MethodInfo;
    static getRuntimeBaseDefinition(method: MethodInfo): MethodInfo;
    static getRuntimeEvent(type_: Type, name: string): EventInfo;
    static getRuntimeEvents(type_: Type): IEnumerable_1<EventInfo>;
    static getRuntimeField(type_: Type, name: string): FieldInfo;
    static getRuntimeFields(type_: Type): IEnumerable_1<FieldInfo>;
    static getRuntimeInterfaceMap(typeInfo: TypeInfo, interfaceType: Type): InterfaceMapping;
    static getRuntimeMethod(type_: Type, name: string, parameters: Type[]): MethodInfo;
    static getRuntimeMethods(type_: Type): IEnumerable_1<MethodInfo>;
    static getRuntimeProperties(type_: Type): IEnumerable_1<PropertyInfo>;
    static getRuntimeProperty(type_: Type, name: string): PropertyInfo;
}


export type RuntimeReflectionExtensions = RuntimeReflectionExtensions$instance;

export abstract class TypeExtensions$instance {
    static getConstructor(type_: Type, types: Type[]): ConstructorInfo;
    static getConstructors(type_: Type, bindingAttr: BindingFlags): ConstructorInfo[];
    static getConstructors(type_: Type): ConstructorInfo[];
    static getDefaultMembers(type_: Type): MemberInfo[];
    static getEvent(type_: Type, name: string, bindingAttr: BindingFlags): EventInfo;
    static getEvent(type_: Type, name: string): EventInfo;
    static getEvents(type_: Type, bindingAttr: BindingFlags): EventInfo[];
    static getEvents(type_: Type): EventInfo[];
    static getField(type_: Type, name: string, bindingAttr: BindingFlags): FieldInfo;
    static getField(type_: Type, name: string): FieldInfo;
    static getFields(type_: Type, bindingAttr: BindingFlags): FieldInfo[];
    static getFields(type_: Type): FieldInfo[];
    static getGenericArguments(type_: Type): Type[];
    static getInterfaces(type_: Type): Type[];
    static getMember(type_: Type, name: string, bindingAttr: BindingFlags): MemberInfo[];
    static getMember(type_: Type, name: string): MemberInfo[];
    static getMembers(type_: Type, bindingAttr: BindingFlags): MemberInfo[];
    static getMembers(type_: Type): MemberInfo[];
    static getMethod(type_: Type, name: string, bindingAttr: BindingFlags): MethodInfo;
    static getMethod(type_: Type, name: string, types: Type[]): MethodInfo;
    static getMethod(type_: Type, name: string): MethodInfo;
    static getMethods(type_: Type, bindingAttr: BindingFlags): MethodInfo[];
    static getMethods(type_: Type): MethodInfo[];
    static getNestedType(type_: Type, name: string, bindingAttr: BindingFlags): Type;
    static getNestedTypes(type_: Type, bindingAttr: BindingFlags): Type[];
    static getProperties(type_: Type, bindingAttr: BindingFlags): PropertyInfo[];
    static getProperties(type_: Type): PropertyInfo[];
    static getProperty(type_: Type, name: string, bindingAttr: BindingFlags): PropertyInfo;
    static getProperty(type_: Type, name: string, returnType: Type, types: Type[]): PropertyInfo;
    static getProperty(type_: Type, name: string, returnType: Type): PropertyInfo;
    static getProperty(type_: Type, name: string): PropertyInfo;
    static isAssignableFrom(type_: Type, c: Type): boolean;
    static isInstanceOfType(type_: Type, o: unknown): boolean;
}


export type TypeExtensions = TypeExtensions$instance;

