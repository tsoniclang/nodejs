// Generated by tsbindgen - Architecture
// Namespace: System.Diagnostics.SymbolStore
// Assembly: System.Diagnostics.StackTrace, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { FieldAttributes, ParameterAttributes } from "../../System.Reflection/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Byte, Enum, Guid, IComparable, IConvertible, IEquatable_1, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, Object as ClrObject, String as ClrString, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum SymAddressKind {
    ilOffset = 1,
    nativeRVA = 2,
    nativeRegister = 3,
    nativeRegisterRelative = 4,
    nativeOffset = 5,
    nativeRegisterRegister = 6,
    nativeRegisterStack = 7,
    nativeStackRegister = 8,
    bitField = 9,
    nativeSectionOffset = 10
}


export interface ISymbolBinder$instance {
    getReader(importer: int, filename: string, searchPath: string): ISymbolReader;
}


export type ISymbolBinder = ISymbolBinder$instance;

export interface ISymbolBinder1$instance {
    getReader(importer: nint, filename: string, searchPath: string): ISymbolReader;
}


export type ISymbolBinder1 = ISymbolBinder1$instance;

export interface ISymbolDocument$instance {
    readonly URL: string;
    readonly documentType: Guid;
    readonly language: Guid;
    readonly languageVendor: Guid;
    readonly checkSumAlgorithmId: Guid;
    readonly hasEmbeddedSource: boolean;
    readonly sourceLength: int;
    findClosestLine(line: int): int;
    getCheckSum(): byte[];
    getSourceRange(startLine: int, startColumn: int, endLine: int, endColumn: int): byte[];
}


export type ISymbolDocument = ISymbolDocument$instance;

export interface ISymbolDocumentWriter$instance {
    setCheckSum(algorithmId: Guid, checkSum: byte[]): void;
    setSource(source: byte[]): void;
}


export type ISymbolDocumentWriter = ISymbolDocumentWriter$instance;

export interface ISymbolMethod$instance {
    readonly token: SymbolToken;
    readonly sequencePointCount: int;
    readonly rootScope: ISymbolScope;
    getNamespace(): ISymbolNamespace;
    getOffset(document: ISymbolDocument, line: int, column: int): int;
    getParameters(): ISymbolVariable[];
    getRanges(document: ISymbolDocument, line: int, column: int): int[];
    getScope(offset: int): ISymbolScope;
    getSequencePoints(offsets: int[], documents: ISymbolDocument[], lines: int[], columns: int[], endLines: int[], endColumns: int[]): void;
    getSourceStartEnd(docs: ISymbolDocument[], lines: int[], columns: int[]): boolean;
}


export type ISymbolMethod = ISymbolMethod$instance;

export interface ISymbolNamespace$instance {
    readonly name: string;
    getNamespaces(): ISymbolNamespace[];
    getVariables(): ISymbolVariable[];
}


export type ISymbolNamespace = ISymbolNamespace$instance;

export interface ISymbolReader$instance {
    readonly userEntryPoint: SymbolToken;
    getDocument(url: string, language: Guid, languageVendor: Guid, documentType: Guid): ISymbolDocument;
    getDocuments(): ISymbolDocument[];
    getGlobalVariables(): ISymbolVariable[];
    getMethod(method: SymbolToken, version: int): ISymbolMethod;
    getMethod(method: SymbolToken): ISymbolMethod;
    getMethodFromDocumentPosition(document: ISymbolDocument, line: int, column: int): ISymbolMethod;
    getNamespaces(): ISymbolNamespace[];
    getSymAttribute(parent: SymbolToken, name: string): byte[];
    getVariables(parent: SymbolToken): ISymbolVariable[];
}


export type ISymbolReader = ISymbolReader$instance;

export interface ISymbolScope$instance {
    readonly method: ISymbolMethod;
    readonly parent: ISymbolScope;
    readonly startOffset: int;
    readonly endOffset: int;
    getChildren(): ISymbolScope[];
    getLocals(): ISymbolVariable[];
    getNamespaces(): ISymbolNamespace[];
}


export type ISymbolScope = ISymbolScope$instance;

export interface ISymbolVariable$instance {
    readonly name: string;
    readonly attributes: unknown;
    readonly addressKind: SymAddressKind;
    readonly addressField1: int;
    readonly addressField2: int;
    readonly addressField3: int;
    readonly startOffset: int;
    readonly endOffset: int;
    getSignature(): byte[];
}


export type ISymbolVariable = ISymbolVariable$instance;

export interface ISymbolWriter$instance {
    closeMethod(): void;
    closeScope(endOffset: int): void;
    defineDocument(url: string, language: Guid, languageVendor: Guid, documentType: Guid): ISymbolDocumentWriter;
    defineField(parent: SymbolToken, name: string, attributes: FieldAttributes, signature: byte[], addrKind: SymAddressKind, addr1: int, addr2: int, addr3: int): void;
    defineGlobalVariable(name: string, attributes: FieldAttributes, signature: byte[], addrKind: SymAddressKind, addr1: int, addr2: int, addr3: int): void;
    defineLocalVariable(name: string, attributes: FieldAttributes, signature: byte[], addrKind: SymAddressKind, addr1: int, addr2: int, addr3: int, startOffset: int, endOffset: int): void;
    defineParameter(name: string, attributes: ParameterAttributes, sequence: int, addrKind: SymAddressKind, addr1: int, addr2: int, addr3: int): void;
    defineSequencePoints(document: ISymbolDocumentWriter, offsets: int[], lines: int[], columns: int[], endLines: int[], endColumns: int[]): void;
    initialize(emitter: nint, filename: string, fFullBuild: boolean): void;
    openNamespace(name: string): void;
    openScope(startOffset: int): int;
    setMethodSourceRange(startDoc: ISymbolDocumentWriter, startLine: int, startColumn: int, endDoc: ISymbolDocumentWriter, endLine: int, endColumn: int): void;
    setScopeRange(scopeID: int, startOffset: int, endOffset: int): void;
    setSymAttribute(parent: SymbolToken, name: string, data: byte[]): void;
    setUnderlyingWriter(underlyingWriter: nint): void;
    setUserEntryPoint(entryMethod: SymbolToken): void;
}


export type ISymbolWriter = ISymbolWriter$instance;

export interface SymbolToken$instance {
    equals(obj: unknown): boolean;
    equals(obj: SymbolToken): boolean;
    getHashCode(): int;
    getToken(): int;
}


export const SymbolToken: {
    new(val: int): SymbolToken$instance;
};


export interface __SymbolToken$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SymbolToken>;

    // Structural method bridges for numeric interface constraints
    Equals(other: SymbolToken): boolean;
}

export type SymbolToken = SymbolToken$instance & __SymbolToken$views;


export interface SymDocumentType$instance {
}


export const SymDocumentType: {
    new(): SymDocumentType$instance;
    readonly text: Guid;
};


export type SymDocumentType = SymDocumentType$instance;

export interface SymLanguageType$instance {
}


export const SymLanguageType: {
    new(): SymLanguageType$instance;
    readonly C: Guid;
    readonly cPlusPlus: Guid;
    readonly cSharp: Guid;
    readonly basic: Guid;
    readonly java: Guid;
    readonly cobol: Guid;
    readonly pascal: Guid;
    readonly ilAssembly: Guid;
    readonly jScript: Guid;
    readonly SMC: Guid;
    readonly mcPlusPlus: Guid;
};


export type SymLanguageType = SymLanguageType$instance;

export interface SymLanguageVendor$instance {
}


export const SymLanguageVendor: {
    new(): SymLanguageVendor$instance;
    readonly microsoft: Guid;
};


export type SymLanguageVendor = SymLanguageVendor$instance;

