// Generated by tsbindgen - Architecture
// Namespace: System.Text.RegularExpressions
// Assembly: System.Text.RegularExpressions

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IList_1, IReadOnlyCollection_1, IReadOnlyDictionary_2, IReadOnlyList_1, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import type { CustomAttributeBuilder } from "../../System.Reflection.Emit/internal/index.js";
import type { AssemblyName, MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ArgumentException, Array as ClrArray, AsyncCallback, Attribute, Boolean as ClrBoolean, Char, Delegate, Enum, Exception, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, MulticastDelegate, Object as ClrObject, Range, ReadOnlySpan_1, String as ClrString, TimeoutException, TimeSpan, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum RegexOptions {
    none = 0,
    ignoreCase = 1,
    multiline = 2,
    explicitCapture = 4,
    compiled = 8,
    singleline = 16,
    ignorePatternWhitespace = 32,
    rightToLeft = 64,
    ecmaScript = 256,
    cultureInvariant = 512,
    nonBacktracking = 1024
}


export enum RegexParseError {
    unknown_ = 0,
    alternationHasTooManyConditions = 1,
    alternationHasMalformedCondition = 2,
    invalidUnicodePropertyEscape = 3,
    malformedUnicodePropertyEscape = 4,
    unrecognizedEscape = 5,
    unrecognizedControlCharacter = 6,
    missingControlCharacter = 7,
    insufficientOrInvalidHexDigits = 8,
    quantifierOrCaptureGroupOutOfRange = 9,
    undefinedNamedReference = 10,
    undefinedNumberedReference = 11,
    malformedNamedReference = 12,
    unescapedEndingBackslash = 13,
    unterminatedComment = 14,
    invalidGroupingConstruct = 15,
    alternationHasNamedCapture = 16,
    alternationHasComment = 17,
    alternationHasMalformedReference = 18,
    alternationHasUndefinedReference = 19,
    captureGroupNameInvalid = 20,
    captureGroupOfZero = 21,
    unterminatedBracket = 22,
    exclusionGroupNotLast = 23,
    reversedCharacterRange = 24,
    shorthandClassInCharacterRange = 25,
    insufficientClosingParentheses = 26,
    reversedQuantifierRange = 27,
    nestedQuantifiersNotParenthesized = 28,
    quantifierAfterNothing = 29,
    insufficientOpeningParentheses = 30,
    unrecognizedUnicodeProperty = 31
}


export type MatchEvaluator = (match: Match) => string;


export interface Regex_ValueMatchEnumerator$instance {
    readonly current: ValueMatch;
    getEnumerator(): Regex_ValueMatchEnumerator;
    moveNext(): boolean;
    reset(): void;
}


export const Regex_ValueMatchEnumerator: {
    new(): Regex_ValueMatchEnumerator$instance;
};


export interface __Regex_ValueMatchEnumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<ValueMatch>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type Regex_ValueMatchEnumerator = Regex_ValueMatchEnumerator$instance & __Regex_ValueMatchEnumerator$views;


export interface Regex_ValueSplitEnumerator$instance {
    readonly current: Range;
    getEnumerator(): Regex_ValueSplitEnumerator;
    moveNext(): boolean;
    reset(): void;
}


export const Regex_ValueSplitEnumerator: {
    new(): Regex_ValueSplitEnumerator$instance;
};


export interface __Regex_ValueSplitEnumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<Range>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type Regex_ValueSplitEnumerator = Regex_ValueSplitEnumerator$instance & __Regex_ValueSplitEnumerator$views;


export interface ValueMatch$instance {
    readonly index: int;
    readonly length: int;
}


export const ValueMatch: {
    new(): ValueMatch$instance;
};


export type ValueMatch = ValueMatch$instance;

export interface Capture$instance {
    readonly index: int;
    readonly length: int;
    readonly value: string;
    readonly valueSpan: ReadOnlySpan_1<CLROf<char>>;
    toString(): string;
}


export const Capture: {
    new(): Capture$instance;
};


export type Capture = Capture$instance;

export interface CaptureCollection$instance {
    readonly count: int;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    readonly item: Capture;
    readonly syncRoot: unknown;
    copyTo(array: ClrArray, arrayIndex: int): void;
    copyTo(array: Capture[], arrayIndex: int): void;
    getEnumerator(): IEnumerator;
}


export const CaptureCollection: {
    new(): CaptureCollection$instance;
};


export interface __CaptureCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<Capture>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<Capture>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<Capture>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<Capture>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type CaptureCollection = CaptureCollection$instance & __CaptureCollection$views;


export interface GeneratedRegexAttribute$instance extends Attribute {
    readonly cultureName: string;
    readonly matchTimeoutMilliseconds: int;
    readonly options: RegexOptions;
    readonly pattern: string;
}


export const GeneratedRegexAttribute: {
    new(pattern: string): GeneratedRegexAttribute$instance;
    new(pattern: string, options: RegexOptions): GeneratedRegexAttribute$instance;
    new(pattern: string, options: RegexOptions, cultureName: string): GeneratedRegexAttribute$instance;
    new(pattern: string, options: RegexOptions, matchTimeoutMilliseconds: int): GeneratedRegexAttribute$instance;
    new(pattern: string, options: RegexOptions, matchTimeoutMilliseconds: int, cultureName: string): GeneratedRegexAttribute$instance;
};


export type GeneratedRegexAttribute = GeneratedRegexAttribute$instance;

export interface Group$instance extends Capture {
    readonly captures: CaptureCollection;
    readonly name: string;
    readonly success: boolean;
}


export const Group: {
    new(): Group$instance;
    synchronized(inner: Group): Group;
};


export type Group = Group$instance;

export interface GroupCollection$instance {
    readonly count: int;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    readonly keys: IEnumerable_1<CLROf<string>>;
    readonly syncRoot: unknown;
    readonly values: IEnumerable_1<Group>;
    containsKey(key: string): boolean;
    copyTo(array: ClrArray, arrayIndex: int): void;
    copyTo(array: Group[], arrayIndex: int): void;
    get_Item(groupnum: int): Group;
    get_Item(groupname: string): Group;
    getEnumerator(): IEnumerator;
    tryGetValue(key: string, value: { value: ref<Group> }): boolean;
}


export const GroupCollection: {
    new(): GroupCollection$instance;
};


export interface __GroupCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<Group>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<Group>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<Group>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<Group>;
    As_IReadOnlyDictionary_2(): System_Collections_Generic_Internal.IReadOnlyDictionary_2$instance<CLROf<string>, Group>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type GroupCollection = GroupCollection$instance & __GroupCollection$views;


export interface Match$instance extends Group {
    readonly groups: GroupCollection;
    nextMatch(): Match;
    result(replacement: string): string;
}


export const Match: {
    new(): Match$instance;
    readonly empty: Match;
};


export type Match = Match$instance;

export interface MatchCollection$instance {
    readonly count: int;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    readonly item: Match;
    readonly syncRoot: unknown;
    copyTo(array: ClrArray, arrayIndex: int): void;
    copyTo(array: Match[], arrayIndex: int): void;
    getEnumerator(): IEnumerator;
}


export const MatchCollection: {
    new(): MatchCollection$instance;
};


export interface __MatchCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<Match>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<Match>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<Match>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<Match>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type MatchCollection = MatchCollection$instance & __MatchCollection$views;


export interface Regex$instance {
    readonly matchTimeout: TimeSpan;
    readonly options: RegexOptions;
    readonly rightToLeft: boolean;
    count(input: string): int;
    count(input: ReadOnlySpan_1<CLROf<char>>): int;
    count(input: ReadOnlySpan_1<CLROf<char>>, startat: int): int;
    enumerateMatches(input: ReadOnlySpan_1<CLROf<char>>): Regex_ValueMatchEnumerator;
    enumerateMatches(input: ReadOnlySpan_1<CLROf<char>>, startat: int): Regex_ValueMatchEnumerator;
    enumerateSplits(input: ReadOnlySpan_1<CLROf<char>>): Regex_ValueSplitEnumerator;
    enumerateSplits(input: ReadOnlySpan_1<CLROf<char>>, count: int): Regex_ValueSplitEnumerator;
    enumerateSplits(input: ReadOnlySpan_1<CLROf<char>>, count: int, startat: int): Regex_ValueSplitEnumerator;
    getGroupNames(): string[];
    getGroupNumbers(): int[];
    groupNameFromNumber(i: int): string;
    groupNumberFromName(name: string): int;
    isMatch(input: string): boolean;
    isMatch(input: string, startat: int): boolean;
    isMatch(input: ReadOnlySpan_1<CLROf<char>>): boolean;
    isMatch(input: ReadOnlySpan_1<CLROf<char>>, startat: int): boolean;
    match(input: string): Match;
    match(input: string, startat: int): Match;
    match(input: string, beginning: int, length: int): Match;
    matches(input: string): MatchCollection;
    matches(input: string, startat: int): MatchCollection;
    replace(input: string, replacement: string): string;
    replace(input: string, replacement: string, count: int): string;
    replace(input: string, replacement: string, count: int, startat: int): string;
    replace(input: string, evaluator: MatchEvaluator): string;
    replace(input: string, evaluator: MatchEvaluator, count: int): string;
    replace(input: string, evaluator: MatchEvaluator, count: int, startat: int): string;
    split(input: string): string[];
    split(input: string, count: int): string[];
    split(input: string, count: int, startat: int): string[];
    toString(): string;
}


export const Regex: {
    new(pattern: string): Regex$instance;
    new(pattern: string, options: RegexOptions): Regex$instance;
    new(pattern: string, options: RegexOptions, matchTimeout: TimeSpan): Regex$instance;
    readonly infiniteMatchTimeout: TimeSpan;
    cacheSize: int;
    compileToAssembly(regexinfos: RegexCompilationInfo[], assemblyname: AssemblyName, attributes: CustomAttributeBuilder[], resourceFile: string): void;
    compileToAssembly(regexinfos: RegexCompilationInfo[], assemblyname: AssemblyName, attributes: CustomAttributeBuilder[]): void;
    compileToAssembly(regexinfos: RegexCompilationInfo[], assemblyname: AssemblyName): void;
    count(input: ReadOnlySpan_1<CLROf<char>>, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): int;
    count(input: ReadOnlySpan_1<CLROf<char>>, pattern: string, options: RegexOptions): int;
    count(input: ReadOnlySpan_1<CLROf<char>>, pattern: string): int;
    count(input: string, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): int;
    count(input: string, pattern: string, options: RegexOptions): int;
    count(input: string, pattern: string): int;
    enumerateMatches(input: ReadOnlySpan_1<CLROf<char>>, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): Regex_ValueMatchEnumerator;
    enumerateMatches(input: ReadOnlySpan_1<CLROf<char>>, pattern: string, options: RegexOptions): Regex_ValueMatchEnumerator;
    enumerateMatches(input: ReadOnlySpan_1<CLROf<char>>, pattern: string): Regex_ValueMatchEnumerator;
    enumerateSplits(input: ReadOnlySpan_1<CLROf<char>>, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): Regex_ValueSplitEnumerator;
    enumerateSplits(input: ReadOnlySpan_1<CLROf<char>>, pattern: string, options: RegexOptions): Regex_ValueSplitEnumerator;
    enumerateSplits(input: ReadOnlySpan_1<CLROf<char>>, pattern: string): Regex_ValueSplitEnumerator;
    escape(str: string): string;
    isMatch(input: ReadOnlySpan_1<CLROf<char>>, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): boolean;
    isMatch(input: ReadOnlySpan_1<CLROf<char>>, pattern: string, options: RegexOptions): boolean;
    isMatch(input: ReadOnlySpan_1<CLROf<char>>, pattern: string): boolean;
    isMatch(input: string, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): boolean;
    isMatch(input: string, pattern: string, options: RegexOptions): boolean;
    isMatch(input: string, pattern: string): boolean;
    match(input: string, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): Match;
    match(input: string, pattern: string, options: RegexOptions): Match;
    match(input: string, pattern: string): Match;
    matches(input: string, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): MatchCollection;
    matches(input: string, pattern: string, options: RegexOptions): MatchCollection;
    matches(input: string, pattern: string): MatchCollection;
    replace(input: string, pattern: string, replacement: string, options: RegexOptions, matchTimeout: TimeSpan): string;
    replace(input: string, pattern: string, replacement: string, options: RegexOptions): string;
    replace(input: string, pattern: string, replacement: string): string;
    replace(input: string, pattern: string, evaluator: MatchEvaluator, options: RegexOptions, matchTimeout: TimeSpan): string;
    replace(input: string, pattern: string, evaluator: MatchEvaluator, options: RegexOptions): string;
    replace(input: string, pattern: string, evaluator: MatchEvaluator): string;
    split(input: string, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): string[];
    split(input: string, pattern: string, options: RegexOptions): string[];
    split(input: string, pattern: string): string[];
    unescape(str: string): string;
};


export interface __Regex$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Regex$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Regex = Regex$instance & __Regex$views;


export interface RegexCompilationInfo$instance {
    isPublic: boolean;
    matchTimeout: TimeSpan;
    name: string;
    namespace_: string;
    options: RegexOptions;
    pattern: string;
}


export const RegexCompilationInfo: {
    new(pattern: string, options: RegexOptions, name: string, fullnamespace: string, ispublic: boolean): RegexCompilationInfo$instance;
    new(pattern: string, options: RegexOptions, name: string, fullnamespace: string, ispublic: boolean, matchTimeout: TimeSpan): RegexCompilationInfo$instance;
};


export type RegexCompilationInfo = RegexCompilationInfo$instance;

export interface RegexMatchTimeoutException$instance extends TimeoutException {
    readonly input: string;
    readonly matchTimeout: TimeSpan;
    readonly pattern: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const RegexMatchTimeoutException: {
    new(regexInput: string, regexPattern: string, matchTimeout: TimeSpan): RegexMatchTimeoutException$instance;
    new(): RegexMatchTimeoutException$instance;
    new(message: string): RegexMatchTimeoutException$instance;
    new(message: string, inner: Exception): RegexMatchTimeoutException$instance;
};


export interface __RegexMatchTimeoutException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type RegexMatchTimeoutException = RegexMatchTimeoutException$instance & __RegexMatchTimeoutException$views;


export interface RegexParseException$instance extends ArgumentException {
    readonly error: RegexParseError;
    readonly offset: int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const RegexParseException: {
    new(): RegexParseException$instance;
};


export interface __RegexParseException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type RegexParseException = RegexParseException$instance & __RegexParseException$views;


export interface RegexRunner$instance {
}


export const RegexRunner: {
    charInClass(ch: char, charClass: string): boolean;
};


export type RegexRunner = RegexRunner$instance;

export interface RegexRunnerFactory$instance {
}


export const RegexRunnerFactory: {
};


export type RegexRunnerFactory = RegexRunnerFactory$instance;

